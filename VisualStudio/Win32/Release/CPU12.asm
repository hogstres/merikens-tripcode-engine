; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	Z:\GitHub\merikens-tripcode-engine\SourceFiles\CPU12.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_SHA1_GenerateTripcodesWithOptimization_x86_SSE2:PROC
EXTRN	_SHA1_GenerateTripcodesWithOptimization_x86_SSE2_Nehalem:PROC
EXTRN	__myxgetbv:PROC
EXTRN	_SHA1_GenerateTripcodesWithOptimization_x86_AVX2:PROC
EXTRN	_SHA1_GenerateTripcodesWithOptimization_x86_AVX:PROC
;	COMDAT ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA
_DATA	SEGMENT
?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA DD 0ffffffffH ; `IsAVX2Supported'::`2'::the_4th_gen_features_available
PUBLIC	?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ	; Thread_SearchForSHA1TripcodesOnCPU
PUBLIC	?check_4th_gen_intel_core_features@@YAHXZ	; check_4th_gen_intel_core_features
PUBLIC	?check_xcr0_ymm@@YAHXZ				; check_xcr0_ymm
PUBLIC	?run_cpuid@@YAXIIPAH@Z				; run_cpuid
PUBLIC	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
PUBLIC	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ	; IsCPUBasedOnNehalemMicroarchitecture
PUBLIC	?IsAVX2Supported@@YAHXZ				; IsAVX2Supported
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_errno_ecat DD	01H DUP (?)
_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_native_ecat DD	01H DUP (?)
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_posix_category DD 01H DUP (?)
_BSS	ENDS
_posix_category$initializer$ DD FLAT:??__Eposix_category@system@boost@@YAXXZ
_errno_ecat$initializer$ DD FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
_native_ecat$initializer$ DD FLAT:??__Enative_ecat@system@boost@@YAXXZ
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?IsAVX2Supported@@YAHXZ
_TEXT	SEGMENT
?IsAVX2Supported@@YAHXZ PROC				; IsAVX2Supported, COMDAT

; 632  :     static int32_t the_4th_gen_features_available = -1;
; 633  :     /* test is performed once */
; 634  :     if (the_4th_gen_features_available < 0 )

	mov	eax, DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA
	test	eax, eax
	jns	SHORT $LN1@IsAVX2Supp

; 635  :         the_4th_gen_features_available = check_4th_gen_intel_core_features();

	call	?check_4th_gen_intel_core_features@@YAHXZ ; check_4th_gen_intel_core_features
	mov	DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA, eax
$LN1@IsAVX2Supp:

; 636  :  
; 637  :     return the_4th_gen_features_available;
; 638  : }

	ret	0
?IsAVX2Supported@@YAHXZ ENDP				; IsAVX2Supported
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ
_TEXT	SEGMENT
_results$ = -48						; size = 16
_processorInfoArray$ = -32				; size = 28
__$ArrayPad$ = -4					; size = 4
?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ PROC	; IsCPUBasedOnNehalemMicroarchitecture, COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movdqa	xmm0, XMMWORD PTR __xmm@000106e0000206f0000206c000020650

; 244  : 	int32_t results[4];
; 245  : 	int32_t processorInfoArray[] = {
; 246  : 		// 0x306a0, // For testing
; 247  : 
; 248  : 		// See: http://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers
; 249  : 		0x20650,
; 250  : 		0x206c0,
; 251  : 		0x206f0,
; 252  : 		0x106e0,
; 253  : 		0x106a0,
; 254  : 		0x206e0,
; 255  : 		0
; 256  : 	};
; 257  : 	int32_t mask = 0xfffffff0;
; 258  : 	
; 259  : 	__cpuid(results, 1);

	xor	ecx, ecx
	push	ebx
	push	esi
	lea	esi, DWORD PTR _results$[ebp]
	mov	DWORD PTR _processorInfoArray$[ebp+16], 67232 ; 000106a0H
	mov	eax, 1
	mov	DWORD PTR _processorInfoArray$[ebp+20], 132832 ; 000206e0H
	cpuid
	mov	DWORD PTR [esi], eax
	mov	eax, 132688				; 00020650H
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx

; 260  : 	for (int32_t i = 0; processorInfoArray[i]; ++i) {

	xor	ecx, ecx
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR _results$[ebp]
	pop	esi
	movdqu	XMMWORD PTR _processorInfoArray$[ebp], xmm0
	mov	DWORD PTR _processorInfoArray$[ebp+24], 0
	and	edx, -16				; fffffff0H
	pop	ebx
	npad	6
$LL4@IsCPUBased:

; 261  : 		if ((results[0] & mask) == processorInfoArray[i])

	cmp	edx, eax
	je	SHORT $LN8@IsCPUBased

; 260  : 	for (int32_t i = 0; processorInfoArray[i]; ++i) {

	mov	eax, DWORD PTR _processorInfoArray$[ebp+ecx*4+4]
	inc	ecx
	test	eax, eax
	jne	SHORT $LL4@IsCPUBased

; 262  : 			return TRUE;
; 263  : 	}
; 264  : 
; 265  : 	return FALSE;
; 266  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@IsCPUBased:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ENDP	; IsCPUBasedOnNehalemMicroarchitecture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _posix_category, eax
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _errno_ecat, eax
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	call	?system_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::system_category
	mov	DWORD PTR _native_ecat, eax
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z
_TEXT	SEGMENT
?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z PROC ; ConvertRaw12CharTripcodeIntoDisplayFormat, COMDAT
; _rawTripcodeArray$ = ecx
; _tripcode$ = edx

; 54   : {

	push	esi
	mov	esi, ecx

; 55   : 	tripcode[0]  = base64CharTable[ rawTripcodeArray[0] >> 26                                    ];

	mov	eax, DWORD PTR [esi]
	shr	eax, 26					; 0000001aH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx], al

; 56   : 	tripcode[1]  = base64CharTable[(rawTripcodeArray[0] >> 20                            ) & 0x3f];

	mov	eax, DWORD PTR [esi]
	shr	eax, 20					; 00000014H
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+1], al

; 57   : 	tripcode[2]  = base64CharTable[(rawTripcodeArray[0] >> 14                            ) & 0x3f];

	mov	eax, DWORD PTR [esi]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+2], al

; 58   : 	tripcode[3]  = base64CharTable[(rawTripcodeArray[0] >>  8                            ) & 0x3f];

	mov	eax, DWORD PTR [esi]
	shr	eax, 8
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+3], al

; 59   : 	tripcode[4]  = base64CharTable[(rawTripcodeArray[0] >>  2                            ) & 0x3f];

	mov	eax, DWORD PTR [esi]
	shr	eax, 2
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+4], al

; 60   : 	tripcode[5]  = base64CharTable[(rawTripcodeArray[1] >> 28 | rawTripcodeArray[0] <<  4) & 0x3f];

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	shl	eax, 4
	shr	ecx, 28					; 0000001cH
	or	ecx, eax
	and	ecx, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[ecx]
	mov	BYTE PTR [edx+5], al

; 61   : 	tripcode[6]  = base64CharTable[(rawTripcodeArray[1] >> 22                            ) & 0x3f];

	mov	eax, DWORD PTR [esi+4]
	shr	eax, 22					; 00000016H
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+6], al

; 62   : 	tripcode[7]  = base64CharTable[(rawTripcodeArray[1] >> 16                            ) & 0x3f];

	movzx	eax, WORD PTR [esi+6]
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+7], al

; 63   : 	tripcode[8]  = base64CharTable[(rawTripcodeArray[1] >> 10                            ) & 0x3f];

	mov	eax, DWORD PTR [esi+4]
	shr	eax, 10					; 0000000aH
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+8], al

; 64   : 	tripcode[9]  = base64CharTable[(rawTripcodeArray[1] >>  4                            ) & 0x3f];

	mov	eax, DWORD PTR [esi+4]
	shr	eax, 4
	and	eax, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+9], al

; 65   : 	tripcode[10] = base64CharTable[(rawTripcodeArray[1] <<  2 | rawTripcodeArray[2] >> 30) & 0x3f];

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 2
	shr	ecx, 30					; 0000001eH
	or	ecx, eax
	and	ecx, 63					; 0000003fH
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[ecx]
	mov	BYTE PTR [edx+10], al

; 66   : 	tripcode[11] = base64CharTable[(rawTripcodeArray[2] >> 24                            ) & 0x3f];

	movzx	eax, BYTE PTR [esi+11]
	and	eax, 63					; 0000003fH
	pop	esi
	movzx	eax, BYTE PTR ?base64CharTable@@3PADA[eax]
	mov	BYTE PTR [edx+11], al

; 67   : }

	ret	0
?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ENDP ; ConvertRaw12CharTripcodeIntoDisplayFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?SearchForTripcodesWithOptimization@@YAIXZ
_TEXT	SEGMENT
_W0$1 = -2912						; size = 16
_SHA1_GenerateTripcodesWithOptimization$1$ = -2896	; size = 4
_indexKey1$1$ = -2892					; size = 4
_wordIndex$1$ = -2888					; size = 4
_indexKey3$1$ = -2884					; size = 4
_indexKey2$1$ = -2880					; size = 4
_numGeneratedTripcodes$1$ = -2876			; size = 4
_maxPos$1$ = -2872					; size = 4
_generatedTripcodeChunkArray$2$ = -2868			; size = 4
_lower$1$ = -2864					; size = 4
_lower$1$ = -2864					; size = 4
_lower$1$ = -2860					; size = 4
_found$1$ = -2860					; size = 4
tv2419 = -2856						; size = 4
_key$2$ = -2849						; size = 1
_W0Shifted$ = -2848					; size = 368
_PW$ = -2480						; size = 1280
_ABC$2 = -1200						; size = 48
_generatedTripcodeChunkArray$3 = -1144			; size = 32
_rawTripcodeArray$ = -1112				; size = 48
_keyCharTable_FirstByte_local$ = -1064			; size = 512
_keyCharTable_SecondByteAndOneByte_local$ = -552	; size = 512
_key$ = -36						; size = 13
_tripcode$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?SearchForTripcodesWithOptimization@@YAIXZ PROC		; SearchForTripcodesWithOptimization, COMDAT

; 269  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 2920				; 00000b68H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 270  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE + 1], key[MAX_LEN_TRIPCODE_KEY + 1];
; 271  : 	uint32_t   numGeneratedTripcodes = 0;

	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _numGeneratedTripcodes$1$[ebp], eax

; 272  : 	uint32_t   rawTripcodeArray[4][3];
; 273  : 
; 274  : #ifdef _M_X64
; 275  : 	void           (*SHA1_GenerateTripcodesWithOptimization)(void *, void *, void *, void *) = 
; 276  : 		(options.isAVXEnabled && IsAVXSupported()) ? SHA1_GenerateTripcodesWithOptimization_x64_AVX          :
; 277  : 		(IsCPUBasedOnNehalemMicroarchitecture()  ) ? SHA1_GenerateTripcodesWithOptimization_x64_SSE2_Nehalem :
; 278  : 		                                             SHA1_GenerateTripcodesWithOptimization_x64_SSE2;
; 279  : #else
; 280  : 	void           (*SHA1_GenerateTripcodesWithOptimization)(void *, void *, void *, void *) = 

	cmp	DWORD PTR ?options@@3UOptions@@A+80, eax
	je	SHORT $LN93@SearchForT
	call	_IsAVXSupported
	test	eax, eax
	je	SHORT $LN93@SearchForT
	mov	DWORD PTR _SHA1_GenerateTripcodesWithOptimization$1$[ebp], OFFSET _SHA1_GenerateTripcodesWithOptimization_x86_AVX
	jmp	SHORT $LN94@SearchForT
$LN93@SearchForT:
	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture
	test	eax, eax
	mov	ecx, OFFSET _SHA1_GenerateTripcodesWithOptimization_x86_SSE2
	mov	edx, OFFSET _SHA1_GenerateTripcodesWithOptimization_x86_SSE2_Nehalem
	cmovne	ecx, edx
	mov	DWORD PTR _SHA1_GenerateTripcodesWithOptimization$1$[ebp], ecx
$LN94@SearchForT:

; 281  : 		(options.isAVXEnabled && IsAVXSupported()) ? SHA1_GenerateTripcodesWithOptimization_x86_AVX          :
; 282  : 		(IsCPUBasedOnNehalemMicroarchitecture()  ) ? SHA1_GenerateTripcodesWithOptimization_x86_SSE2_Nehalem :
; 283  : 		                                             SHA1_GenerateTripcodesWithOptimization_x86_SSE2;
; 284  : #endif
; 285  : 
; 286  : 	tripcode[lenTripcode]    = '\0';

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 13					; 0000000dH
	jae	$LN200@SearchForT
	mov	BYTE PTR _tripcode$[ebp+eax], 0

; 287  : 	key     [lenTripcodeKey] = '\0';

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	cmp	eax, 13					; 0000000dH
	jae	$LN200@SearchForT
	mov	BYTE PTR _key$[ebp+eax], 0
$LN192@SearchForT:

; 288  : 
; 289  : 	SetCharactersInTripcodeKeyForSHA1Tripcode(key);

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
$LN193@SearchForT:
	call	?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z ; SetCharactersInTripcodeKeyForSHA1Tripcode

; 290  : 	while (TRUE) {
; 291  : 		key[0] = ((key[0] & 0xfc) | 0x00); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$[ebp]
	add	esp, 4
	and	al, 252					; 000000fcH
	mov	BYTE PTR _key$2$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN192@SearchForT

; 292  : 		key[0] = ((key[0] & 0xfc) | 0x01); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$2$[ebp]
	and	al, 253					; 000000fdH
	or	al, 1
	mov	BYTE PTR _key$2$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN192@SearchForT

; 293  : 		key[0] = ((key[0] & 0xfc) | 0x02); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$2$[ebp]
	and	al, 254					; 000000feH
	or	al, 2
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	je	SHORT $LN193@SearchForT

; 294  : 		key[0] = ((key[0] & 0xfc) | 0x03); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	or	BYTE PTR _key$[ebp], 3
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN192@SearchForT

; 303  : 		keyCharTable_FirstByte_local[i]            = keyCharTable_FirstByte[i];
; 304  : 		keyCharTable_SecondByteAndOneByte_local[i] = keyCharTable_SecondByteAndOneByte[i];

	push	512					; 00000200H
	lea	eax, DWORD PTR _keyCharTable_SecondByteAndOneByte_local$[ebp]
	push	OFFSET ?keyCharTable_SecondByteAndOneByte@@3PAEA ; keyCharTable_SecondByteAndOneByte
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _keyCharTable_FirstByte_local$[ebp]
	push	512					; 00000200H
	push	OFFSET ?keyCharTable_FirstByte@@3PAEA	; keyCharTable_FirstByte
	push	eax
	call	_memcpy

; 305  : 	}
; 306  : 
; 307  : 	PW[0]  = _mm_set1_epi32(0);
; 308  : 	PW[1]  = _mm_set1_epi32((key[4] << 24) | (key[5] << 16) | (key[ 6] << 8) | key[ 7]);

	movzx	ecx, BYTE PTR _key$[ebp+4]
	xorps	xmm2, xmm2
	movzx	eax, BYTE PTR _key$[ebp+5]
	add	esp, 12					; 0000000cH
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp], xmm2
	movzx	eax, BYTE PTR _key$[ebp+6]
	shl	ecx, 8
	or	ecx, eax

; 309  : 	PW[2]  = _mm_set1_epi32((key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11]);
; 310  : 	PW[3]  = _mm_set1_epi32(0x80000000);
; 311  : 	PW[4]  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+64], xmm2
	movzx	eax, BYTE PTR _key$[ebp+7]
	shl	ecx, 8
	or	ecx, eax

; 312  : 	PW[5]  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+80], xmm2
	movzx	eax, BYTE PTR _key$[ebp+9]

; 313  : 	PW[6]  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+96], xmm2

; 314  : 	PW[7]  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+112], xmm2
	movd	xmm0, ecx
	movzx	ecx, BYTE PTR _key$[ebp+8]
	shl	ecx, 8
	or	ecx, eax
	pshufd	xmm0, xmm0, 0
	movzx	eax, BYTE PTR _key$[ebp+10]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+16], xmm0
	movzx	eax, BYTE PTR _key$[ebp+11]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+128], xmm2

; 315  : 	PW[8]  = _mm_set1_epi32(0);
; 316  : 	PW[9]  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+144], xmm2
	lea	eax, DWORD PTR _PW$[ebp+224]

; 317  : 	PW[10] = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+160], xmm2

; 318  : 	PW[11] = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+176], xmm2
	movd	xmm0, ecx
	mov	ecx, 63					; 0000003fH
	pshufd	xmm1, xmm0, 0
	movdqa	xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
	movdqa	XMMWORD PTR _PW$[ebp+48], xmm0

; 319  : 	PW[12] = _mm_set1_epi32(0);
; 320  : 	PW[13] = _mm_set1_epi32(0);
; 321  : 	PW[14] = _mm_set1_epi32(0);
; 322  : 	PW[15] = _mm_set1_epi32(12 * 8);

	movdqa	xmm0, XMMWORD PTR __xmm@00000060000000600000006000000060
	movdqa	XMMWORD PTR _PW$[ebp+192], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+208], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+224], xmm2

; 323  : 	PW[16] = ROTL(1, _mm_xor_si128(_mm_xor_si128(PW[16 - 3], PW[16 - 8]), PW[16 - 14]));

	pxor	xmm2, xmm1
	movdqa	XMMWORD PTR _PW$[ebp+240], xmm0
	movdqa	xmm0, xmm2
	psrld	xmm0, 31				; 0000001fH
	pslld	xmm2, 1
	movdqa	XMMWORD PTR _PW$[ebp+32], xmm1
	por	xmm0, xmm2
	movdqa	XMMWORD PTR _PW$[ebp+256], xmm0
	npad	7
$LL81@SearchForT:

; 324  : 	for (int32_t t = 17; t < 80; ++t)
; 325  : 		PW[t] = ROTL(1, _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(PW[(t) - 3], PW[(t) - 8]), PW[(t) - 14]), PW[(t) - 16]));

	movdqa	xmm1, XMMWORD PTR [eax-80]
	lea	eax, DWORD PTR [eax+16]
	pxor	xmm1, XMMWORD PTR [eax-16]
	pxor	xmm1, XMMWORD PTR [eax-192]
	pxor	xmm1, XMMWORD PTR [eax-224]
	movdqa	xmm0, xmm1
	pslld	xmm1, 1
	psrld	xmm0, 31				; 0000001fH
	por	xmm0, xmm1
	movdqa	XMMWORD PTR [eax+32], xmm0
	dec	ecx
	jne	SHORT $LL81@SearchForT

; 326  : 
; 327  : 	for (int32_t indexKey1 = 0; indexKey1 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey1) {

	xor	eax, eax
	mov	DWORD PTR _indexKey1$1$[ebp], eax
	npad	1
$LL78@SearchForT:

; 328  : 		key[1] = keyCharTable_SecondByteAndOneByte_local[indexKey1];

	mov	al, BYTE PTR _keyCharTable_SecondByteAndOneByte_local$[ebp+eax]
	mov	BYTE PTR _key$[ebp+1], al

; 329  : 
; 330  : 		for (int32_t indexKey2 = 0; indexKey2 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey2) {

	xor	eax, eax
	mov	DWORD PTR _indexKey2$1$[ebp], eax
$LL75@SearchForT:

; 331  : 			key[2] = keyCharTable_FirstByte_local[indexKey2];

	mov	dl, BYTE PTR _keyCharTable_FirstByte_local$[ebp+eax]

; 332  : 
; 333  : 			for (int32_t indexKey3 = 0; indexKey3 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey3) {

	xor	eax, eax
	mov	BYTE PTR _key$[ebp+2], dl
	mov	DWORD PTR _indexKey3$1$[ebp], eax
	npad	12
$LL72@SearchForT:

; 334  : 				key[3] = keyCharTable_SecondByteAndOneByte_local[indexKey3];

	mov	al, BYTE PTR _keyCharTable_SecondByteAndOneByte_local$[ebp+eax]

; 335  : 
; 336  : 				__declspec(align(16)) __m128i W0, ABC[3];
; 337  : 				W0.m128i_u32[0] = (((key[0] & 0xfc) | 0x00) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	movzx	edi, BYTE PTR _key$[ebp]
	movzx	ecx, BYTE PTR _key$[ebp+1]
	movzx	esi, al
	mov	BYTE PTR _key$[ebp+3], al
	mov	eax, edi
	and	eax, -4					; fffffffcH
	movzx	edx, dl
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$1[ebp], eax

; 338  : 				W0.m128i_u32[1] = (((key[0] & 0xfc) | 0x01) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -3					; fffffffdH
	or	eax, 1
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$1[ebp+4], eax

; 339  : 				W0.m128i_u32[2] = (((key[0] & 0xfc) | 0x02) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -2					; fffffffeH

; 340  : 				W0.m128i_u32[3] = (((key[0] & 0xfc) | 0x03) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	or	edi, 3
	or	eax, 2
	shl	edi, 8
	shl	eax, 8
	or	edi, ecx
	or	eax, ecx
	shl	edi, 8
	shl	eax, 8
	or	edi, edx
	or	eax, edx
	shl	edi, 8
	shl	eax, 8
	or	edi, esi
	or	eax, esi
	mov	DWORD PTR _W0$1[ebp+12], edi
	mov	DWORD PTR _W0$1[ebp+8], eax

; 341  : 
; 342  : 				(*SHA1_GenerateTripcodesWithOptimization)(&W0, PW, W0Shifted, ABC);

	lea	eax, DWORD PTR _ABC$2[ebp]
	push	eax
	lea	eax, DWORD PTR _W0Shifted$[ebp]
	push	eax
	lea	eax, DWORD PTR _PW$[ebp]
	push	eax
	lea	eax, DWORD PTR _W0$1[ebp]
	push	eax
	call	DWORD PTR _SHA1_GenerateTripcodesWithOptimization$1$[ebp]

; 343  : 
; 344  : 				rawTripcodeArray[0][0] = ABC[0].m128i_u32[0];

	mov	eax, DWORD PTR _ABC$2[ebp]
	add	esp, 16					; 00000010H

; 345  : 				rawTripcodeArray[0][1] = ABC[1].m128i_u32[0];
; 346  : 				rawTripcodeArray[0][2] = ABC[2].m128i_u32[0];
; 347  : 
; 348  : 				rawTripcodeArray[1][0] = ABC[0].m128i_u32[1];
; 349  : 				rawTripcodeArray[1][1] = ABC[1].m128i_u32[1];
; 350  : 				rawTripcodeArray[1][2] = ABC[2].m128i_u32[1];
; 351  : 
; 352  : 				rawTripcodeArray[2][0] = ABC[0].m128i_u32[2];
; 353  : 				rawTripcodeArray[2][1] = ABC[1].m128i_u32[2];
; 354  : 				rawTripcodeArray[2][2] = ABC[2].m128i_u32[2];
; 355  : 
; 356  : 				rawTripcodeArray[3][0] = ABC[0].m128i_u32[3];
; 357  : 				rawTripcodeArray[3][1] = ABC[1].m128i_u32[3];
; 358  : 				rawTripcodeArray[3][2] = ABC[2].m128i_u32[3];
; 359  : 
; 360  : 				numGeneratedTripcodes += 4;

	add	DWORD PTR _numGeneratedTripcodes$1$[ebp], 4

; 361  : 			
; 362  : 				LOOK_FOR_POSSIBLE_MATCH(4)

	xor	edx, edx
	mov	DWORD PTR _rawTripcodeArray$[ebp], eax
	mov	eax, DWORD PTR _ABC$2[ebp+16]
	mov	DWORD PTR _rawTripcodeArray$[ebp+4], eax
	mov	eax, DWORD PTR _ABC$2[ebp+32]
	mov	DWORD PTR _rawTripcodeArray$[ebp+8], eax
	mov	eax, DWORD PTR _ABC$2[ebp+4]
	mov	DWORD PTR _rawTripcodeArray$[ebp+12], eax
	mov	eax, DWORD PTR _ABC$2[ebp+20]
	mov	DWORD PTR _rawTripcodeArray$[ebp+16], eax
	mov	eax, DWORD PTR _ABC$2[ebp+36]
	mov	DWORD PTR _rawTripcodeArray$[ebp+20], eax
	mov	eax, DWORD PTR _ABC$2[ebp+8]
	mov	DWORD PTR _rawTripcodeArray$[ebp+24], eax
	mov	eax, DWORD PTR _ABC$2[ebp+24]
	mov	DWORD PTR _rawTripcodeArray$[ebp+28], eax
	mov	eax, DWORD PTR _ABC$2[ebp+40]
	mov	DWORD PTR _rawTripcodeArray$[ebp+32], eax
	mov	eax, DWORD PTR _ABC$2[ebp+12]
	mov	DWORD PTR _rawTripcodeArray$[ebp+36], eax
	mov	eax, DWORD PTR _ABC$2[ebp+28]
	mov	DWORD PTR _rawTripcodeArray$[ebp+40], eax
	mov	eax, DWORD PTR _ABC$2[ebp+44]
	mov	DWORD PTR _rawTripcodeArray$[ebp+44], eax
	mov	eax, DWORD PTR _generatedTripcodeChunkArray$3[ebp+4]
	mov	DWORD PTR _wordIndex$1$[ebp], edx
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], eax
$LL69@SearchForT:
	mov	al, BYTE PTR _key$[ebp]
	xor	ecx, ecx
	and	al, 252					; 000000fcH
	mov	DWORD PTR _found$1$[ebp], ecx
	or	al, dl
	mov	BYTE PTR _key$[ebp], al
	cmp	DWORD PTR ?searchMode@@3HA, ecx		; searchMode
	jne	SHORT $LN66@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx]
	shr	edi, 2
	jmp	SHORT $LN194@SearchForT
$LN66@SearchForT:
	cmp	DWORD PTR ?searchMode@@3HA, 1		; searchMode
	jne	SHORT $LN64@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx+4]
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	and	edi, 4194303				; 003fffffH
	shl	edi, 8
	or	edi, eax
$LN194@SearchForT:
	cmp	DWORD PTR ?numTripcodeChunk@@3IA, 1	; numTripcodeChunk
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp], edi
	mov	DWORD PTR tv2419[ebp], edx
	jne	$LN60@SearchForT
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	cmp	edi, DWORD PTR [eax]
	jne	$LN158@SearchForT
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
	jmp	$LN158@SearchForT
$LN64@SearchForT:
	cmp	DWORD PTR ?searchMode@@3HA, 2		; searchMode
	jne	SHORT $LN62@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	DWORD PTR tv2419[ebp], edx
	mov	ecx, DWORD PTR _rawTripcodeArray$[ebp+edx+4]
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx]
	and	ecx, 4194303				; 003fffffH
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	shl	ecx, 8
	shr	edi, 2
	or	ecx, eax
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+4], ecx
	jmp	$LN157@SearchForT
$LN62@SearchForT:
	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 2
	mov	DWORD PTR tv2419[ebp], eax
	mov	esi, DWORD PTR _rawTripcodeArray$[ebp+eax+4]
	mov	ecx, esi
	mov	edx, DWORD PTR _rawTripcodeArray$[ebp+eax]
	mov	edi, edx
	shr	ecx, 28					; 0000001cH
	mov	eax, edx
	shl	eax, 4
	or	ecx, eax
	shr	edi, 2
	and	ecx, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp], edi
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
	mov	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+4], ecx
	mov	ecx, esi
	shr	ecx, 22					; 00000016H
	shl	eax, 10					; 0000000aH
	or	ecx, eax
	mov	eax, DWORD PTR tv2419[ebp]
	and	ecx, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+8], ecx
	movzx	ecx, WORD PTR _rawTripcodeArray$[ebp+eax+6]
	mov	eax, edx
	and	eax, 16383				; 00003fffH
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+12], ecx
	mov	ecx, esi
	shr	ecx, 10					; 0000000aH
	shl	eax, 22					; 00000016H
	or	ecx, eax
	shl	edx, 28					; 0000001cH
	mov	eax, esi
	and	ecx, 1073741823				; 3fffffffH
	shr	eax, 4
	or	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+16], ecx
	mov	edx, DWORD PTR tv2419[ebp]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+20], eax
	lea	eax, DWORD PTR [esi*4]
	and	esi, 4194303				; 003fffffH
	shl	esi, 8
	mov	ecx, DWORD PTR _rawTripcodeArray$[ebp+edx+8]
	shr	ecx, 30					; 0000001eH
	or	ecx, eax
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	and	ecx, 1073741823				; 3fffffffH
	or	eax, esi
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+24], ecx
	mov	ecx, DWORD PTR _found$1$[ebp]
	mov	DWORD PTR _generatedTripcodeChunkArray$3[ebp+28], eax
$LN60@SearchForT:
	mov	eax, DWORD PTR ?searchMode@@3HA		; searchMode
	test	eax, eax
	je	$LN159@SearchForT
	cmp	eax, 1
	je	$LN159@SearchForT
	cmp	eax, 2
	jne	$LN46@SearchForT
$LN157@SearchForT:
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN160@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	SHORT $LN160@SearchForT
	npad	8
$LL44@SearchForT:
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	add	ecx, esi
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	edi, eax
	jbe	SHORT $LN195@SearchForT
	inc	ecx
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN39@SearchForT
$LN195@SearchForT:
	jae	SHORT $LN40@SearchForT
	lea	esi, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _lower$1$[ebp]
$LN39@SearchForT:
	cmp	ecx, esi
	jle	SHORT $LL44@SearchForT
$LN160@SearchForT:
	mov	eax, DWORD PTR _generatedTripcodeChunkArray$2$[ebp]
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	$LN158@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	edi, edi
	dec	esi
	js	$LN158@SearchForT
	npad	3
$LL37@SearchForT:
	mov	ecx, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [esi+edi]
	sar	eax, 1
	mov	ecx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
	jbe	SHORT $LN196@SearchForT
	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN32@SearchForT
$LN40@SearchForT:
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
	jmp	$LN68@SearchForT
$LN196@SearchForT:
	jae	SHORT $LN40@SearchForT
	lea	esi, DWORD PTR [eax-1]
$LN32@SearchForT:
	cmp	edi, esi
	jle	SHORT $LL37@SearchForT

; 295  : 		break;
; 296  : 	}
; 297  : 
; 298  : 	__declspec(align(16)) __m128i PW[80], W0Shifted[23];
; 299  : 	unsigned char keyCharTable_FirstByte_local           [SIZE_KEY_CHAR_TABLE];
; 300  : 	unsigned char keyCharTable_SecondByteAndOneByte_local[SIZE_KEY_CHAR_TABLE];
; 301  : 
; 302  : 	for (int32_t i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	jmp	$LN158@SearchForT
$LN46@SearchForT:

; 361  : 			
; 362  : 				LOOK_FOR_POSSIBLE_MATCH(4)

	cmp	DWORD PTR ?searchMode@@3HA, 3		; searchMode
	je	SHORT $LN103@SearchForT
	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _maxPos$1$[ebp], eax
	jmp	SHORT $LL168@SearchForT
$LN103@SearchForT:
	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	xor	esi, esi
	add	eax, -5					; fffffffbH
	mov	DWORD PTR _maxPos$1$[ebp], eax
	js	$LN158@SearchForT
	npad	7
$LL168@SearchForT:
	test	ecx, ecx
	jne	SHORT $LN29@SearchForT
	mov	edi, DWORD PTR _generatedTripcodeChunkArray$3[ebp+esi*4]
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], cl
	jne	SHORT $LN187@SearchForT
	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	dec	edx
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	SHORT $LN186@SearchForT
$LL26@SearchForT:
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	add	ecx, edx
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	edi, eax
	jbe	SHORT $LN197@SearchForT
	inc	ecx
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN21@SearchForT
$LN197@SearchForT:
	jae	SHORT $LN22@SearchForT
	lea	edx, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _lower$1$[ebp]
$LN21@SearchForT:
	cmp	ecx, edx
	jle	SHORT $LL26@SearchForT
$LN186@SearchForT:
	mov	ecx, DWORD PTR _found$1$[ebp]
$LN187@SearchForT:
	mov	eax, DWORD PTR _maxPos$1$[ebp]
$LN29@SearchForT:
	inc	esi
	cmp	esi, eax
	jle	SHORT $LL168@SearchForT
	test	ecx, ecx
	je	$LN158@SearchForT
	jmp	$LN68@SearchForT
$LN22@SearchForT:
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, DWORD PTR tv2419[ebp]
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	mov	ecx, 1
	add	esp, 8
	mov	DWORD PTR _found$1$[ebp], ecx
	jmp	SHORT $LN187@SearchForT
$LN159@SearchForT:
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN158@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	SHORT $LN158@SearchForT
	npad	3
$LL53@SearchForT:
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	add	ecx, esi
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	edi, eax
	jbe	SHORT $LN198@SearchForT
	inc	ecx
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN48@SearchForT
$LN198@SearchForT:
	jae	$LN40@SearchForT
	lea	esi, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _lower$1$[ebp]
$LN48@SearchForT:
	cmp	ecx, esi
	jle	SHORT $LL53@SearchForT
$LN158@SearchForT:
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	je	$LN68@SearchForT
	mov	eax, DWORD PTR tv2419[ebp]
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, eax
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	cmp	DWORD PTR ?options@@3UOptions@@A+60, 0
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	mov	ch, BYTE PTR _tripcode$[ebp+2]
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	mov	dl, BYTE PTR _tripcode$[ebp]
	je	SHORT $LN19@SearchForT
	cmp	dl, BYTE PTR _tripcode$[ebp+11]
	jne	SHORT $LN19@SearchForT
	cmp	cl, BYTE PTR _tripcode$[ebp+10]
	jne	SHORT $LN19@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+9]
	jne	SHORT $LN19@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+3]
	cmp	al, BYTE PTR _tripcode$[ebp+8]
	jne	SHORT $LN19@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN19@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+5]
	cmp	al, BYTE PTR _tripcode$[ebp+6]
	je	$LN199@SearchForT
$LN19@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+72, 0
	je	SHORT $LN17@SearchForT
	mov	dh, BYTE PTR _tripcode$[ebp+11]
	movzx	eax, dl
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN17@SearchForT
	movzx	eax, cl
	mov	cl, BYTE PTR _tripcode$[ebp+10]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	jne	SHORT $LN17@SearchForT
	mov	cl, BYTE PTR _tripcode$[ebp+9]
	movzx	eax, ch
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	jne	SHORT $LN17@SearchForT
	movzx	eax, BYTE PTR _tripcode$[ebp+3]
	mov	dh, BYTE PTR _tripcode$[ebp+8]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN17@SearchForT
	mov	dl, BYTE PTR _tripcode$[ebp+7]
	movzx	eax, dh
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dl
	mov	dl, BYTE PTR _tripcode$[ebp]
	jne	SHORT $LN17@SearchForT
	movzx	eax, BYTE PTR _tripcode$[ebp+5]
	mov	dl, BYTE PTR _tripcode$[ebp+6]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dl
	mov	dl, BYTE PTR _tripcode$[ebp]
	je	$LN199@SearchForT
$LN17@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+64, 0
	mov	al, BYTE PTR _tripcode$[ebp+6]
	mov	ah, BYTE PTR _tripcode$[ebp+8]
	je	SHORT $LN15@SearchForT
	cmp	dl, al
	jne	SHORT $LN15@SearchForT
	cmp	cl, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN15@SearchForT
	cmp	ch, ah
	jne	SHORT $LN15@SearchForT
	mov	dh, BYTE PTR _tripcode$[ebp+9]
	cmp	BYTE PTR _tripcode$[ebp+3], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN15@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+10]
	jne	SHORT $LN15@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+11]
	cmp	BYTE PTR _tripcode$[ebp+5], al
	mov	al, BYTE PTR _tripcode$[ebp+6]
	je	$LN199@SearchForT
$LN15@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+68, 0
	je	SHORT $LN13@SearchForT
	cmp	dl, cl
	jne	SHORT $LN13@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+3]
	jne	SHORT $LN13@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+5]
	jne	SHORT $LN13@SearchForT
	cmp	al, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN13@SearchForT
	cmp	ah, BYTE PTR _tripcode$[ebp+9]
	jne	SHORT $LN13@SearchForT
	mov	cl, BYTE PTR _tripcode$[ebp+11]
	cmp	BYTE PTR _tripcode$[ebp+10], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	je	$LN199@SearchForT
$LN13@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+52, 0
	je	SHORT $LN5@SearchForT
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN11@SearchForT
	cmp	ch, dl
	jne	SHORT $LN11@SearchForT
	cmp	dh, dl
	jne	SHORT $LN11@SearchForT
	cmp	al, dl
	jne	SHORT $LN11@SearchForT
	cmp	ah, dl
	jne	SHORT $LN11@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	$LN199@SearchForT
$LN11@SearchForT:
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	je	SHORT $LN199@SearchForT
$LN9@SearchForT:
	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN7@SearchForT
	cmp	ch, dl
	jne	SHORT $LN7@SearchForT
	cmp	dh, dl
	jne	SHORT $LN7@SearchForT
	cmp	al, dl
	jne	SHORT $LN7@SearchForT
	cmp	ah, dl
	jne	SHORT $LN7@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	SHORT $LN199@SearchForT
$LN7@SearchForT:
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	je	SHORT $LN199@SearchForT
$LN5@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+56, 0
	je	SHORT $LN68@SearchForT
	cmp	ch, dl
	jne	SHORT $LN3@SearchForT
	cmp	dh, dl
	jne	SHORT $LN3@SearchForT
	cmp	al, dl
	jne	SHORT $LN3@SearchForT
	cmp	ah, dl
	jne	SHORT $LN3@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	SHORT $LN199@SearchForT
$LN3@SearchForT:
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	jne	SHORT $LN68@SearchForT
$LN199@SearchForT:
	lea	edx, DWORD PTR _key$[ebp]
	lea	ecx, DWORD PTR _tripcode$[ebp]
	call	?ProcessMatch@@YAXPAE0@Z		; ProcessMatch
$LN68@SearchForT:
	mov	edx, DWORD PTR _wordIndex$1$[ebp]
	inc	edx
	mov	DWORD PTR _wordIndex$1$[ebp], edx
	cmp	edx, 4
	jl	$LL69@SearchForT

; 332  : 
; 333  : 			for (int32_t indexKey3 = 0; indexKey3 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey3) {

	mov	eax, DWORD PTR _indexKey3$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey3$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jg	SHORT $LN184@SearchForT
	mov	dl, BYTE PTR _key$[ebp+2]
	jmp	$LL72@SearchForT
$LN184@SearchForT:

; 329  : 
; 330  : 		for (int32_t indexKey2 = 0; indexKey2 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey2) {

	mov	eax, DWORD PTR _indexKey2$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey2$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jle	$LL75@SearchForT

; 326  : 
; 327  : 	for (int32_t indexKey1 = 0; indexKey1 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey1) {

	mov	eax, DWORD PTR _indexKey1$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey1$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jle	$LL78@SearchForT

; 363  : 			}
; 364  : 		}
; 365  : 	}
; 366  : 
; 367  : 	return numGeneratedTripcodes;
; 368  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _numGeneratedTripcodes$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN200@SearchForT:

; 287  : 	key     [lenTripcodeKey] = '\0';

	call	___report_rangecheckfailure
$LN201@SearchForT:
$LN191@SearchForT:
	int	3
?SearchForTripcodesWithOptimization@@YAIXZ ENDP		; SearchForTripcodesWithOptimization
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?SearchForTripcodesWithOptimization_AVX2@@YAIXZ
_TEXT	SEGMENT
_indexKey3$1$ = -4688					; size = 4
tv3063 = -4684						; size = 4
_wordIndex$1$ = -4680					; size = 4
_indexKey1$1$ = -4676					; size = 4
_indexKey2$1$ = -4672					; size = 4
_numGeneratedTripcodes$1$ = -4668			; size = 4
_maxPos$1$ = -4664					; size = 4
_lower$1$ = -4660					; size = 4
_lower$1$ = -4660					; size = 4
_generatedTripcodeChunkArray$2$ = -4656			; size = 4
tv3069 = -4652						; size = 4
_lower$1$ = -4648					; size = 4
_lower$1$ = -4648					; size = 4
_found$1$ = -4648					; size = 4
_key$6$ = -4641						; size = 1
_W0$ = -4640						; size = 32
_W0Shifted$ = -4608					; size = 736
_PW$ = -3872						; size = 2560
_ABC$ = -1312						; size = 96
_rawTripcodeArray$ = -1192				; size = 96
_generatedTripcodeChunkArray$1 = -1096			; size = 32
_keyCharTable_FirstByte_local$ = -1064			; size = 512
_keyCharTable_SecondByteAndOneByte_local$ = -552	; size = 512
_key$ = -36						; size = 13
_tripcode$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?SearchForTripcodesWithOptimization_AVX2@@YAIXZ PROC	; SearchForTripcodesWithOptimization_AVX2, COMDAT

; 371  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -32				; ffffffe0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	mov	eax, 4696				; 00001258H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 372  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE + 1], key[MAX_LEN_TRIPCODE_KEY + 1];
; 373  : 	uint32_t   numGeneratedTripcodes = 0;

	xor	eax, eax
	mov	DWORD PTR _numGeneratedTripcodes$1$[ebp], eax

; 374  : 	uint32_t   rawTripcodeArray[8][3];
; 375  : 
; 376  : 	tripcode[lenTripcode]    = '\0';

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	push	esi
	push	edi
	cmp	eax, 13					; 0000000dH
	jae	$LN206@SearchForT
	mov	BYTE PTR _tripcode$[ebp+eax], 0

; 377  : 	key     [lenTripcodeKey] = '\0';

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	cmp	eax, 13					; 0000000dH
	jae	$LN206@SearchForT
	mov	BYTE PTR _key$[ebp+eax], 0
$LN198@SearchForT:

; 378  : 
; 379  : 	SetCharactersInTripcodeKeyForSHA1Tripcode(key);

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
$LN199@SearchForT:
	call	?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z ; SetCharactersInTripcodeKeyForSHA1Tripcode

; 380  : 	while (TRUE) {
; 381  : 		key[0] = ((key[0] & 0xf8) | 0x00); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$[ebp]
	add	esp, 4
	and	al, 248					; 000000f8H
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN198@SearchForT

; 382  : 		key[0] = ((key[0] & 0xf8) | 0x01); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 249					; 000000f9H
	or	al, 1
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN198@SearchForT

; 383  : 		key[0] = ((key[0] & 0xf8) | 0x02); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 250					; 000000faH
	or	al, 2
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LN198@SearchForT

; 384  : 		key[0] = ((key[0] & 0xf8) | 0x03); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 251					; 000000fbH
	or	al, 3
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	$LN198@SearchForT

; 385  : 		key[0] = ((key[0] & 0xf8) | 0x04); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 252					; 000000fcH
	or	al, 4
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	$LN198@SearchForT

; 386  : 		key[0] = ((key[0] & 0xf8) | 0x05); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 253					; 000000fdH
	or	al, 5
	mov	BYTE PTR _key$6$[ebp], al
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	$LN198@SearchForT

; 387  : 		key[0] = ((key[0] & 0xf8) | 0x06); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	mov	al, BYTE PTR _key$6$[ebp]
	and	al, 254					; 000000feH
	or	al, 6
	mov	BYTE PTR _key$[ebp], al
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	je	$LN199@SearchForT

; 388  : 		key[0] = ((key[0] & 0xf8) | 0x07); if (!IsValidKey(key)) { SetCharactersInTripcodeKeyForSHA1Tripcode(key); continue; }

	or	BYTE PTR _key$[ebp], 7
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	$LN198@SearchForT

; 399  : 		keyCharTable_FirstByte_local[i]            = keyCharTable_FirstByte[i];
; 400  : 		keyCharTable_SecondByteAndOneByte_local[i] = keyCharTable_SecondByteAndOneByte[i];

	push	512					; 00000200H
	lea	eax, DWORD PTR _keyCharTable_SecondByteAndOneByte_local$[ebp]
	push	OFFSET ?keyCharTable_SecondByteAndOneByte@@3PAEA ; keyCharTable_SecondByteAndOneByte
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _keyCharTable_FirstByte_local$[ebp]
	push	512					; 00000200H
	push	OFFSET ?keyCharTable_FirstByte@@3PAEA	; keyCharTable_FirstByte
	push	eax
	call	_memcpy

; 401  : 	}
; 402  : 
; 403  : 	PW[0].lower  = PW[0].upper  = _mm_set1_epi32(0);
; 404  : 	PW[1].lower  = PW[1].upper  = _mm_set1_epi32((key[4] << 24) | (key[5] << 16) | (key[ 6] << 8) | key[ 7]);

	movzx	ecx, BYTE PTR _key$[ebp+4]
	xorps	xmm2, xmm2
	movzx	eax, BYTE PTR _key$[ebp+5]
	add	esp, 12					; 0000000cH
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+16], xmm2
	movzx	eax, BYTE PTR _key$[ebp+6]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp], xmm2
	movzx	eax, BYTE PTR _key$[ebp+7]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+144], xmm2

; 405  : 	PW[2].lower  = PW[2].upper  = _mm_set1_epi32((key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11]);

	movzx	eax, BYTE PTR _key$[ebp+9]

; 406  : 	PW[3].lower  = PW[3].upper  = _mm_set1_epi32(0x80000000);
; 407  : 	PW[4].lower  = PW[4].upper  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+128], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+176], xmm2
	movd	xmm0, ecx
	movzx	ecx, BYTE PTR _key$[ebp+8]
	shl	ecx, 8
	or	ecx, eax
	pshufd	xmm0, xmm0, 0
	movzx	eax, BYTE PTR _key$[ebp+10]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+48], xmm0
	movzx	eax, BYTE PTR _key$[ebp+11]
	shl	ecx, 8
	or	ecx, eax
	movdqa	XMMWORD PTR _PW$[ebp+32], xmm0

; 408  : 	PW[5].lower  = PW[5].upper  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+160], xmm2
	lea	eax, DWORD PTR _PW$[ebp+448]
	movdqa	XMMWORD PTR _PW$[ebp+208], xmm2

; 409  : 	PW[6].lower  = PW[6].upper  = _mm_set1_epi32(0);

	movdqa	XMMWORD PTR _PW$[ebp+192], xmm2
	movd	xmm0, ecx
	mov	ecx, 63					; 0000003fH
	pshufd	xmm1, xmm0, 0
	movdqa	xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
	movdqa	XMMWORD PTR _PW$[ebp+112], xmm0
	movdqa	XMMWORD PTR _PW$[ebp+96], xmm0

; 410  : 	PW[7].lower  = PW[7].upper  = _mm_set1_epi32(0);
; 411  : 	PW[8].lower  = PW[8].upper  = _mm_set1_epi32(0);
; 412  : 	PW[9].lower  = PW[9].upper  = _mm_set1_epi32(0);
; 413  : 	PW[10].lower = PW[10].upper = _mm_set1_epi32(0);
; 414  : 	PW[11].lower = PW[11].upper = _mm_set1_epi32(0);
; 415  : 	PW[12].lower = PW[12].upper = _mm_set1_epi32(0);
; 416  : 	PW[13].lower = PW[13].upper = _mm_set1_epi32(0);
; 417  : 	PW[14].lower = PW[14].upper = _mm_set1_epi32(0);
; 418  : 	PW[15].lower = PW[15].upper = _mm_set1_epi32(12 * 8);

	movdqa	xmm0, XMMWORD PTR __xmm@00000060000000600000006000000060
	movdqa	XMMWORD PTR _PW$[ebp+240], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+224], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+272], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+256], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+304], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+288], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+336], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+320], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+368], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+352], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+400], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+384], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+432], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+416], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+464], xmm2
	movdqa	XMMWORD PTR _PW$[ebp+448], xmm2

; 419  : 	PW[16].lower = PW[16].upper = ROTL(1, _mm_xor_si128(_mm_xor_si128(PW[16 - 3].lower, PW[16 - 8].lower), PW[16 - 14].lower));

	pxor	xmm2, xmm1
	movdqa	XMMWORD PTR _PW$[ebp+496], xmm0
	movdqa	XMMWORD PTR _PW$[ebp+480], xmm0
	movdqa	xmm0, xmm2
	psrld	xmm0, 31				; 0000001fH
	pslld	xmm2, 1
	movdqa	XMMWORD PTR _PW$[ebp+80], xmm1
	por	xmm0, xmm2
	movdqa	XMMWORD PTR _PW$[ebp+64], xmm1
	movdqa	XMMWORD PTR _PW$[ebp+528], xmm0
	movdqa	XMMWORD PTR _PW$[ebp+512], xmm0
	npad	2
$LL81@SearchForT:

; 420  : 	for (int32_t t = 17; t < 80; ++t)
; 421  : 		PW[t].lower = PW[t].upper = ROTL(1, _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(PW[(t) - 3].lower, PW[(t) - 8].lower), PW[(t) - 14].lower), PW[(t) - 16].lower));

	movdqa	xmm1, XMMWORD PTR [eax-160]
	lea	eax, DWORD PTR [eax+32]
	pxor	xmm1, XMMWORD PTR [eax-32]
	pxor	xmm1, XMMWORD PTR [eax-384]
	pxor	xmm1, XMMWORD PTR [eax-448]
	movdqa	xmm0, xmm1
	pslld	xmm1, 1
	psrld	xmm0, 31				; 0000001fH
	por	xmm0, xmm1
	movdqa	XMMWORD PTR [eax+80], xmm0
	movdqa	XMMWORD PTR [eax+64], xmm0
	dec	ecx
	jne	SHORT $LL81@SearchForT

; 422  : 
; 423  : 	for (int32_t indexKey1 = 0; indexKey1 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey1) {

	xor	eax, eax
	mov	DWORD PTR _indexKey1$1$[ebp], eax
	npad	9
$LL78@SearchForT:

; 424  : 		key[1] = keyCharTable_SecondByteAndOneByte_local[indexKey1];

	mov	al, BYTE PTR _keyCharTable_SecondByteAndOneByte_local$[ebp+eax]
	mov	BYTE PTR _key$[ebp+1], al

; 425  : 
; 426  : 		for (int32_t indexKey2 = 0; indexKey2 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey2) {

	xor	eax, eax
	mov	DWORD PTR _indexKey2$1$[ebp], eax
$LL75@SearchForT:

; 427  : 			key[2] = keyCharTable_FirstByte_local[indexKey2];

	mov	dl, BYTE PTR _keyCharTable_FirstByte_local$[ebp+eax]

; 428  : 
; 429  : 			for (int32_t indexKey3 = 0; indexKey3 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey3) {

	xor	eax, eax
	mov	BYTE PTR _key$[ebp+2], dl
	mov	DWORD PTR _indexKey3$1$[ebp], eax
	npad	12
$LL72@SearchForT:

; 430  : 				key[3] = keyCharTable_SecondByteAndOneByte_local[indexKey3];

	mov	al, BYTE PTR _keyCharTable_SecondByteAndOneByte_local$[ebp+eax]
	mov	BYTE PTR _key$[ebp+3], al

; 431  : 				
; 432  : 				W0.lower.m128i_u32[0] = (((key[0] & 0xf8) | 0x00) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	movzx	esi, al
	movzx	edi, BYTE PTR _key$[ebp]
	movzx	ecx, BYTE PTR _key$[ebp+1]
	mov	eax, edi
	and	eax, -8					; fffffff8H
	movzx	edx, dl
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp], eax

; 433  : 				W0.lower.m128i_u32[1] = (((key[0] & 0xf8) | 0x01) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -7					; fffffff9H
	or	eax, 1
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp+4], eax

; 434  : 				W0.lower.m128i_u32[2] = (((key[0] & 0xf8) | 0x02) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -6					; fffffffaH
	or	eax, 2
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp+8], eax

; 435  : 				W0.lower.m128i_u32[3] = (((key[0] & 0xf8) | 0x03) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -5					; fffffffbH
	or	eax, 3
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp+12], eax

; 436  : 
; 437  : 				W0.upper.m128i_u32[0] = (((key[0] & 0xf8) | 0x04) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -4					; fffffffcH
	or	eax, 4
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp+16], eax

; 438  : 				W0.upper.m128i_u32[1] = (((key[0] & 0xf8) | 0x05) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -3					; fffffffdH
	or	eax, 5
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	mov	DWORD PTR _W0$[ebp+20], eax

; 439  : 				W0.upper.m128i_u32[2] = (((key[0] & 0xf8) | 0x06) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	mov	eax, edi
	and	eax, -2					; fffffffeH

; 440  : 				W0.upper.m128i_u32[3] = (((key[0] & 0xf8) | 0x07) << 24) | (key[1] << 16) | (key[ 2] << 8) | key[ 3];

	or	edi, 7
	or	eax, 6
	shl	edi, 8
	shl	eax, 8
	or	edi, ecx
	or	eax, ecx
	shl	edi, 8
	shl	eax, 8
	or	edi, edx
	or	eax, edx
	shl	eax, 8
	or	eax, esi
	shl	edi, 8
	mov	DWORD PTR _W0$[ebp+24], eax

; 441  : 
; 442  : #ifdef _M_X64
; 443  : 				SHA1_GenerateTripcodesWithOptimization_x64_AVX2(&W0, PW, W0Shifted, ABC);
; 444  : #else
; 445  : 				SHA1_GenerateTripcodesWithOptimization_x86_AVX2(&W0, PW, W0Shifted, ABC);

	lea	eax, DWORD PTR _ABC$[ebp]
	or	edi, esi
	push	eax
	lea	eax, DWORD PTR _W0Shifted$[ebp]
	mov	DWORD PTR _W0$[ebp+28], edi
	push	eax
	lea	eax, DWORD PTR _PW$[ebp]
	push	eax
	lea	eax, DWORD PTR _W0$[ebp]
	push	eax
	call	_SHA1_GenerateTripcodesWithOptimization_x86_AVX2

; 446  : #endif
; 447  : 
; 448  : 				rawTripcodeArray[0][0] = ABC[0].lower.m128i_u32[0];

	mov	eax, DWORD PTR _ABC$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rawTripcodeArray$[ebp], eax

; 449  : 				rawTripcodeArray[0][1] = ABC[1].lower.m128i_u32[0];

	mov	eax, DWORD PTR _ABC$[ebp+32]
	mov	DWORD PTR _rawTripcodeArray$[ebp+4], eax

; 450  : 				rawTripcodeArray[0][2] = ABC[2].lower.m128i_u32[0];

	mov	eax, DWORD PTR _ABC$[ebp+64]
	mov	DWORD PTR _rawTripcodeArray$[ebp+8], eax

; 451  : 
; 452  : 				rawTripcodeArray[1][0] = ABC[0].lower.m128i_u32[1];

	mov	eax, DWORD PTR _ABC$[ebp+4]
	mov	DWORD PTR _rawTripcodeArray$[ebp+12], eax

; 453  : 				rawTripcodeArray[1][1] = ABC[1].lower.m128i_u32[1];

	mov	eax, DWORD PTR _ABC$[ebp+36]
	mov	DWORD PTR _rawTripcodeArray$[ebp+16], eax

; 454  : 				rawTripcodeArray[1][2] = ABC[2].lower.m128i_u32[1];

	mov	eax, DWORD PTR _ABC$[ebp+68]
	mov	DWORD PTR _rawTripcodeArray$[ebp+20], eax

; 455  : 
; 456  : 				rawTripcodeArray[2][0] = ABC[0].lower.m128i_u32[2];

	mov	eax, DWORD PTR _ABC$[ebp+8]
	mov	DWORD PTR _rawTripcodeArray$[ebp+24], eax

; 457  : 				rawTripcodeArray[2][1] = ABC[1].lower.m128i_u32[2];

	mov	eax, DWORD PTR _ABC$[ebp+40]
	mov	DWORD PTR _rawTripcodeArray$[ebp+28], eax

; 458  : 				rawTripcodeArray[2][2] = ABC[2].lower.m128i_u32[2];

	mov	eax, DWORD PTR _ABC$[ebp+72]
	mov	DWORD PTR _rawTripcodeArray$[ebp+32], eax

; 459  : 
; 460  : 				rawTripcodeArray[3][0] = ABC[0].lower.m128i_u32[3];

	mov	eax, DWORD PTR _ABC$[ebp+12]
	mov	DWORD PTR _rawTripcodeArray$[ebp+36], eax

; 461  : 				rawTripcodeArray[3][1] = ABC[1].lower.m128i_u32[3];

	mov	eax, DWORD PTR _ABC$[ebp+44]
	mov	DWORD PTR _rawTripcodeArray$[ebp+40], eax

; 462  : 				rawTripcodeArray[3][2] = ABC[2].lower.m128i_u32[3];

	mov	eax, DWORD PTR _ABC$[ebp+76]
	mov	DWORD PTR _rawTripcodeArray$[ebp+44], eax

; 463  : 
; 464  : 				rawTripcodeArray[4][0] = ABC[0].upper.m128i_u32[0];

	mov	eax, DWORD PTR _ABC$[ebp+16]

; 465  : 				rawTripcodeArray[4][1] = ABC[1].upper.m128i_u32[0];
; 466  : 				rawTripcodeArray[4][2] = ABC[2].upper.m128i_u32[0];
; 467  : 
; 468  : 				rawTripcodeArray[5][0] = ABC[0].upper.m128i_u32[1];
; 469  : 				rawTripcodeArray[5][1] = ABC[1].upper.m128i_u32[1];
; 470  : 				rawTripcodeArray[5][2] = ABC[2].upper.m128i_u32[1];
; 471  : 
; 472  : 				rawTripcodeArray[6][0] = ABC[0].upper.m128i_u32[2];
; 473  : 				rawTripcodeArray[6][1] = ABC[1].upper.m128i_u32[2];
; 474  : 				rawTripcodeArray[6][2] = ABC[2].upper.m128i_u32[2];
; 475  : 
; 476  : 				rawTripcodeArray[7][0] = ABC[0].upper.m128i_u32[3];
; 477  : 				rawTripcodeArray[7][1] = ABC[1].upper.m128i_u32[3];
; 478  : 				rawTripcodeArray[7][2] = ABC[2].upper.m128i_u32[3];
; 479  : 
; 480  : 				numGeneratedTripcodes += 8;

	add	DWORD PTR _numGeneratedTripcodes$1$[ebp], 8

; 481  : 			
; 482  : 				LOOK_FOR_POSSIBLE_MATCH(8)

	xor	edx, edx
	mov	ecx, DWORD PTR _generatedTripcodeChunkArray$1[ebp+4]
	mov	DWORD PTR _rawTripcodeArray$[ebp+48], eax
	mov	eax, DWORD PTR _ABC$[ebp+48]
	mov	DWORD PTR _rawTripcodeArray$[ebp+52], eax
	mov	eax, DWORD PTR _ABC$[ebp+80]
	mov	DWORD PTR _rawTripcodeArray$[ebp+56], eax
	mov	eax, DWORD PTR _ABC$[ebp+20]
	mov	DWORD PTR _rawTripcodeArray$[ebp+60], eax
	mov	eax, DWORD PTR _ABC$[ebp+52]
	mov	DWORD PTR _rawTripcodeArray$[ebp+64], eax
	mov	eax, DWORD PTR _ABC$[ebp+84]
	mov	DWORD PTR _rawTripcodeArray$[ebp+68], eax
	mov	eax, DWORD PTR _ABC$[ebp+24]
	mov	DWORD PTR _rawTripcodeArray$[ebp+72], eax
	mov	eax, DWORD PTR _ABC$[ebp+56]
	mov	DWORD PTR _rawTripcodeArray$[ebp+76], eax
	mov	eax, DWORD PTR _ABC$[ebp+88]
	mov	DWORD PTR _rawTripcodeArray$[ebp+80], eax
	mov	eax, DWORD PTR _ABC$[ebp+28]
	mov	DWORD PTR _rawTripcodeArray$[ebp+84], eax
	mov	eax, DWORD PTR _ABC$[ebp+60]
	mov	DWORD PTR _rawTripcodeArray$[ebp+88], eax
	mov	eax, DWORD PTR _ABC$[ebp+92]
	mov	DWORD PTR _rawTripcodeArray$[ebp+92], eax
	mov	DWORD PTR _wordIndex$1$[ebp], edx
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
$LL69@SearchForT:
	mov	al, BYTE PTR _key$[ebp]
	xor	esi, esi
	and	al, 248					; 000000f8H
	mov	DWORD PTR _found$1$[ebp], esi
	or	al, dl
	mov	BYTE PTR _key$[ebp], al
	cmp	DWORD PTR ?searchMode@@3HA, esi		; searchMode
	jne	SHORT $LN66@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx]
	shr	edi, 2
	jmp	SHORT $LN200@SearchForT
$LN66@SearchForT:
	cmp	DWORD PTR ?searchMode@@3HA, 1		; searchMode
	jne	SHORT $LN64@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx+4]
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	and	edi, 4194303				; 003fffffH
	shl	edi, 8
	or	edi, eax
$LN200@SearchForT:
	cmp	DWORD PTR ?numTripcodeChunk@@3IA, 1	; numTripcodeChunk
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp], edi
	mov	DWORD PTR tv3069[ebp], edx
	jne	$LN60@SearchForT
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	cmp	edi, DWORD PTR [eax]
	jne	$LN164@SearchForT
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
	jmp	$LN164@SearchForT
$LN64@SearchForT:
	cmp	DWORD PTR ?searchMode@@3HA, 2		; searchMode
	jne	SHORT $LN62@SearchForT
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 2
	mov	DWORD PTR tv3069[ebp], edx
	mov	ecx, DWORD PTR _rawTripcodeArray$[ebp+edx+4]
	mov	edi, DWORD PTR _rawTripcodeArray$[ebp+edx]
	and	ecx, 4194303				; 003fffffH
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	shl	ecx, 8
	shr	edi, 2
	or	ecx, eax
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+4], ecx
	jmp	$LN163@SearchForT
$LN62@SearchForT:
	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 2
	mov	DWORD PTR tv3069[ebp], eax
	mov	esi, DWORD PTR _rawTripcodeArray$[ebp+eax+4]
	mov	ecx, esi
	mov	edx, DWORD PTR _rawTripcodeArray$[ebp+eax]
	mov	edi, edx
	shr	ecx, 28					; 0000001cH
	mov	eax, edx
	shl	eax, 4
	or	ecx, eax
	shr	edi, 2
	and	ecx, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp], edi
	mov	DWORD PTR _generatedTripcodeChunkArray$2$[ebp], ecx
	mov	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+4], ecx
	mov	ecx, esi
	shr	ecx, 22					; 00000016H
	shl	eax, 10					; 0000000aH
	or	ecx, eax
	mov	eax, DWORD PTR tv3069[ebp]
	and	ecx, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+8], ecx
	movzx	ecx, WORD PTR _rawTripcodeArray$[ebp+eax+6]
	mov	eax, edx
	and	eax, 16383				; 00003fffH
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+12], ecx
	mov	ecx, esi
	shr	ecx, 10					; 0000000aH
	shl	eax, 22					; 00000016H
	or	ecx, eax
	shl	edx, 28					; 0000001cH
	mov	eax, esi
	and	ecx, 1073741823				; 3fffffffH
	shr	eax, 4
	or	eax, edx
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+16], ecx
	mov	edx, DWORD PTR tv3069[ebp]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+20], eax
	lea	eax, DWORD PTR [esi*4]
	and	esi, 4194303				; 003fffffH
	shl	esi, 8
	mov	ecx, DWORD PTR _rawTripcodeArray$[ebp+edx+8]
	shr	ecx, 30					; 0000001eH
	or	ecx, eax
	movzx	eax, BYTE PTR _rawTripcodeArray$[ebp+edx+11]
	and	ecx, 1073741823				; 3fffffffH
	or	eax, esi
	mov	esi, DWORD PTR _found$1$[ebp]
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+24], ecx
	mov	ecx, DWORD PTR _generatedTripcodeChunkArray$2$[ebp]
	mov	DWORD PTR _generatedTripcodeChunkArray$1[ebp+28], eax
$LN60@SearchForT:
	mov	eax, DWORD PTR ?searchMode@@3HA		; searchMode
	test	eax, eax
	je	$LN165@SearchForT
	cmp	eax, 1
	je	$LN165@SearchForT
	cmp	eax, 2
	jne	$LN46@SearchForT
$LN163@SearchForT:
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN166@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], 0
	js	SHORT $LN166@SearchForT
	mov	eax, DWORD PTR _lower$1$[ebp]
	npad	7
$LL44@SearchForT:
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	edi, eax
	jbe	SHORT $LN201@SearchForT
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _lower$1$[ebp], eax
	jmp	SHORT $LN39@SearchForT
$LN201@SearchForT:
	jae	SHORT $LN40@SearchForT
	mov	eax, DWORD PTR _lower$1$[ebp]
	lea	esi, DWORD PTR [ecx-1]
$LN39@SearchForT:
	cmp	eax, esi
	jle	SHORT $LL44@SearchForT

; 389  : 		break;
; 390  : 	}
; 391  : 
; 392  : 	__declspec(align(32)) struct {
; 393  : 		__m128i lower, upper; 
; 394  : 	} PW[80], W0Shifted[23], W0, ABC[3];
; 395  : 	unsigned char keyCharTable_FirstByte_local           [SIZE_KEY_CHAR_TABLE];
; 396  : 	unsigned char keyCharTable_SecondByteAndOneByte_local[SIZE_KEY_CHAR_TABLE];
; 397  : 
; 398  : 	for (int32_t i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	ecx, DWORD PTR _generatedTripcodeChunkArray$2$[ebp]
$LN166@SearchForT:

; 481  : 			
; 482  : 				LOOK_FOR_POSSIBLE_MATCH(8)

	mov	eax, ecx
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	$LN164@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	$LN164@SearchForT
	mov	edi, DWORD PTR _generatedTripcodeChunkArray$2$[ebp]
	npad	2
$LL37@SearchForT:
	lea	eax, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	sar	eax, 1
	mov	ecx, DWORD PTR [ecx+eax*4]
	cmp	edi, ecx
	jbe	SHORT $LN202@SearchForT
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN32@SearchForT
$LN40@SearchForT:
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
	jmp	$LN68@SearchForT
$LN202@SearchForT:
	jae	SHORT $LN40@SearchForT
	mov	ecx, DWORD PTR _lower$1$[ebp]
	lea	esi, DWORD PTR [eax-1]
$LN32@SearchForT:
	cmp	ecx, esi
	jle	SHORT $LL37@SearchForT

; 389  : 		break;
; 390  : 	}
; 391  : 
; 392  : 	__declspec(align(32)) struct {
; 393  : 		__m128i lower, upper; 
; 394  : 	} PW[80], W0Shifted[23], W0, ABC[3];
; 395  : 	unsigned char keyCharTable_FirstByte_local           [SIZE_KEY_CHAR_TABLE];
; 396  : 	unsigned char keyCharTable_SecondByteAndOneByte_local[SIZE_KEY_CHAR_TABLE];
; 397  : 
; 398  : 	for (int32_t i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	jmp	$LN164@SearchForT
$LN46@SearchForT:

; 481  : 			
; 482  : 				LOOK_FOR_POSSIBLE_MATCH(8)

	cmp	DWORD PTR ?searchMode@@3HA, 3		; searchMode
	je	SHORT $LN105@SearchForT
	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _maxPos$1$[ebp], eax
	jmp	SHORT $LL174@SearchForT
$LN105@SearchForT:
	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	xor	edi, edi
	add	eax, -5					; fffffffbH
	mov	DWORD PTR _maxPos$1$[ebp], eax
	js	$LN164@SearchForT
$LL174@SearchForT:
	test	esi, esi
	jne	SHORT $LN29@SearchForT
	mov	eax, DWORD PTR _generatedTripcodeChunkArray$1[ebp+edi*4]
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN193@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	SHORT $LN192@SearchForT
	npad	7
$LL26@SearchForT:
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	add	ecx, esi
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv3063[ebp], eax
	mov	eax, DWORD PTR _generatedTripcodeChunkArray$1[ebp+edi*4]
	cmp	eax, DWORD PTR tv3063[ebp]
	jbe	SHORT $LN203@SearchForT
	inc	ecx
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN21@SearchForT
$LN203@SearchForT:
	jae	SHORT $LN22@SearchForT
	lea	esi, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _lower$1$[ebp]
$LN21@SearchForT:
	cmp	ecx, esi
	jle	SHORT $LL26@SearchForT
$LN192@SearchForT:
	mov	esi, DWORD PTR _found$1$[ebp]
$LN193@SearchForT:
	mov	eax, DWORD PTR _maxPos$1$[ebp]
$LN29@SearchForT:
	inc	edi
	cmp	edi, eax
	jle	SHORT $LL174@SearchForT
	test	esi, esi
	je	$LN164@SearchForT
	jmp	$LN68@SearchForT
$LN22@SearchForT:
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	mov	edx, DWORD PTR tv3069[ebp]
	mov	esi, 1
	add	esp, 8
	mov	DWORD PTR _found$1$[ebp], esi
	jmp	SHORT $LN193@SearchForT
$LN165@SearchForT:
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN164@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	dec	esi
	mov	DWORD PTR _lower$1$[ebp], ecx
	js	SHORT $LN164@SearchForT
	npad	7
$LL53@SearchForT:
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	add	ecx, esi
	sar	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	edi, eax
	jbe	SHORT $LN204@SearchForT
	inc	ecx
	mov	DWORD PTR _lower$1$[ebp], ecx
	jmp	SHORT $LN48@SearchForT
$LN204@SearchForT:
	jae	$LN40@SearchForT
	lea	esi, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _lower$1$[ebp]
$LN48@SearchForT:
	cmp	ecx, esi
	jle	SHORT $LL53@SearchForT
$LN164@SearchForT:
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	je	$LN68@SearchForT
	mov	eax, DWORD PTR tv3069[ebp]
	lea	ecx, DWORD PTR _rawTripcodeArray$[ebp]
	add	ecx, eax
	lea	edx, DWORD PTR _tripcode$[ebp]
	call	?ConvertRaw12CharTripcodeIntoDisplayFormat@@YAXPAIPAE@Z ; ConvertRaw12CharTripcodeIntoDisplayFormat
	cmp	DWORD PTR ?options@@3UOptions@@A+60, 0
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	mov	ch, BYTE PTR _tripcode$[ebp+2]
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	mov	dl, BYTE PTR _tripcode$[ebp]
	je	SHORT $LN19@SearchForT
	cmp	dl, BYTE PTR _tripcode$[ebp+11]
	jne	SHORT $LN19@SearchForT
	cmp	cl, BYTE PTR _tripcode$[ebp+10]
	jne	SHORT $LN19@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+9]
	jne	SHORT $LN19@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+3]
	cmp	al, BYTE PTR _tripcode$[ebp+8]
	jne	SHORT $LN19@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN19@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+5]
	cmp	al, BYTE PTR _tripcode$[ebp+6]
	je	$LN205@SearchForT
$LN19@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+72, 0
	je	SHORT $LN17@SearchForT
	mov	dh, BYTE PTR _tripcode$[ebp+11]
	movzx	eax, dl
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN17@SearchForT
	movzx	eax, cl
	mov	cl, BYTE PTR _tripcode$[ebp+10]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	jne	SHORT $LN17@SearchForT
	mov	cl, BYTE PTR _tripcode$[ebp+9]
	movzx	eax, ch
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	jne	SHORT $LN17@SearchForT
	movzx	eax, BYTE PTR _tripcode$[ebp+3]
	mov	dh, BYTE PTR _tripcode$[ebp+8]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN17@SearchForT
	mov	dl, BYTE PTR _tripcode$[ebp+7]
	movzx	eax, dh
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dl
	mov	dl, BYTE PTR _tripcode$[ebp]
	jne	SHORT $LN17@SearchForT
	movzx	eax, BYTE PTR _tripcode$[ebp+5]
	mov	dl, BYTE PTR _tripcode$[ebp+6]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dl
	mov	dl, BYTE PTR _tripcode$[ebp]
	je	$LN205@SearchForT
$LN17@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+64, 0
	mov	al, BYTE PTR _tripcode$[ebp+6]
	mov	ah, BYTE PTR _tripcode$[ebp+8]
	je	SHORT $LN15@SearchForT
	cmp	dl, al
	jne	SHORT $LN15@SearchForT
	cmp	cl, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN15@SearchForT
	cmp	ch, ah
	jne	SHORT $LN15@SearchForT
	mov	dh, BYTE PTR _tripcode$[ebp+9]
	cmp	BYTE PTR _tripcode$[ebp+3], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN15@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+10]
	jne	SHORT $LN15@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+11]
	cmp	BYTE PTR _tripcode$[ebp+5], al
	mov	al, BYTE PTR _tripcode$[ebp+6]
	je	$LN205@SearchForT
$LN15@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+68, 0
	je	SHORT $LN13@SearchForT
	cmp	dl, cl
	jne	SHORT $LN13@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+3]
	jne	SHORT $LN13@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+5]
	jne	SHORT $LN13@SearchForT
	cmp	al, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN13@SearchForT
	cmp	ah, BYTE PTR _tripcode$[ebp+9]
	jne	SHORT $LN13@SearchForT
	mov	cl, BYTE PTR _tripcode$[ebp+11]
	cmp	BYTE PTR _tripcode$[ebp+10], cl
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	je	$LN205@SearchForT
$LN13@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+52, 0
	je	SHORT $LN5@SearchForT
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN11@SearchForT
	cmp	ch, dl
	jne	SHORT $LN11@SearchForT
	cmp	dh, dl
	jne	SHORT $LN11@SearchForT
	cmp	al, dl
	jne	SHORT $LN11@SearchForT
	cmp	ah, dl
	jne	SHORT $LN11@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	$LN205@SearchForT
$LN11@SearchForT:
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	je	SHORT $LN205@SearchForT
$LN9@SearchForT:
	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN7@SearchForT
	cmp	ch, dl
	jne	SHORT $LN7@SearchForT
	cmp	dh, dl
	jne	SHORT $LN7@SearchForT
	cmp	al, dl
	jne	SHORT $LN7@SearchForT
	cmp	ah, dl
	jne	SHORT $LN7@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	SHORT $LN205@SearchForT
$LN7@SearchForT:
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	je	SHORT $LN205@SearchForT
$LN5@SearchForT:
	cmp	DWORD PTR ?options@@3UOptions@@A+56, 0
	je	SHORT $LN68@SearchForT
	cmp	ch, dl
	jne	SHORT $LN3@SearchForT
	cmp	dh, dl
	jne	SHORT $LN3@SearchForT
	cmp	al, dl
	jne	SHORT $LN3@SearchForT
	cmp	ah, dl
	jne	SHORT $LN3@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+10], dl
	je	SHORT $LN205@SearchForT
$LN3@SearchForT:
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN68@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+11], cl
	jne	SHORT $LN68@SearchForT
$LN205@SearchForT:
	lea	edx, DWORD PTR _key$[ebp]
	lea	ecx, DWORD PTR _tripcode$[ebp]
	call	?ProcessMatch@@YAXPAE0@Z		; ProcessMatch
$LN68@SearchForT:
	mov	edx, DWORD PTR _wordIndex$1$[ebp]
	mov	ecx, DWORD PTR _generatedTripcodeChunkArray$2$[ebp]
	inc	edx
	mov	DWORD PTR _wordIndex$1$[ebp], edx
	cmp	edx, 8
	jl	$LL69@SearchForT

; 428  : 
; 429  : 			for (int32_t indexKey3 = 0; indexKey3 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey3) {

	mov	eax, DWORD PTR _indexKey3$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey3$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jg	SHORT $LN190@SearchForT
	mov	dl, BYTE PTR _key$[ebp+2]
	jmp	$LL72@SearchForT
$LN190@SearchForT:

; 425  : 
; 426  : 		for (int32_t indexKey2 = 0; indexKey2 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey2) {

	mov	eax, DWORD PTR _indexKey2$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey2$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jle	$LL75@SearchForT

; 422  : 
; 423  : 	for (int32_t indexKey1 = 0; indexKey1 <= CPU_SHA1_MAX_INDEX_FOR_KEYS; ++indexKey1) {

	mov	eax, DWORD PTR _indexKey1$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey1$1$[ebp], eax
	cmp	eax, 63					; 0000003fH
	jle	$LL78@SearchForT

; 483  : 			}
; 484  : 		}
; 485  : 	}
; 486  : 
; 487  : 	return numGeneratedTripcodes;
; 488  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _numGeneratedTripcodes$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN206@SearchForT:

; 377  : 	key     [lenTripcodeKey] = '\0';

	call	___report_rangecheckfailure
$LN207@SearchForT:
$LN197@SearchForT:
	int	3
?SearchForTripcodesWithOptimization_AVX2@@YAIXZ ENDP	; SearchForTripcodesWithOptimization_AVX2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?run_cpuid@@YAXIIPAH@Z
_TEXT	SEGMENT
_abcd$ = 8						; size = 4
?run_cpuid@@YAXIIPAH@Z PROC				; run_cpuid, COMDAT
; _eax$ = ecx
; _ecx$dead$ = edx

; 588  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 589  :     __cpuidex(abcd, eax, ecx);

	mov	esi, DWORD PTR _abcd$[ebp]
	mov	eax, ecx
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx
	pop	esi
	pop	ebx

; 590  : }     

	pop	ebp
	ret	0
?run_cpuid@@YAXIIPAH@Z ENDP				; run_cpuid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?check_xcr0_ymm@@YAHXZ
_TEXT	SEGMENT
?check_xcr0_ymm@@YAHXZ PROC				; check_xcr0_ymm, COMDAT

; 594  :     uint32_t xcr0;
; 595  :     xcr0 = (uint32_t)_myxgetbv(0);

	push	0
	call	__myxgetbv

; 596  :     return ((xcr0 & 6) == 6); /* checking if xmm and ymm state are enabled in XCR0 */

	and	eax, 6
	xor	ecx, ecx
	add	esp, 4
	cmp	al, 6
	sete	cl
	mov	eax, ecx

; 597  : }

	ret	0
?check_xcr0_ymm@@YAHXZ ENDP				; check_xcr0_ymm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?check_4th_gen_intel_core_features@@YAHXZ
_TEXT	SEGMENT
_abcd$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?check_4th_gen_intel_core_features@@YAHXZ PROC		; check_4th_gen_intel_core_features, COMDAT

; 600  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 589  :     __cpuidex(abcd, eax, ecx);

	xor	ecx, ecx
	mov	eax, 1
	cpuid
	push	esi
	lea	esi, DWORD PTR _abcd$[ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 601  :     int32_t abcd[4];
; 602  :     uint32_t fma_movbe_osxsave_mask = ((1 << 12) | (1 << 22) | (1 << 27));
; 603  :     uint32_t avx2_bmi12_mask = (1 << 5) | (1 << 3) | (1 << 8);
; 604  :  
; 605  :     /* CPUID.(EAX=01H, ECX=0H):ECX.FMA[bit 12]==1   && 
; 606  :        CPUID.(EAX=01H, ECX=0H):ECX.MOVBE[bit 22]==1 && 
; 607  :        CPUID.(EAX=01H, ECX=0H):ECX.OSXSAVE[bit 27]==1 */
; 608  :     run_cpuid( 1, 0, abcd );
; 609  :     if ( (abcd[2] & fma_movbe_osxsave_mask) != fma_movbe_osxsave_mask ) 

	mov	eax, DWORD PTR _abcd$[ebp+8]
	and	eax, 138416128				; 08401000H
	cmp	eax, 138416128				; 08401000H
	je	SHORT $LN4@check_4th_
$LN15@check_4th_:
	pop	esi

; 610  :         return 0;

	xor	eax, eax
	pop	ebx

; 620  :         return 0;
; 621  :  
; 622  :     /* CPUID.(EAX=80000001H):ECX.LZCNT[bit 5]==1 */
; 623  :     run_cpuid( 0x80000001, 0, abcd );
; 624  :     if ( (abcd[2] & (1 << 5)) == 0)
; 625  :         return 0;
; 626  :  
; 627  :     return 1;
; 628  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@check_4th_:

; 590  : }     
; 591  : 
; 592  : int32_t check_xcr0_ymm() 
; 593  : {
; 594  :     uint32_t xcr0;
; 595  :     xcr0 = (uint32_t)_myxgetbv(0);

	push	0
	call	__myxgetbv

; 596  :     return ((xcr0 & 6) == 6); /* checking if xmm and ymm state are enabled in XCR0 */

	and	eax, 6
	add	esp, 4
	cmp	al, 6

; 611  :  
; 612  :     if ( ! check_xcr0_ymm() )

	jne	SHORT $LN15@check_4th_

; 589  :     __cpuidex(abcd, eax, ecx);

	lea	esi, DWORD PTR _abcd$[ebp]
	xor	ecx, ecx
	mov	eax, 7
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 613  :         return 0;
; 614  :  
; 615  :     /*  CPUID.(EAX=07H, ECX=0H):EBX.AVX2[bit 5]==1  &&
; 616  :         CPUID.(EAX=07H, ECX=0H):EBX.BMI1[bit 3]==1  &&
; 617  :         CPUID.(EAX=07H, ECX=0H):EBX.BMI2[bit 8]==1  */
; 618  :     run_cpuid( 7, 0, abcd );
; 619  :     if ( (abcd[1] & avx2_bmi12_mask) != avx2_bmi12_mask ) 

	mov	eax, DWORD PTR _abcd$[ebp+4]
	and	eax, 296				; 00000128H
	cmp	eax, 296				; 00000128H
	jne	SHORT $LN15@check_4th_

; 589  :     __cpuidex(abcd, eax, ecx);

	xor	ecx, ecx
	mov	eax, -2147483647			; 80000001H
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx

; 620  :         return 0;
; 621  :  
; 622  :     /* CPUID.(EAX=80000001H):ECX.LZCNT[bit 5]==1 */
; 623  :     run_cpuid( 0x80000001, 0, abcd );
; 624  :     if ( (abcd[2] & (1 << 5)) == 0)
; 625  :         return 0;
; 626  :  
; 627  :     return 1;
; 628  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]

; 589  :     __cpuidex(abcd, eax, ecx);

	mov	DWORD PTR [esi+12], edx

; 620  :         return 0;
; 621  :  
; 622  :     /* CPUID.(EAX=80000001H):ECX.LZCNT[bit 5]==1 */
; 623  :     run_cpuid( 0x80000001, 0, abcd );
; 624  :     if ( (abcd[2] & (1 << 5)) == 0)
; 625  :         return 0;
; 626  :  
; 627  :     return 1;
; 628  : }

	xor	ecx, ebp
	movsx	eax, BYTE PTR _abcd$[ebp+8]
	and	eax, 32					; 00000020H
	pop	esi
	shr	eax, 5
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?check_4th_gen_intel_core_features@@YAHXZ ENDP		; check_4th_gen_intel_core_features
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
;	COMDAT ?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ
_TEXT	SEGMENT
?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ PROC		; Thread_SearchForSHA1TripcodesOnCPU, COMDAT

; 641  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx

; 642  : 	BOOL useAVX2 = options.isAVX2Enabled && IsAVX2Supported();

	cmp	DWORD PTR ?options@@3UOptions@@A+92, 0
	push	ebx
	push	esi
	push	edi
	je	SHORT $LN7@Thread_Sea

; 634  :     if (the_4th_gen_features_available < 0 )

	mov	eax, DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA
	test	eax, eax
	jns	SHORT $LN68@Thread_Sea

; 635  :         the_4th_gen_features_available = check_4th_gen_intel_core_features();

	call	?check_4th_gen_intel_core_features@@YAHXZ ; check_4th_gen_intel_core_features
	mov	DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA, eax

; 642  : 	BOOL useAVX2 = options.isAVX2Enabled && IsAVX2Supported();

	test	eax, eax
$LN68@Thread_Sea:
	je	SHORT $LN7@Thread_Sea
	mov	edi, 1
	jmp	SHORT $LN8@Thread_Sea
$LN7@Thread_Sea:
	xor	edi, edi
$LN8@Thread_Sea:

; 643  : 
; 644  : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN3@Thread_Sea
	mov	esi, DWORD PTR __imp__Sleep@4
	mov	ebx, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL17@Thread_Sea:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [ebx], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN16@Thread_Sea
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN31@Thread_Sea

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL17@Thread_Sea
$LN31@Thread_Sea:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL17@Thread_Sea
$LN16@Thread_Sea:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1633 : 	ret = isSearchPaused;

	mov	eax, DWORD PTR ?isSearchPaused@@3HA	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp

; 645  : 		while (GetPauseState() && !GetTerminationState())

	test	eax, eax
	je	SHORT $LN1@Thread_Sea
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN1@Thread_Sea

; 646  : 			Sleep(PAUSE_INTERVAL);

	push	100					; 00000064H
	call	esi
	jmp	SHORT $LL17@Thread_Sea
$LN1@Thread_Sea:

; 647  : 
; 648  : 		uint32_t numGeneratedTripcodes = (useAVX2) ? SearchForTripcodesWithOptimization_AVX2()
; 649  : 			                                           : SearchForTripcodesWithOptimization();

	test	edi, edi
	je	SHORT $LN9@Thread_Sea
	call	?SearchForTripcodesWithOptimization_AVX2@@YAIXZ ; SearchForTripcodesWithOptimization_AVX2
	jmp	SHORT $LN10@Thread_Sea
$LN9@Thread_Sea:
	call	?SearchForTripcodesWithOptimization@@YAIXZ ; SearchForTripcodesWithOptimization
$LN10@Thread_Sea:

; 650  : 		AddToNumGeneratedTripcodesByCPU(numGeneratedTripcodes);

	mov	ecx, eax
	call	?AddToNumGeneratedTripcodesByCPU@@YAXI@Z ; AddToNumGeneratedTripcodesByCPU
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	je	SHORT $LL17@Thread_Sea
$LN3@Thread_Sea:

; 651  : 	}
; 652  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ ENDP		; Thread_SearchForSHA1TripcodesOnCPU
_TEXT	ENDS
END
