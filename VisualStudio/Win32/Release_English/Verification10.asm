; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	Z:\GitHub\merikens-tripcode-engine\SourceFiles\Verification10.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?_ufc_keytab@@3PAY01IA				; _ufc_keytab
PUBLIC	?_ufc_sb1@@3PAIA				; _ufc_sb1
PUBLIC	?_ufc_sb2@@3PAIA				; _ufc_sb2
PUBLIC	?_ufc_sb3@@3PAIA				; _ufc_sb3
PUBLIC	?_ufc_sb0@@3PAIA				; _ufc_sb0
?_ufc_keytab@@3PAY01IA DD 020H DUP (?)			; _ufc_keytab
_initialized DD	01H DUP (?)
?_ufc_sb1@@3PAIA DD 02000H DUP (?)			; _ufc_sb1
?_ufc_sb2@@3PAIA DD 02000H DUP (?)			; _ufc_sb2
?_ufc_sb3@@3PAIA DD 02000H DUP (?)			; _ufc_sb3
_direction DD	01H DUP (?)
_current_saltbits DD 01H DUP (?)
?_ufc_sb0@@3PAIA DD 02000H DUP (?)			; _ufc_sb0
_BSS	ENDS
_current_salt DB '&&', 00H
	ORG $+2
$SG4294916474 DB '..', 00H
	ORG $+2
$SG4294916473 DB '..', 00H
	ORG $+2
_bytemask DB	080H
	DB	040H
	DB	020H
	DB	010H
	DB	08H
	DB	04H
	DB	02H
	DB	01H
	ORG $+7
_sb	DD	FLAT:?_ufc_sb0@@3PAIA
	DD	FLAT:?_ufc_sb1@@3PAIA
	DD	FLAT:?_ufc_sb2@@3PAIA
	DD	FLAT:?_ufc_sb3@@3PAIA
_perm32	DD	010H
	DD	07H
	DD	014H
	DD	015H
	DD	01dH
	DD	0cH
	DD	01cH
	DD	011H
	DD	01H
	DD	0fH
	DD	017H
	DD	01aH
	DD	05H
	DD	012H
	DD	01fH
	DD	0aH
	DD	02H
	DD	08H
	DD	018H
	DD	0eH
	DD	020H
	DD	01bH
	DD	03H
	DD	09H
	DD	013H
	DD	0dH
	DD	01eH
	DD	06H
	DD	016H
	DD	0bH
	DD	04H
	DD	019H
_DES_charToIndexTable DB 07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
_pc1	DD	039H
	DD	031H
	DD	029H
	DD	021H
	DD	019H
	DD	011H
	DD	09H
	DD	01H
	DD	03aH
	DD	032H
	DD	02aH
	DD	022H
	DD	01aH
	DD	012H
	DD	0aH
	DD	02H
	DD	03bH
	DD	033H
	DD	02bH
	DD	023H
	DD	01bH
	DD	013H
	DD	0bH
	DD	03H
	DD	03cH
	DD	034H
	DD	02cH
	DD	024H
	DD	03fH
	DD	037H
	DD	02fH
	DD	027H
	DD	01fH
	DD	017H
	DD	0fH
	DD	07H
	DD	03eH
	DD	036H
	DD	02eH
	DD	026H
	DD	01eH
	DD	016H
	DD	0eH
	DD	06H
	DD	03dH
	DD	035H
	DD	02dH
	DD	025H
	DD	01dH
	DD	015H
	DD	0dH
	DD	05H
	DD	01cH
	DD	014H
	DD	0cH
	DD	04H
_charTableForSeed DB 02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
_esel	DD	020H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	020H
	DD	01H
_sbox	DD	0eH
	DD	04H
	DD	0dH
	DD	01H
	DD	02H
	DD	0fH
	DD	0bH
	DD	08H
	DD	03H
	DD	0aH
	DD	06H
	DD	0cH
	DD	05H
	DD	09H
	DD	00H
	DD	07H
	DD	00H
	DD	0fH
	DD	07H
	DD	04H
	DD	0eH
	DD	02H
	DD	0dH
	DD	01H
	DD	0aH
	DD	06H
	DD	0cH
	DD	0bH
	DD	09H
	DD	05H
	DD	03H
	DD	08H
	DD	04H
	DD	01H
	DD	0eH
	DD	08H
	DD	0dH
	DD	06H
	DD	02H
	DD	0bH
	DD	0fH
	DD	0cH
	DD	09H
	DD	07H
	DD	03H
	DD	0aH
	DD	05H
	DD	00H
	DD	0fH
	DD	0cH
	DD	08H
	DD	02H
	DD	04H
	DD	09H
	DD	01H
	DD	07H
	DD	05H
	DD	0bH
	DD	03H
	DD	0eH
	DD	0aH
	DD	00H
	DD	06H
	DD	0dH
	DD	0fH
	DD	01H
	DD	08H
	DD	0eH
	DD	06H
	DD	0bH
	DD	03H
	DD	04H
	DD	09H
	DD	07H
	DD	02H
	DD	0dH
	DD	0cH
	DD	00H
	DD	05H
	DD	0aH
	DD	03H
	DD	0dH
	DD	04H
	DD	07H
	DD	0fH
	DD	02H
	DD	08H
	DD	0eH
	DD	0cH
	DD	00H
	DD	01H
	DD	0aH
	DD	06H
	DD	09H
	DD	0bH
	DD	05H
	DD	00H
	DD	0eH
	DD	07H
	DD	0bH
	DD	0aH
	DD	04H
	DD	0dH
	DD	01H
	DD	05H
	DD	08H
	DD	0cH
	DD	06H
	DD	09H
	DD	03H
	DD	02H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0aH
	DD	01H
	DD	03H
	DD	0fH
	DD	04H
	DD	02H
	DD	0bH
	DD	06H
	DD	07H
	DD	0cH
	DD	00H
	DD	05H
	DD	0eH
	DD	09H
	DD	0aH
	DD	00H
	DD	09H
	DD	0eH
	DD	06H
	DD	03H
	DD	0fH
	DD	05H
	DD	01H
	DD	0dH
	DD	0cH
	DD	07H
	DD	0bH
	DD	04H
	DD	02H
	DD	08H
	DD	0dH
	DD	07H
	DD	00H
	DD	09H
	DD	03H
	DD	04H
	DD	06H
	DD	0aH
	DD	02H
	DD	08H
	DD	05H
	DD	0eH
	DD	0cH
	DD	0bH
	DD	0fH
	DD	01H
	DD	0dH
	DD	06H
	DD	04H
	DD	09H
	DD	08H
	DD	0fH
	DD	03H
	DD	00H
	DD	0bH
	DD	01H
	DD	02H
	DD	0cH
	DD	05H
	DD	0aH
	DD	0eH
	DD	07H
	DD	01H
	DD	0aH
	DD	0dH
	DD	00H
	DD	06H
	DD	09H
	DD	08H
	DD	07H
	DD	04H
	DD	0fH
	DD	0eH
	DD	03H
	DD	0bH
	DD	05H
	DD	02H
	DD	0cH
	DD	07H
	DD	0dH
	DD	0eH
	DD	03H
	DD	00H
	DD	06H
	DD	09H
	DD	0aH
	DD	01H
	DD	02H
	DD	08H
	DD	05H
	DD	0bH
	DD	0cH
	DD	04H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0bH
	DD	05H
	DD	06H
	DD	0fH
	DD	00H
	DD	03H
	DD	04H
	DD	07H
	DD	02H
	DD	0cH
	DD	01H
	DD	0aH
	DD	0eH
	DD	09H
	DD	0aH
	DD	06H
	DD	09H
	DD	00H
	DD	0cH
	DD	0bH
	DD	07H
	DD	0dH
	DD	0fH
	DD	01H
	DD	03H
	DD	0eH
	DD	05H
	DD	02H
	DD	08H
	DD	04H
	DD	03H
	DD	0fH
	DD	00H
	DD	06H
	DD	0aH
	DD	01H
	DD	0dH
	DD	08H
	DD	09H
	DD	04H
	DD	05H
	DD	0bH
	DD	0cH
	DD	07H
	DD	02H
	DD	0eH
	DD	02H
	DD	0cH
	DD	04H
	DD	01H
	DD	07H
	DD	0aH
	DD	0bH
	DD	06H
	DD	08H
	DD	05H
	DD	03H
	DD	0fH
	DD	0dH
	DD	00H
	DD	0eH
	DD	09H
	DD	0eH
	DD	0bH
	DD	02H
	DD	0cH
	DD	04H
	DD	07H
	DD	0dH
	DD	01H
	DD	05H
	DD	00H
	DD	0fH
	DD	0aH
	DD	03H
	DD	09H
	DD	08H
	DD	06H
	DD	04H
	DD	02H
	DD	01H
	DD	0bH
	DD	0aH
	DD	0dH
	DD	07H
	DD	08H
	DD	0fH
	DD	09H
	DD	0cH
	DD	05H
	DD	06H
	DD	03H
	DD	00H
	DD	0eH
	DD	0bH
	DD	08H
	DD	0cH
	DD	07H
	DD	01H
	DD	0eH
	DD	02H
	DD	0dH
	DD	06H
	DD	0fH
	DD	00H
	DD	09H
	DD	0aH
	DD	04H
	DD	05H
	DD	03H
	DD	0cH
	DD	01H
	DD	0aH
	DD	0fH
	DD	09H
	DD	02H
	DD	06H
	DD	08H
	DD	00H
	DD	0dH
	DD	03H
	DD	04H
	DD	0eH
	DD	07H
	DD	05H
	DD	0bH
	DD	0aH
	DD	0fH
	DD	04H
	DD	02H
	DD	07H
	DD	0cH
	DD	09H
	DD	05H
	DD	06H
	DD	01H
	DD	0dH
	DD	0eH
	DD	00H
	DD	0bH
	DD	03H
	DD	08H
	DD	09H
	DD	0eH
	DD	0fH
	DD	05H
	DD	02H
	DD	08H
	DD	0cH
	DD	03H
	DD	07H
	DD	00H
	DD	04H
	DD	0aH
	DD	01H
	DD	0dH
	DD	0bH
	DD	06H
	DD	04H
	DD	03H
	DD	02H
	DD	0cH
	DD	09H
	DD	05H
	DD	0fH
	DD	0aH
	DD	0bH
	DD	0eH
	DD	01H
	DD	07H
	DD	06H
	DD	00H
	DD	08H
	DD	0dH
	DD	04H
	DD	0bH
	DD	02H
	DD	0eH
	DD	0fH
	DD	00H
	DD	08H
	DD	0dH
	DD	03H
	DD	0cH
	DD	09H
	DD	07H
	DD	05H
	DD	0aH
	DD	06H
	DD	01H
	DD	0dH
	DD	00H
	DD	0bH
	DD	07H
	DD	04H
	DD	09H
	DD	01H
	DD	0aH
	DD	0eH
	DD	03H
	DD	05H
	DD	0cH
	DD	02H
	DD	0fH
	DD	08H
	DD	06H
	DD	01H
	DD	04H
	DD	0bH
	DD	0dH
	DD	0cH
	DD	03H
	DD	07H
	DD	0eH
	DD	0aH
	DD	0fH
	DD	06H
	DD	08H
	DD	00H
	DD	05H
	DD	09H
	DD	02H
	DD	06H
	DD	0bH
	DD	0dH
	DD	08H
	DD	01H
	DD	04H
	DD	0aH
	DD	07H
	DD	09H
	DD	05H
	DD	00H
	DD	0fH
	DD	0eH
	DD	02H
	DD	03H
	DD	0cH
	DD	0dH
	DD	02H
	DD	08H
	DD	04H
	DD	06H
	DD	0fH
	DD	0bH
	DD	01H
	DD	0aH
	DD	09H
	DD	03H
	DD	0eH
	DD	05H
	DD	00H
	DD	0cH
	DD	07H
	DD	01H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0aH
	DD	03H
	DD	07H
	DD	04H
	DD	0cH
	DD	05H
	DD	06H
	DD	0bH
	DD	00H
	DD	0eH
	DD	09H
	DD	02H
	DD	07H
	DD	0bH
	DD	04H
	DD	01H
	DD	09H
	DD	0cH
	DD	0eH
	DD	02H
	DD	00H
	DD	06H
	DD	0aH
	DD	0dH
	DD	0fH
	DD	03H
	DD	05H
	DD	08H
	DD	02H
	DD	01H
	DD	0eH
	DD	07H
	DD	04H
	DD	0aH
	DD	08H
	DD	0dH
	DD	0fH
	DD	0cH
	DD	09H
	DD	00H
	DD	03H
	DD	05H
	DD	06H
	DD	0bH
_longmask DD	080000000H
	DD	040000000H
	DD	020000000H
	DD	010000000H
	DD	08000000H
	DD	04000000H
	DD	02000000H
	DD	01000000H
	DD	0800000H
	DD	0400000H
	DD	0200000H
	DD	0100000H
	DD	080000H
	DD	040000H
	DD	020000H
	DD	010000H
	DD	08000H
	DD	04000H
	DD	02000H
	DD	01000H
	DD	0800H
	DD	0400H
	DD	0200H
	DD	0100H
	DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
	DD	02H
	DD	01H
_rots	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
_DES_indexToCharTable DB 02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
_pc2	DD	0eH
	DD	011H
	DD	0bH
	DD	018H
	DD	01H
	DD	05H
	DD	03H
	DD	01cH
	DD	0fH
	DD	06H
	DD	015H
	DD	0aH
	DD	017H
	DD	013H
	DD	0cH
	DD	04H
	DD	01aH
	DD	08H
	DD	010H
	DD	07H
	DD	01bH
	DD	014H
	DD	0dH
	DD	02H
	DD	029H
	DD	034H
	DD	01fH
	DD	025H
	DD	02fH
	DD	037H
	DD	01eH
	DD	028H
	DD	033H
	DD	02dH
	DD	021H
	DD	030H
	DD	02cH
	DD	031H
	DD	027H
	DD	038H
	DD	022H
	DD	035H
	DD	02eH
	DD	02aH
	DD	032H
	DD	024H
	DD	01dH
	DD	020H
_keySchedule DB	0cH
	DB	02eH
	DB	021H
	DB	034H
	DB	030H
	DB	014H
	DB	022H
	DB	037H
	DB	05H
	DB	0dH
	DB	012H
	DB	028H
	DB	04H
	DB	020H
	DB	01aH
	DB	01bH
	DB	026H
	DB	036H
	DB	035H
	DB	06H
	DB	01fH
	DB	019H
	DB	013H
	DB	029H
	DB	0fH
	DB	018H
	DB	01cH
	DB	02bH
	DB	01eH
	DB	03H
	DB	023H
	DB	016H
	DB	02H
	DB	02cH
	DB	0eH
	DB	017H
	DB	033H
	DB	010H
	DB	01dH
	DB	031H
	DB	07H
	DB	011H
	DB	025H
	DB	08H
	DB	09H
	DB	032H
	DB	02aH
	DB	015H
	DB	05H
	DB	027H
	DB	01aH
	DB	02dH
	DB	029H
	DB	0dH
	DB	01bH
	DB	030H
	DB	035H
	DB	06H
	DB	0bH
	DB	021H
	DB	034H
	DB	019H
	DB	013H
	DB	014H
	DB	01fH
	DB	02fH
	DB	02eH
	DB	036H
	DB	037H
	DB	012H
	DB	0cH
	DB	022H
	DB	08H
	DB	011H
	DB	015H
	DB	024H
	DB	017H
	DB	031H
	DB	01cH
	DB	0fH
	DB	018H
	DB	025H
	DB	07H
	DB	010H
	DB	02cH
	DB	09H
	DB	016H
	DB	02aH
	DB	00H
	DB	0aH
	DB	01eH
	DB	01H
	DB	02H
	DB	02bH
	DB	023H
	DB	0eH
	DB	02eH
	DB	019H
	DB	0cH
	DB	01fH
	DB	01bH
	DB	036H
	DB	0dH
	DB	022H
	DB	027H
	DB	02fH
	DB	034H
	DB	013H
	DB	026H
	DB	0bH
	DB	05H
	DB	06H
	DB	030H
	DB	021H
	DB	020H
	DB	028H
	DB	029H
	DB	04H
	DB	035H
	DB	014H
	DB	033H
	DB	03H
	DB	07H
	DB	016H
	DB	09H
	DB	023H
	DB	0eH
	DB	01H
	DB	0aH
	DB	017H
	DB	032H
	DB	02H
	DB	01eH
	DB	018H
	DB	08H
	DB	01cH
	DB	02bH
	DB	031H
	DB	010H
	DB	02cH
	DB	011H
	DB	01dH
	DB	015H
	DB	00H
	DB	020H
	DB	0bH
	DB	035H
	DB	030H
	DB	0dH
	DB	028H
	DB	036H
	DB	014H
	DB	019H
	DB	021H
	DB	026H
	DB	05H
	DB	037H
	DB	034H
	DB	02eH
	DB	02fH
	DB	022H
	DB	013H
	DB	012H
	DB	01aH
	DB	01bH
	DB	02dH
	DB	027H
	DB	06H
	DB	025H
	DB	02aH
	DB	032H
	DB	08H
	DB	018H
	DB	015H
	DB	00H
	DB	02cH
	DB	031H
	DB	09H
	DB	024H
	DB	011H
	DB	010H
	DB	0aH
	DB	033H
	DB	0eH
	DB	01dH
	DB	023H
	DB	02H
	DB	01eH
	DB	03H
	DB	0fH
	DB	07H
	DB	02bH
	DB	012H
	DB	034H
	DB	027H
	DB	022H
	DB	036H
	DB	01aH
	DB	028H
	DB	06H
	DB	0bH
	DB	013H
	DB	037H
	DB	02eH
	DB	029H
	DB	026H
	DB	020H
	DB	021H
	DB	014H
	DB	05H
	DB	04H
	DB	0cH
	DB	0dH
	DB	01fH
	DB	019H
	DB	02fH
	DB	017H
	DB	01cH
	DB	024H
	DB	033H
	DB	0aH
	DB	07H
	DB	02bH
	DB	01eH
	DB	023H
	DB	018H
	DB	016H
	DB	03H
	DB	02H
	DB	031H
	DB	025H
	DB	00H
	DB	0fH
	DB	015H
	DB	011H
	DB	010H
	DB	02aH
	DB	01H
	DB	032H
	DB	01dH
	DB	04H
	DB	026H
	DB	019H
	DB	014H
	DB	028H
	DB	0cH
	DB	01aH
	DB	02fH
	DB	034H
	DB	05H
	DB	029H
	DB	020H
	DB	01bH
	DB	037H
	DB	012H
	DB	013H
	DB	06H
	DB	02eH
	DB	02dH
	DB	035H
	DB	036H
	DB	030H
	DB	0bH
	DB	021H
	DB	09H
	DB	0eH
	DB	016H
	DB	025H
	DB	031H
	DB	032H
	DB	01dH
	DB	010H
	DB	015H
	DB	0aH
	DB	08H
	DB	02aH
	DB	011H
	DB	023H
	DB	017H
	DB	02bH
	DB	01H
	DB	07H
	DB	03H
	DB	02H
	DB	01cH
	DB	02cH
	DB	024H
	DB	0fH
	DB	02dH
	DB	037H
	DB	0bH
	DB	06H
	DB	01aH
	DB	035H
	DB	0cH
	DB	021H
	DB	026H
	DB	02eH
	DB	01bH
	DB	012H
	DB	0dH
	DB	029H
	DB	04H
	DB	05H
	DB	02fH
	DB	020H
	DB	01fH
	DB	027H
	DB	028H
	DB	022H
	DB	034H
	DB	013H
	DB	018H
	DB	00H
	DB	08H
	DB	017H
	DB	023H
	DB	024H
	DB	0fH
	DB	02H
	DB	07H
	DB	031H
	DB	033H
	DB	01cH
	DB	03H
	DB	015H
	DB	09H
	DB	01dH
	DB	02cH
	DB	032H
	DB	02aH
	DB	011H
	DB	0eH
	DB	01eH
	DB	016H
	DB	01H
	DB	01fH
	DB	029H
	DB	034H
	DB	02fH
	DB	0cH
	DB	027H
	DB	035H
	DB	013H
	DB	037H
	DB	020H
	DB	0dH
	DB	04H
	DB	036H
	DB	01bH
	DB	02dH
	DB	02eH
	DB	021H
	DB	012H
	DB	030H
	DB	019H
	DB	01aH
	DB	014H
	DB	026H
	DB	05H
	DB	0aH
	DB	02bH
	DB	033H
	DB	09H
	DB	015H
	DB	016H
	DB	01H
	DB	011H
	DB	032H
	DB	023H
	DB	025H
	DB	0eH
	DB	02aH
	DB	07H
	DB	018H
	DB	0fH
	DB	01eH
	DB	024H
	DB	01cH
	DB	03H
	DB	00H
	DB	010H
	DB	08H
	DB	02cH
	DB	037H
	DB	022H
	DB	02dH
	DB	028H
	DB	05H
	DB	020H
	DB	02eH
	DB	0cH
	DB	030H
	DB	019H
	DB	06H
	DB	034H
	DB	02fH
	DB	014H
	DB	026H
	DB	027H
	DB	01aH
	DB	0bH
	DB	029H
	DB	012H
	DB	013H
	DB	0dH
	DB	01fH
	DB	035H
	DB	03H
	DB	024H
	DB	02cH
	DB	02H
	DB	0eH
	DB	0fH
	DB	033H
	DB	0aH
	DB	02bH
	DB	01cH
	DB	01eH
	DB	07H
	DB	023H
	DB	00H
	DB	011H
	DB	08H
	DB	017H
	DB	01dH
	DB	015H
	DB	031H
	DB	032H
	DB	09H
	DB	01H
	DB	025H
	DB	029H
	DB	014H
	DB	01fH
	DB	01aH
	DB	02eH
	DB	012H
	DB	020H
	DB	035H
	DB	022H
	DB	0bH
	DB	02fH
	DB	026H
	DB	021H
	DB	06H
	DB	037H
	DB	019H
	DB	0cH
	DB	034H
	DB	01bH
	DB	04H
	DB	05H
	DB	036H
	DB	030H
	DB	027H
	DB	02aH
	DB	016H
	DB	01eH
	DB	011H
	DB	00H
	DB	01H
	DB	025H
	DB	031H
	DB	01dH
	DB	0eH
	DB	010H
	DB	032H
	DB	015H
	DB	02bH
	DB	03H
	DB	033H
	DB	09H
	DB	0fH
	DB	07H
	DB	023H
	DB	024H
	DB	018H
	DB	02cH
	DB	017H
	DB	01bH
	DB	06H
	DB	030H
	DB	0cH
	DB	020H
	DB	04H
	DB	012H
	DB	027H
	DB	014H
	DB	034H
	DB	021H
	DB	037H
	DB	013H
	DB	02fH
	DB	029H
	DB	0bH
	DB	035H
	DB	026H
	DB	0dH
	DB	02dH
	DB	02eH
	DB	028H
	DB	022H
	DB	019H
	DB	01cH
	DB	08H
	DB	010H
	DB	03H
	DB	02bH
	DB	02cH
	DB	017H
	DB	023H
	DB	0fH
	DB	00H
	DB	02H
	DB	024H
	DB	07H
	DB	01dH
	DB	02aH
	DB	025H
	DB	018H
	DB	01H
	DB	032H
	DB	015H
	DB	016H
	DB	0aH
	DB	01eH
	DB	09H
	DB	0dH
	DB	02fH
	DB	022H
	DB	035H
	DB	012H
	DB	02dH
	DB	04H
	DB	019H
	DB	06H
	DB	026H
	DB	013H
	DB	029H
	DB	05H
	DB	021H
	DB	01bH
	DB	034H
	DB	027H
	DB	037H
	DB	036H
	DB	01fH
	DB	020H
	DB	01aH
	DB	014H
	DB	0bH
	DB	0eH
	DB	033H
	DB	02H
	DB	02aH
	DB	01dH
	DB	01eH
	DB	09H
	DB	015H
	DB	01H
	DB	02bH
	DB	011H
	DB	016H
	DB	032H
	DB	0fH
	DB	01cH
	DB	017H
	DB	0aH
	DB	02cH
	DB	024H
	DB	07H
	DB	08H
	DB	031H
	DB	010H
	DB	018H
	DB	036H
	DB	021H
	DB	014H
	DB	027H
	DB	04H
	DB	01fH
	DB	02dH
	DB	0bH
	DB	02fH
	DB	037H
	DB	05H
	DB	01bH
	DB	02eH
	DB	013H
	DB	0dH
	DB	026H
	DB	019H
	DB	029H
	DB	028H
	DB	030H
	DB	012H
	DB	0cH
	DB	06H
	DB	034H
	DB	00H
	DB	025H
	DB	011H
	DB	01cH
	DB	0fH
	DB	010H
	DB	018H
	DB	07H
	DB	02cH
	DB	01dH
	DB	03H
	DB	08H
	DB	024H
	DB	01H
	DB	0eH
	DB	09H
	DB	031H
	DB	01eH
	DB	016H
	DB	032H
	DB	033H
	DB	023H
	DB	02H
	DB	0aH
	DB	028H
	DB	013H
	DB	06H
	DB	019H
	DB	02dH
	DB	030H
	DB	01fH
	DB	034H
	DB	021H
	DB	029H
	DB	02eH
	DB	0dH
	DB	020H
	DB	05H
	DB	036H
	DB	037H
	DB	0bH
	DB	01bH
	DB	01aH
	DB	022H
	DB	04H
	DB	035H
	DB	02fH
	DB	026H
	DB	02bH
	DB	017H
	DB	03H
	DB	0eH
	DB	01H
	DB	02H
	DB	0aH
	DB	032H
	DB	01eH
	DB	0fH
	DB	02aH
	DB	033H
	DB	016H
	DB	02cH
	DB	00H
	DB	018H
	DB	023H
	DB	010H
	DB	08H
	DB	024H
	DB	025H
	DB	015H
	DB	011H
	DB	031H
	DB	01aH
	DB	05H
	DB	02fH
	DB	0bH
	DB	01fH
	DB	022H
	DB	030H
	DB	026H
	DB	013H
	DB	01bH
	DB	020H
	DB	036H
	DB	012H
	DB	02eH
	DB	028H
	DB	029H
	DB	034H
	DB	0dH
	DB	0cH
	DB	014H
	DB	02dH
	DB	027H
	DB	021H
	DB	037H
	DB	01dH
	DB	09H
	DB	02aH
	DB	00H
	DB	02cH
	DB	011H
	DB	031H
	DB	024H
	DB	010H
	DB	01H
	DB	01cH
	DB	025H
	DB	08H
	DB	01eH
	DB	02bH
	DB	0aH
	DB	015H
	DB	02H
	DB	033H
	DB	016H
	DB	017H
	DB	07H
	DB	03H
	DB	023H
	DB	013H
	DB	035H
	DB	028H
	DB	04H
	DB	037H
	DB	01bH
	DB	029H
	DB	01fH
	DB	0cH
	DB	014H
	DB	019H
	DB	02fH
	DB	0bH
	DB	027H
	DB	021H
	DB	022H
	DB	02dH
	DB	06H
	DB	05H
	DB	0dH
	DB	026H
	DB	020H
	DB	01aH
	DB	030H
	DB	016H
	DB	02H
	DB	023H
	DB	032H
	DB	025H
	DB	0aH
	DB	02aH
	DB	01dH
	DB	09H
	DB	033H
	DB	015H
	DB	01eH
	DB	01H
	DB	017H
	DB	024H
	DB	03H
	DB	0eH
	DB	018H
	DB	02cH
	DB	0fH
	DB	010H
	DB	00H
	DB	031H
	DB	01cH
_final_perm DD	028H
	DD	08H
	DD	030H
	DD	010H
	DD	038H
	DD	018H
	DD	040H
	DD	020H
	DD	027H
	DD	07H
	DD	02fH
	DD	0fH
	DD	037H
	DD	017H
	DD	03fH
	DD	01fH
	DD	026H
	DD	06H
	DD	02eH
	DD	0eH
	DD	036H
	DD	016H
	DD	03eH
	DD	01eH
	DD	025H
	DD	05H
	DD	02dH
	DD	0dH
	DD	035H
	DD	015H
	DD	03dH
	DD	01dH
	DD	024H
	DD	04H
	DD	02cH
	DD	0cH
	DD	034H
	DD	014H
	DD	03cH
	DD	01cH
	DD	023H
	DD	03H
	DD	02bH
	DD	0bH
	DD	033H
	DD	013H
	DD	03bH
	DD	01bH
	DD	022H
	DD	02H
	DD	02aH
	DD	0aH
	DD	032H
	DD	012H
	DD	03aH
	DD	01aH
	DD	021H
	DD	01H
	DD	029H
	DD	09H
	DD	031H
	DD	011H
	DD	039H
	DD	019H
PUBLIC	?Generate10CharTripcodes@@YAXPAUTripcodeKeyPair@@H@Z ; Generate10CharTripcodes
PUBLIC	?_ufc_doit@@YAPAIIIIII@Z			; _ufc_doit
PUBLIC	?crypt@@YAPADPAD0@Z				; crypt
PUBLIC	?_ufc_dofinalperm@@YAPAIIIII@Z			; _ufc_dofinalperm
PUBLIC	?init_des@@YAXXZ				; init_des
PUBLIC	??0spinlock@@QAE@XZ				; spinlock::spinlock
PUBLIC	?VerifyDESTripcode@@YAHPAE0@Z			; VerifyDESTripcode
PUBLIC	?GenerateDESTripcode@@YAXPAE0@Z			; GenerateDESTripcode
;	COMDAT ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA
_BSS	SEGMENT
?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA DB 0eH DUP (?) ; `output_conversion'::`2'::outbuf
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_eperm32tab DD	0800H DUP (?)
_errno_ecat DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?ary@?1??_ufc_dofinalperm@@YAPAIIIII@Z@4PAIA
_BSS	SEGMENT
?ary@?1??_ufc_dofinalperm@@YAPAIIIII@Z@4PAIA DD 02H DUP (?) ; `_ufc_dofinalperm'::`2'::ary
_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_efp	DD	0800H DUP (?)
_native_ecat DD	01H DUP (?)
_do_pc1	DD	0800H DUP (?)
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_descrypt_spinlock DD 01H DUP (?)
_do_pc2	DD	0400H DUP (?)
_e_inverse DD	040H DUP (?)
_posix_category DD 01H DUP (?)
_BSS	ENDS
	ORG $-60
_posix_category$initializer$ DD FLAT:??__Eposix_category@system@boost@@YAXXZ
_errno_ecat$initializer$ DD FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
_native_ecat$initializer$ DD FLAT:??__Enative_ecat@system@boost@@YAXXZ
_descrypt_spinlock$initializer$ DD FLAT:??__Edescrypt_spinlock@@YAXXZ
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?GenerateDESTripcode@@YAXPAE0@Z
_TEXT	SEGMENT
_ktab$1 = -32						; size = 9
_actualKey$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_tripcode$ = 8						; size = 4
_key$ = 12						; size = 4
?GenerateDESTripcode@@YAXPAE0@Z PROC			; GenerateDESTripcode, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _key$[ebp]
	mov	ebx, OFFSET _descrypt_spinlock
	push	edi
	mov	edi, DWORD PTR _tripcode$[ebp]
	npad	2
$LL14@GenerateDE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [ebx], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN13@GenerateDE
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN28@GenerateDE

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL14@GenerateDE
$LN28@GenerateDE:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL14@GenerateDE
$LN13@GenerateDE:
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 93   :     memcpy(actualKey, (char *)key, 8);

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	mov	DWORD PTR _actualKey$[ebp], eax
	mov	eax, DWORD PTR [esi+4]

; 94   : 	actualKey[8] = '\0';
; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	mov	DWORD PTR _actualKey$[ebp+4], eax
	xor	eax, eax
	mov	BYTE PTR _actualKey$[ebp+8], dl
	test	esi, esi
	jle	SHORT $LN73@GenerateDE
	lea	ebx, DWORD PTR [edx+1]
$LL6@GenerateDE:

; 96   :             if (fillRestWithZero) {

	test	edx, edx
	je	SHORT $LN3@GenerateDE

; 97   :                     actualKey[i] = 0x00;

	cmp	eax, 13					; 0000000dH
	jae	$LN75@GenerateDE
	mov	BYTE PTR _actualKey$[ebp+eax], 0
	jmp	SHORT $LN5@GenerateDE
$LN3@GenerateDE:

; 98   :             } else if (actualKey[i] == 0x80) {

	movsx	ecx, BYTE PTR _actualKey$[ebp+eax]
	cmp	ecx, 128				; 00000080H
	cmove	edx, ebx
$LN5@GenerateDE:

; 94   : 	actualKey[8] = '\0';
; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL6@GenerateDE
$LN73@GenerateDE:

; 420  :   }
; 421  : 
; 422  : static int32_t initialized = 0;
; 423  : 
; 424  : /* lookup a 6 bit value in sbox */
; 425  : 
; 426  : #define s_lookup(i,s) sbox[(i)][(((s)>>4) & 0x2)|((s) & 0x1)][((s)>>1) & 0xf];
; 427  : 
; 428  : /*
; 429  :  * Initialize unit - may be invoked directly
; 430  :  * by fcrypt users.
; 431  :  */
; 432  : 
; 433  : void init_des()
; 434  :   { int32_t comes_from_bit;
; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {
; 445  :       comes_from_bit  = pc1[bit] - 1;
; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];
; 447  :       mask2 = longmask[bit % 28 + 4];
; 448  :       for(j = 0; j < 128; j++) {
; 449  :         if(j & mask1) 
; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;
; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {
; 460  :       comes_from_bit  = pc2[bit] - 1;
; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];
; 462  :       mask2 = BITMASK(bit % 24);
; 463  :       for(j = 0; j < 128; j++) {
; 464  :         if(j & mask1)
; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;
; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {
; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;
; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {
; 490  :         if(j & mask1)
; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);
; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {
; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {
; 512  :         s1 = s_lookup(2 * sg, j1);
; 513  :         for(j2 = 0; j2 < 64; j2++) {
; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);
; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);
; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;
; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];
; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];
; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];
; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];
; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];
; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {
; 554  :       e_inverse[esel[bit] - 1     ] = bit;
; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;
; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {
; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */
; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {
; 589  :         if(word_value & mask1)
; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;
; 591  :       }
; 592  :     }
; 593  :     initialized++;
; 594  :   }
; 595  : 
; 596  : /* 
; 597  :  * Process the elements of the sb table permuting the
; 598  :  * bits swapped in the expansion by the current salt.
; 599  :  */
; 600  : 
; 601  : #ifdef _UFC_32_
; 602  : STATIC void shuffle_sb(long32 *k, ufc_long saltbits)
; 603  :   { ufc_long j;
; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {
; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;
; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;
; 609  :     }
; 610  :   }
; 611  : #endif
; 612  : 
; 613  : #ifdef _UFC_64_
; 614  : STATIC void shuffle_sb(k, saltbits)
; 615  :   long64 *k;
; 616  :   ufc_long saltbits;
; 617  :   { ufc_long j;
; 618  :     long64 x;
; 619  :     for(j=4096; j--;) {
; 620  :       x = ((*k >> 32) ^ *k) & (long64)saltbits;
; 621  :       *k++ ^= (x << 32) | x;
; 622  :     }
; 623  :   }
; 624  : #endif
; 625  : 
; 626  : /* 
; 627  :  * Setup the unit for a new salt
; 628  :  * Hopefully we'll not see a new salt in each crypt call.
; 629  :  */
; 630  : 
; 631  : static unsigned char current_salt[3] = "&&"; /* invalid value */
; 632  : static ufc_long current_saltbits = 0;
; 633  : static int32_t direction = 0;
; 634  : 
; 635  : STATIC void setup_salt(char *s)
; 636  :   { ufc_long i, j, saltbits;
; 637  : 
; 638  :     if(!initialized)
; 639  :       init_des();
; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])
; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];
; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;
; 651  :     for(i = 0; i < 2; i++) {
; 652  :       int32_t c=ascii_to_bin(s[i]);
; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)
; 657  :           saltbits |= BITMASK(6 * i + j);
; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 
; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);
; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);
; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);
; 670  : 
; 671  :     current_saltbits = saltbits;
; 672  :   }
; 673  : 
; 674  : STATIC void ufc_mk_keytab(char *key)
; 675  :   { ufc_long v1, v2, *k1;
; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];
; 685  :     for(i = 8; i--;) {
; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;
; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;
; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {
; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));
; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;
; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;
; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;
; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;
; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));
; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;
; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;
; 714  :     }
; 715  : 
; 716  :     direction = 0;
; 717  :   }
; 718  : 
; 719  : /* 
; 720  :  * Undo an extra E selection and do final permutations
; 721  :  */
; 722  : 
; 723  : ufc_long *_ufc_dofinalperm(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2)
; 724  :   { ufc_long v1, v2, x;
; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;
; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;
; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];
; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];
; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];
; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];
; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];
; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];
; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];
; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];
; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];
; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];
; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];
; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];
; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];
; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];
; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];
; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];
; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;
; 753  :     return ary;
; 754  :   }
; 755  : 
; 756  : /* 
; 757  :  * crypt only: convert from 64 bit to 11 bit ASCII 
; 758  :  * prefixing with the salt
; 759  :  */
; 760  : 
; 761  : STATIC char *output_conversion(ufc_long v1, ufc_long v2, char *salt)
; 762  :   { static char outbuf[14];
; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];
; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];
; 767  : 
; 768  :     for(i = 0; i < 5; i++)
; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);
; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;
; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);
; 773  : 
; 774  :     for(i = 5; i < 10; i++)
; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);
; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);
; 778  :     outbuf[13] = 0;
; 779  : 
; 780  :     return outbuf;
; 781  :   }
; 782  : 
; 783  : ufc_long *_ufc_doit(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2, ufc_long itr);
; 784  : 
; 785  : /* 
; 786  :  * UNIX crypt function
; 787  :  */
; 788  :    
; 789  : char *crypt(char *key, char *salt)
; 790  :   { ufc_long *s;
; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	lea	ecx, DWORD PTR _actualKey$[ebp+1]
	call	?setup_salt@@YAXPAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	8
	lea	eax, DWORD PTR _actualKey$[ebp]

; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	mov	BYTE PTR _ktab$1[ebp+8], 0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	eax
	lea	eax, DWORD PTR _ktab$1[ebp]
	xorps	xmm0, xmm0
	push	eax

; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	movq	QWORD PTR _ktab$1[ebp], xmm0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	_strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	ecx, DWORD PTR _ktab$1[ebp]
	call	?ufc_mk_keytab@@YAXPAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPAIIIIII@Z		; _ufc_doit
	add	esp, 12					; 0000000cH

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	lea	ecx, DWORD PTR _actualKey$[ebp+1]
	mov	edx, DWORD PTR [eax+4]

; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);

	push	10					; 0000000aH

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	?output_conversion@@YAPADIIPAD@Z	; output_conversion
	add	esp, 4

; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);

	add	eax, 3
	push	eax
	push	edi
	call	_strncpy
	add	esp, 12					; 0000000cH

; 103  : 	tripcode[10] = '\0';

	mov	BYTE PTR [edi+10], 0

; 106  : }

	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR _descrypt_spinlock, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 106  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@GenerateDE:

; 97   :                     actualKey[i] = 0x00;

	call	___report_rangecheckfailure
$LN76@GenerateDE:
$LN74@GenerateDE:
	int	3
?GenerateDESTripcode@@YAXPAE0@Z ENDP			; GenerateDESTripcode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?VerifyDESTripcode@@YAHPAE0@Z
_TEXT	SEGMENT
_ktab$1 = -32						; size = 9
_actualKey$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?VerifyDESTripcode@@YAHPAE0@Z PROC			; VerifyDESTripcode, COMDAT
; _tripcode$ = ecx
; _key$ = edx

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	mov	ebx, OFFSET _descrypt_spinlock
	npad	4
$LL15@VerifyDEST:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [ebx], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN14@VerifyDEST
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN29@VerifyDEST

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL15@VerifyDEST
$LN29@VerifyDEST:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL15@VerifyDEST
$LN14@VerifyDEST:
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 55   :         if (strlen((char *)tripcode) != lenTripcode || strlen((char *)key) != lenTripcodeKey)

	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL78@VerifyDEST:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL78@VerifyDEST
	sub	ecx, edx
	cmp	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jne	$LN7@VerifyDEST
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL79@VerifyDEST:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL79@VerifyDEST
	mov	ebx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	sub	ecx, edx
	cmp	ecx, ebx
	jne	$LN7@VerifyDEST

; 56   :                 return FALSE;
; 57   :         
; 58   :         char actualKey[MAX_LEN_TRIPCODE_KEY + 1];
; 59   :         BOOL fillRestWithZero = FALSE;
; 60   :         
; 61   :         strcpy(actualKey, (char *)key);

	lea	ecx, DWORD PTR _actualKey$[ebp]
	xor	edx, edx
	sub	ecx, esi
	npad	2
$LL11@VerifyDEST:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL11@VerifyDEST

; 62   :         for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN77@VerifyDEST
	lea	esi, DWORD PTR [ecx+1]
$LL6@VerifyDEST:

; 63   :                 if (fillRestWithZero) {

	test	edx, edx
	je	SHORT $LN3@VerifyDEST

; 64   :                         actualKey[i] = 0x00;

	cmp	ecx, 13					; 0000000dH
	jae	$LN85@VerifyDEST
	mov	BYTE PTR _actualKey$[ebp+ecx], 0
	jmp	SHORT $LN5@VerifyDEST
$LN3@VerifyDEST:

; 65   :                 } else if (actualKey[i] == 0x80) {

	movsx	eax, BYTE PTR _actualKey$[ebp+ecx]
	cmp	eax, 128				; 00000080H
	cmove	edx, esi
$LN5@VerifyDEST:

; 62   :         for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL6@VerifyDEST
$LN77@VerifyDEST:

; 420  :   }
; 421  : 
; 422  : static int32_t initialized = 0;
; 423  : 
; 424  : /* lookup a 6 bit value in sbox */
; 425  : 
; 426  : #define s_lookup(i,s) sbox[(i)][(((s)>>4) & 0x2)|((s) & 0x1)][((s)>>1) & 0xf];
; 427  : 
; 428  : /*
; 429  :  * Initialize unit - may be invoked directly
; 430  :  * by fcrypt users.
; 431  :  */
; 432  : 
; 433  : void init_des()
; 434  :   { int32_t comes_from_bit;
; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {
; 445  :       comes_from_bit  = pc1[bit] - 1;
; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];
; 447  :       mask2 = longmask[bit % 28 + 4];
; 448  :       for(j = 0; j < 128; j++) {
; 449  :         if(j & mask1) 
; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;
; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {
; 460  :       comes_from_bit  = pc2[bit] - 1;
; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];
; 462  :       mask2 = BITMASK(bit % 24);
; 463  :       for(j = 0; j < 128; j++) {
; 464  :         if(j & mask1)
; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;
; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {
; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;
; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {
; 490  :         if(j & mask1)
; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);
; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {
; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {
; 512  :         s1 = s_lookup(2 * sg, j1);
; 513  :         for(j2 = 0; j2 < 64; j2++) {
; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);
; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);
; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;
; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];
; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];
; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];
; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];
; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];
; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {
; 554  :       e_inverse[esel[bit] - 1     ] = bit;
; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;
; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {
; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */
; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {
; 589  :         if(word_value & mask1)
; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;
; 591  :       }
; 592  :     }
; 593  :     initialized++;
; 594  :   }
; 595  : 
; 596  : /* 
; 597  :  * Process the elements of the sb table permuting the
; 598  :  * bits swapped in the expansion by the current salt.
; 599  :  */
; 600  : 
; 601  : #ifdef _UFC_32_
; 602  : STATIC void shuffle_sb(long32 *k, ufc_long saltbits)
; 603  :   { ufc_long j;
; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {
; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;
; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;
; 609  :     }
; 610  :   }
; 611  : #endif
; 612  : 
; 613  : #ifdef _UFC_64_
; 614  : STATIC void shuffle_sb(k, saltbits)
; 615  :   long64 *k;
; 616  :   ufc_long saltbits;
; 617  :   { ufc_long j;
; 618  :     long64 x;
; 619  :     for(j=4096; j--;) {
; 620  :       x = ((*k >> 32) ^ *k) & (long64)saltbits;
; 621  :       *k++ ^= (x << 32) | x;
; 622  :     }
; 623  :   }
; 624  : #endif
; 625  : 
; 626  : /* 
; 627  :  * Setup the unit for a new salt
; 628  :  * Hopefully we'll not see a new salt in each crypt call.
; 629  :  */
; 630  : 
; 631  : static unsigned char current_salt[3] = "&&"; /* invalid value */
; 632  : static ufc_long current_saltbits = 0;
; 633  : static int32_t direction = 0;
; 634  : 
; 635  : STATIC void setup_salt(char *s)
; 636  :   { ufc_long i, j, saltbits;
; 637  : 
; 638  :     if(!initialized)
; 639  :       init_des();
; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])
; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];
; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;
; 651  :     for(i = 0; i < 2; i++) {
; 652  :       int32_t c=ascii_to_bin(s[i]);
; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)
; 657  :           saltbits |= BITMASK(6 * i + j);
; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 
; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);
; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);
; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);
; 670  : 
; 671  :     current_saltbits = saltbits;
; 672  :   }
; 673  : 
; 674  : STATIC void ufc_mk_keytab(char *key)
; 675  :   { ufc_long v1, v2, *k1;
; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];
; 685  :     for(i = 8; i--;) {
; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;
; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;
; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {
; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));
; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;
; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;
; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;
; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;
; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));
; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;
; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;
; 714  :     }
; 715  : 
; 716  :     direction = 0;
; 717  :   }
; 718  : 
; 719  : /* 
; 720  :  * Undo an extra E selection and do final permutations
; 721  :  */
; 722  : 
; 723  : ufc_long *_ufc_dofinalperm(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2)
; 724  :   { ufc_long v1, v2, x;
; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;
; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;
; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];
; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];
; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];
; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];
; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];
; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];
; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];
; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];
; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];
; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];
; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];
; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];
; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];
; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];
; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];
; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];
; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;
; 753  :     return ary;
; 754  :   }
; 755  : 
; 756  : /* 
; 757  :  * crypt only: convert from 64 bit to 11 bit ASCII 
; 758  :  * prefixing with the salt
; 759  :  */
; 760  : 
; 761  : STATIC char *output_conversion(ufc_long v1, ufc_long v2, char *salt)
; 762  :   { static char outbuf[14];
; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];
; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];
; 767  : 
; 768  :     for(i = 0; i < 5; i++)
; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);
; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;
; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);
; 773  : 
; 774  :     for(i = 5; i < 10; i++)
; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);
; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);
; 778  :     outbuf[13] = 0;
; 779  : 
; 780  :     return outbuf;
; 781  :   }
; 782  : 
; 783  : ufc_long *_ufc_doit(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2, ufc_long itr);
; 784  : 
; 785  : /* 
; 786  :  * UNIX crypt function
; 787  :  */
; 788  :    
; 789  : char *crypt(char *key, char *salt)
; 790  :   { ufc_long *s;
; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	lea	ecx, DWORD PTR _actualKey$[ebp+1]
	call	?setup_salt@@YAXPAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	8
	lea	eax, DWORD PTR _actualKey$[ebp]

; 85   : 
; 86   : void GenerateDESTripcode(unsigned char *tripcode, unsigned char *key)
; 87   : {
; 88   :     descrypt_spinlock.lock();
; 89   : 
; 90   :     char actualKey[MAX_LEN_TRIPCODE_KEY + 1];
; 91   :     BOOL fillRestWithZero = FALSE;
; 92   :         
; 93   :     memcpy(actualKey, (char *)key, 8);
; 94   : 	actualKey[8] = '\0';
; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 96   :             if (fillRestWithZero) {
; 97   :                     actualKey[i] = 0x00;
; 98   :             } else if (actualKey[i] == 0x80) {
; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);
; 103  : 	tripcode[10] = '\0';
; 104  : 
; 105  :     descrypt_spinlock.unlock();
; 106  : }
; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	mov	BYTE PTR _ktab$1[ebp+8], 0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	eax
	lea	eax, DWORD PTR _ktab$1[ebp]
	xorps	xmm0, xmm0
	push	eax

; 85   : 
; 86   : void GenerateDESTripcode(unsigned char *tripcode, unsigned char *key)
; 87   : {
; 88   :     descrypt_spinlock.lock();
; 89   : 
; 90   :     char actualKey[MAX_LEN_TRIPCODE_KEY + 1];
; 91   :     BOOL fillRestWithZero = FALSE;
; 92   :         
; 93   :     memcpy(actualKey, (char *)key, 8);
; 94   : 	actualKey[8] = '\0';
; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 96   :             if (fillRestWithZero) {
; 97   :                     actualKey[i] = 0x00;
; 98   :             } else if (actualKey[i] == 0x80) {
; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);
; 103  : 	tripcode[10] = '\0';
; 104  : 
; 105  :     descrypt_spinlock.unlock();
; 106  : }
; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	movq	QWORD PTR _ktab$1[ebp], xmm0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	_strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	ecx, DWORD PTR _ktab$1[ebp]
	call	?ufc_mk_keytab@@YAXPAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPAIIIIII@Z		; _ufc_doit

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	lea	ecx, DWORD PTR _actualKey$[ebp+1]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	call	?output_conversion@@YAPADIIPAD@Z	; output_conversion
	add	esp, 16					; 00000010H

; 69   :         BOOL result = strcmp((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3) == 0;

	add	eax, 3
$LL80@VerifyDEST:
	mov	cl, BYTE PTR [edi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN81@VerifyDEST
	test	cl, cl
	je	SHORT $LN82@VerifyDEST
	mov	cl, BYTE PTR [edi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN81@VerifyDEST
	add	edi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL80@VerifyDEST
$LN82@VerifyDEST:
	xor	ecx, ecx
	jmp	SHORT $LN83@VerifyDEST
$LN81@VerifyDEST:
	sbb	ecx, ecx
	or	ecx, 1
$LN83@VerifyDEST:
	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR _descrypt_spinlock, 0
	pop	edi
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 69   :         BOOL result = strcmp((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3) == 0;

	test	ecx, ecx
	pop	esi
	sete	al
	pop	ebx

; 70   : 
; 71   : #if FALSE
; 72   :         if (!result) {
; 73   :                 printf("key:       `%s'\n", key);
; 74   :                 printf("actualKey: `%s'\n", actualKey);
; 75   :                 printf("tripcode:  `%s'\n", tripcode);
; 76   :                 printf("crypt((char *)actualKey, (char *)(actualKey + 1)): `%s'\n", crypt((char *)actualKey, (char *)(actualKey + 1)));
; 77   :         }
; 78   :         fflush(stdout);
; 79   : #endif
; 80   : 
; 81   :         descrypt_spinlock.unlock();
; 82   : 
; 83   :         return result;
; 84   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@VerifyDEST:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@VerifyDEST:

; 64   :                         actualKey[i] = 0x00;

	call	___report_rangecheckfailure
$LN86@VerifyDEST:
$LN84@VerifyDEST:
	int	3
?VerifyDESTripcode@@YAHPAE0@Z ENDP			; VerifyDESTripcode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _posix_category, eax
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _errno_ecat, eax
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	call	?system_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::system_category
	mov	DWORD PTR _native_ecat, eax
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
;	COMDAT ??0spinlock@@QAE@XZ
_TEXT	SEGMENT
??0spinlock@@QAE@XZ PROC				; spinlock::spinlock, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 145  : 	}

	mov	eax, ecx
	ret	0
??0spinlock@@QAE@XZ ENDP				; spinlock::spinlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ??__Edescrypt_spinlock@@YAXXZ
text$di	SEGMENT
??__Edescrypt_spinlock@@YAXXZ PROC			; `dynamic initializer for 'descrypt_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET _descrypt_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 49   : static spinlock descrypt_spinlock;

	ret	0
??__Edescrypt_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'descrypt_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?clearmem@@YAXPADH@Z
_TEXT	SEGMENT
?clearmem@@YAXPADH@Z PROC				; clearmem, COMDAT
; _start$ = ecx
; _cnt$ = edx

; 418  :   { while(cnt--)

	push	edi
	mov	edi, ecx
	xor	eax, eax
	mov	ecx, edx
	shr	ecx, 2
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb
	pop	edi

; 419  :       *start++ = '\0';
; 420  :   }

	ret	0
?clearmem@@YAXPADH@Z ENDP				; clearmem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?init_des@@YAXXZ
_TEXT	SEGMENT
_mask2$1$ = -24						; size = 4
tv1302 = -24						; size = 4
_j1$1$ = -20						; size = 4
_mask2$1$ = -20						; size = 4
_bit$5$ = -20						; size = 4
tv1293 = -20						; size = 4
_s1$1$ = -16						; size = 4
tv1285 = -16						; size = 4
_mask1$1$ = -12						; size = 4
_mask1$1$ = -12						; size = 4
tv1291 = -12						; size = 4
_bit$1$ = -12						; size = 4
tv1290 = -8						; size = 4
_bit$3$ = -8						; size = 4
_bit$2$ = -8						; size = 4
_comes_from$1$ = -4					; size = 4
tv1292 = -4						; size = 4
?init_des@@YAXXZ PROC					; init_des, COMDAT

; 434  :   { int32_t comes_from_bit;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {

	xor	edi, edi
	mov	DWORD PTR _bit$2$[ebp], edi
	npad	2
$LL37@init_des:

; 445  :       comes_from_bit  = pc1[bit] - 1;

	mov	ebx, DWORD PTR _pc1[edi*4]

; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];

	lea	eax, DWORD PTR [ebx-1]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN107@init_des
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN107@init_des:
	movzx	eax, BYTE PTR _bytemask[eax+1]

; 447  :       mask2 = longmask[bit % 28 + 4];

	mov	esi, edi
	mov	DWORD PTR _mask1$1$[ebp], eax
	mov	eax, 613566757				; 24924925H
	mul	edi
	mov	eax, edi
	sub	esi, edx
	shr	esi, 1
	add	esi, edx
	shr	esi, 4
	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	shl	ecx, 2
	sub	eax, ecx

; 448  :       for(j = 0; j < 128; j++) {

	xor	ecx, ecx
	mov	eax, DWORD PTR _longmask[eax*4+16]
	mov	DWORD PTR _mask2$1$[ebp], eax
	mov	eax, DWORD PTR _mask1$1$[ebp]
	mov	edi, DWORD PTR _mask2$1$[ebp]
$LL34@init_des:

; 449  :         if(j & mask1) 

	test	ecx, eax
	je	SHORT $LN33@init_des

; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;

	lea	eax, DWORD PTR [ebx-1]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	eax, DWORD PTR [esi+eax*2]
	shl	eax, 7
	add	eax, ecx
	or	DWORD PTR _do_pc1[eax*4], edi
	mov	eax, DWORD PTR _mask1$1$[ebp]
$LN33@init_des:

; 448  :       for(j = 0; j < 128; j++) {

	inc	ecx
	cmp	ecx, 128				; 00000080H
	jb	SHORT $LL34@init_des

; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {

	mov	edi, DWORD PTR _bit$2$[ebp]
	inc	edi
	mov	DWORD PTR _bit$2$[ebp], edi
	cmp	edi, 56					; 00000038H
	jl	$LL37@init_des

; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {

	xor	esi, esi
	mov	DWORD PTR _bit$1$[ebp], esi
	npad	12
$LL30@init_des:

; 460  :       comes_from_bit  = pc2[bit] - 1;

	mov	ecx, DWORD PTR _pc2[esi*4]

; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];

	mov	eax, -1840700269			; 92492493H
	dec	ecx
	imul	ecx
	add	edx, ecx
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	sub	ecx, eax

; 462  :       mask2 = BITMASK(bit % 24);

	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	movzx	ebx, BYTE PTR _bytemask[ecx+1]
	mov	ecx, 12					; 0000000cH
	shr	edx, 4
	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 3
	sub	esi, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 16					; 00000010H
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	xor	ecx, ecx
	cmp	esi, 12					; 0000000cH
	cmovl	ecx, eax
	shl	edx, cl

; 463  :       for(j = 0; j < 128; j++) {

	xor	ecx, ecx
$LL27@init_des:

; 464  :         if(j & mask1)

	test	ecx, ebx
	je	SHORT $LN26@init_des

; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;

	mov	eax, edi
	shl	eax, 7
	add	eax, ecx
	or	DWORD PTR _do_pc2[eax*4], edx
$LN26@init_des:

; 463  :       for(j = 0; j < 128; j++) {

	inc	ecx
	cmp	ecx, 128				; 00000080H
	jb	SHORT $LL27@init_des

; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {

	mov	esi, DWORD PTR _bit$1$[ebp]
	inc	esi
	mov	DWORD PTR _bit$1$[ebp], esi
	cmp	esi, 48					; 00000030H
	jl	$LL30@init_des

; 419  :       *start++ = '\0';

	xor	eax, eax
	mov	ecx, 2048				; 00000800H
	mov	edi, OFFSET _eperm32tab
	rep stosd

; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {

	xor	ecx, ecx
	mov	DWORD PTR _bit$3$[ebp], ecx
	npad	10
$LL23@init_des:

; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;

	mov	eax, DWORD PTR _esel[ecx*4]

; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {

	mov	edi, 256				; 00000100H
	mov	esi, DWORD PTR _perm32[eax*4-4]
	dec	esi
	mov	eax, esi
	mov	DWORD PTR _comes_from$1$[ebp], esi
	and	eax, 7
	movzx	eax, BYTE PTR _bytemask[eax]
	mov	DWORD PTR _mask1$1$[ebp], eax

; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);

	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	ebx, edx
	shr	ebx, 4
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 3
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	DWORD PTR tv1285[ebp], ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	sub	eax, ecx
	add	eax, 14					; 0000000eH
	mov	DWORD PTR tv1293[ebp], eax
	mov	eax, DWORD PTR _mask1$1$[ebp]
	npad	2
$LL20@init_des:

; 490  :         if(j & mask1)

	dec	edi
	test	eax, edi
	je	SHORT $LN18@init_des

; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);

	mov	eax, esi
	xor	edx, edx
	shr	eax, 3
	shl	eax, 8
	add	eax, edi
	cmp	ecx, 12					; 0000000cH
	mov	ecx, DWORD PTR tv1293[ebp]
	lea	esi, DWORD PTR [ebx+eax*2]
	mov	eax, 16					; 00000010H
	cmovl	edx, eax
	mov	eax, 1
	shl	eax, cl
	mov	ecx, edx
	shl	eax, cl
	or	DWORD PTR _eperm32tab[esi*4], eax
	mov	ecx, DWORD PTR tv1285[ebp]
	mov	esi, DWORD PTR _comes_from$1$[ebp]
	mov	eax, DWORD PTR _mask1$1$[ebp]
$LN18@init_des:

; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {

	test	edi, edi
	jne	SHORT $LL20@init_des

; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {

	mov	ecx, DWORD PTR _bit$3$[ebp]
	inc	ecx
	mov	DWORD PTR _bit$3$[ebp], ecx
	cmp	ecx, 48					; 00000030H
	jl	$LL23@init_des

; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {

	xor	ebx, ebx
	mov	DWORD PTR tv1290[ebp], 24		; 00000018H
	mov	ecx, OFFSET _sb
	mov	DWORD PTR tv1292[ebp], ebx
	mov	DWORD PTR tv1291[ebp], ecx
$LL17@init_des:

; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {

	xor	edi, edi
	mov	DWORD PTR _j1$1$[ebp], edi
	npad	6
$LL14@init_des:

; 512  :         s1 = s_lookup(2 * sg, j1);

	mov	ecx, edi
	mov	eax, edi
	sar	ecx, 4
	and	eax, 1
	and	ecx, 2
	mov	esi, edi
	or	ecx, eax
	mov	eax, edi
	add	ecx, ebx
	sar	eax, 1
	shl	ecx, 4
	and	eax, 15					; 0000000fH
	add	ecx, eax

; 513  :         for(j2 = 0; j2 < 64; j2++) {

	xor	eax, eax
	mov	ecx, DWORD PTR _sbox[ecx*4]
	shl	ecx, 4
	shl	esi, 6
	mov	edi, ecx
	mov	DWORD PTR _s1$1$[ebp], ecx
	mov	DWORD PTR tv1302[ebp], esi
$LL11@init_des:

; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);
; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);

	mov	edx, eax
	mov	ecx, eax
	sar	edx, 4
	and	ecx, 1
	and	edx, 2
	or	edx, ecx
	mov	ecx, eax
	add	edx, ebx
	sar	ecx, 1
	and	ecx, 15					; 0000000fH
	shl	edx, 4
	add	edx, ecx
	mov	ecx, DWORD PTR tv1290[ebp]
	mov	ebx, DWORD PTR _sbox[edx*4+256]
	or	ebx, edi

; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;
; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];

	mov	edi, DWORD PTR tv1291[ebp]
	shl	ebx, cl
	mov	ecx, esi
	or	ecx, eax
	mov	edx, ebx
	add	ecx, ecx
	shr	edx, 24					; 00000018H
	mov	esi, DWORD PTR [edi]
	inc	eax
	lea	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR _s1$1$[ebp]
	mov	ecx, DWORD PTR _eperm32tab[edx*8]
	mov	DWORD PTR [esi], ecx

; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];

	mov	ecx, DWORD PTR _eperm32tab[edx*8+4]

; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];

	mov	edx, ebx
	mov	DWORD PTR [esi+4], ecx
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _eperm32tab[edx*8+2048]
	or	DWORD PTR [esi], ecx

; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];

	mov	ecx, DWORD PTR _eperm32tab[edx*8+2052]

; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];

	mov	edx, ebx
	or	DWORD PTR [esi+4], ecx
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _eperm32tab[edx*8+4096]
	or	DWORD PTR [esi], ecx

; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];

	mov	ecx, DWORD PTR _eperm32tab[edx*8+4100]
	or	DWORD PTR [esi+4], ecx

; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];

	movzx	edx, bl
	mov	ebx, DWORD PTR tv1292[ebp]
	mov	ecx, DWORD PTR _eperm32tab[edx*8+6144]
	or	DWORD PTR [esi], ecx

; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];

	mov	ecx, DWORD PTR _eperm32tab[edx*8+6148]
	or	DWORD PTR [esi+4], ecx
	mov	esi, DWORD PTR tv1302[ebp]
	cmp	eax, 64					; 00000040H
	jl	$LL11@init_des

; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {

	mov	edi, DWORD PTR _j1$1$[ebp]
	inc	edi
	mov	DWORD PTR _j1$1$[ebp], edi
	cmp	edi, 64					; 00000040H
	jl	$LL14@init_des

; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {

	mov	eax, DWORD PTR tv1290[ebp]
	add	ebx, 8
	add	DWORD PTR tv1291[ebp], 4
	sub	eax, 8
	mov	DWORD PTR tv1290[ebp], eax
	mov	DWORD PTR tv1292[ebp], ebx
	cmp	eax, -8					; fffffff8H
	jg	$LL17@init_des

; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {

	mov	esi, 48					; 00000030H
	npad	3
$LL8@init_des:

; 554  :       e_inverse[esel[bit] - 1     ] = bit;

	mov	edx, DWORD PTR _esel[esi*4-4]
	dec	esi

; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;

	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _e_inverse[edx*4-4], esi
	mov	DWORD PTR _e_inverse[edx*4+124], eax
	jne	SHORT $LL8@init_des

; 419  :       *start++ = '\0';

	xor	eax, eax
	mov	ecx, 2048				; 00000800H
	mov	edi, OFFSET _efp

; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {

	xor	ebx, ebx

; 419  :       *start++ = '\0';

	rep stosd

; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {

	mov	DWORD PTR _bit$5$[ebp], ebx
	npad	2
$LL6@init_des:

; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */

	mov	eax, DWORD PTR _final_perm[ebx*4]
	mov	edi, ebx
	shr	edi, 5
	mov	ecx, DWORD PTR _e_inverse[eax*4-4]

; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */

	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];

	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	sub	ecx, eax
	and	ebx, 31					; 0000001fH

; 586  :       mask2 = longmask[o_bit];

	mov	eax, DWORD PTR _longmask[ebx*4]
	mov	ebx, eax
	mov	edx, DWORD PTR _longmask[ecx*4+104]

; 587  : 
; 588  :       for(word_value = 64; word_value--;) {

	mov	ecx, 64					; 00000040H
	mov	DWORD PTR _mask2$1$[ebp], eax
$LL3@init_des:
	dec	ecx

; 589  :         if(word_value & mask1)

	test	ecx, edx
	je	SHORT $LN1@init_des

; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;

	mov	eax, esi
	shl	eax, 6
	add	eax, ecx
	lea	eax, DWORD PTR [edi+eax*2]
	or	DWORD PTR _efp[eax*4], ebx
$LN1@init_des:

; 587  : 
; 588  :       for(word_value = 64; word_value--;) {

	test	ecx, ecx
	jne	SHORT $LL3@init_des

; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {

	mov	ebx, DWORD PTR _bit$5$[ebp]
	inc	ebx
	mov	DWORD PTR _bit$5$[ebp], ebx
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL6@init_des

; 591  :       }
; 592  :     }
; 593  :     initialized++;

	inc	DWORD PTR _initialized
	pop	edi
	pop	esi
	pop	ebx

; 594  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_des@@YAXXZ ENDP					; init_des
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?shuffle_sb@@YAXPAII@Z
_TEXT	SEGMENT
?shuffle_sb@@YAXPAII@Z PROC				; shuffle_sb, COMDAT
; _k$ = ecx
; _saltbits$ = edx

; 603  :   { ufc_long j;

	push	ebx
	push	esi
	push	edi
	mov	ebx, edx

; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {

	mov	edi, 4096				; 00001000H
	npad	6
$LL2@shuffle_sb:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [ecx]

; 607  :       *k++ ^= x;

	lea	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]

; 608  :       *k++ ^= x;

	lea	ecx, DWORD PTR [ecx+4]
	xor	edx, eax
	and	edx, ebx
	xor	eax, edx
	mov	DWORD PTR [ecx-8], eax
	xor	DWORD PTR [ecx-4], edx
	dec	edi
	jne	SHORT $LL2@shuffle_sb

; 609  :     }
; 610  :   }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?shuffle_sb@@YAXPAII@Z ENDP				; shuffle_sb
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?setup_salt@@YAXPAD@Z
_TEXT	SEGMENT
_s$1$ = -12						; size = 4
_saltbits$1$ = -8					; size = 4
tv1022 = -1						; size = 1
?setup_salt@@YAXPAD@Z PROC				; setup_salt, COMDAT
; _s$ = ecx

; 636  :   { ufc_long i, j, saltbits;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 637  : 
; 638  :     if(!initialized)

	cmp	DWORD PTR _initialized, 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	jne	SHORT $LN11@setup_salt

; 639  :       init_des();

	call	?init_des@@YAXXZ			; init_des
$LN11@setup_salt:

; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])

	movsx	edx, BYTE PTR [ebx]
	movzx	eax, BYTE PTR _current_salt
	cmp	edx, eax
	jne	SHORT $LN10@setup_salt
	movsx	ecx, BYTE PTR [ebx+1]
	movzx	eax, BYTE PTR _current_salt+1
	cmp	ecx, eax
	je	$LN12@setup_salt
$LN10@setup_salt:

; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];

	mov	al, BYTE PTR [ebx]
	push	esi

; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;

	xor	esi, esi
	mov	BYTE PTR _current_salt, al
	movzx	eax, BYTE PTR [ebx+1]
	push	edi
	mov	BYTE PTR _current_salt+1, al
	mov	DWORD PTR _saltbits$1$[ebp], esi
	lea	edi, DWORD PTR [esi+2]
	lea	ecx, DWORD PTR [esi+12]
$LL9@setup_salt:

; 652  :       int32_t c=ascii_to_bin(s[i]);

	mov	al, BYTE PTR [ebx]
	movsx	ebx, al
	cmp	al, 97					; 00000061H
	jl	SHORT $LN16@setup_salt
	sub	ebx, 59					; 0000003bH
	jmp	SHORT $LN15@setup_salt
$LN16@setup_salt:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN14@setup_salt
	sub	ebx, 53					; 00000035H
	jmp	SHORT $LN15@setup_salt
$LN14@setup_salt:
	sub	ebx, 46					; 0000002eH
$LN15@setup_salt:

; 653  :       if(c < 0 || c > 63)

	test	ebx, ebx
	js	SHORT $LN5@setup_salt
	cmp	ebx, 63					; 0000003fH
	jle	SHORT $LN6@setup_salt
$LN5@setup_salt:

; 654  :         c = 0;

	xor	ebx, ebx
$LN6@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 1
	je	SHORT $LN3@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	esi, DWORD PTR [edi-2]
	xor	edx, edx
	mov	eax, esi
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	esi, 12					; 0000000cH
	mov	esi, DWORD PTR _saltbits$1$[ebp]
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	mov	ecx, 12					; 0000000cH
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN3@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 2
	je	SHORT $LN60@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	esi, DWORD PTR [edi-1]
	xor	edx, edx
	mov	eax, esi
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	esi, 12					; 0000000cH
	mov	esi, DWORD PTR _saltbits$1$[ebp]
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN60@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 4
	je	SHORT $LN62@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	xor	edx, edx
	mov	ecx, 12					; 0000000cH
	mov	eax, edi
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	edi, 12					; 0000000cH
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN62@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 8
	je	SHORT $LN64@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	esi, DWORD PTR [edi+1]
	xor	edx, edx
	mov	eax, esi
	mov	ecx, 12					; 0000000cH
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	esi, 12					; 0000000cH
	mov	esi, DWORD PTR _saltbits$1$[ebp]
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN64@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 16					; 00000010H
	je	SHORT $LN66@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	esi, DWORD PTR [edi+2]
	xor	edx, edx
	mov	eax, esi
	mov	ecx, 12					; 0000000cH
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	esi, 12					; 0000000cH
	mov	esi, DWORD PTR _saltbits$1$[ebp]
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN66@setup_salt:

; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	bl, 32					; 00000020H
	je	SHORT $LN8@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	esi, DWORD PTR [edi+3]
	xor	edx, edx
	mov	eax, esi
	mov	ecx, 12					; 0000000cH
	div	ecx
	mov	ecx, 14					; 0000000eH
	mov	eax, 1
	sub	ecx, edx
	shl	eax, cl
	cmp	esi, 12					; 0000000cH
	mov	esi, DWORD PTR _saltbits$1$[ebp]
	sbb	ecx, ecx
	and	ecx, 16					; 00000010H
	shl	eax, cl
	or	esi, eax
	mov	DWORD PTR _saltbits$1$[ebp], esi
$LN8@setup_salt:

; 651  :     for(i = 0; i < 2; i++) {

	mov	ebx, DWORD PTR _s$1$[ebp]
	add	edi, 6
	inc	ebx
	mov	ecx, 12					; 0000000cH
	mov	DWORD PTR _s$1$[ebp], ebx
	cmp	edi, 14					; 0000000eH
	jb	$LL9@setup_salt

; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 

	mov	edi, DWORD PTR _current_saltbits

; 605  :     for(j=4096; j--;) {

	mov	ebx, 4096				; 00001000H

; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 

	xor	edi, esi
	mov	esi, OFFSET ?_ufc_sb0@@3PAIA		; _ufc_sb0
	npad	2
$LL19@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [esi]

; 607  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]

; 608  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	xor	ecx, eax
	and	ecx, edi
	xor	eax, ecx
	mov	DWORD PTR [esi-8], eax
	xor	DWORD PTR [esi-4], ecx
	dec	ebx
	jne	SHORT $LL19@setup_salt

; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);

	mov	esi, OFFSET ?_ufc_sb1@@3PAIA		; _ufc_sb1

; 605  :     for(j=4096; j--;) {

	mov	ebx, 4096				; 00001000H
$LL23@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [esi]

; 607  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]

; 608  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	xor	ecx, eax
	and	ecx, edi
	xor	eax, ecx
	mov	DWORD PTR [esi-8], eax
	xor	DWORD PTR [esi-4], ecx
	dec	ebx
	jne	SHORT $LL23@setup_salt

; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);

	mov	esi, OFFSET ?_ufc_sb2@@3PAIA		; _ufc_sb2

; 605  :     for(j=4096; j--;) {

	mov	ebx, 4096				; 00001000H
$LL27@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [esi]

; 607  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]

; 608  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	xor	ecx, eax
	and	ecx, edi
	xor	eax, ecx
	mov	DWORD PTR [esi-8], eax
	xor	DWORD PTR [esi-4], ecx
	dec	ebx
	jne	SHORT $LL27@setup_salt

; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);

	mov	esi, OFFSET ?_ufc_sb3@@3PAIA		; _ufc_sb3

; 605  :     for(j=4096; j--;) {

	mov	ebx, 4096				; 00001000H
	npad	7
$LL31@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [esi]

; 607  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]

; 608  :       *k++ ^= x;

	lea	esi, DWORD PTR [esi+4]
	xor	ecx, eax
	and	ecx, edi
	xor	eax, ecx
	mov	DWORD PTR [esi-8], eax
	xor	DWORD PTR [esi-4], ecx
	dec	ebx
	jne	SHORT $LL31@setup_salt

; 670  : 
; 671  :     current_saltbits = saltbits;

	mov	eax, DWORD PTR _saltbits$1$[ebp]
	pop	edi
	mov	DWORD PTR _current_saltbits, eax
	pop	esi
$LN12@setup_salt:
	pop	ebx

; 672  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?setup_salt@@YAXPAD@Z ENDP				; setup_salt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?ufc_mk_keytab@@YAXPAD@Z
_TEXT	SEGMENT
_v1$1$ = -12						; size = 4
tv441 = -8						; size = 4
_k2$1$ = -4						; size = 4
?ufc_mk_keytab@@YAXPAD@Z PROC				; ufc_mk_keytab, COMDAT
; _key$ = ecx

; 675  :   { ufc_long v1, v2, *k1;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];

	xor	ebx, ebx
	mov	DWORD PTR _k2$1$[ebp], OFFSET ?_ufc_keytab@@3PAY01IA ; _ufc_keytab
	push	esi
	push	edi
	mov	esi, ecx
	xor	edx, edx
	mov	eax, OFFSET _do_pc1

; 685  :     for(i = 8; i--;) {

	lea	edi, DWORD PTR [ebx+8]
	npad	2
$LL5@ufc_mk_key:

; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;

	movsx	ecx, BYTE PTR [esi]

; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;

	lea	esi, DWORD PTR [esi+1]
	and	ecx, 127				; 0000007fH
	lea	eax, DWORD PTR [eax+1024]
	or	edx, DWORD PTR [eax+ecx*4-1024]
	or	ebx, DWORD PTR [eax+ecx*4-512]
	dec	edi
	jne	SHORT $LL5@ufc_mk_key

; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {

	mov	eax, OFFSET _rots
	mov	DWORD PTR tv441[ebp], eax
	npad	8
$LL3@ufc_mk_key:

; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));

	mov	edi, DWORD PTR [eax]
	mov	esi, 28					; 0000001cH
	mov	eax, edx
	sub	esi, edi
	mov	ecx, esi
	shr	eax, cl
	mov	ecx, edi
	shl	edx, cl
	or	edx, eax

; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;

	mov	ecx, edx
	mov	DWORD PTR _v1$1$[ebp], edx
	shr	ecx, 21					; 00000015H
	mov	eax, edx
	shr	eax, 14					; 0000000eH
	and	ecx, 127				; 0000007fH
	and	eax, 127				; 0000007fH
	mov	edx, DWORD PTR _do_pc2[ecx*4]
	or	edx, DWORD PTR _do_pc2[eax*4+512]

; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;

	mov	ecx, DWORD PTR _v1$1$[ebp]
	mov	eax, ecx
	shr	eax, 7

; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;

	and	ecx, 127				; 0000007fH
	and	eax, 127				; 0000007fH
	or	edx, DWORD PTR _do_pc2[eax*4+1024]
	mov	eax, DWORD PTR _do_pc2[ecx*4+1536]

; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;

	mov	ecx, DWORD PTR _k2$1$[ebp]
	or	eax, edx
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR _k2$1$[ebp], ecx

; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));

	mov	eax, ebx
	mov	ecx, esi
	shr	eax, cl
	mov	ecx, edi
	shl	ebx, cl
	or	ebx, eax

; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;

	mov	eax, ebx

; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;

	mov	ecx, ebx
	shr	eax, 21					; 00000015H
	and	eax, 127				; 0000007fH
	shr	ecx, 7
	and	ecx, 127				; 0000007fH
	mov	edx, DWORD PTR _do_pc2[eax*4+2048]
	mov	eax, ebx
	mov	ecx, DWORD PTR _do_pc2[ecx*4+3072]
	shr	eax, 14					; 0000000eH
	and	eax, 127				; 0000007fH
	or	edx, DWORD PTR _do_pc2[eax*4+2560]
	mov	eax, ebx
	and	eax, 127				; 0000007fH
	or	ecx, DWORD PTR _do_pc2[eax*4+3584]
	mov	eax, DWORD PTR _k2$1$[ebp]
	or	ecx, edx
	mov	edx, DWORD PTR _v1$1$[ebp]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR _k2$1$[ebp], eax
	mov	eax, DWORD PTR tv441[ebp]
	add	eax, 4
	mov	DWORD PTR tv441[ebp], eax
	cmp	eax, OFFSET _rots+64
	jl	$LL3@ufc_mk_key

; 714  :     }
; 715  : 
; 716  :     direction = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _direction, 0
	pop	ebx

; 717  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?ufc_mk_keytab@@YAXPAD@Z ENDP				; ufc_mk_keytab
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?_ufc_dofinalperm@@YAPAIIIII@Z
_TEXT	SEGMENT
_l2$1$ = 8						; size = 4
_r1$ = 8						; size = 4
_l1$1$ = 12						; size = 4
_r2$ = 12						; size = 4
?_ufc_dofinalperm@@YAPAIIIII@Z PROC			; _ufc_dofinalperm, COMDAT
; _l1$ = ecx
; _l2$ = edx

; 724  :   { ufc_long v1, v2, x;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, edx
	mov	ebx, ecx

; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;

	mov	ecx, DWORD PTR _r2$[ebp]
	mov	eax, ebx
	xor	eax, edi
	and	eax, DWORD PTR _current_saltbits
	xor	ebx, eax
	xor	edi, eax
	mov	eax, DWORD PTR _r1$[ebp]
	mov	edx, eax
	xor	edx, ecx

; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;

	shr	ebx, 3
	and	edx, DWORD PTR _current_saltbits
	mov	esi, edx
	shr	edi, 3
	xor	esi, eax
	mov	DWORD PTR _l1$1$[ebp], ebx
	xor	edx, ecx
	mov	DWORD PTR _l2$1$[ebp], edi
	shr	edx, 3

; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];

	mov	eax, edx
	shr	esi, 3
	and	eax, 63					; 0000003fH

; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];

	shr	edx, 6

; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];
; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];
; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];

	mov	ecx, esi

; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];

	shr	esi, 6
	and	ecx, 63					; 0000003fH
	mov	edi, DWORD PTR _efp[eax*8+7680]
	mov	ebx, DWORD PTR _efp[eax*8+7684]
	mov	eax, edx
	and	eax, 63					; 0000003fH
	shr	edx, 10					; 0000000aH
	or	edi, DWORD PTR _efp[eax*8+7168]
	or	ebx, DWORD PTR _efp[eax*8+7172]
	mov	eax, edx
	and	eax, 63					; 0000003fH
	shr	edx, 6
	and	edx, 63					; 0000003fH
	or	edi, DWORD PTR _efp[eax*8+6656]
	or	ebx, DWORD PTR _efp[eax*8+6660]
	mov	eax, DWORD PTR _efp[ecx*8+5632]
	or	eax, DWORD PTR _efp[edx*8+6144]
	or	edi, eax
	mov	eax, DWORD PTR _efp[ecx*8+5636]
	or	eax, DWORD PTR _efp[edx*8+6148]

; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];
; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];
; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];

	mov	edx, DWORD PTR _l2$1$[ebp]
	or	ebx, eax
	mov	eax, esi
	mov	ecx, edx
	and	eax, 63					; 0000003fH
	shr	esi, 10					; 0000000aH
	and	ecx, 63					; 0000003fH

; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];

	shr	edx, 6
	or	edi, DWORD PTR _efp[eax*8+5120]
	or	ebx, DWORD PTR _efp[eax*8+5124]
	mov	eax, esi
	and	eax, 63					; 0000003fH
	shr	esi, 6
	and	esi, 63					; 0000003fH
	or	edi, DWORD PTR _efp[eax*8+4608]
	or	ebx, DWORD PTR _efp[eax*8+4612]
	mov	eax, DWORD PTR _efp[ecx*8+3584]
	or	eax, DWORD PTR _efp[esi*8+4096]
	or	edi, eax
	mov	eax, DWORD PTR _efp[ecx*8+3588]
	or	eax, DWORD PTR _efp[esi*8+4100]

; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];
; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];
; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];

	mov	esi, DWORD PTR _l1$1$[ebp]
	or	ebx, eax
	mov	eax, edx
	shr	edx, 10					; 0000000aH
	and	eax, 63					; 0000003fH
	or	edi, DWORD PTR _efp[eax*8+3072]
	or	ebx, DWORD PTR _efp[eax*8+3076]
	mov	eax, edx
	and	eax, 63					; 0000003fH
	or	edi, DWORD PTR _efp[eax*8+2560]
	or	ebx, DWORD PTR _efp[eax*8+2564]
	shr	edx, 6
	mov	ecx, esi
	and	edx, 63					; 0000003fH
	and	ecx, 63					; 0000003fH

; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];

	shr	esi, 6
	mov	eax, DWORD PTR _efp[ecx*8+1536]
	or	eax, DWORD PTR _efp[edx*8+2048]
	or	edi, eax
	mov	eax, DWORD PTR _efp[ecx*8+1540]
	or	eax, DWORD PTR _efp[edx*8+2052]
	or	ebx, eax
	mov	eax, esi
	and	eax, 63					; 0000003fH

; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];

	shr	esi, 10					; 0000000aH
	or	edi, DWORD PTR _efp[eax*8+1024]
	or	ebx, DWORD PTR _efp[eax*8+1028]
	mov	eax, esi
	and	eax, 63					; 0000003fH

; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];

	shr	esi, 6
	and	esi, 63					; 0000003fH
	or	edi, DWORD PTR _efp[eax*8+512]
	or	ebx, DWORD PTR _efp[eax*8+516]
	mov	eax, DWORD PTR _efp[esi*8]
	or	eax, edi

; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;

	mov	DWORD PTR ?ary@?1??_ufc_dofinalperm@@YAPAIIIII@Z@4PAIA, eax
	mov	eax, DWORD PTR _efp[esi*8+4]
	or	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR ?ary@?1??_ufc_dofinalperm@@YAPAIIIII@Z@4PAIA+4, eax

; 753  :     return ary;

	mov	eax, OFFSET ?ary@?1??_ufc_dofinalperm@@YAPAIIIII@Z@4PAIA
	pop	ebx

; 754  :   }

	pop	ebp
	ret	0
?_ufc_dofinalperm@@YAPAIIIII@Z ENDP			; _ufc_dofinalperm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?output_conversion@@YAPADIIPAD@Z
_TEXT	SEGMENT
_salt$ = 8						; size = 4
?output_conversion@@YAPADIIPAD@Z PROC			; output_conversion, COMDAT
; _v1$ = ecx
; _v2$ = edx

; 762  :   { static char outbuf[14];

	push	ebp
	mov	ebp, esp
	push	esi

; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];

	mov	esi, DWORD PTR _salt$[ebp]
	push	edi
	mov	edi, edx
	movzx	eax, BYTE PTR [esi]
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA, al

; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];

	mov	al, BYTE PTR [esi+1]
	test	al, al
	jne	SHORT $LN10@output_con
	mov	al, BYTE PTR [esi]
$LN10@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+1, al

; 767  : 
; 768  :     for(i = 0; i < 5; i++)
; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);

	mov	eax, ecx
	shr	eax, 26					; 0000001aH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN13@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN12@output_con
$LN13@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN11@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN12@output_con
$LN11@output_con:
	add	eax, 46					; 0000002eH
$LN12@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+2, al
	mov	eax, ecx
	shr	eax, 20					; 00000014H
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN37@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN39@output_con
$LN37@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN38@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN39@output_con
$LN38@output_con:
	add	eax, 46					; 0000002eH
$LN39@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+3, al
	mov	eax, ecx
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN41@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN43@output_con
$LN41@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN42@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN43@output_con
$LN42@output_con:
	add	eax, 46					; 0000002eH
$LN43@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+4, al
	mov	eax, ecx
	shr	eax, 8
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN45@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN47@output_con
$LN45@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN46@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN47@output_con
$LN46@output_con:
	add	eax, 46					; 0000002eH
$LN47@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+5, al
	mov	eax, ecx
	shr	eax, 2
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN49@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN51@output_con
$LN49@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN50@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN51@output_con
$LN50@output_con:
	add	eax, 46					; 0000002eH
$LN51@output_con:

; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;
; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);

	shr	edi, 2
	and	edx, 15					; 0000000fH
	shl	ecx, 30					; 0000001eH
	or	ecx, edi
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+6, al

; 773  : 
; 774  :     for(i = 5; i < 10; i++)
; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);

	mov	eax, ecx
	shl	edx, 2
	shr	eax, 26					; 0000001aH
	pop	edi
	pop	esi
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN17@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN16@output_con
$LN17@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN15@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN16@output_con
$LN15@output_con:
	add	eax, 46					; 0000002eH
$LN16@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+7, al
	mov	eax, ecx
	shr	eax, 20					; 00000014H
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN58@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN60@output_con
$LN58@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN59@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN60@output_con
$LN59@output_con:
	add	eax, 46					; 0000002eH
$LN60@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+8, al
	mov	eax, ecx
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN62@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN64@output_con
$LN62@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN63@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN64@output_con
$LN63@output_con:
	add	eax, 46					; 0000002eH
$LN64@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+9, al
	mov	eax, ecx
	shr	eax, 8
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN66@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN68@output_con
$LN66@output_con:
	cmp	eax, 12					; 0000000cH
	jb	SHORT $LN67@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN68@output_con
$LN67@output_con:
	add	eax, 46					; 0000002eH
$LN68@output_con:
	shr	ecx, 2
	and	ecx, 63					; 0000003fH
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+10, al
	cmp	ecx, 38					; 00000026H
	jb	SHORT $LN70@output_con
	add	ecx, 59					; 0000003bH
	jmp	SHORT $LN72@output_con
$LN70@output_con:
	cmp	ecx, 12					; 0000000cH
	jb	SHORT $LN71@output_con
	add	ecx, 53					; 00000035H
	jmp	SHORT $LN72@output_con
$LN71@output_con:
	add	ecx, 46					; 0000002eH
$LN72@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+11, cl

; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);

	cmp	edx, 38					; 00000026H
	jl	SHORT $LN21@output_con
	add	edx, 59					; 0000003bH

; 778  :     outbuf[13] = 0;

	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+13, 0
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+12, dl

; 779  : 
; 780  :     return outbuf;

	mov	eax, OFFSET ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA

; 781  :   }

	pop	ebp
	ret	0
$LN21@output_con:

; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);

	cmp	edx, 12					; 0000000cH
	jl	SHORT $LN19@output_con
	add	edx, 53					; 00000035H

; 778  :     outbuf[13] = 0;

	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+13, 0
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+12, dl

; 779  : 
; 780  :     return outbuf;

	mov	eax, OFFSET ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA

; 781  :   }

	pop	ebp
	ret	0
$LN19@output_con:

; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);

	add	edx, 46					; 0000002eH

; 778  :     outbuf[13] = 0;

	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+13, 0
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA+12, dl

; 779  : 
; 780  :     return outbuf;

	mov	eax, OFFSET ?outbuf@?1??output_conversion@@YAPADIIPAD@Z@4PADA

; 781  :   }

	pop	ebp
	ret	0
?output_conversion@@YAPADIIPAD@Z ENDP			; output_conversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?crypt@@YAPADPAD0@Z
_TEXT	SEGMENT
_ktab$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
?crypt@@YAPADPAD0@Z PROC				; crypt, COMDAT
; _key$ = ecx
; _salt$ = edx

; 790  :   { ufc_long *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	mov	ecx, edi
	call	?setup_salt@@YAXPAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	8
	lea	eax, DWORD PTR _ktab$[ebp]

; 419  :       *start++ = '\0';

	mov	BYTE PTR _ktab$[ebp+8], 0
	xorps	xmm0, xmm0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	push	esi
	push	eax

; 419  :       *start++ = '\0';

	movq	QWORD PTR _ktab$[ebp], xmm0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	_strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	ecx, DWORD PTR _ktab$[ebp]
	call	?ufc_mk_keytab@@YAXPAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPAIIIIII@Z		; _ufc_doit

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	push	edi
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	call	?output_conversion@@YAPADIIPAD@Z	; output_conversion

; 815  :   }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?crypt@@YAPADPAD0@Z ENDP				; crypt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?_ufc_doit@@YAPAIIIIII@Z
_TEXT	SEGMENT
_itr$1$ = -16						; size = 4
_l1$1$ = -12						; size = 4
_i$1$ = -8						; size = 4
_r2$1$ = -4						; size = 4
_r1$dead$ = 8						; size = 4
_r2$dead$ = 12						; size = 4
_itr$dead$ = 16						; size = 4
?_ufc_doit@@YAPAIIIIII@Z PROC				; _ufc_doit, COMDAT
; _l1$dead$ = ecx
; _l2$dead$ = edx

; 970  :   { int32_t i;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	xor	esi, esi
	mov	DWORD PTR _r2$1$[ebp], 0
	xor	edi, edi
	mov	eax, 25					; 00000019H
	xor	ebx, ebx
	npad	5
$LL4@ufc_doit:

; 971  :     long32 s, *k;
; 972  : 
; 973  :     while(itr--) {

	dec	eax

; 974  :       k = &_ufc_keytab[0][0];
; 975  :       for(i=8; i--; ) {

	mov	edx, 8
	mov	DWORD PTR _itr$1$[ebp], eax
	mov	eax, OFFSET ?_ufc_keytab@@3PAY01IA	; _ufc_keytab
	npad	2
$LL2@ufc_doit:
	dec	edx

; 976  :         s = *k++ ^ r1;
; 977  :         l1 ^= SBA(_ufc_sb1, s & 0xffff); l2 ^= SBA(_ufc_sb1, (s & 0xffff)+4);  
; 978  :         l1 ^= SBA(_ufc_sb0, s >>= 16);   l2 ^= SBA(_ufc_sb0, (s)         +4); 
; 979  :         s = *k++ ^ r2; 
; 980  :         l1 ^= SBA(_ufc_sb3, s & 0xffff); l2 ^= SBA(_ufc_sb3, (s & 0xffff)+4);
; 981  :         l1 ^= SBA(_ufc_sb2, s >>= 16);   l2 ^= SBA(_ufc_sb2, (s)         +4);
; 982  : 
; 983  :         s = *k++ ^ l1; 
; 984  :         r1 ^= SBA(_ufc_sb1, s & 0xffff); r2 ^= SBA(_ufc_sb1, (s & 0xffff)+4);  
; 985  :         r1 ^= SBA(_ufc_sb0, s >>= 16);   r2 ^= SBA(_ufc_sb0, (s)         +4); 
; 986  :         s = *k++ ^ l2; 

	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _i$1$[ebp], edx
	mov	edx, DWORD PTR [eax-16]
	xor	edx, esi
	mov	ecx, edx
	shr	edx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	xor	ebx, DWORD PTR ?_ufc_sb1@@3PAIA[ecx]
	xor	ebx, DWORD PTR ?_ufc_sb0@@3PAIA[edx]
	xor	edi, DWORD PTR ?_ufc_sb1@@3PAIA[ecx+4]
	xor	edi, DWORD PTR ?_ufc_sb0@@3PAIA[edx+4]
	mov	edx, DWORD PTR [eax-12]
	xor	edx, DWORD PTR _r2$1$[ebp]
	mov	ecx, edx
	shr	edx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	xor	ebx, DWORD PTR ?_ufc_sb3@@3PAIA[ecx]
	xor	ebx, DWORD PTR ?_ufc_sb2@@3PAIA[edx]
	xor	edi, DWORD PTR ?_ufc_sb3@@3PAIA[ecx+4]
	xor	edi, DWORD PTR ?_ufc_sb2@@3PAIA[edx+4]
	mov	edx, DWORD PTR [eax-8]
	xor	edx, ebx
	mov	DWORD PTR _l1$1$[ebp], ebx
	mov	ebx, DWORD PTR _r2$1$[ebp]
	mov	ecx, edx
	and	ecx, 65535				; 0000ffffH
	shr	edx, 16					; 00000010H
	xor	ebx, DWORD PTR ?_ufc_sb1@@3PAIA[ecx+4]
	xor	esi, DWORD PTR ?_ufc_sb1@@3PAIA[ecx]
	mov	ecx, ebx
	xor	ecx, DWORD PTR ?_ufc_sb0@@3PAIA[edx+4]
	xor	esi, DWORD PTR ?_ufc_sb0@@3PAIA[edx]
	mov	edx, DWORD PTR [eax-4]
	mov	DWORD PTR _r2$1$[ebp], ebx
	xor	edx, edi
	mov	DWORD PTR _r2$1$[ebp], ecx

; 987  :         r1 ^= SBA(_ufc_sb3, s & 0xffff); r2 ^= SBA(_ufc_sb3, (s & 0xffff)+4);  

	mov	ecx, edx
	mov	ebx, DWORD PTR _r2$1$[ebp]
	and	ecx, 65535				; 0000ffffH

; 988  :         r1 ^= SBA(_ufc_sb2, s >>= 16);   r2 ^= SBA(_ufc_sb2, (s)         +4);

	shr	edx, 16					; 00000010H
	xor	ebx, DWORD PTR ?_ufc_sb3@@3PAIA[ecx+4]
	xor	esi, DWORD PTR ?_ufc_sb3@@3PAIA[ecx]
	mov	ecx, ebx
	xor	ecx, DWORD PTR ?_ufc_sb2@@3PAIA[edx+4]
	xor	esi, DWORD PTR ?_ufc_sb2@@3PAIA[edx]
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR _r2$1$[ebp], ebx
	mov	ebx, DWORD PTR _l1$1$[ebp]
	mov	DWORD PTR _r2$1$[ebp], ecx
	test	edx, edx
	jne	$LL2@ufc_doit

; 989  :       } 
; 990  :       s=l1; l1=r1; r1=s; s=l2; l2=r2; r2=s;

	mov	eax, ebx
	mov	edx, edi
	mov	ebx, esi
	mov	DWORD PTR _r2$1$[ebp], edx
	mov	esi, eax
	mov	edi, ecx
	mov	eax, DWORD PTR _itr$1$[ebp]
	test	eax, eax
	jne	$LL4@ufc_doit

; 991  :     }
; 992  :     return _ufc_dofinalperm(l1, l2, r1, r2);

	push	edx
	push	esi
	mov	edx, edi
	mov	ecx, ebx
	call	?_ufc_dofinalperm@@YAPAIIIII@Z		; _ufc_dofinalperm
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 993  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?_ufc_doit@@YAPAIIIIII@Z ENDP				; _ufc_doit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?CPU_DES_SBoxes1@@YAXPAEPAI1H@Z
_TEXT	SEGMENT
_var12$8$ = -56						; size = 4
_var10$8$ = -56						; size = 4
_var7$15$ = -56						; size = 4
_var14$1$ = -52						; size = 4
_var9$10$ = -52						; size = 4
_var7$3$ = -52						; size = 4
_var4$6$ = -52						; size = 4
_var0$11$ = -52						; size = 4
tv2101 = -52						; size = 4
_var13$4$ = -48						; size = 4
_var9$15$ = -48						; size = 4
_var7$8$ = -48						; size = 4
_var6$2$ = -48						; size = 4
_var4$10$ = -48						; size = 4
_var2$8$ = -48						; size = 4
_var1$8$ = -48						; size = 4
tv2098 = -48						; size = 4
_var12$1$ = -44						; size = 4
_var10$7$ = -44						; size = 4
_var9$6$ = -44						; size = 4
_var7$12$ = -44						; size = 4
_var4$8$ = -44						; size = 4
_var2$3$ = -44						; size = 4
_var1$4$ = -44						; size = 4
_var13$7$ = -40						; size = 4
_var6$17$ = -40						; size = 4
_var4$9$ = -40						; size = 4
_expansionFunction$1$ = -40				; size = 4
_var14$3$ = -36						; size = 4
_var5$12$ = -36						; size = 4
_var4$2$ = -36						; size = 4
_var2$16$ = -36						; size = 4
_var2$2$ = -36						; size = 4
_var1$10$ = -36						; size = 4
_var1$5$ = -36						; size = 4
_var0$12$ = -36						; size = 4
_var14$5$ = -32						; size = 4
_var8$11$ = -32						; size = 4
_var8$9$ = -32						; size = 4
_var5$9$ = -32						; size = 4
_var4$11$ = -32						; size = 4
_var4$1$ = -32						; size = 4
_var3$4$ = -32						; size = 4
_var0$6$ = -32						; size = 4
_var15$2$ = -28						; size = 4
_var13$1$ = -28						; size = 4
_var9$11$ = -28						; size = 4
_var6$7$ = -28						; size = 4
_var3$7$ = -28						; size = 4
_var3$3$ = -28						; size = 4
_var1$11$ = -28						; size = 4
_var11$6$ = -24						; size = 4
_var10$5$ = -24						; size = 4
_var4$5$ = -24						; size = 4
_var3$13$ = -24						; size = 4
_var2$13$ = -24						; size = 4
_var1$3$ = -24						; size = 4
_var0$1$ = -24						; size = 4
_var11$5$ = -20						; size = 4
_var8$10$ = -20						; size = 4
_var5$14$ = -20						; size = 4
_var4$4$ = -20						; size = 4
_var3$8$ = -20						; size = 4
_var1$9$ = -20						; size = 4
_var1$1$ = -20						; size = 4
_var0$4$ = -20						; size = 4
_var10$4$ = -16						; size = 4
_var7$1$ = -16						; size = 4
_var6$14$ = -16						; size = 4
_var6$12$ = -16						; size = 4
_var3$5$ = -16						; size = 4
_var1$7$ = -16						; size = 4
_var9$9$ = -12						; size = 4
_var9$5$ = -12						; size = 4
_var9$2$ = -12						; size = 4
_var8$4$ = -12						; size = 4
_var0$14$ = -12						; size = 4
_var0$13$ = -12						; size = 4
_var6$9$ = -8						; size = 4
_var5$13$ = -8						; size = 4
_var4$3$ = -8						; size = 4
_var3$10$ = -8						; size = 4
_var0$7$ = -8						; size = 4
_var0$2$ = -8						; size = 4
_expandedKeySchedule$1$ = -4				; size = 4
_dataBlocks$ = 8					; size = 4
_var0$15$ = 12						; size = 4
_keyScheduleIndexBase$ = 12				; size = 4
?CPU_DES_SBoxes1@@YAXPAEPAI1H@Z PROC			; CPU_DES_SBoxes1, COMDAT
; _expansionFunction$ = ecx
; _expandedKeySchedule$ = edx

; 1581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	mov	esi, edx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _expandedKeySchedule$1$[ebp], esi

; 1582 : 	vtype var0;
; 1583 : 	vtype var1;
; 1584 : 	vtype var2;
; 1585 : 	vtype var3; 
; 1586 : 	vtype var4; 
; 1587 : 	vtype var5; 
; 1588 : 	vtype var6; 
; 1589 : 	vtype var7; 
; 1590 : 	vtype var8; 
; 1591 : 	vtype var9; 
; 1592 : 	vtype var10; 
; 1593 : 	vtype var11; 
; 1594 : 	vtype var12; 
; 1595 : 	vtype var13; 
; 1596 : 	vtype var14; 
; 1597 : 	vtype var15; 
; 1598 : 	vtype var16; 
; 1599 : 	vtype var17; 
; 1600 : 	vtype var18;  
; 1601 : 
; 1602 : 	s1(x( 0),     x( 1),     x( 2),     x( 3),     x( 4),     x( 5),     z(40), z(48), z(54), z(62));

	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _expansionFunction$1$[ebp], edi
	movzx	eax, BYTE PTR [edi]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _keyScheduleIndexBase$[ebp]
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _var0$1$[ebp], edx
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	eax, DWORD PTR [esi+ecx*4+4]
	mov	DWORD PTR _var1$1$[ebp], eax
	movzx	eax, BYTE PTR [edi+2]
	mov	ebx, DWORD PTR [edx+eax*4]
	xor	ebx, DWORD PTR [esi+ecx*4+8]
	movzx	eax, BYTE PTR [edi+3]
	mov	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	esi, DWORD PTR [eax+ecx*4+12]
	movzx	eax, BYTE PTR [edi+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edx+eax*4+16]
	movzx	eax, BYTE PTR [edi+5]
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$1$[ebp], ecx
	not	ecx
	and	ecx, DWORD PTR _var0$1$[ebp]
	mov	DWORD PTR _var6$2$[ebp], ecx
	xor	ecx, esi
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR _var7$1$[ebp], ecx
	mov	ecx, ebx
	xor	ecx, DWORD PTR _var0$1$[ebp]
	xor	edi, DWORD PTR [edx+eax*4+20]
	mov	eax, ecx
	mov	edx, DWORD PTR _var7$1$[ebp]
	not	ecx
	mov	DWORD PTR _var9$2$[ebp], edi
	not	edx
	or	edi, ebx
	and	eax, edi
	mov	DWORD PTR _var2$2$[ebp], edi
	mov	edi, eax
	or	eax, DWORD PTR _var9$2$[ebp]
	xor	edi, esi
	and	edx, edi
	not	edi
	mov	DWORD PTR _var12$1$[ebp], edx
	mov	edx, DWORD PTR _var9$2$[ebp]
	xor	edx, DWORD PTR _var4$1$[ebp]
	and	edi, DWORD PTR _var4$1$[ebp]
	mov	DWORD PTR _var0$2$[ebp], edx
	xor	DWORD PTR _var0$2$[ebp], ebx
	not	DWORD PTR _var0$2$[ebp]
	mov	DWORD PTR _var13$1$[ebp], edx
	mov	edx, DWORD PTR _var7$1$[ebp]
	and	DWORD PTR _var0$2$[ebp], edx
	xor	DWORD PTR _var0$2$[ebp], eax
	mov	edx, DWORD PTR _var12$1$[ebp]
	and	ecx, DWORD PTR _var13$1$[ebp]
	not	edx
	and	edx, DWORD PTR _var0$2$[ebp]
	mov	DWORD PTR _var14$1$[ebp], edx
	mov	edx, DWORD PTR _var9$2$[ebp]
	or	edx, DWORD PTR _var0$1$[ebp]
	mov	DWORD PTR _var9$2$[ebp], edx
	mov	eax, DWORD PTR _var9$2$[ebp]
	or	edx, DWORD PTR _var0$2$[ebp]
	not	eax
	and	eax, esi
	xor	eax, edi
	or	eax, ecx
	mov	esi, DWORD PTR _var6$2$[ebp]
	mov	ecx, edi
	mov	DWORD PTR _var9$2$[ebp], eax
	not	esi
	mov	eax, DWORD PTR _var7$1$[ebp]
	and	esi, ebx
	xor	eax, edx
	mov	ebx, DWORD PTR _var0$2$[ebp]
	and	ebx, DWORD PTR _var2$2$[ebp]
	not	esi
	and	esi, eax
	xor	ecx, edx
	mov	eax, esi
	not	eax
	xor	ebx, eax
	mov	eax, DWORD PTR _var1$1$[ebp]
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR [eax+216]
	xor	ecx, ebx
	mov	DWORD PTR [eax+216], ecx
	mov	ecx, DWORD PTR _var13$1$[ebp]
	mov	eax, DWORD PTR _var12$1$[ebp]
	xor	ecx, esi
	or	eax, DWORD PTR _var1$1$[ebp]
	or	ecx, edi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR _var2$2$[ebp]
	xor	ecx, edi
	xor	ecx, DWORD PTR _var0$1$[ebp]
	xor	edi, edx
	mov	edx, DWORD PTR _var13$1$[ebp]
	xor	ebx, ecx
	xor	eax, DWORD PTR [esi+160]
	or	edx, ebx
	or	edi, DWORD PTR _var9$2$[ebp]
	xor	eax, ebx
	mov	DWORD PTR [esi+160], eax
	xor	edi, ecx
	mov	esi, DWORD PTR _var14$1$[ebp]
	mov	eax, esi
	or	eax, DWORD PTR _var1$1$[ebp]
	and	esi, ecx
	xor	eax, edx

; 1603 : 	s2(x( 6),     x( 7),     x( 8),     x( 9),     x(10),     x(11),     z(44), z(59), z(33), z(49));

	mov	ecx, DWORD PTR _expansionFunction$1$[ebp]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [edx+192]
	xor	eax, edi
	not	edi
	mov	DWORD PTR [edx+192], eax
	mov	eax, DWORD PTR _var7$1$[ebp]
	or	eax, DWORD PTR _var4$1$[ebp]
	and	eax, edi
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	or	eax, DWORD PTR _var1$1$[ebp]
	xor	eax, DWORD PTR [edx+248]
	xor	eax, DWORD PTR _var9$2$[ebp]
	mov	DWORD PTR [edx+248], eax
	movzx	eax, BYTE PTR [ecx+6]
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	movzx	eax, BYTE PTR [ecx+7]
	xor	ebx, DWORD PTR [edi+edx*4+24]
	mov	esi, DWORD PTR [esi+eax*4]
	xor	esi, DWORD PTR [edi+edx*4+28]
	movzx	eax, BYTE PTR [ecx+8]
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var0$4$[ebp], ebx
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, DWORD PTR [eax+edx*4+32]
	movzx	eax, BYTE PTR [ecx+9]
	mov	DWORD PTR _var2$3$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, DWORD PTR [edi+edx*4+36]
	mov	DWORD PTR _var3$3$[ebp], eax
	movzx	eax, BYTE PTR [ecx+10]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+40]
	movzx	eax, BYTE PTR [ecx+11]
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$2$[ebp], edx
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edi+eax*4+44]
	mov	eax, edx
	xor	eax, esi
	mov	edi, DWORD PTR _var2$3$[ebp]
	mov	DWORD PTR _var8$4$[ebp], eax
	mov	eax, ecx
	not	eax
	mov	DWORD PTR _var4$3$[ebp], eax
	and	eax, ebx
	not	eax
	and	eax, edx
	mov	edx, eax
	or	edx, esi
	mov	DWORD PTR _var0$6$[ebp], edx
	mov	edx, DWORD PTR _var8$4$[ebp]
	and	DWORD PTR _var4$3$[ebp], edx
	and	edx, ebx
	mov	ebx, DWORD PTR _var4$3$[ebp]
	xor	DWORD PTR _var4$3$[ebp], eax
	not	ebx
	xor	edx, DWORD PTR _var4$2$[ebp]
	mov	eax, DWORD PTR _var4$3$[ebp]
	and	eax, DWORD PTR _var0$6$[ebp]
	mov	DWORD PTR tv2098[ebp], ebx
	and	ebx, edx
	mov	DWORD PTR _var4$3$[ebp], eax
	mov	DWORD PTR _var10$4$[ebp], ebx
	mov	ebx, ecx
	and	ebx, edi
	mov	DWORD PTR _var7$3$[ebp], ebx
	not	ebx
	mov	eax, ebx
	and	eax, DWORD PTR _var4$3$[ebp]
	and	DWORD PTR _var4$3$[ebp], edi
	not	eax
	mov	edi, DWORD PTR _var0$4$[ebp]
	and	eax, DWORD PTR _var3$3$[ebp]
	not	edi
	xor	edi, DWORD PTR _var4$3$[ebp]
	mov	DWORD PTR _var0$4$[ebp], edi
	mov	edi, DWORD PTR _var8$4$[ebp]
	xor	edi, ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	and	ebx, edi
	mov	DWORD PTR _var8$4$[ebp], edi
	mov	edi, ebx
	not	ebx
	xor	edi, DWORD PTR _var0$4$[ebp]
	and	ebx, esi
	xor	eax, DWORD PTR [ecx+236]
	mov	esi, ebx
	xor	eax, edi
	xor	esi, edx
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	not	esi
	mov	DWORD PTR [ecx+236], eax
	mov	eax, DWORD PTR _var3$3$[ebp]
	mov	ecx, DWORD PTR _var8$4$[ebp]
	not	eax
	and	eax, DWORD PTR _var0$6$[ebp]
	xor	eax, DWORD PTR [edx+176]
	xor	ecx, DWORD PTR _var2$3$[ebp]
	mov	DWORD PTR _var1$3$[ebp], esi
	and	esi, DWORD PTR _var0$4$[ebp]
	xor	esi, ecx
	xor	eax, esi
	mov	DWORD PTR [edx+176], eax
	mov	eax, DWORD PTR _var4$3$[ebp]
	xor	eax, ebx
	mov	edx, eax
	or	edx, ecx
	mov	ebx, DWORD PTR _var0$6$[ebp]
	xor	eax, esi
	mov	ecx, DWORD PTR _var7$3$[ebp]
	xor	ebx, edi
	or	ecx, ebx
	and	eax, ecx
	xor	eax, DWORD PTR _var4$2$[ebp]
	and	eax, DWORD PTR tv2098[ebp]
	xor	eax, edi
	mov	DWORD PTR _var4$3$[ebp], eax
	or	eax, DWORD PTR _var3$3$[ebp]
	xor	eax, edx

; 1604 : 	s3(y( 7, 12), y( 8, 13), y( 9, 14), y(10, 15), y(11, 16), y(12, 17), z(55), z(47), z(61), z(37));

	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	DWORD PTR [ecx+132], eax
	mov	eax, DWORD PTR _var1$3$[ebp]
	and	eax, DWORD PTR _var4$3$[ebp]
	mov	ecx, DWORD PTR _var10$4$[ebp]
	or	ecx, DWORD PTR _var3$3$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _var8$4$[ebp]
	or	ecx, ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [ebx+196], eax
	mov	edi, DWORD PTR [ecx+edx*4+48]
	xor	edi, DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [ecx+edx*4+52]
	xor	eax, DWORD PTR [ebx+32]
	mov	esi, DWORD PTR [ecx+edx*4+56]
	xor	esi, DWORD PTR [ebx+36]
	mov	ebx, DWORD PTR [ecx+edx*4+60]
	mov	ecx, DWORD PTR [ecx+edx*4+64]
	mov	DWORD PTR _var0$7$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var1$4$[ebp], eax
	mov	DWORD PTR _var3$5$[ebp], esi
	xor	ecx, DWORD PTR [edi+44]
	xor	ebx, DWORD PTR [edi+40]
	mov	DWORD PTR _var4$4$[ebp], ecx
	mov	ecx, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	DWORD PTR _var3$4$[ebp], ebx
	mov	ecx, DWORD PTR [ecx+edx*4+68]
	mov	edx, edi
	mov	edi, DWORD PTR _var0$7$[ebp]
	xor	ecx, DWORD PTR [edx+48]
	mov	edx, ecx
	mov	DWORD PTR _var9$5$[ebp], ecx
	xor	edx, esi
	xor	ecx, ebx
	mov	ebx, DWORD PTR _var9$5$[ebp]
	mov	esi, eax
	not	esi
	not	ebx
	mov	eax, esi
	and	eax, edi
	not	edi
	or	eax, edx
	and	edi, ecx
	mov	DWORD PTR _var6$7$[ebp], edi
	xor	edi, eax
	mov	DWORD PTR _var10$5$[ebp], edi
	mov	edi, edx
	xor	edi, DWORD PTR _var1$4$[ebp]
	and	ebx, edi
	xor	ebx, eax
	mov	eax, DWORD PTR _var10$5$[ebp]
	and	eax, DWORD PTR _var9$5$[ebp]
	or	eax, DWORD PTR _var3$4$[ebp]
	and	eax, DWORD PTR _var0$7$[ebp]
	xor	eax, edi
	mov	DWORD PTR _var13$4$[ebp], ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var14$3$[ebp], eax
	mov	eax, DWORD PTR _var4$4$[ebp]
	not	eax
	and	eax, DWORD PTR _var10$5$[ebp]
	xor	eax, DWORD PTR _var14$3$[ebp]
	xor	DWORD PTR [ebx+148], eax
	mov	eax, DWORD PTR _var3$4$[ebp]
	and	edx, ecx
	xor	eax, DWORD PTR _var0$7$[ebp]
	not	edx
	mov	ebx, DWORD PTR _var13$4$[ebp]
	mov	ecx, DWORD PTR _var3$5$[ebp]
	xor	ebx, eax
	or	ebx, ecx
	not	ecx
	and	ebx, edx
	mov	edx, DWORD PTR _var6$7$[ebp]
	or	edx, eax
	mov	eax, DWORD PTR _var9$5$[ebp]
	and	eax, DWORD PTR _var3$4$[ebp]
	and	esi, eax
	mov	DWORD PTR _var6$7$[ebp], edx
	not	edx
	mov	DWORD PTR _var9$5$[ebp], eax
	and	edx, DWORD PTR _var14$3$[ebp]
	mov	eax, edi
	or	eax, DWORD PTR _var9$5$[ebp]
	xor	edx, esi
	and	ecx, edx
	mov	esi, DWORD PTR _var6$7$[ebp]
	not	ecx
	or	edx, DWORD PTR _var4$4$[ebp]
	and	ecx, eax
	xor	esi, edi
	mov	edi, DWORD PTR _var10$5$[ebp]
	mov	eax, ebx
	and	eax, DWORD PTR _var4$4$[ebp]
	not	esi
	xor	ebx, DWORD PTR _var0$7$[ebp]
	xor	ecx, eax
	xor	ecx, DWORD PTR _var0$7$[ebp]
	or	ebx, esi
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ebx, edx

; 1605 : 	s4(y(11, 18), y(12, 19), y(13, 20), y(14, 21), y(15, 22), y(16, 23), z(57), z(51), z(41), z(32));

	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [eax+188], ecx
	mov	ecx, DWORD PTR _var13$4$[ebp]
	mov	eax, DWORD PTR _var3$5$[ebp]
	not	ecx
	or	eax, DWORD PTR _var1$4$[ebp]
	and	ecx, edi
	mov	DWORD PTR _var3$5$[ebp], eax
	not	ecx
	and	ecx, DWORD PTR _var4$4$[ebp]
	not	eax
	and	eax, edi
	xor	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ebx, DWORD PTR [eax+244]
	xor	ebx, DWORD PTR _var14$3$[ebp]
	xor	ecx, DWORD PTR [eax+220]
	xor	ebx, edi
	xor	ebx, DWORD PTR _var3$5$[ebp]
	xor	ecx, esi
	mov	DWORD PTR [eax+244], ebx
	mov	ebx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR [eax+220], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR [edx+ebx*4+76]
	xor	edi, DWORD PTR [eax+48]
	mov	eax, DWORD PTR [edx+ebx*4+80]
	mov	esi, DWORD PTR [edx+ebx*4+84]
	xor	esi, DWORD PTR [ecx+56]
	xor	eax, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR [edx+ebx*4+88]
	mov	edx, DWORD PTR [edx+ebx*4+92]
	mov	DWORD PTR _var1$5$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var2$8$[ebp], esi
	xor	edx, DWORD PTR [edi+64]
	xor	ecx, DWORD PTR [edi+60]
	mov	DWORD PTR _var5$9$[ebp], edx
	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	DWORD PTR _var4$5$[ebp], ecx
	mov	ebx, DWORD PTR [edx+ebx*4+72]
	mov	edx, edi
	xor	ebx, DWORD PTR [edx+44]
	mov	edi, DWORD PTR _var1$5$[ebp]
	xor	ebx, eax
	or	esi, edi
	mov	edx, ecx
	xor	edx, eax
	xor	esi, ecx
	not	edi
	not	esi
	and	edi, edx
	and	esi, edx
	mov	ecx, edi
	mov	DWORD PTR _var3$7$[ebp], edi
	xor	ecx, DWORD PTR _var2$8$[ebp]
	mov	eax, esi
	not	eax
	mov	edi, ecx
	or	edi, ebx
	and	edi, eax
	mov	eax, edi
	xor	eax, DWORD PTR _var1$5$[ebp]
	mov	DWORD PTR _var9$6$[ebp], eax
	and	eax, ecx
	mov	DWORD PTR _var11$5$[ebp], eax
	not	eax
	and	eax, edx
	mov	DWORD PTR _var0$11$[ebp], eax
	mov	eax, DWORD PTR _var9$6$[ebp]
	mov	edx, DWORD PTR _var0$11$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _var2$8$[ebp]
	not	edx
	xor	ebx, DWORD PTR _var1$5$[ebp]
	and	edx, eax
	xor	edx, esi
	not	ebx
	mov	esi, DWORD PTR _var3$7$[ebp]
	mov	ecx, ebx
	or	esi, DWORD PTR _var4$5$[ebp]
	xor	esi, eax
	mov	eax, edx
	not	eax
	and	ecx, esi
	and	eax, DWORD PTR _var5$9$[ebp]
	xor	ecx, edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [edi+228]
	xor	eax, ecx
	not	ecx
	mov	DWORD PTR [edi+228], eax
	mov	eax, DWORD PTR _var5$9$[ebp]
	not	eax
	and	eax, edx
	xor	edx, ecx
	xor	eax, DWORD PTR [edi+204]
	and	edx, ebx
	or	edx, DWORD PTR _var11$5$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _var9$6$[ebp]
	xor	edx, esi

; 1606 : 	s5(x(24),     x(25),     x(26),     x(27),     x(28),     x(29),     z(39), z(45), z(56), z(34));

	mov	ebx, DWORD PTR _expansionFunction$1$[ebp]
	mov	esi, edi
	mov	DWORD PTR [edi+204], eax
	mov	eax, ecx
	or	eax, DWORD PTR _var5$9$[ebp]
	and	ecx, DWORD PTR _var5$9$[ebp]
	xor	eax, DWORD PTR [esi+164]
	xor	ecx, DWORD PTR [esi+128]
	xor	eax, edx
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	ecx, edx
	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR [esi+128], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR [esi+164], eax
	movzx	eax, BYTE PTR [ebx+24]
	mov	esi, DWORD PTR [esi+eax*4]
	movzx	eax, BYTE PTR [ebx+25]
	xor	esi, DWORD PTR [edi+edx*4+96]
	mov	DWORD PTR _var0$12$[ebp], esi
	mov	eax, DWORD PTR [ecx+eax*4]
	xor	eax, DWORD PTR [edi+edx*4+100]
	mov	DWORD PTR _var1$7$[ebp], eax
	movzx	eax, BYTE PTR [ebx+26]
	mov	ecx, DWORD PTR [ecx+eax*4]
	xor	ecx, DWORD PTR [edi+edx*4+104]
	movzx	eax, BYTE PTR [ebx+27]
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, DWORD PTR [eax+edx*4+108]
	movzx	eax, BYTE PTR [ebx+28]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var3$8$[ebp], edi
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+112]
	movzx	eax, BYTE PTR [ebx+29]
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$6$[ebp], edx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	eax, DWORD PTR [edi+ebx*4+116]
	mov	ebx, ecx
	mov	edi, DWORD PTR _var3$8$[ebp]
	or	ebx, esi
	mov	DWORD PTR _var9$9$[ebp], eax
	not	eax
	and	eax, ebx
	mov	DWORD PTR _var6$9$[ebp], ebx
	mov	ebx, eax
	xor	ebx, esi
	mov	esi, ebx
	mov	DWORD PTR _var8$9$[ebp], ebx
	xor	esi, ecx
	mov	ebx, esi
	or	esi, DWORD PTR _var0$12$[ebp]
	or	ebx, edi
	mov	DWORD PTR _var11$6$[ebp], esi
	not	edi
	mov	DWORD PTR _var10$7$[ebp], ebx
	and	edi, eax
	mov	eax, DWORD PTR _var9$9$[ebp]
	xor	edi, ecx
	mov	DWORD PTR _var7$8$[ebp], edi
	and	edi, edx
	xor	edi, esi
	and	esi, DWORD PTR _var3$8$[ebp]
	xor	edi, DWORD PTR _var3$8$[ebp]
	xor	eax, edi
	mov	DWORD PTR _var9$9$[ebp], eax
	or	eax, DWORD PTR _var8$9$[ebp]
	mov	ebx, eax
	and	ebx, edx
	mov	edx, DWORD PTR _var0$12$[ebp]
	xor	esi, ebx
	not	edx
	xor	esi, DWORD PTR _var8$9$[ebp]
	and	edx, eax
	mov	eax, DWORD PTR _var1$7$[ebp]
	mov	ecx, edx
	xor	ecx, DWORD PTR _var7$8$[ebp]
	not	eax
	mov	DWORD PTR _var15$2$[ebp], esi
	not	ecx
	mov	esi, DWORD PTR _var10$7$[ebp]
	xor	esi, DWORD PTR _var4$6$[ebp]
	and	ecx, esi
	not	ecx
	and	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR [eax+224]
	xor	ecx, edi
	mov	edi, esi
	mov	DWORD PTR [eax+224], ecx
	xor	edi, edx
	or	edi, DWORD PTR _var15$2$[ebp]
	mov	eax, ebx
	mov	edx, DWORD PTR _var7$8$[ebp]
	not	eax
	and	eax, edx
	not	eax
	and	edi, eax
	mov	eax, DWORD PTR _var9$9$[ebp]
	and	eax, edi
	xor	eax, esi
	mov	DWORD PTR _var9$9$[ebp], eax
	mov	eax, DWORD PTR _var11$6$[ebp]
	mov	esi, DWORD PTR _var9$9$[ebp]
	and	eax, edx
	or	eax, esi
	mov	ecx, esi
	and	ecx, DWORD PTR _var3$8$[ebp]
	xor	eax, ebx
	and	eax, DWORD PTR _var1$7$[ebp]
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR _var6$9$[ebp]
	xor	ecx, edi
	not	edi
	xor	ecx, DWORD PTR _var0$12$[ebp]
	xor	eax, DWORD PTR [ebx+136]
	xor	eax, DWORD PTR _var15$2$[ebp]
	mov	DWORD PTR [ebx+136], eax
	mov	ebx, DWORD PTR _var10$7$[ebp]
	and	edi, ebx
	or	edi, DWORD PTR _var1$7$[ebp]
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	edi, DWORD PTR [eax+156]
	xor	edi, ecx
	not	ecx
	mov	DWORD PTR [eax+156], edi
	mov	eax, ebx
	and	ebx, DWORD PTR _var1$7$[ebp]
	xor	eax, edx

; 1607 : 	s6(x(30),     x(31),     x(32),     x(33),     x(34),     x(35),     z(35), z(60), z(42), z(50));

	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	and	eax, ecx
	mov	ecx, DWORD PTR _expansionFunction$1$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, esi
	xor	eax, DWORD PTR _var8$9$[ebp]
	mov	esi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [ebx+180], eax
	movzx	eax, BYTE PTR [ecx+30]
	mov	edi, DWORD PTR [ebx+eax*4]
	xor	edi, DWORD PTR [esi+edx*4+120]
	movzx	eax, BYTE PTR [ecx+31]
	mov	DWORD PTR _var0$13$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	ebx, DWORD PTR [ebx+eax*4]
	xor	ebx, DWORD PTR [esi+edx*4+124]
	movzx	eax, BYTE PTR [ecx+32]
	mov	DWORD PTR _var1$8$[ebp], ebx
	mov	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	esi, DWORD PTR [eax+edx*4+128]
	movzx	eax, BYTE PTR [ecx+33]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, DWORD PTR [edi+edx*4+132]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var3$10$[ebp], eax
	movzx	eax, BYTE PTR [ecx+34]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+136]
	movzx	eax, BYTE PTR [ecx+35]
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$8$[ebp], edx
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edi+eax*4+140]
	mov	eax, ecx
	mov	DWORD PTR _var5$12$[ebp], ecx
	or	eax, ebx
	and	eax, DWORD PTR _var0$13$[ebp]
	mov	edi, eax
	mov	DWORD PTR _var8$10$[ebp], eax
	xor	edi, edx
	xor	edi, ebx
	mov	eax, edi
	mov	DWORD PTR _var2$13$[ebp], edi
	xor	eax, ecx
	mov	ecx, eax
	and	eax, DWORD PTR _var0$13$[ebp]
	mov	DWORD PTR _var10$8$[ebp], eax
	not	ecx
	xor	eax, ebx
	and	ecx, edx
	mov	edx, esi
	mov	DWORD PTR _var9$10$[ebp], ecx
	xor	edx, DWORD PTR _var0$13$[ebp]
	or	ecx, eax
	mov	ebx, edx
	mov	DWORD PTR _var9$11$[ebp], edx
	or	ebx, eax
	mov	edx, DWORD PTR _var5$12$[ebp]
	mov	DWORD PTR _var4$9$[ebp], ebx
	mov	eax, ecx
	xor	ebx, edi
	not	edx
	mov	edi, ebx
	and	edi, esi
	and	edx, edi
	mov	DWORD PTR _var14$5$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, edx
	mov	DWORD PTR _var6$12$[ebp], eax
	not	edx
	and	eax, DWORD PTR _var3$10$[ebp]
	xor	eax, DWORD PTR [edi+200]
	xor	eax, ebx
	or	ebx, DWORD PTR _var0$13$[ebp]
	mov	DWORD PTR [edi+200], eax
	and	ebx, ecx
	mov	eax, DWORD PTR _var4$9$[ebp]
	xor	eax, DWORD PTR _var1$8$[ebp]
	mov	ecx, DWORD PTR _var3$10$[ebp]
	not	eax
	mov	edi, eax
	mov	DWORD PTR _var4$9$[ebp], eax
	and	edi, DWORD PTR _var5$12$[ebp]
	mov	eax, DWORD PTR _var9$10$[ebp]
	xor	edi, esi
	or	eax, ecx
	mov	esi, DWORD PTR _var14$5$[ebp]
	xor	ebx, edi
	not	ecx
	and	edx, ebx
	mov	DWORD PTR _var3$10$[ebp], ecx
	xor	edx, eax
	not	esi
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	and	esi, DWORD PTR _var4$8$[ebp]
	or	esi, edi
	xor	edi, DWORD PTR _var0$13$[ebp]
	xor	DWORD PTR [eax+168], edx
	mov	eax, DWORD PTR _var2$13$[ebp]
	mov	edx, DWORD PTR _var9$11$[ebp]
	xor	eax, ebx
	or	edx, DWORD PTR _var1$8$[ebp]
	not	eax
	and	eax, DWORD PTR _var4$8$[ebp]
	mov	ebx, DWORD PTR _var4$9$[ebp]
	xor	ebx, edx
	mov	ecx, ebx
	xor	ecx, eax
	mov	eax, esi
	and	ecx, DWORD PTR _var3$10$[ebp]
	or	eax, DWORD PTR _var8$10$[ebp]
	xor	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR [eax+240]
	xor	ecx, edx
	mov	edx, eax
	xor	ecx, DWORD PTR _var6$12$[ebp]
	mov	eax, DWORD PTR _var10$8$[ebp]
	xor	eax, DWORD PTR _var5$12$[ebp]
	mov	DWORD PTR [edx+240], ecx
	and	eax, edi
	mov	ecx, DWORD PTR _var3$10$[ebp]
	and	ecx, esi
	xor	eax, ecx
	xor	eax, DWORD PTR _var14$5$[ebp]

; 1608 : 	s7(y(23, 36), y(24, 37), y(25, 38),	y(26, 39), y(27, 40), y(28, 41), z(63), z(43), z(53), z(38));

	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, ebx
	xor	DWORD PTR [edx+140], eax
	mov	esi, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	eax, DWORD PTR [edi+esi*4+144]
	xor	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [edi+esi*4+148]
	xor	ecx, DWORD PTR [edx+96]
	mov	ebx, DWORD PTR [edi+esi*4+152]
	xor	ebx, DWORD PTR [edx+100]
	mov	edx, DWORD PTR [edi+esi*4+156]
	mov	DWORD PTR _var0$14$[ebp], eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var1$9$[ebp], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	edx, DWORD PTR [eax+104]
	mov	eax, DWORD PTR [edi+esi*4+160]
	xor	eax, DWORD PTR [ecx+108]
	mov	esi, DWORD PTR [edi+esi*4+164]
	mov	edi, ecx
	mov	DWORD PTR _var4$10$[ebp], eax
	not	eax
	mov	DWORD PTR tv2101[ebp], eax
	mov	DWORD PTR _var6$14$[ebp], edx
	xor	esi, DWORD PTR [edi+112]
	mov	edi, edx
	xor	edi, DWORD PTR _var0$14$[ebp]
	mov	DWORD PTR _var5$13$[ebp], esi
	mov	esi, eax
	and	esi, edx
	mov	edx, edi
	xor	edx, DWORD PTR _var4$10$[ebp]
	mov	eax, esi
	xor	eax, DWORD PTR _var1$9$[ebp]
	mov	ecx, eax
	mov	DWORD PTR _var2$16$[ebp], edx
	or	ecx, ebx
	xor	ecx, edx
	xor	edx, ebx
	mov	DWORD PTR _var8$11$[ebp], edx
	not	edx
	and	edx, DWORD PTR _var0$14$[ebp]
	xor	edx, esi
	mov	DWORD PTR _var13$7$[ebp], edx
	and	edx, eax
	mov	DWORD PTR _var12$8$[ebp], edx
	xor	edx, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	eax, edx
	not	eax
	and	eax, DWORD PTR _var5$13$[ebp]
	xor	eax, DWORD PTR [esi+152]
	xor	eax, ecx
	mov	DWORD PTR [esi+152], eax
	mov	eax, DWORD PTR _var6$14$[ebp]
	or	eax, DWORD PTR _var1$9$[ebp]
	mov	esi, DWORD PTR _var8$11$[ebp]
	mov	ecx, eax
	and	ecx, ebx
	mov	DWORD PTR _var6$14$[ebp], eax
	mov	ebx, DWORD PTR _var13$7$[ebp]
	xor	esi, edx
	mov	eax, ecx
	mov	edx, esi
	or	eax, DWORD PTR _var0$14$[ebp]
	not	edx
	and	edx, DWORD PTR _var13$7$[ebp]
	not	ecx
	xor	esi, DWORD PTR _var1$9$[ebp]
	and	ecx, edi
	mov	edi, DWORD PTR _var2$16$[ebp]
	not	ebx
	and	ebx, eax
	mov	DWORD PTR _var7$12$[ebp], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	and	edi, eax
	not	edx
	mov	eax, ebx
	and	edx, DWORD PTR _var6$14$[ebp]
	or	esi, edi
	or	eax, DWORD PTR _var5$13$[ebp]
	xor	eax, DWORD PTR [ecx+252]
	and	edi, DWORD PTR _var8$11$[ebp]
	xor	eax, edx
	xor	eax, esi
	xor	edx, DWORD PTR _var7$12$[ebp]
	mov	DWORD PTR [ecx+252], eax
	mov	eax, edi
	xor	eax, DWORD PTR _var1$9$[ebp]
	mov	ecx, DWORD PTR _var7$12$[ebp]
	and	edx, DWORD PTR _var5$13$[ebp]
	not	ecx
	and	eax, ecx
	mov	DWORD PTR _var2$16$[ebp], edi
	xor	eax, DWORD PTR _var13$7$[ebp]
	and	ecx, DWORD PTR _var4$10$[ebp]
	xor	esi, eax
	and	esi, DWORD PTR _var5$13$[ebp]
	xor	ecx, ebx
	or	ecx, DWORD PTR _var0$14$[ebp]
	not	eax
	mov	edi, DWORD PTR _var12$8$[ebp]
	xor	ecx, edx
	or	edi, DWORD PTR _var2$16$[ebp]
	xor	ecx, eax
	and	edi, DWORD PTR tv2101[ebp]

; 1609 : 	s8(y(27, 42), y(28, 43), y(29, 44), y(30, 45), y(31, 46), y( 0, 47), z(36), z(58), z(46), z(52));

	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	ebx, esi
	xor	DWORD PTR [ebx+172], ecx
	xor	edi, DWORD PTR [esi+212]
	mov	ecx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edi, DWORD PTR _var8$11$[ebp]
	xor	edi, DWORD PTR _var6$14$[ebp]
	mov	DWORD PTR [esi+212], edi
	mov	eax, DWORD PTR [edx+ecx*4+168]
	xor	eax, DWORD PTR [ebx+108]
	mov	esi, DWORD PTR [edx+ecx*4+172]
	mov	edi, DWORD PTR [edx+ecx*4+176]
	xor	esi, DWORD PTR [ebx+112]
	xor	edi, DWORD PTR [ebx+116]
	mov	DWORD PTR _var0$15$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*4+180]
	xor	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR _var3$13$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*4+184]
	mov	ecx, DWORD PTR [edx+ecx*4+188]
	xor	eax, DWORD PTR [ebx+124]
	xor	ecx, DWORD PTR [ebx]
	mov	ebx, esi
	mov	DWORD PTR _var5$14$[ebp], ecx
	not	ebx
	mov	ecx, edi
	mov	DWORD PTR _var4$11$[ebp], eax
	not	ecx
	mov	DWORD PTR _var1$10$[ebp], esi
	mov	edx, ecx
	mov	DWORD PTR _var1$11$[ebp], ecx
	and	edx, eax
	and	ebx, edi
	xor	edx, DWORD PTR _var3$13$[ebp]
	mov	eax, ebx
	not	eax
	mov	ecx, edx
	and	ecx, DWORD PTR _var0$15$[ebp]
	not	edx
	and	eax, ecx
	mov	DWORD PTR _var9$15$[ebp], eax
	mov	eax, edx
	and	eax, esi
	mov	esi, eax
	mov	DWORD PTR _var7$15$[ebp], eax
	mov	eax, DWORD PTR _var1$11$[ebp]
	and	eax, DWORD PTR _var1$10$[ebp]
	or	esi, DWORD PTR _var0$15$[ebp]
	xor	eax, DWORD PTR _var4$11$[ebp]
	mov	DWORD PTR _var1$11$[ebp], eax
	and	eax, esi
	mov	DWORD PTR _var6$17$[ebp], esi
	mov	esi, eax
	or	esi, ecx
	mov	ecx, DWORD PTR _var6$17$[ebp]
	not	ecx
	and	ecx, edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	edi, edx
	mov	edx, DWORD PTR _var7$15$[ebp]
	xor	edi, eax
	mov	eax, DWORD PTR _var9$15$[ebp]
	or	eax, DWORD PTR _var5$14$[ebp]
	xor	ebx, edi
	xor	edi, DWORD PTR _var1$10$[ebp]
	xor	eax, ebx
	xor	DWORD PTR [ecx+232], eax
	mov	eax, esi
	xor	ebx, DWORD PTR _var0$15$[ebp]
	and	esi, DWORD PTR _var5$14$[ebp]
	mov	ecx, ebx
	and	ecx, DWORD PTR _var4$11$[ebp]
	xor	ecx, edi
	or	edi, DWORD PTR _var3$13$[ebp]
	xor	eax, ecx
	xor	edx, ecx
	or	eax, DWORD PTR _var1$10$[ebp]
	mov	ecx, DWORD PTR _var1$11$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _var4$11$[ebp]
	xor	ecx, edx
	xor	ebx, eax
	xor	edi, ecx
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	esi, ebx
	xor	DWORD PTR [eax+184], esi
	mov	eax, edi
	xor	eax, DWORD PTR _var0$15$[ebp]
	and	eax, DWORD PTR _var5$14$[ebp]
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [esi+208]
	xor	eax, edx
	mov	DWORD PTR [esi+208], eax
	mov	eax, DWORD PTR _var3$13$[ebp]
	not	eax
	and	eax, ebx
	and	eax, ecx
	mov	ecx, esi
	xor	eax, DWORD PTR _var9$15$[ebp]
	xor	eax, edi
	or	eax, DWORD PTR _var5$14$[ebp]
	xor	eax, DWORD PTR [ecx+144]
	pop	edi
	xor	eax, edx
	pop	esi
	mov	DWORD PTR [ecx+144], eax
	pop	ebx

; 1610 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CPU_DES_SBoxes1@@YAXPAEPAI1H@Z ENDP			; CPU_DES_SBoxes1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?CPU_DES_SBoxes2@@YAXPAEPAI1H@Z
_TEXT	SEGMENT
_var12$8$ = -56						; size = 4
_var10$8$ = -56						; size = 4
_var7$15$ = -56						; size = 4
_var14$1$ = -52						; size = 4
_var9$10$ = -52						; size = 4
_var7$3$ = -52						; size = 4
_var4$6$ = -52						; size = 4
_var0$11$ = -52						; size = 4
tv2104 = -52						; size = 4
_var13$4$ = -48						; size = 4
_var9$15$ = -48						; size = 4
_var7$8$ = -48						; size = 4
_var6$2$ = -48						; size = 4
_var4$10$ = -48						; size = 4
_var2$8$ = -48						; size = 4
_var1$8$ = -48						; size = 4
tv2101 = -48						; size = 4
_var12$1$ = -44						; size = 4
_var10$7$ = -44						; size = 4
_var9$6$ = -44						; size = 4
_var7$12$ = -44						; size = 4
_var4$8$ = -44						; size = 4
_var2$3$ = -44						; size = 4
_var1$4$ = -44						; size = 4
_var13$7$ = -40						; size = 4
_var6$17$ = -40						; size = 4
_var4$9$ = -40						; size = 4
_expansionFunction$1$ = -40				; size = 4
_var14$3$ = -36						; size = 4
_var5$12$ = -36						; size = 4
_var4$2$ = -36						; size = 4
_var3$8$ = -36						; size = 4
_var2$16$ = -36						; size = 4
_var2$2$ = -36						; size = 4
_var1$10$ = -36						; size = 4
_var1$5$ = -36						; size = 4
_var14$5$ = -32						; size = 4
_var8$11$ = -32						; size = 4
_var5$9$ = -32						; size = 4
_var4$11$ = -32						; size = 4
_var4$1$ = -32						; size = 4
_var3$4$ = -32						; size = 4
_var0$12$ = -32						; size = 4
_var0$6$ = -32						; size = 4
_var13$1$ = -28						; size = 4
_var9$11$ = -28						; size = 4
_var8$9$ = -28						; size = 4
_var6$7$ = -28						; size = 4
_var3$7$ = -28						; size = 4
_var3$3$ = -28						; size = 4
_var1$11$ = -28						; size = 4
_var12$5$ = -24						; size = 4
_var10$5$ = -24						; size = 4
_var4$5$ = -24						; size = 4
_var3$13$ = -24						; size = 4
_var2$13$ = -24						; size = 4
_var1$3$ = -24						; size = 4
_var0$1$ = -24						; size = 4
_var11$5$ = -20						; size = 4
_var8$10$ = -20						; size = 4
_var5$14$ = -20						; size = 4
_var4$4$ = -20						; size = 4
_var1$9$ = -20						; size = 4
_var1$7$ = -20						; size = 4
_var1$1$ = -20						; size = 4
_var0$4$ = -20						; size = 4
_var11$6$ = -16						; size = 4
_var10$4$ = -16						; size = 4
_var7$1$ = -16						; size = 4
_var6$14$ = -16						; size = 4
_var6$12$ = -16						; size = 4
_var3$5$ = -16						; size = 4
_var9$9$ = -12						; size = 4
_var9$5$ = -12						; size = 4
_var9$2$ = -12						; size = 4
_var8$4$ = -12						; size = 4
_var0$14$ = -12						; size = 4
_var0$13$ = -12						; size = 4
_var6$9$ = -8						; size = 4
_var5$13$ = -8						; size = 4
_var4$3$ = -8						; size = 4
_var3$10$ = -8						; size = 4
_var0$7$ = -8						; size = 4
_var0$2$ = -8						; size = 4
_expandedKeySchedule$1$ = -4				; size = 4
_dataBlocks$ = 8					; size = 4
_var0$15$ = 12						; size = 4
_keyScheduleIndexBase$ = 12				; size = 4
?CPU_DES_SBoxes2@@YAXPAEPAI1H@Z PROC			; CPU_DES_SBoxes2, COMDAT
; _expansionFunction$ = ecx
; _expandedKeySchedule$ = edx

; 1613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	mov	esi, edx
	mov	edx, ecx

; 1614 : 	vtype var0;
; 1615 : 	vtype var1;
; 1616 : 	vtype var2;
; 1617 : 	vtype var3; 
; 1618 : 	vtype var4; 
; 1619 : 	vtype var5; 
; 1620 : 	vtype var6; 
; 1621 : 	vtype var7; 
; 1622 : 	vtype var8; 
; 1623 : 	vtype var9; 
; 1624 : 	vtype var10; 
; 1625 : 	vtype var11; 
; 1626 : 	vtype var12; 
; 1627 : 	vtype var13; 
; 1628 : 	vtype var14; 
; 1629 : 	vtype var15; 
; 1630 : 	vtype var16; 
; 1631 : 	vtype var17; 
; 1632 : 	vtype var18; 
; 1633 : 
; 1634 : 	s1(x(48),     x(49),     x(50),     x(51),     x(52),     x(53),     z( 8), z(16), z(22), z(30));

	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	push	edi
	mov	DWORD PTR _expandedKeySchedule$1$[ebp], esi
	movzx	eax, BYTE PTR [edx+48]
	mov	DWORD PTR _expansionFunction$1$[ebp], edx
	mov	edi, DWORD PTR [ecx+eax*4]
	movzx	eax, BYTE PTR [edx+49]
	mov	ecx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edi, DWORD PTR [esi+ecx*4+192]
	mov	DWORD PTR _var0$1$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	eax, DWORD PTR [edi+eax*4]
	xor	eax, DWORD PTR [esi+ecx*4+196]
	mov	DWORD PTR _var1$1$[ebp], eax
	movzx	eax, BYTE PTR [edx+50]
	mov	ebx, DWORD PTR [edi+eax*4]
	movzx	eax, BYTE PTR [edx+51]
	xor	ebx, DWORD PTR [esi+ecx*4+200]
	mov	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	esi, DWORD PTR [eax+ecx*4+204]
	movzx	eax, BYTE PTR [edx+52]
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edi+eax*4+208]
	movzx	eax, BYTE PTR [edx+53]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$1$[ebp], ecx
	not	ecx
	and	ecx, DWORD PTR _var0$1$[ebp]
	mov	DWORD PTR _var6$2$[ebp], ecx
	xor	ecx, esi
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR _var7$1$[ebp], ecx
	mov	ecx, ebx
	xor	ecx, DWORD PTR _var0$1$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+212]
	mov	eax, ecx
	mov	DWORD PTR _var9$2$[ebp], edx
	not	ecx
	or	edx, ebx
	and	eax, edx
	mov	DWORD PTR _var2$2$[ebp], edx
	mov	edx, DWORD PTR _var7$1$[ebp]
	mov	edi, eax
	or	eax, DWORD PTR _var9$2$[ebp]
	not	edx
	xor	edi, esi
	and	edx, edi
	not	edi
	mov	DWORD PTR _var12$1$[ebp], edx
	mov	edx, DWORD PTR _var9$2$[ebp]
	xor	edx, DWORD PTR _var4$1$[ebp]
	and	edi, DWORD PTR _var4$1$[ebp]
	mov	DWORD PTR _var0$2$[ebp], edx
	xor	DWORD PTR _var0$2$[ebp], ebx
	not	DWORD PTR _var0$2$[ebp]
	mov	DWORD PTR _var13$1$[ebp], edx
	mov	edx, DWORD PTR _var7$1$[ebp]
	and	DWORD PTR _var0$2$[ebp], edx
	xor	DWORD PTR _var0$2$[ebp], eax
	mov	edx, DWORD PTR _var12$1$[ebp]
	and	ecx, DWORD PTR _var13$1$[ebp]
	not	edx
	and	edx, DWORD PTR _var0$2$[ebp]
	mov	DWORD PTR _var14$1$[ebp], edx
	mov	edx, DWORD PTR _var9$2$[ebp]
	or	edx, DWORD PTR _var0$1$[ebp]
	mov	DWORD PTR _var9$2$[ebp], edx
	mov	eax, DWORD PTR _var9$2$[ebp]
	or	edx, DWORD PTR _var0$2$[ebp]
	not	eax
	and	eax, esi
	xor	eax, edi
	or	eax, ecx
	mov	esi, DWORD PTR _var6$2$[ebp]
	mov	ecx, edi
	mov	DWORD PTR _var9$2$[ebp], eax
	not	esi
	mov	eax, DWORD PTR _var7$1$[ebp]
	and	esi, ebx
	xor	eax, edx
	mov	ebx, DWORD PTR _var0$2$[ebp]
	and	ebx, DWORD PTR _var2$2$[ebp]
	not	esi
	and	esi, eax
	xor	ecx, edx
	mov	eax, esi
	not	eax
	xor	ebx, eax
	mov	eax, DWORD PTR _var1$1$[ebp]
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR [eax+88]
	xor	ecx, ebx
	mov	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR _var13$1$[ebp]
	mov	eax, DWORD PTR _var12$1$[ebp]
	xor	ecx, esi
	or	eax, DWORD PTR _var1$1$[ebp]
	or	ecx, edi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR _var2$2$[ebp]
	xor	ecx, edi
	xor	ecx, DWORD PTR _var0$1$[ebp]
	xor	edi, edx
	mov	edx, DWORD PTR _var13$1$[ebp]
	xor	ebx, ecx
	xor	eax, DWORD PTR [esi+32]
	or	edx, ebx
	or	edi, DWORD PTR _var9$2$[ebp]
	xor	eax, ebx
	mov	DWORD PTR [esi+32], eax
	xor	edi, ecx
	mov	esi, DWORD PTR _var14$1$[ebp]
	mov	eax, esi
	or	eax, DWORD PTR _var1$1$[ebp]
	and	esi, ecx
	xor	eax, edx

; 1635 : 	s2(x(54),     x(55),     x(56),     x(57),     x(58),     x(59),     z(12), z(27), z( 1), z(17));

	mov	ecx, DWORD PTR _expansionFunction$1$[ebp]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [edx+64]
	xor	eax, edi
	not	edi
	mov	DWORD PTR [edx+64], eax
	mov	eax, DWORD PTR _var7$1$[ebp]
	or	eax, DWORD PTR _var4$1$[ebp]
	and	eax, edi
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	or	eax, DWORD PTR _var1$1$[ebp]
	xor	eax, DWORD PTR [edx+120]
	xor	eax, DWORD PTR _var9$2$[ebp]
	mov	DWORD PTR [edx+120], eax
	movzx	eax, BYTE PTR [ecx+54]
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	movzx	eax, BYTE PTR [ecx+55]
	xor	ebx, DWORD PTR [edi+edx*4+216]
	mov	esi, DWORD PTR [esi+eax*4]
	xor	esi, DWORD PTR [edi+edx*4+220]
	movzx	eax, BYTE PTR [ecx+56]
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var0$4$[ebp], ebx
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, DWORD PTR [eax+edx*4+224]
	movzx	eax, BYTE PTR [ecx+57]
	mov	DWORD PTR _var2$3$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, DWORD PTR [edi+edx*4+228]
	mov	DWORD PTR _var3$3$[ebp], eax
	movzx	eax, BYTE PTR [ecx+58]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+232]
	movzx	eax, BYTE PTR [ecx+59]
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$2$[ebp], edx
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edi+eax*4+236]
	mov	eax, edx
	xor	eax, esi
	mov	edi, DWORD PTR _var2$3$[ebp]
	mov	DWORD PTR _var8$4$[ebp], eax
	mov	eax, ecx
	not	eax
	mov	DWORD PTR _var4$3$[ebp], eax
	and	eax, ebx
	not	eax
	and	eax, edx
	mov	edx, eax
	or	edx, esi
	mov	DWORD PTR _var0$6$[ebp], edx
	mov	edx, DWORD PTR _var8$4$[ebp]
	and	DWORD PTR _var4$3$[ebp], edx
	and	edx, ebx
	mov	ebx, DWORD PTR _var4$3$[ebp]
	xor	DWORD PTR _var4$3$[ebp], eax
	not	ebx
	xor	edx, DWORD PTR _var4$2$[ebp]
	mov	eax, DWORD PTR _var4$3$[ebp]
	and	eax, DWORD PTR _var0$6$[ebp]
	mov	DWORD PTR tv2101[ebp], ebx
	and	ebx, edx
	mov	DWORD PTR _var4$3$[ebp], eax
	mov	DWORD PTR _var10$4$[ebp], ebx
	mov	ebx, ecx
	and	ebx, edi
	mov	DWORD PTR _var7$3$[ebp], ebx
	not	ebx
	mov	eax, ebx
	and	eax, DWORD PTR _var4$3$[ebp]
	and	DWORD PTR _var4$3$[ebp], edi
	not	eax
	mov	edi, DWORD PTR _var0$4$[ebp]
	and	eax, DWORD PTR _var3$3$[ebp]
	not	edi
	xor	edi, DWORD PTR _var4$3$[ebp]
	mov	DWORD PTR _var0$4$[ebp], edi
	mov	edi, DWORD PTR _var8$4$[ebp]
	xor	edi, ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	and	ebx, edi
	mov	DWORD PTR _var8$4$[ebp], edi
	mov	edi, ebx
	not	ebx
	xor	edi, DWORD PTR _var0$4$[ebp]
	and	ebx, esi
	xor	eax, DWORD PTR [ecx+108]
	mov	esi, ebx
	xor	eax, edi
	xor	esi, edx
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	not	esi
	mov	DWORD PTR [ecx+108], eax
	mov	eax, DWORD PTR _var3$3$[ebp]
	mov	ecx, DWORD PTR _var8$4$[ebp]
	not	eax
	and	eax, DWORD PTR _var0$6$[ebp]
	xor	eax, DWORD PTR [edx+48]
	xor	ecx, DWORD PTR _var2$3$[ebp]
	mov	DWORD PTR _var1$3$[ebp], esi
	and	esi, DWORD PTR _var0$4$[ebp]
	xor	esi, ecx
	xor	eax, esi
	mov	DWORD PTR [edx+48], eax
	mov	eax, DWORD PTR _var4$3$[ebp]
	xor	eax, ebx
	mov	edx, eax
	or	edx, ecx
	mov	ebx, DWORD PTR _var0$6$[ebp]
	xor	eax, esi
	mov	ecx, DWORD PTR _var7$3$[ebp]
	xor	ebx, edi
	or	ecx, ebx
	and	eax, ecx
	xor	eax, DWORD PTR _var4$2$[ebp]
	and	eax, DWORD PTR tv2101[ebp]
	xor	eax, edi
	mov	DWORD PTR _var4$3$[ebp], eax
	or	eax, DWORD PTR _var3$3$[ebp]
	xor	eax, edx

; 1636 : 	s3(y(39, 60), y(40, 61), y(41, 62), y(42, 63), y(43, 64), y(44, 65), z(23), z(15), z(29), z( 5));

	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _var1$3$[ebp]
	and	eax, DWORD PTR _var4$3$[ebp]
	mov	ecx, DWORD PTR _var10$4$[ebp]
	or	ecx, DWORD PTR _var3$3$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _var8$4$[ebp]
	or	ecx, ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [ebx+68], eax
	mov	edi, DWORD PTR [ecx+edx*4+240]
	xor	edi, DWORD PTR [ebx+156]
	mov	eax, DWORD PTR [ecx+edx*4+244]
	xor	eax, DWORD PTR [ebx+160]
	mov	esi, DWORD PTR [ecx+edx*4+248]
	xor	esi, DWORD PTR [ebx+164]
	mov	ebx, DWORD PTR [ecx+edx*4+252]
	mov	ecx, DWORD PTR [ecx+edx*4+256]
	mov	DWORD PTR _var0$7$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var1$4$[ebp], eax
	mov	DWORD PTR _var3$5$[ebp], esi
	xor	ecx, DWORD PTR [edi+172]
	xor	ebx, DWORD PTR [edi+168]
	mov	DWORD PTR _var4$4$[ebp], ecx
	mov	ecx, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	DWORD PTR _var3$4$[ebp], ebx
	mov	ecx, DWORD PTR [ecx+edx*4+260]
	mov	edx, edi
	mov	edi, DWORD PTR _var0$7$[ebp]
	xor	ecx, DWORD PTR [edx+176]
	mov	edx, ecx
	mov	DWORD PTR _var9$5$[ebp], ecx
	xor	edx, esi
	xor	ecx, ebx
	mov	ebx, DWORD PTR _var9$5$[ebp]
	mov	esi, eax
	not	esi
	not	ebx
	mov	eax, esi
	and	eax, edi
	not	edi
	or	eax, edx
	and	edi, ecx
	mov	DWORD PTR _var6$7$[ebp], edi
	xor	edi, eax
	mov	DWORD PTR _var10$5$[ebp], edi
	mov	edi, edx
	xor	edi, DWORD PTR _var1$4$[ebp]
	and	ebx, edi
	xor	ebx, eax
	mov	eax, DWORD PTR _var10$5$[ebp]
	and	eax, DWORD PTR _var9$5$[ebp]
	or	eax, DWORD PTR _var3$4$[ebp]
	and	eax, DWORD PTR _var0$7$[ebp]
	xor	eax, edi
	mov	DWORD PTR _var13$4$[ebp], ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var14$3$[ebp], eax
	mov	eax, DWORD PTR _var4$4$[ebp]
	not	eax
	and	eax, DWORD PTR _var10$5$[ebp]
	xor	eax, DWORD PTR _var14$3$[ebp]
	xor	DWORD PTR [ebx+20], eax
	mov	eax, DWORD PTR _var3$4$[ebp]
	and	edx, ecx
	xor	eax, DWORD PTR _var0$7$[ebp]
	not	edx
	mov	ebx, DWORD PTR _var13$4$[ebp]
	mov	ecx, DWORD PTR _var3$5$[ebp]
	xor	ebx, eax
	or	ebx, ecx
	not	ecx
	and	ebx, edx
	mov	edx, DWORD PTR _var6$7$[ebp]
	or	edx, eax
	mov	eax, DWORD PTR _var9$5$[ebp]
	and	eax, DWORD PTR _var3$4$[ebp]
	and	esi, eax
	mov	DWORD PTR _var6$7$[ebp], edx
	not	edx
	mov	DWORD PTR _var9$5$[ebp], eax
	and	edx, DWORD PTR _var14$3$[ebp]
	mov	eax, edi
	or	eax, DWORD PTR _var9$5$[ebp]
	xor	edx, esi
	and	ecx, edx
	mov	esi, DWORD PTR _var6$7$[ebp]
	not	ecx
	or	edx, DWORD PTR _var4$4$[ebp]
	and	ecx, eax
	xor	esi, edi
	mov	edi, DWORD PTR _var10$5$[ebp]
	mov	eax, ebx
	and	eax, DWORD PTR _var4$4$[ebp]
	not	esi
	xor	ebx, DWORD PTR _var0$7$[ebp]
	xor	ecx, eax
	xor	ecx, DWORD PTR _var0$7$[ebp]
	or	ebx, esi
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ebx, edx

; 1637 : 	s4(y(43, 66), y(44, 67), y(45, 68), y(46, 69), y(47, 70), y(48, 71), z(25), z(19), z( 9), z( 0));

	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [eax+60], ecx
	mov	ecx, DWORD PTR _var13$4$[ebp]
	mov	eax, DWORD PTR _var3$5$[ebp]
	not	ecx
	or	eax, DWORD PTR _var1$4$[ebp]
	and	ecx, edi
	mov	DWORD PTR _var3$5$[ebp], eax
	not	ecx
	and	ecx, DWORD PTR _var4$4$[ebp]
	not	eax
	and	eax, edi
	xor	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ebx, DWORD PTR [eax+116]
	xor	ebx, DWORD PTR _var14$3$[ebp]
	xor	ecx, DWORD PTR [eax+92]
	xor	ebx, edi
	xor	ebx, DWORD PTR _var3$5$[ebp]
	xor	ecx, esi
	mov	DWORD PTR [eax+116], ebx
	mov	ebx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR [eax+92], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR [edx+ebx*4+268]
	xor	edi, DWORD PTR [eax+176]
	mov	eax, DWORD PTR [edx+ebx*4+272]
	mov	esi, DWORD PTR [edx+ebx*4+276]
	xor	esi, DWORD PTR [ecx+184]
	xor	eax, DWORD PTR [ecx+180]
	mov	ecx, DWORD PTR [edx+ebx*4+280]
	mov	edx, DWORD PTR [edx+ebx*4+284]
	mov	DWORD PTR _var1$5$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var2$8$[ebp], esi
	xor	edx, DWORD PTR [edi+192]
	xor	ecx, DWORD PTR [edi+188]
	mov	DWORD PTR _var5$9$[ebp], edx
	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	DWORD PTR _var4$5$[ebp], ecx
	mov	ebx, DWORD PTR [edx+ebx*4+264]
	mov	edx, edi
	xor	ebx, DWORD PTR [edx+172]
	mov	edi, DWORD PTR _var1$5$[ebp]
	xor	ebx, eax
	or	esi, edi
	mov	edx, ecx
	xor	edx, eax
	xor	esi, ecx
	not	edi
	not	esi
	and	edi, edx
	and	esi, edx
	mov	ecx, edi
	mov	DWORD PTR _var3$7$[ebp], edi
	xor	ecx, DWORD PTR _var2$8$[ebp]
	mov	eax, esi
	not	eax
	mov	edi, ecx
	or	edi, ebx
	and	edi, eax
	mov	eax, edi
	xor	eax, DWORD PTR _var1$5$[ebp]
	mov	DWORD PTR _var9$6$[ebp], eax
	and	eax, ecx
	mov	DWORD PTR _var11$5$[ebp], eax
	not	eax
	and	eax, edx
	mov	DWORD PTR _var0$11$[ebp], eax
	mov	eax, DWORD PTR _var9$6$[ebp]
	mov	edx, DWORD PTR _var0$11$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _var2$8$[ebp]
	not	edx
	xor	ebx, DWORD PTR _var1$5$[ebp]
	and	edx, eax
	xor	edx, esi
	not	ebx
	mov	esi, DWORD PTR _var3$7$[ebp]
	mov	ecx, ebx
	or	esi, DWORD PTR _var4$5$[ebp]
	xor	esi, eax
	mov	eax, edx
	not	eax
	and	ecx, esi
	and	eax, DWORD PTR _var5$9$[ebp]
	xor	ecx, edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [edi+100]
	xor	eax, ecx
	not	ecx
	mov	DWORD PTR [edi+100], eax
	mov	eax, DWORD PTR _var5$9$[ebp]
	not	eax
	and	eax, edx
	xor	edx, ecx
	xor	eax, DWORD PTR [edi+76]
	and	edx, ebx
	or	edx, DWORD PTR _var11$5$[ebp]
	xor	eax, ecx
	mov	ecx, DWORD PTR _var9$6$[ebp]
	xor	edx, esi

; 1638 : 	s5(x(72),     x(73),     x(74),     x(75),     x(76),     x(77),     z( 7), z(13), z(24), z( 2));

	mov	ebx, DWORD PTR _expansionFunction$1$[ebp]
	mov	esi, edi
	mov	DWORD PTR [edi+76], eax
	mov	eax, ecx
	or	eax, DWORD PTR _var5$9$[ebp]
	and	ecx, DWORD PTR _var5$9$[ebp]
	xor	eax, DWORD PTR [esi+36]
	xor	ecx, DWORD PTR [esi]
	xor	eax, edx
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	ecx, edx
	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR [esi+36], eax
	movzx	eax, BYTE PTR [ebx+72]
	mov	esi, DWORD PTR [esi+eax*4]
	movzx	eax, BYTE PTR [ebx+73]
	xor	esi, DWORD PTR [edi+edx*4+288]
	mov	DWORD PTR _var0$12$[ebp], esi
	mov	eax, DWORD PTR [ecx+eax*4]
	xor	eax, DWORD PTR [edi+edx*4+292]
	mov	DWORD PTR _var1$7$[ebp], eax
	movzx	eax, BYTE PTR [ebx+74]
	mov	ecx, DWORD PTR [ecx+eax*4]
	xor	ecx, DWORD PTR [edi+edx*4+296]
	movzx	eax, BYTE PTR [ebx+75]
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, DWORD PTR [eax+edx*4+300]
	movzx	eax, BYTE PTR [ebx+76]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var3$8$[ebp], edi
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+304]
	movzx	eax, BYTE PTR [ebx+77]
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$6$[ebp], edx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	eax, DWORD PTR [edi+ebx*4+308]
	mov	ebx, ecx
	mov	edi, DWORD PTR _var3$8$[ebp]
	or	ebx, esi
	mov	DWORD PTR _var9$9$[ebp], eax
	not	eax
	and	eax, ebx
	mov	DWORD PTR _var6$9$[ebp], ebx
	mov	ebx, eax
	xor	ebx, esi
	mov	DWORD PTR _var8$9$[ebp], ebx
	xor	ebx, ecx
	mov	esi, ebx
	or	ebx, DWORD PTR _var0$12$[ebp]
	or	esi, edi
	mov	DWORD PTR _var11$6$[ebp], ebx
	not	edi
	mov	DWORD PTR _var10$7$[ebp], esi
	and	edi, eax
	xor	esi, DWORD PTR _var4$6$[ebp]
	mov	eax, DWORD PTR _var9$9$[ebp]
	xor	edi, ecx
	mov	DWORD PTR _var7$8$[ebp], edi
	and	edi, edx
	xor	edi, ebx
	and	ebx, DWORD PTR _var3$8$[ebp]
	xor	edi, DWORD PTR _var3$8$[ebp]
	xor	eax, edi
	mov	DWORD PTR _var9$9$[ebp], eax
	or	eax, DWORD PTR _var8$9$[ebp]
	mov	ecx, eax
	and	ecx, edx
	mov	edx, DWORD PTR _var0$12$[ebp]
	xor	ebx, ecx
	mov	DWORD PTR _var12$5$[ebp], ecx
	xor	ebx, DWORD PTR _var8$9$[ebp]
	not	edx
	and	edx, eax
	mov	eax, DWORD PTR _var1$7$[ebp]
	mov	ecx, edx
	not	eax
	xor	ecx, DWORD PTR _var7$8$[ebp]
	not	ecx
	and	ecx, esi
	not	ecx
	and	ecx, eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, DWORD PTR [eax+96]
	xor	ecx, edi
	mov	edi, esi
	mov	DWORD PTR [eax+96], ecx
	xor	edi, edx
	mov	eax, DWORD PTR _var12$5$[ebp]
	or	edi, ebx
	mov	edx, DWORD PTR _var7$8$[ebp]
	not	eax
	and	eax, edx
	not	eax
	and	edi, eax
	mov	eax, DWORD PTR _var9$9$[ebp]
	and	eax, edi
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, esi
	mov	DWORD PTR _var9$9$[ebp], eax
	mov	esi, DWORD PTR _var9$9$[ebp]
	mov	eax, DWORD PTR _var11$6$[ebp]
	and	eax, edx
	or	eax, esi
	xor	eax, DWORD PTR _var12$5$[ebp]
	and	eax, DWORD PTR _var1$7$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _var10$7$[ebp]
	xor	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	and	ecx, DWORD PTR _var3$8$[ebp]
	xor	ecx, DWORD PTR _var6$9$[ebp]
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	ecx, edi
	xor	ecx, DWORD PTR _var0$12$[ebp]
	not	edi
	and	edi, ebx
	or	edi, DWORD PTR _var1$7$[ebp]
	xor	edi, DWORD PTR [eax+28]
	xor	edi, ecx
	not	ecx
	mov	DWORD PTR [eax+28], edi
	mov	eax, ebx
	and	ebx, DWORD PTR _var1$7$[ebp]
	xor	eax, edx
	and	eax, ecx

; 1639 : 	s6(x(78),     x(79),     x(80),     x(81),     x(82),     x(83),     z( 3), z(28), z(10), z(18));

	mov	edx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	ecx, DWORD PTR _expansionFunction$1$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [ebx+52]
	xor	eax, esi
	mov	esi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, DWORD PTR _var8$9$[ebp]
	mov	DWORD PTR [ebx+52], eax
	movzx	eax, BYTE PTR [ecx+78]
	mov	edi, DWORD PTR [ebx+eax*4]
	xor	edi, DWORD PTR [esi+edx*4+312]
	movzx	eax, BYTE PTR [ecx+79]
	mov	DWORD PTR _var0$13$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	mov	ebx, DWORD PTR [ebx+eax*4]
	movzx	eax, BYTE PTR [ecx+80]
	xor	ebx, DWORD PTR [esi+edx*4+316]
	mov	DWORD PTR _var1$8$[ebp], ebx
	mov	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	esi, DWORD PTR [eax+edx*4+320]
	movzx	eax, BYTE PTR [ecx+81]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	eax, DWORD PTR [edi+edx*4+324]
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var3$10$[ebp], eax
	movzx	eax, BYTE PTR [ecx+82]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	edx, DWORD PTR [edi+eax*4+328]
	movzx	eax, BYTE PTR [ecx+83]
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var4$8$[ebp], edx
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	ecx, DWORD PTR [edi+eax*4+332]
	mov	eax, ecx
	mov	DWORD PTR _var5$12$[ebp], ecx
	or	eax, ebx
	and	eax, DWORD PTR _var0$13$[ebp]
	mov	edi, eax
	mov	DWORD PTR _var8$10$[ebp], eax
	xor	edi, edx
	xor	edi, ebx
	mov	eax, edi
	mov	DWORD PTR _var2$13$[ebp], edi
	xor	eax, ecx
	mov	ecx, eax
	not	ecx
	and	eax, DWORD PTR _var0$13$[ebp]
	and	ecx, edx
	mov	DWORD PTR _var10$8$[ebp], eax
	mov	edx, esi
	xor	edx, DWORD PTR _var0$13$[ebp]
	xor	eax, ebx
	mov	ebx, edx
	mov	DWORD PTR _var9$10$[ebp], ecx
	or	ebx, eax
	mov	DWORD PTR _var9$11$[ebp], edx
	mov	edx, DWORD PTR _var5$12$[ebp]
	or	ecx, eax
	mov	DWORD PTR _var4$9$[ebp], ebx
	mov	eax, ecx
	xor	ebx, edi
	not	edx
	mov	edi, ebx
	and	edi, esi
	and	edx, edi
	mov	DWORD PTR _var14$5$[ebp], edi
	mov	edi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, edx
	mov	DWORD PTR _var6$12$[ebp], eax
	not	edx
	and	eax, DWORD PTR _var3$10$[ebp]
	xor	eax, ebx
	or	ebx, DWORD PTR _var0$13$[ebp]
	xor	DWORD PTR [edi+72], eax
	and	ebx, ecx
	mov	eax, DWORD PTR _var4$9$[ebp]
	xor	eax, DWORD PTR _var1$8$[ebp]
	mov	ecx, DWORD PTR _var3$10$[ebp]
	not	eax
	mov	edi, eax
	mov	DWORD PTR _var4$9$[ebp], eax
	and	edi, DWORD PTR _var5$12$[ebp]
	mov	eax, DWORD PTR _var9$10$[ebp]
	xor	edi, esi
	or	eax, ecx
	mov	esi, DWORD PTR _var14$5$[ebp]
	xor	ebx, edi
	not	ecx
	and	edx, ebx
	mov	DWORD PTR _var3$10$[ebp], ecx
	xor	edx, eax
	not	esi
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	and	esi, DWORD PTR _var4$8$[ebp]
	or	esi, edi
	xor	edi, DWORD PTR _var0$13$[ebp]
	xor	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _var2$13$[ebp]
	mov	edx, DWORD PTR _var9$11$[ebp]
	xor	eax, ebx
	or	edx, DWORD PTR _var1$8$[ebp]
	not	eax
	and	eax, DWORD PTR _var4$8$[ebp]
	mov	ebx, DWORD PTR _var4$9$[ebp]
	xor	ebx, edx
	mov	ecx, ebx
	xor	ecx, eax
	mov	eax, esi
	or	eax, DWORD PTR _var8$10$[ebp]
	and	ecx, DWORD PTR _var3$10$[ebp]
	xor	ecx, eax
	mov	eax, DWORD PTR _var10$8$[ebp]
	xor	eax, DWORD PTR _var5$12$[ebp]
	xor	ecx, edx
	mov	edx, DWORD PTR _dataBlocks$[ebp]
	and	eax, edi
	xor	ecx, DWORD PTR _var6$12$[ebp]

; 1640 : 	s7(y(55, 84), y(56, 85), y(57, 86), y(58, 87), y(59, 88), y(60, 89), z(31), z(11), z(21), z( 6));

	mov	edi, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	DWORD PTR [edx+112], ecx
	mov	ecx, DWORD PTR _var3$10$[ebp]
	and	ecx, esi
	mov	esi, DWORD PTR _keyScheduleIndexBase$[ebp]
	xor	eax, ecx
	xor	eax, DWORD PTR [edx+12]
	xor	eax, DWORD PTR _var14$5$[ebp]
	xor	eax, ebx
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [edi+esi*4+336]
	xor	eax, DWORD PTR [edx+220]
	mov	ecx, DWORD PTR [edi+esi*4+340]
	xor	ecx, DWORD PTR [edx+224]
	mov	ebx, DWORD PTR [edi+esi*4+344]
	xor	ebx, DWORD PTR [edx+228]
	mov	edx, DWORD PTR [edi+esi*4+348]
	mov	DWORD PTR _var0$14$[ebp], eax
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	mov	DWORD PTR _var1$9$[ebp], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	edx, DWORD PTR [eax+232]
	mov	eax, DWORD PTR [edi+esi*4+352]
	xor	eax, DWORD PTR [ecx+236]
	mov	esi, DWORD PTR [edi+esi*4+356]
	mov	edi, ecx
	mov	DWORD PTR _var4$10$[ebp], eax
	not	eax
	mov	DWORD PTR tv2104[ebp], eax
	mov	DWORD PTR _var6$14$[ebp], edx
	xor	esi, DWORD PTR [edi+240]
	mov	edi, edx
	xor	edi, DWORD PTR _var0$14$[ebp]
	mov	DWORD PTR _var5$13$[ebp], esi
	mov	esi, eax
	and	esi, edx
	mov	edx, edi
	xor	edx, DWORD PTR _var4$10$[ebp]
	mov	eax, esi
	xor	eax, DWORD PTR _var1$9$[ebp]
	mov	ecx, eax
	mov	DWORD PTR _var2$16$[ebp], edx
	or	ecx, ebx
	xor	ecx, edx
	xor	edx, ebx
	mov	DWORD PTR _var8$11$[ebp], edx
	not	edx
	and	edx, DWORD PTR _var0$14$[ebp]
	xor	edx, esi
	mov	DWORD PTR _var13$7$[ebp], edx
	and	edx, eax
	mov	DWORD PTR _var12$8$[ebp], edx
	xor	edx, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	eax, edx
	not	eax
	and	eax, DWORD PTR _var5$13$[ebp]
	xor	eax, DWORD PTR [esi+24]
	xor	eax, ecx
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR _var6$14$[ebp]
	or	eax, DWORD PTR _var1$9$[ebp]
	mov	esi, DWORD PTR _var8$11$[ebp]
	mov	ecx, eax
	and	ecx, ebx
	mov	DWORD PTR _var6$14$[ebp], eax
	mov	ebx, DWORD PTR _var13$7$[ebp]
	xor	esi, edx
	mov	eax, ecx
	mov	edx, esi
	or	eax, DWORD PTR _var0$14$[ebp]
	not	ecx
	xor	esi, DWORD PTR _var1$9$[ebp]
	and	ecx, edi
	mov	edi, DWORD PTR _var2$16$[ebp]
	not	ebx
	and	ebx, eax
	mov	DWORD PTR _var7$12$[ebp], ecx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	and	edi, eax
	not	edx
	mov	eax, ebx
	and	edx, DWORD PTR _var13$7$[ebp]
	or	esi, edi
	or	eax, DWORD PTR _var5$13$[ebp]
	not	edx
	xor	eax, DWORD PTR [ecx+124]
	and	edx, DWORD PTR _var6$14$[ebp]
	xor	eax, edx
	xor	eax, esi
	mov	DWORD PTR [ecx+124], eax
	and	edi, DWORD PTR _var8$11$[ebp]
	mov	ecx, DWORD PTR _var7$12$[ebp]
	mov	eax, edi
	xor	eax, DWORD PTR _var1$9$[ebp]
	not	ecx
	and	eax, ecx
	xor	edx, DWORD PTR _var7$12$[ebp]
	xor	eax, DWORD PTR _var13$7$[ebp]
	and	ecx, DWORD PTR _var4$10$[ebp]
	xor	esi, eax
	and	esi, DWORD PTR _var5$13$[ebp]
	xor	ecx, ebx
	or	ecx, DWORD PTR _var0$14$[ebp]
	not	eax
	and	edx, DWORD PTR _var5$13$[ebp]
	mov	DWORD PTR _var2$16$[ebp], edi
	xor	ecx, edx
	mov	edi, DWORD PTR _var12$8$[ebp]
	xor	ecx, eax
	or	edi, DWORD PTR _var2$16$[ebp]
	and	edi, DWORD PTR tv2104[ebp]

; 1641 : 	s8(y(59, 90), y(60, 91), y(61, 92), y(62, 93), y(63, 94), y(32, 95), z( 4), z(26), z(14), z(20));

	mov	edx, DWORD PTR _expandedKeySchedule$1$[ebp]
	xor	edi, esi
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	mov	ebx, esi
	xor	edi, DWORD PTR _var8$11$[ebp]
	xor	edi, DWORD PTR _var6$14$[ebp]
	xor	DWORD PTR [ebx+44], ecx
	xor	DWORD PTR [esi+84], edi
	mov	ecx, DWORD PTR _keyScheduleIndexBase$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+360]
	xor	eax, DWORD PTR [ebx+236]
	mov	esi, DWORD PTR [edx+ecx*4+364]
	mov	edi, DWORD PTR [edx+ecx*4+368]
	xor	edi, DWORD PTR [ebx+244]
	xor	esi, DWORD PTR [ebx+240]
	mov	DWORD PTR _var0$15$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*4+372]
	xor	eax, DWORD PTR [ebx+248]
	mov	DWORD PTR _var3$13$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*4+376]
	mov	ecx, DWORD PTR [edx+ecx*4+380]
	xor	ecx, DWORD PTR [ebx+128]
	xor	eax, DWORD PTR [ebx+252]
	mov	ebx, esi
	mov	DWORD PTR _var5$14$[ebp], ecx
	not	ebx
	mov	ecx, edi
	mov	DWORD PTR _var4$11$[ebp], eax
	not	ecx
	mov	DWORD PTR _var1$10$[ebp], esi
	mov	edx, ecx
	mov	DWORD PTR _var1$11$[ebp], ecx
	and	edx, eax
	and	ebx, edi
	xor	edx, DWORD PTR _var3$13$[ebp]
	mov	eax, ebx
	not	eax
	mov	ecx, edx
	and	ecx, DWORD PTR _var0$15$[ebp]
	not	edx
	and	eax, ecx
	mov	DWORD PTR _var9$15$[ebp], eax
	mov	eax, edx
	and	eax, esi
	mov	esi, eax
	mov	DWORD PTR _var7$15$[ebp], eax
	mov	eax, DWORD PTR _var1$11$[ebp]
	and	eax, DWORD PTR _var1$10$[ebp]
	or	esi, DWORD PTR _var0$15$[ebp]
	xor	eax, DWORD PTR _var4$11$[ebp]
	mov	DWORD PTR _var6$17$[ebp], esi
	mov	DWORD PTR _var1$11$[ebp], eax
	and	eax, esi
	mov	esi, eax
	or	esi, ecx
	mov	ecx, DWORD PTR _var6$17$[ebp]
	not	ecx
	and	ecx, edi
	mov	edi, ecx
	xor	edi, edx
	mov	ecx, DWORD PTR _dataBlocks$[ebp]
	xor	edi, eax
	mov	eax, DWORD PTR _var9$15$[ebp]
	xor	ebx, edi
	or	eax, DWORD PTR _var5$14$[ebp]
	xor	edi, DWORD PTR _var1$10$[ebp]
	xor	eax, ebx
	xor	DWORD PTR [ecx+104], eax
	mov	eax, esi
	xor	ebx, DWORD PTR _var0$15$[ebp]
	mov	edx, DWORD PTR _var7$15$[ebp]
	mov	ecx, ebx
	and	ecx, DWORD PTR _var4$11$[ebp]
	and	esi, DWORD PTR _var5$14$[ebp]
	xor	ecx, edi
	or	edi, DWORD PTR _var3$13$[ebp]
	xor	eax, ecx
	or	eax, DWORD PTR _var1$10$[ebp]
	xor	edx, ecx
	mov	ecx, DWORD PTR _var1$11$[ebp]
	xor	eax, ebx
	mov	ebx, DWORD PTR _var4$11$[ebp]
	xor	ecx, edx
	xor	ebx, eax
	xor	edi, ecx
	mov	eax, DWORD PTR _dataBlocks$[ebp]
	xor	esi, ebx
	xor	DWORD PTR [eax+56], esi
	mov	eax, edi
	xor	eax, DWORD PTR _var0$15$[ebp]
	and	eax, DWORD PTR _var5$14$[ebp]
	mov	esi, DWORD PTR _dataBlocks$[ebp]
	xor	eax, DWORD PTR [esi+80]
	xor	eax, edx
	mov	DWORD PTR [esi+80], eax
	mov	eax, DWORD PTR _var3$13$[ebp]
	not	eax
	and	eax, ebx
	and	eax, ecx
	mov	ecx, esi
	xor	eax, DWORD PTR _var9$15$[ebp]
	xor	eax, edi
	or	eax, DWORD PTR _var5$14$[ebp]
	xor	eax, DWORD PTR [ecx+16]
	pop	edi
	xor	eax, edx
	pop	esi
	mov	DWORD PTR [ecx+16], eax
	pop	ebx

; 1642 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CPU_DES_SBoxes2@@YAXPAEPAI1H@Z ENDP			; CPU_DES_SBoxes2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z
_TEXT	SEGMENT
_tripcode$ = 8						; size = 4
?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z PROC	; DES_GetTripcode, COMDAT
; _context$ = ecx
; _tripcodeIndex$ = edx

; 1675 : {

	push	ebp
	mov	ebp, esp

; 1676 : 	// Perform the final permutation as necessary.
; 1677 :   	tripcode[0] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0)];

	and	edx, 31					; 0000001fH
	push	ebx
	mov	ebx, ecx
	mov	ecx, edx
	push	esi
	push	edi
	mov	edi, 1
	mov	esi, DWORD PTR _tripcode$[ebp]
	mov	edx, DWORD PTR [ebx+3420]
	shl	edi, cl
	mov	eax, DWORD PTR [ebx+3292]
	and	edx, edi
	neg	edx
	sbb	edx, edx
	and	eax, edi
	neg	edx
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+3320]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+3192]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+3352]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+3224]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[edx]
	mov	BYTE PTR [esi], al

; 1678 :   	tripcode[1] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0)];

	mov	ecx, DWORD PTR [ebx+3384]
	mov	eax, DWORD PTR [ebx+3256]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3416]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3288]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3316]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3188]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+1], al

; 1679 :   	tripcode[2] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0)];

	mov	ecx, DWORD PTR [ebx+3348]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+3220]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3380]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3252]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3412]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3284]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+2], al

; 1680 :   	tripcode[3] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0)];

	mov	ecx, DWORD PTR [ebx+3312]
	mov	eax, DWORD PTR [ebx+3184]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3344]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3216]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [ebx+3376]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3248]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+3], al

; 1681 :   	tripcode[4] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0)];

	mov	ecx, DWORD PTR [ebx+3408]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+3280]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3308]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3180]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3340]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3212]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+4], al

; 1682 :   	tripcode[5] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0)];

	mov	ecx, DWORD PTR [ebx+3372]
	mov	eax, DWORD PTR [ebx+3244]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3404]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3276]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3304]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3176]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+5], al

; 1683 :   	tripcode[6] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0)];

	mov	ecx, DWORD PTR [ebx+3336]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+3208]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3368]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3240]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3400]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3272]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+6], al

; 1684 :   	tripcode[7] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0)];

	mov	ecx, DWORD PTR [ebx+3300]
	mov	eax, DWORD PTR [ebx+3172]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3332]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3204]
	add	ecx, ecx
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3364]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3236]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+7], al

; 1685 :   	tripcode[8] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0)];

	mov	ecx, DWORD PTR [ebx+3396]
	mov	eax, DWORD PTR [ebx+3268]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3296]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3168]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3328]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+3200]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+8], al

; 1686 : 	tripcode[9] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24)];

	mov	edx, DWORD PTR [ebx+3360]
	mov	eax, DWORD PTR [ebx+3232]
	and	edx, edi
	neg	edx
	sbb	edx, edx
	and	eax, edi
	neg	edx
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+3392]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	ecx, DWORD PTR [ebx+3264]
	or	edx, eax
	and	ecx, edi

; 1687 :  	tripcode[10] = '\0';

	mov	BYTE PTR [esi+10], 0
	add	edx, edx

; 1688 : 
; 1689 : 	return tripcode;

	mov	eax, esi
	neg	ecx
	pop	edi
	sbb	ecx, ecx
	neg	ecx
	or	edx, ecx
	mov	cl, BYTE PTR _DES_indexToCharTable[edx*4]
	mov	BYTE PTR [esi+9], cl
	pop	esi
	pop	ebx

; 1690 : }

	pop	ebp
	ret	0
?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z ENDP	; DES_GetTripcode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_SetSalt@@YAXPAUDES_Context@@H@Z
_TEXT	SEGMENT
?DES_SetSalt@@YAXPAUDES_Context@@H@Z PROC		; DES_SetSalt, COMDAT
; _context$ = ecx
; _salt$ = edx

; 1703 : {

	push	ebx
	push	esi

; 1704 : 	int32_t mask;
; 1705 : 	int32_t src, dst;
; 1706 : 
; 1707 : 	mask = 1;

	mov	esi, 1

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	ebx, esi
	npad	2
$LL8@DES_SetSal:

; 1709 : 		if (dst == 24) mask = 1;

	cmp	eax, 24					; 00000018H
	cmove	esi, ebx

; 1710 : 
; 1711 : 		if (salt & mask) {

	test	esi, edx
	je	SHORT $LN4@DES_SetSal

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	cmp	eax, 24					; 00000018H
	jge	SHORT $LN3@DES_SetSal
	lea	ecx, DWORD PTR [eax+24]
	jmp	SHORT $LN1@DES_SetSal
$LN3@DES_SetSal:
	lea	ecx, DWORD PTR [eax-24]
	jmp	SHORT $LN1@DES_SetSal
$LN4@DES_SetSal:

; 1713 : 		} else src = dst;

	mov	ecx, eax
$LN1@DES_SetSal:

; 1714 : 
; 1715 : 		context->expansionFunction[dst     ] = expansionTable[src];

	mov	cl, BYTE PTR ?expansionTable@@3QBEB[ecx]

; 1716 : 		context->expansionFunction[dst + 48] = expansionTable[src] + 32;
; 1717 : 
; 1718 : 		mask <<= 1;

	add	esi, esi
	mov	BYTE PTR [eax+edi], cl
	add	cl, 32					; 00000020H
	mov	BYTE PTR [edi+eax+48], cl
	inc	eax
	cmp	eax, 48					; 00000030H
	jl	SHORT $LL8@DES_SetSal

; 1719 : 	}
; 1720 : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?DES_SetSalt@@YAXPAUDES_Context@@H@Z ENDP		; DES_SetSalt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_Crypt25@@YAXPAUDES_Context@@@Z
_TEXT	SEGMENT
tv179 = -12						; size = 4
tv180 = -8						; size = 4
_context$1$ = -4					; size = 4
?DES_Crypt25@@YAXPAUDES_Context@@@Z PROC		; DES_Crypt25, COMDAT
; _context$ = ecx

; 1783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	eax, ecx
	push	esi

; 1784 : 	int32_t iterations, roundsAndSwapped; 
; 1785 : 	int32_t keyScheduleIndexBase = 0;

	xor	esi, esi
	mov	DWORD PTR _context$1$[ebp], eax
	push	edi
	lea	ecx, DWORD PTR [eax+3168]
	lea	edx, DWORD PTR [eax+96]
	mov	DWORD PTR tv180[ebp], ecx

; 1786 : 
; 1787 : 	roundsAndSwapped = 8;

	lea	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR tv179[ebp], edx

; 1788 : 	iterations = 25;

	lea	edi, DWORD PTR [esi+25]
	jmp	SHORT $start$21
$LL17@DES_Crypt2:
	mov	edx, DWORD PTR tv179[ebp]
$LN19@DES_Crypt2:
	mov	eax, DWORD PTR _context$1$[ebp]
	mov	ecx, DWORD PTR tv180[ebp]
$start$21:

; 1789 : 
; 1790 : start:
; 1791 : 	CPU_DES_SBoxes1(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	push	esi
	push	ecx
	mov	ecx, eax
	call	?CPU_DES_SBoxes1@@YAXPAEPAI1H@Z		; CPU_DES_SBoxes1

; 1813 : 	goto start;

	mov	edx, DWORD PTR tv179[ebp]
	add	esp, 8
	cmp	ebx, 256				; 00000100H
	jne	SHORT $LN9@DES_Crypt2

; 1806 : 		goto swap;
; 1807 : 	return;
; 1808 : 
; 1809 : next:
; 1810 : 	keyScheduleIndexBase -= (0x300 - 48);
; 1811 : 	roundsAndSwapped = 8;

	sub	esi, 720				; 000002d0H
	mov	ebx, 8
$next$22:

; 1812 : 	iterations--;

	dec	edi

; 1813 : 	goto start;

	jmp	SHORT $LN19@DES_Crypt2
$LN9@DES_Crypt2:

; 1792 : 
; 1793 : 	if (roundsAndSwapped == 0x100)
; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	mov	ecx, DWORD PTR _context$1$[ebp]
	push	esi
	push	DWORD PTR tv180[ebp]
	call	?CPU_DES_SBoxes2@@YAXPAEPAI1H@Z		; CPU_DES_SBoxes2
	add	esp, 8

; 1798 : 
; 1799 : 	keyScheduleIndexBase += 96;

	add	esi, 96					; 00000060H

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	dec	ebx
	jne	SHORT $LL17@DES_Crypt2

; 1802 : 		goto start;
; 1803 : 	keyScheduleIndexBase -= (0x300 + 48);

	sub	esi, 816				; 00000330H
$swap$23:

; 1804 : 	roundsAndSwapped = 0x108;
; 1805 : 	if (--iterations)

	dec	edi
	je	SHORT $LN1@DES_Crypt2

; 1792 : 
; 1793 : 	if (roundsAndSwapped == 0x100)
; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	mov	edx, DWORD PTR tv179[ebp]
	mov	ecx, DWORD PTR _context$1$[ebp]
	push	esi
	push	DWORD PTR tv180[ebp]
	call	?CPU_DES_SBoxes2@@YAXPAEPAI1H@Z		; CPU_DES_SBoxes2
	add	esp, 8

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	mov	ebx, 263				; 00000107H
	add	esi, 96					; 00000060H
	jmp	SHORT $LL17@DES_Crypt2
$LN1@DES_Crypt2:
	pop	edi
	pop	esi
	pop	ebx

; 1814 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DES_Crypt25@@YAXPAUDES_Context@@@Z ENDP		; DES_Crypt25
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?Generate10CharTripcodes@@YAXPAUTripcodeKeyPair@@H@Z
_TEXT	SEGMENT
_context$ = -3712					; size = 3704
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_numTripcodes$ = 12					; size = 4
?Generate10CharTripcodes@@YAXPAUTripcodeKeyPair@@H@Z PROC ; Generate10CharTripcodes, COMDAT

; 1869 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 3716				; 00000e84H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+3716], eax
	push	ebx
	mov	ebx, DWORD PTR _p$[ebp]
	push	esi

; 1870 : 	DES_Context context;
; 1871 : 
; 1872 : 	CLEAR_KEYS(0);
; 1873 : 	CLEAR_KEYS(1);
; 1874 : 	CLEAR_KEYS(2);
; 1875 : 	CLEAR_KEYS(3);
; 1876 : 	CLEAR_KEYS(4);
; 1877 : 	CLEAR_KEYS(5);
; 1878 : 	CLEAR_KEYS(6);
; 1879 : 	CLEAR_KEYS(7);
; 1880 : 
; 1881 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	mov	esi, DWORD PTR _numTripcodes$[ebp]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _context$[esp+7204], 0
	mov	DWORD PTR _context$[esp+7208], 0
	mov	DWORD PTR _context$[esp+7212], 0
	mov	DWORD PTR _context$[esp+7216], 0
	mov	DWORD PTR _context$[esp+7220], 0
	mov	DWORD PTR _context$[esp+7224], 0
	mov	DWORD PTR _context$[esp+7228], 0
	mov	DWORD PTR _context$[esp+7232], 0
	mov	DWORD PTR _context$[esp+7236], 0
	mov	DWORD PTR _context$[esp+7240], 0
	mov	DWORD PTR _context$[esp+7244], 0
	mov	DWORD PTR _context$[esp+7248], 0
	mov	DWORD PTR _context$[esp+7252], 0
	mov	DWORD PTR _context$[esp+7256], 0
	mov	DWORD PTR _context$[esp+7260], 0
	mov	DWORD PTR _context$[esp+7264], 0
	mov	DWORD PTR _context$[esp+7268], 0
	mov	DWORD PTR _context$[esp+7272], 0
	mov	DWORD PTR _context$[esp+7276], 0
	mov	DWORD PTR _context$[esp+7280], 0
	mov	DWORD PTR _context$[esp+7284], 0
	mov	DWORD PTR _context$[esp+7288], 0
	mov	DWORD PTR _context$[esp+7292], 0
	mov	DWORD PTR _context$[esp+7296], 0
	mov	DWORD PTR _context$[esp+7300], 0
	mov	DWORD PTR _context$[esp+7304], 0
	mov	DWORD PTR _context$[esp+7308], 0
	mov	DWORD PTR _context$[esp+7312], 0
	mov	DWORD PTR _context$[esp+7316], 0
	mov	DWORD PTR _context$[esp+7320], 0
	mov	DWORD PTR _context$[esp+7324], 0
	mov	DWORD PTR _context$[esp+7328], 0
	mov	DWORD PTR _context$[esp+7332], 0
	mov	DWORD PTR _context$[esp+7336], 0
	mov	DWORD PTR _context$[esp+7340], 0
	mov	DWORD PTR _context$[esp+7344], 0
	mov	DWORD PTR _context$[esp+7348], 0
	mov	DWORD PTR _context$[esp+7352], 0
	mov	DWORD PTR _context$[esp+7356], 0
	mov	DWORD PTR _context$[esp+7360], 0
	mov	DWORD PTR _context$[esp+7364], 0
	mov	DWORD PTR _context$[esp+7368], 0
	mov	DWORD PTR _context$[esp+7372], 0
	mov	DWORD PTR _context$[esp+7376], 0
	mov	DWORD PTR _context$[esp+7380], 0
	mov	DWORD PTR _context$[esp+7384], 0
	mov	DWORD PTR _context$[esp+7388], 0
	mov	DWORD PTR _context$[esp+7392], 0
	mov	DWORD PTR _context$[esp+7396], 0
	mov	DWORD PTR _context$[esp+7400], 0
	mov	DWORD PTR _context$[esp+7404], 0
	mov	DWORD PTR _context$[esp+7408], 0
	mov	DWORD PTR _context$[esp+7412], 0
	mov	DWORD PTR _context$[esp+7416], 0
	mov	DWORD PTR _context$[esp+7420], 0
	mov	DWORD PTR _context$[esp+7424], 0
	test	esi, esi
	jle	$LN66@Generate10
	lea	ecx, DWORD PTR [edi+1]
	npad	8
$LL68@Generate10:

; 1882 : 		SET_BIT_FOR_KEY( 0, 0, 0);

	lea	eax, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [ebx+eax*8]
	mov	al, BYTE PTR [edx+12]
	test	al, 1
	je	SHORT $LN65@Generate10
	or	DWORD PTR _context$[esp+7204], ecx
$LN65@Generate10:

; 1883 : 		SET_BIT_FOR_KEY( 1, 0, 1);

	test	al, 2
	je	SHORT $LN64@Generate10
	or	DWORD PTR _context$[esp+7208], ecx
$LN64@Generate10:

; 1884 : 		SET_BIT_FOR_KEY( 2, 0, 2);

	test	al, 4
	je	SHORT $LN63@Generate10
	or	DWORD PTR _context$[esp+7212], ecx
$LN63@Generate10:

; 1885 : 		SET_BIT_FOR_KEY( 3, 0, 3);

	test	al, 8
	je	SHORT $LN62@Generate10
	or	DWORD PTR _context$[esp+7216], ecx
$LN62@Generate10:

; 1886 : 		SET_BIT_FOR_KEY( 4, 0, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN61@Generate10
	or	DWORD PTR _context$[esp+7220], ecx
$LN61@Generate10:

; 1887 : 		SET_BIT_FOR_KEY( 5, 0, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN60@Generate10
	or	DWORD PTR _context$[esp+7224], ecx
$LN60@Generate10:

; 1888 : 		SET_BIT_FOR_KEY( 6, 0, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN59@Generate10
	or	DWORD PTR _context$[esp+7228], ecx
$LN59@Generate10:

; 1889 : 
; 1890 : 		SET_BIT_FOR_KEY( 7, 1, 0);

	mov	al, BYTE PTR [edx+13]
	test	al, 1
	je	SHORT $LN58@Generate10
	or	DWORD PTR _context$[esp+7232], ecx
$LN58@Generate10:

; 1891 : 		SET_BIT_FOR_KEY( 8, 1, 1);

	test	al, 2
	je	SHORT $LN57@Generate10
	or	DWORD PTR _context$[esp+7236], ecx
$LN57@Generate10:

; 1892 : 		SET_BIT_FOR_KEY( 9, 1, 2);

	test	al, 4
	je	SHORT $LN56@Generate10
	or	DWORD PTR _context$[esp+7240], ecx
$LN56@Generate10:

; 1893 : 		SET_BIT_FOR_KEY(10, 1, 3);

	test	al, 8
	je	SHORT $LN55@Generate10
	or	DWORD PTR _context$[esp+7244], ecx
$LN55@Generate10:

; 1894 : 		SET_BIT_FOR_KEY(11, 1, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN54@Generate10
	or	DWORD PTR _context$[esp+7248], ecx
$LN54@Generate10:

; 1895 : 		SET_BIT_FOR_KEY(12, 1, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN53@Generate10
	or	DWORD PTR _context$[esp+7252], ecx
$LN53@Generate10:

; 1896 : 		SET_BIT_FOR_KEY(13, 1, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN52@Generate10
	or	DWORD PTR _context$[esp+7256], ecx
$LN52@Generate10:

; 1897 : 	
; 1898 : 		SET_BIT_FOR_KEY(14, 2, 0);

	mov	al, BYTE PTR [edx+14]
	test	al, 1
	je	SHORT $LN51@Generate10
	or	DWORD PTR _context$[esp+7260], ecx
$LN51@Generate10:

; 1899 : 		SET_BIT_FOR_KEY(15, 2, 1);

	test	al, 2
	je	SHORT $LN50@Generate10
	or	DWORD PTR _context$[esp+7264], ecx
$LN50@Generate10:

; 1900 : 		SET_BIT_FOR_KEY(16, 2, 2);

	test	al, 4
	je	SHORT $LN49@Generate10
	or	DWORD PTR _context$[esp+7268], ecx
$LN49@Generate10:

; 1901 : 		SET_BIT_FOR_KEY(17, 2, 3);

	test	al, 8
	je	SHORT $LN48@Generate10
	or	DWORD PTR _context$[esp+7272], ecx
$LN48@Generate10:

; 1902 : 		SET_BIT_FOR_KEY(18, 2, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN47@Generate10
	or	DWORD PTR _context$[esp+7276], ecx
$LN47@Generate10:

; 1903 : 		SET_BIT_FOR_KEY(19, 2, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN46@Generate10
	or	DWORD PTR _context$[esp+7280], ecx
$LN46@Generate10:

; 1904 : 		SET_BIT_FOR_KEY(20, 2, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN45@Generate10
	or	DWORD PTR _context$[esp+7284], ecx
$LN45@Generate10:

; 1905 : 
; 1906 : 		SET_BIT_FOR_KEY(21, 3, 0);

	mov	al, BYTE PTR [edx+15]
	test	al, 1
	je	SHORT $LN44@Generate10
	or	DWORD PTR _context$[esp+7288], ecx
$LN44@Generate10:

; 1907 : 		SET_BIT_FOR_KEY(22, 3, 1);

	test	al, 2
	je	SHORT $LN43@Generate10
	or	DWORD PTR _context$[esp+7292], ecx
$LN43@Generate10:

; 1908 : 		SET_BIT_FOR_KEY(23, 3, 2);

	test	al, 4
	je	SHORT $LN42@Generate10
	or	DWORD PTR _context$[esp+7296], ecx
$LN42@Generate10:

; 1909 : 		SET_BIT_FOR_KEY(24, 3, 3);

	test	al, 8
	je	SHORT $LN41@Generate10
	or	DWORD PTR _context$[esp+7300], ecx
$LN41@Generate10:

; 1910 : 		SET_BIT_FOR_KEY(25, 3, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN40@Generate10
	or	DWORD PTR _context$[esp+7304], ecx
$LN40@Generate10:

; 1911 : 		SET_BIT_FOR_KEY(26, 3, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN39@Generate10
	or	DWORD PTR _context$[esp+7308], ecx
$LN39@Generate10:

; 1912 : 		SET_BIT_FOR_KEY(27, 3, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN38@Generate10
	or	DWORD PTR _context$[esp+7312], ecx
$LN38@Generate10:

; 1913 : 
; 1914 : 		SET_BIT_FOR_KEY(28, 4, 0);

	mov	al, BYTE PTR [edx+16]
	test	al, 1
	je	SHORT $LN37@Generate10
	or	DWORD PTR _context$[esp+7316], ecx
$LN37@Generate10:

; 1915 : 		SET_BIT_FOR_KEY(29, 4, 1);

	test	al, 2
	je	SHORT $LN36@Generate10
	or	DWORD PTR _context$[esp+7320], ecx
$LN36@Generate10:

; 1916 : 		SET_BIT_FOR_KEY(30, 4, 2);

	test	al, 4
	je	SHORT $LN35@Generate10
	or	DWORD PTR _context$[esp+7324], ecx
$LN35@Generate10:

; 1917 : 		SET_BIT_FOR_KEY(31, 4, 3);

	test	al, 8
	je	SHORT $LN34@Generate10
	or	DWORD PTR _context$[esp+7328], ecx
$LN34@Generate10:

; 1918 : 		SET_BIT_FOR_KEY(32, 4, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN33@Generate10
	or	DWORD PTR _context$[esp+7332], ecx
$LN33@Generate10:

; 1919 : 		SET_BIT_FOR_KEY(33, 4, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN32@Generate10
	or	DWORD PTR _context$[esp+7336], ecx
$LN32@Generate10:

; 1920 : 		SET_BIT_FOR_KEY(34, 4, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN31@Generate10
	or	DWORD PTR _context$[esp+7340], ecx
$LN31@Generate10:

; 1921 : 
; 1922 : 		SET_BIT_FOR_KEY(35, 5, 0);

	mov	al, BYTE PTR [edx+17]
	test	al, 1
	je	SHORT $LN30@Generate10
	or	DWORD PTR _context$[esp+7344], ecx
$LN30@Generate10:

; 1923 : 		SET_BIT_FOR_KEY(36, 5, 1);

	test	al, 2
	je	SHORT $LN29@Generate10
	or	DWORD PTR _context$[esp+7348], ecx
$LN29@Generate10:

; 1924 : 		SET_BIT_FOR_KEY(37, 5, 2);

	test	al, 4
	je	SHORT $LN28@Generate10
	or	DWORD PTR _context$[esp+7352], ecx
$LN28@Generate10:

; 1925 : 		SET_BIT_FOR_KEY(38, 5, 3);

	test	al, 8
	je	SHORT $LN27@Generate10
	or	DWORD PTR _context$[esp+7356], ecx
$LN27@Generate10:

; 1926 : 		SET_BIT_FOR_KEY(39, 5, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN26@Generate10
	or	DWORD PTR _context$[esp+7360], ecx
$LN26@Generate10:

; 1927 : 		SET_BIT_FOR_KEY(40, 5, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN25@Generate10
	or	DWORD PTR _context$[esp+7364], ecx
$LN25@Generate10:

; 1928 : 		SET_BIT_FOR_KEY(41, 5, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN24@Generate10
	or	DWORD PTR _context$[esp+7368], ecx
$LN24@Generate10:

; 1929 : 
; 1930 : 		SET_BIT_FOR_KEY(42, 6, 0);

	mov	al, BYTE PTR [edx+18]
	test	al, 1
	je	SHORT $LN23@Generate10
	or	DWORD PTR _context$[esp+7372], ecx
$LN23@Generate10:

; 1931 : 		SET_BIT_FOR_KEY(43, 6, 1);

	test	al, 2
	je	SHORT $LN22@Generate10
	or	DWORD PTR _context$[esp+7376], ecx
$LN22@Generate10:

; 1932 : 		SET_BIT_FOR_KEY(44, 6, 2);

	test	al, 4
	je	SHORT $LN21@Generate10
	or	DWORD PTR _context$[esp+7380], ecx
$LN21@Generate10:

; 1933 : 		SET_BIT_FOR_KEY(45, 6, 3);

	test	al, 8
	je	SHORT $LN20@Generate10
	or	DWORD PTR _context$[esp+7384], ecx
$LN20@Generate10:

; 1934 : 		SET_BIT_FOR_KEY(46, 6, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN19@Generate10
	or	DWORD PTR _context$[esp+7388], ecx
$LN19@Generate10:

; 1935 : 		SET_BIT_FOR_KEY(47, 6, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN18@Generate10
	or	DWORD PTR _context$[esp+7392], ecx
$LN18@Generate10:

; 1936 : 		SET_BIT_FOR_KEY(48, 6, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN17@Generate10
	or	DWORD PTR _context$[esp+7396], ecx
$LN17@Generate10:

; 1937 : 
; 1938 : 		SET_BIT_FOR_KEY(49, 7, 0);

	mov	al, BYTE PTR [edx+19]
	test	al, 1
	je	SHORT $LN16@Generate10
	or	DWORD PTR _context$[esp+7400], ecx
$LN16@Generate10:

; 1939 : 		SET_BIT_FOR_KEY(50, 7, 1);

	test	al, 2
	je	SHORT $LN15@Generate10
	or	DWORD PTR _context$[esp+7404], ecx
$LN15@Generate10:

; 1940 : 		SET_BIT_FOR_KEY(51, 7, 2);

	test	al, 4
	je	SHORT $LN14@Generate10
	or	DWORD PTR _context$[esp+7408], ecx
$LN14@Generate10:

; 1941 : 		SET_BIT_FOR_KEY(52, 7, 3);

	test	al, 8
	je	SHORT $LN13@Generate10
	or	DWORD PTR _context$[esp+7412], ecx
$LN13@Generate10:

; 1942 : 		SET_BIT_FOR_KEY(53, 7, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN12@Generate10
	or	DWORD PTR _context$[esp+7416], ecx
$LN12@Generate10:

; 1943 : 		SET_BIT_FOR_KEY(54, 7, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN11@Generate10
	or	DWORD PTR _context$[esp+7420], ecx
$LN11@Generate10:

; 1944 : 		SET_BIT_FOR_KEY(55, 7, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN67@Generate10
	or	DWORD PTR _context$[esp+7424], ecx
$LN67@Generate10:

; 1870 : 	DES_Context context;
; 1871 : 
; 1872 : 	CLEAR_KEYS(0);
; 1873 : 	CLEAR_KEYS(1);
; 1874 : 	CLEAR_KEYS(2);
; 1875 : 	CLEAR_KEYS(3);
; 1876 : 	CLEAR_KEYS(4);
; 1877 : 	CLEAR_KEYS(5);
; 1878 : 	CLEAR_KEYS(6);
; 1879 : 	CLEAR_KEYS(7);
; 1880 : 
; 1881 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	inc	edi
	rol	ecx, 1
	cmp	edi, esi
	jl	$LL68@Generate10
$LN66@Generate10:

; 1945 : 	}
; 1946 : 
; 1947 : 	for (int32_t i = 0; i < 0x300; ++i)

	xor	ecx, ecx
	npad	13
$LL9@Generate10:

; 1948 : 		context.expandedKeySchedule[i] = context.keys[keySchedule[i]];

	movzx	eax, BYTE PTR _keySchedule[ecx]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3824], eax
	movzx	eax, BYTE PTR _keySchedule[ecx+1]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3828], eax
	movzx	eax, BYTE PTR _keySchedule[ecx+2]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3832], eax
	movzx	eax, BYTE PTR _keySchedule[ecx+3]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3836], eax
	movzx	eax, BYTE PTR _keySchedule[ecx+4]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3840], eax
	movzx	eax, BYTE PTR _keySchedule[ecx+5]
	mov	eax, DWORD PTR _context$[esp+eax*4+7204]
	mov	DWORD PTR _context$[esp+ecx*4+3844], eax
	add	ecx, 6
	cmp	ecx, 768				; 00000300H
	jl	SHORT $LL9@Generate10

; 1949 : 
; 1950 : 	for (int32_t i = 0; i < NUM_DATA_BLOCKS; ++i) {
; 1951 : 		context.dataBlocks[i] = 0;

	xor	eax, eax
	lea	edi, DWORD PTR _context$[esp+6896]
	mov	ecx, 64					; 00000040H

; 1707 : 	mask = 1;

	mov	edx, 1

; 1949 : 
; 1950 : 	for (int32_t i = 0; i < NUM_DATA_BLOCKS; ++i) {
; 1951 : 		context.dataBlocks[i] = 0;

	rep stosd

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	movzx	eax, BYTE PTR [ebx+14]

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	mov	edi, edx

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	movzx	eax, BYTE PTR _charTableForSeed[eax]
	movsx	esi, BYTE PTR _DES_charToIndexTable[eax]
	movzx	eax, BYTE PTR [ebx+13]
	shl	esi, 6
	movzx	eax, BYTE PTR _charTableForSeed[eax]
	movsx	eax, BYTE PTR _DES_charToIndexTable[eax]
	or	esi, eax

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	xor	eax, eax
	npad	1
$LL102@Generate10:

; 1709 : 		if (dst == 24) mask = 1;

	cmp	eax, 24					; 00000018H
	cmove	edx, edi

; 1710 : 
; 1711 : 		if (salt & mask) {

	test	edx, esi
	je	SHORT $LN98@Generate10

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	cmp	eax, 24					; 00000018H
	jge	SHORT $LN97@Generate10
	lea	ecx, DWORD PTR [eax+24]
	jmp	SHORT $LN95@Generate10
$LN97@Generate10:
	lea	ecx, DWORD PTR [eax-24]
	jmp	SHORT $LN95@Generate10
$LN98@Generate10:

; 1713 : 		} else src = dst;

	mov	ecx, eax
$LN95@Generate10:

; 1714 : 
; 1715 : 		context->expansionFunction[dst     ] = expansionTable[src];

	mov	cl, BYTE PTR ?expansionTable@@3QBEB[ecx]

; 1716 : 		context->expansionFunction[dst + 48] = expansionTable[src] + 32;
; 1717 : 
; 1718 : 		mask <<= 1;

	add	edx, edx
	mov	BYTE PTR _context$[esp+eax+3728], cl
	add	cl, 32					; 00000020H
	mov	BYTE PTR _context$[esp+eax+3776], cl
	inc	eax
	cmp	eax, 48					; 00000030H
	jl	SHORT $LL102@Generate10

; 1957 : 
; 1958 : 	DES_Crypt25(&context);

	lea	ecx, DWORD PTR _context$[esp+3728]
	call	?DES_Crypt25@@YAXPAUDES_Context@@@Z	; DES_Crypt25

; 1959 : 	
; 1960 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	mov	edi, DWORD PTR _numTripcodes$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN1@Generate10
$LL3@Generate10:

; 1961 : 		DES_GetTripcode(&context, tripcodeIndex, p[tripcodeIndex].tripcode.c);

	push	ebx
	mov	edx, esi
	lea	ecx, DWORD PTR _context$[esp+3732]
	call	?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z ; DES_GetTripcode

; 1962 : 		p[tripcodeIndex].tripcode.c[10] = '\0';

	mov	BYTE PTR [ebx+10], 0
	inc	esi
	add	esp, 4
	add	ebx, 24					; 00000018H
	cmp	esi, edi
	jl	SHORT $LL3@Generate10
$LN1@Generate10:

; 1963 : 	}
; 1964 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+3728]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Generate10CharTripcodes@@YAXPAUTripcodeKeyPair@@H@Z ENDP ; Generate10CharTripcodes
_TEXT	ENDS
END
