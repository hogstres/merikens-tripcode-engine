; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	Z:\GitHub\merikens-tripcode-engine\SourceFiles\CPU10_AVX2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

$SG4294959199 DB 'THIS_IS_THE_END_OF_THE_FUNCTION', 00H
_DES_charToIndexTable DB 07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
_DES_indexToCharTable DB 02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
_keySchedule DB	0cH
	DB	02eH
	DB	021H
	DB	034H
	DB	030H
	DB	014H
	DB	022H
	DB	037H
	DB	05H
	DB	0dH
	DB	012H
	DB	028H
	DB	04H
	DB	020H
	DB	01aH
	DB	01bH
	DB	026H
	DB	036H
	DB	035H
	DB	06H
	DB	01fH
	DB	019H
	DB	013H
	DB	029H
	DB	0fH
	DB	018H
	DB	01cH
	DB	02bH
	DB	01eH
	DB	03H
	DB	023H
	DB	016H
	DB	02H
	DB	02cH
	DB	0eH
	DB	017H
	DB	033H
	DB	010H
	DB	01dH
	DB	031H
	DB	07H
	DB	011H
	DB	025H
	DB	08H
	DB	09H
	DB	032H
	DB	02aH
	DB	015H
	DB	05H
	DB	027H
	DB	01aH
	DB	02dH
	DB	029H
	DB	0dH
	DB	01bH
	DB	030H
	DB	035H
	DB	06H
	DB	0bH
	DB	021H
	DB	034H
	DB	019H
	DB	013H
	DB	014H
	DB	01fH
	DB	02fH
	DB	02eH
	DB	036H
	DB	037H
	DB	012H
	DB	0cH
	DB	022H
	DB	08H
	DB	011H
	DB	015H
	DB	024H
	DB	017H
	DB	031H
	DB	01cH
	DB	0fH
	DB	018H
	DB	025H
	DB	07H
	DB	010H
	DB	02cH
	DB	09H
	DB	016H
	DB	02aH
	DB	00H
	DB	0aH
	DB	01eH
	DB	01H
	DB	02H
	DB	02bH
	DB	023H
	DB	0eH
	DB	02eH
	DB	019H
	DB	0cH
	DB	01fH
	DB	01bH
	DB	036H
	DB	0dH
	DB	022H
	DB	027H
	DB	02fH
	DB	034H
	DB	013H
	DB	026H
	DB	0bH
	DB	05H
	DB	06H
	DB	030H
	DB	021H
	DB	020H
	DB	028H
	DB	029H
	DB	04H
	DB	035H
	DB	014H
	DB	033H
	DB	03H
	DB	07H
	DB	016H
	DB	09H
	DB	023H
	DB	0eH
	DB	01H
	DB	0aH
	DB	017H
	DB	032H
	DB	02H
	DB	01eH
	DB	018H
	DB	08H
	DB	01cH
	DB	02bH
	DB	031H
	DB	010H
	DB	02cH
	DB	011H
	DB	01dH
	DB	015H
	DB	00H
	DB	020H
	DB	0bH
	DB	035H
	DB	030H
	DB	0dH
	DB	028H
	DB	036H
	DB	014H
	DB	019H
	DB	021H
	DB	026H
	DB	05H
	DB	037H
	DB	034H
	DB	02eH
	DB	02fH
	DB	022H
	DB	013H
	DB	012H
	DB	01aH
	DB	01bH
	DB	02dH
	DB	027H
	DB	06H
	DB	025H
	DB	02aH
	DB	032H
	DB	08H
	DB	018H
	DB	015H
	DB	00H
	DB	02cH
	DB	031H
	DB	09H
	DB	024H
	DB	011H
	DB	010H
	DB	0aH
	DB	033H
	DB	0eH
	DB	01dH
	DB	023H
	DB	02H
	DB	01eH
	DB	03H
	DB	0fH
	DB	07H
	DB	02bH
	DB	012H
	DB	034H
	DB	027H
	DB	022H
	DB	036H
	DB	01aH
	DB	028H
	DB	06H
	DB	0bH
	DB	013H
	DB	037H
	DB	02eH
	DB	029H
	DB	026H
	DB	020H
	DB	021H
	DB	014H
	DB	05H
	DB	04H
	DB	0cH
	DB	0dH
	DB	01fH
	DB	019H
	DB	02fH
	DB	017H
	DB	01cH
	DB	024H
	DB	033H
	DB	0aH
	DB	07H
	DB	02bH
	DB	01eH
	DB	023H
	DB	018H
	DB	016H
	DB	03H
	DB	02H
	DB	031H
	DB	025H
	DB	00H
	DB	0fH
	DB	015H
	DB	011H
	DB	010H
	DB	02aH
	DB	01H
	DB	032H
	DB	01dH
	DB	04H
	DB	026H
	DB	019H
	DB	014H
	DB	028H
	DB	0cH
	DB	01aH
	DB	02fH
	DB	034H
	DB	05H
	DB	029H
	DB	020H
	DB	01bH
	DB	037H
	DB	012H
	DB	013H
	DB	06H
	DB	02eH
	DB	02dH
	DB	035H
	DB	036H
	DB	030H
	DB	0bH
	DB	021H
	DB	09H
	DB	0eH
	DB	016H
	DB	025H
	DB	031H
	DB	032H
	DB	01dH
	DB	010H
	DB	015H
	DB	0aH
	DB	08H
	DB	02aH
	DB	011H
	DB	023H
	DB	017H
	DB	02bH
	DB	01H
	DB	07H
	DB	03H
	DB	02H
	DB	01cH
	DB	02cH
	DB	024H
	DB	0fH
	DB	02dH
	DB	037H
	DB	0bH
	DB	06H
	DB	01aH
	DB	035H
	DB	0cH
	DB	021H
	DB	026H
	DB	02eH
	DB	01bH
	DB	012H
	DB	0dH
	DB	029H
	DB	04H
	DB	05H
	DB	02fH
	DB	020H
	DB	01fH
	DB	027H
	DB	028H
	DB	022H
	DB	034H
	DB	013H
	DB	018H
	DB	00H
	DB	08H
	DB	017H
	DB	023H
	DB	024H
	DB	0fH
	DB	02H
	DB	07H
	DB	031H
	DB	033H
	DB	01cH
	DB	03H
	DB	015H
	DB	09H
	DB	01dH
	DB	02cH
	DB	032H
	DB	02aH
	DB	011H
	DB	0eH
	DB	01eH
	DB	016H
	DB	01H
	DB	01fH
	DB	029H
	DB	034H
	DB	02fH
	DB	0cH
	DB	027H
	DB	035H
	DB	013H
	DB	037H
	DB	020H
	DB	0dH
	DB	04H
	DB	036H
	DB	01bH
	DB	02dH
	DB	02eH
	DB	021H
	DB	012H
	DB	030H
	DB	019H
	DB	01aH
	DB	014H
	DB	026H
	DB	05H
	DB	0aH
	DB	02bH
	DB	033H
	DB	09H
	DB	015H
	DB	016H
	DB	01H
	DB	011H
	DB	032H
	DB	023H
	DB	025H
	DB	0eH
	DB	02aH
	DB	07H
	DB	018H
	DB	0fH
	DB	01eH
	DB	024H
	DB	01cH
	DB	03H
	DB	00H
	DB	010H
	DB	08H
	DB	02cH
	DB	037H
	DB	022H
	DB	02dH
	DB	028H
	DB	05H
	DB	020H
	DB	02eH
	DB	0cH
	DB	030H
	DB	019H
	DB	06H
	DB	034H
	DB	02fH
	DB	014H
	DB	026H
	DB	027H
	DB	01aH
	DB	0bH
	DB	029H
	DB	012H
	DB	013H
	DB	0dH
	DB	01fH
	DB	035H
	DB	03H
	DB	024H
	DB	02cH
	DB	02H
	DB	0eH
	DB	0fH
	DB	033H
	DB	0aH
	DB	02bH
	DB	01cH
	DB	01eH
	DB	07H
	DB	023H
	DB	00H
	DB	011H
	DB	08H
	DB	017H
	DB	01dH
	DB	015H
	DB	031H
	DB	032H
	DB	09H
	DB	01H
	DB	025H
	DB	029H
	DB	014H
	DB	01fH
	DB	01aH
	DB	02eH
	DB	012H
	DB	020H
	DB	035H
	DB	022H
	DB	0bH
	DB	02fH
	DB	026H
	DB	021H
	DB	06H
	DB	037H
	DB	019H
	DB	0cH
	DB	034H
	DB	01bH
	DB	04H
	DB	05H
	DB	036H
	DB	030H
	DB	027H
	DB	02aH
	DB	016H
	DB	01eH
	DB	011H
	DB	00H
	DB	01H
	DB	025H
	DB	031H
	DB	01dH
	DB	0eH
	DB	010H
	DB	032H
	DB	015H
	DB	02bH
	DB	03H
	DB	033H
	DB	09H
	DB	0fH
	DB	07H
	DB	023H
	DB	024H
	DB	018H
	DB	02cH
	DB	017H
	DB	01bH
	DB	06H
	DB	030H
	DB	0cH
	DB	020H
	DB	04H
	DB	012H
	DB	027H
	DB	014H
	DB	034H
	DB	021H
	DB	037H
	DB	013H
	DB	02fH
	DB	029H
	DB	0bH
	DB	035H
	DB	026H
	DB	0dH
	DB	02dH
	DB	02eH
	DB	028H
	DB	022H
	DB	019H
	DB	01cH
	DB	08H
	DB	010H
	DB	03H
	DB	02bH
	DB	02cH
	DB	017H
	DB	023H
	DB	0fH
	DB	00H
	DB	02H
	DB	024H
	DB	07H
	DB	01dH
	DB	02aH
	DB	025H
	DB	018H
	DB	01H
	DB	032H
	DB	015H
	DB	016H
	DB	0aH
	DB	01eH
	DB	09H
	DB	0dH
	DB	02fH
	DB	022H
	DB	035H
	DB	012H
	DB	02dH
	DB	04H
	DB	019H
	DB	06H
	DB	026H
	DB	013H
	DB	029H
	DB	05H
	DB	021H
	DB	01bH
	DB	034H
	DB	027H
	DB	037H
	DB	036H
	DB	01fH
	DB	020H
	DB	01aH
	DB	014H
	DB	0bH
	DB	0eH
	DB	033H
	DB	02H
	DB	02aH
	DB	01dH
	DB	01eH
	DB	09H
	DB	015H
	DB	01H
	DB	02bH
	DB	011H
	DB	016H
	DB	032H
	DB	0fH
	DB	01cH
	DB	017H
	DB	0aH
	DB	02cH
	DB	024H
	DB	07H
	DB	08H
	DB	031H
	DB	010H
	DB	018H
	DB	036H
	DB	021H
	DB	014H
	DB	027H
	DB	04H
	DB	01fH
	DB	02dH
	DB	0bH
	DB	02fH
	DB	037H
	DB	05H
	DB	01bH
	DB	02eH
	DB	013H
	DB	0dH
	DB	026H
	DB	019H
	DB	029H
	DB	028H
	DB	030H
	DB	012H
	DB	0cH
	DB	06H
	DB	034H
	DB	00H
	DB	025H
	DB	011H
	DB	01cH
	DB	0fH
	DB	010H
	DB	018H
	DB	07H
	DB	02cH
	DB	01dH
	DB	03H
	DB	08H
	DB	024H
	DB	01H
	DB	0eH
	DB	09H
	DB	031H
	DB	01eH
	DB	016H
	DB	032H
	DB	033H
	DB	023H
	DB	02H
	DB	0aH
	DB	028H
	DB	013H
	DB	06H
	DB	019H
	DB	02dH
	DB	030H
	DB	01fH
	DB	034H
	DB	021H
	DB	029H
	DB	02eH
	DB	0dH
	DB	020H
	DB	05H
	DB	036H
	DB	037H
	DB	0bH
	DB	01bH
	DB	01aH
	DB	022H
	DB	04H
	DB	035H
	DB	02fH
	DB	026H
	DB	02bH
	DB	017H
	DB	03H
	DB	0eH
	DB	01H
	DB	02H
	DB	0aH
	DB	032H
	DB	01eH
	DB	0fH
	DB	02aH
	DB	033H
	DB	016H
	DB	02cH
	DB	00H
	DB	018H
	DB	023H
	DB	010H
	DB	08H
	DB	024H
	DB	025H
	DB	015H
	DB	011H
	DB	031H
	DB	01aH
	DB	05H
	DB	02fH
	DB	0bH
	DB	01fH
	DB	022H
	DB	030H
	DB	026H
	DB	013H
	DB	01bH
	DB	020H
	DB	036H
	DB	012H
	DB	02eH
	DB	028H
	DB	029H
	DB	034H
	DB	0dH
	DB	0cH
	DB	014H
	DB	02dH
	DB	027H
	DB	021H
	DB	037H
	DB	01dH
	DB	09H
	DB	02aH
	DB	00H
	DB	02cH
	DB	011H
	DB	031H
	DB	024H
	DB	010H
	DB	01H
	DB	01cH
	DB	025H
	DB	08H
	DB	01eH
	DB	02bH
	DB	0aH
	DB	015H
	DB	02H
	DB	033H
	DB	016H
	DB	017H
	DB	07H
	DB	03H
	DB	023H
	DB	013H
	DB	035H
	DB	028H
	DB	04H
	DB	037H
	DB	01bH
	DB	029H
	DB	01fH
	DB	0cH
	DB	014H
	DB	019H
	DB	02fH
	DB	0bH
	DB	027H
	DB	021H
	DB	022H
	DB	02dH
	DB	06H
	DB	05H
	DB	0dH
	DB	026H
	DB	020H
	DB	01aH
	DB	030H
	DB	016H
	DB	02H
	DB	023H
	DB	032H
	DB	025H
	DB	0aH
	DB	02aH
	DB	01dH
	DB	09H
	DB	033H
	DB	015H
	DB	01eH
	DB	01H
	DB	017H
	DB	024H
	DB	03H
	DB	0eH
	DB	018H
	DB	02cH
	DB	0fH
	DB	010H
	DB	00H
	DB	031H
	DB	01cH
PUBLIC	?CPU_DES_MainLoop_AVX2@@YAXXZ			; CPU_DES_MainLoop_AVX2
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_errno_ecat DD	01H DUP (?)
_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_native_ecat DD	01H DUP (?)
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_posix_category DD 01H DUP (?)
_BSS	ENDS
	ORG $-12
_posix_category$initializer$ DD FLAT:??__Eposix_category@system@boost@@YAXXZ
_errno_ecat$initializer$ DD FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
_native_ecat$initializer$ DD FLAT:??__Enative_ecat@system@boost@@YAXXZ
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?CPU_DES_MainLoop_AVX2@@YAXXZ
_TEXT	SEGMENT
_base$1$ = -30340					; size = 4
_context$ = -30336					; size = 30304
__$ArrayPad$ = -4					; size = 4
?CPU_DES_MainLoop_AVX2@@YAXXZ PROC			; CPU_DES_MainLoop_AVX2, COMDAT

; 1018 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -32				; ffffffe0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	mov	eax, 30360				; 00007698H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1019 : 	DES_Context context;
; 1020 : 
; 1021 : 	for (int32_t i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	ecx, ecx
	npad	2
$LL88@CPU_DES_Ma:

; 1022 : 		context.keyCharTable_FirstByte[i]  = keyCharTable_FirstByte[i];

	movzx	eax, BYTE PTR ?keyCharTable_FirstByte@@3PAEA[ecx]
	mov	BYTE PTR _context$[ebp+ecx+28940], al

; 1023 : 		context.keyCharTable_SecondByte[i] = keyCharTable_SecondByte[i];

	movzx	eax, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[ecx]
	mov	BYTE PTR _context$[ebp+ecx+29452], al
	inc	ecx
	cmp	ecx, 512				; 00000200H
	jl	SHORT $LL88@CPU_DES_Ma

; 1026 : 	context.useAVX2 = options.isAVX2Enabled && IsAVX2Supported();

	cmp	DWORD PTR ?options@@3UOptions@@A+92, 0
	je	SHORT $LN19@CPU_DES_Ma
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu12.cpp

; 634  :     if (the_4th_gen_features_available < 0 )

	mov	eax, DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA
	test	eax, eax
	jns	SHORT $LN116@CPU_DES_Ma

; 635  :         the_4th_gen_features_available = check_4th_gen_intel_core_features();

	call	?check_4th_gen_intel_core_features@@YAHXZ ; check_4th_gen_intel_core_features
	mov	DWORD PTR ?the_4th_gen_features_available@?1??IsAVX2Supported@@YAHXZ@4HA, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h

; 1026 : 	context.useAVX2 = options.isAVX2Enabled && IsAVX2Supported();

	test	eax, eax
$LN116@CPU_DES_Ma:
	je	SHORT $LN19@CPU_DES_Ma
	mov	DWORD PTR _context$[ebp+28936], 1
$LN115@CPU_DES_Ma:

; 1027 : 	context.useAVX  = !context.useAVX2 && options.isAVXEnabled && IsAVXSupported();

	xor	eax, eax
$LN117@CPU_DES_Ma:

; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	cmp	DWORD PTR _context$[ebp+28936], 0

; 1027 : 	context.useAVX  = !context.useAVX2 && options.isAVXEnabled && IsAVXSupported();

	mov	DWORD PTR _context$[ebp+28932], eax

; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	je	SHORT $LN30@CPU_DES_Ma
	mov	edx, OFFSET _DES_Crypt25_x86_AVX2
	jmp	SHORT $LN118@CPU_DES_Ma
$LN19@CPU_DES_Ma:

; 1027 : 	context.useAVX  = !context.useAVX2 && options.isAVXEnabled && IsAVXSupported();

	cmp	DWORD PTR ?options@@3UOptions@@A+80, 0
	mov	DWORD PTR _context$[ebp+28936], 0
	je	SHORT $LN115@CPU_DES_Ma
	call	_IsAVXSupported
	test	eax, eax
	je	SHORT $LN115@CPU_DES_Ma
	mov	eax, 1
	jmp	SHORT $LN117@CPU_DES_Ma
$LN30@CPU_DES_Ma:

; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	test	eax, eax
	je	SHORT $LN28@CPU_DES_Ma
	mov	edx, OFFSET _DES_Crypt25_x86_AVX
	jmp	SHORT $LN118@CPU_DES_Ma
$LN28@CPU_DES_Ma:
	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture
	test	eax, eax
	mov	edx, OFFSET _DES_Crypt25_x86_SSE2
	mov	ecx, OFFSET _DES_Crypt25_x86_SSE2_Nehalem
	cmovne	edx, ecx
$LN118@CPU_DES_Ma:
	mov	DWORD PTR _base$1$[ebp], edx

; 1028 : 	// printf("context.useAVX = %d\n", context.useAVX);
; 1029 : 
; 1030 : #ifdef USE_ASSEMBLY_FUNCTION
; 1031 : 	// Prepare a copy of DES_Crypt25_*() for thread-safe rewrites.
; 1032 : 	char *base = GetCrypt25Address(&context);
; 1033 : 	char *p;
; 1034 : 	int32_t functionSize = 0;

	xor	edi, edi

; 1035 : 	for (p = base; strcmp(p, "THIS_IS_THE_END_OF_THE_FUNCTION") != 0; ++p)

	mov	esi, edx
	mov	ecx, OFFSET $SG4294959199
	mov	eax, edx
	npad	6
$LL107@CPU_DES_Ma:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN108@CPU_DES_Ma
	test	dl, dl
	je	SHORT $LN109@CPU_DES_Ma
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN108@CPU_DES_Ma
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL107@CPU_DES_Ma
$LN109@CPU_DES_Ma:
	xor	eax, eax
	jmp	SHORT $LN110@CPU_DES_Ma
$LN108@CPU_DES_Ma:
	sbb	eax, eax
	or	eax, 1
$LN110@CPU_DES_Ma:
	test	eax, eax
	je	SHORT $LN11@CPU_DES_Ma
	npad	7
$LL13@CPU_DES_Ma:

; 1036 : 		++functionSize;

	inc	edi
	mov	ecx, OFFSET $SG4294959199
	inc	esi
	mov	eax, esi
	npad	7
$LL111@CPU_DES_Ma:

; 1035 : 	for (p = base; strcmp(p, "THIS_IS_THE_END_OF_THE_FUNCTION") != 0; ++p)

	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN112@CPU_DES_Ma
	test	dl, dl
	je	SHORT $LN113@CPU_DES_Ma
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN112@CPU_DES_Ma
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL111@CPU_DES_Ma
$LN113@CPU_DES_Ma:
	xor	eax, eax
	jmp	SHORT $LN114@CPU_DES_Ma
$LN112@CPU_DES_Ma:
	sbb	eax, eax
	or	eax, 1
$LN114@CPU_DES_Ma:
	test	eax, eax
	jne	SHORT $LL13@CPU_DES_Ma
$LN11@CPU_DES_Ma:

; 1037 : 	context.crypt25 = (void (*)(void *))VirtualAllocEx(GetCurrentProcess(), 0, functionSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );

	push	64					; 00000040H
	push	4096					; 00001000H
	push	edi
	push	0
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__VirtualAllocEx@20

; 1038 : 	memcpy(context.crypt25, base, functionSize);

	push	edi
	push	DWORD PTR _base$1$[ebp]
	mov	DWORD PTR _context$[ebp+28928], eax
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1039 : #endif
; 1040 : 
; 1041 : 	for (int32_t i = 0; i < 0x40; ++i)

	xor	eax, eax
	npad	8
$LL90@CPU_DES_Ma:

; 1042 : 		context.tripcodeChunkBitmap[0][i] = context.tripcodeChunkBitmap[1][i] = context.tripcodeChunkBitmap[2][i] = context.tripcodeChunkBitmap[3][i] = context.tripcodeChunkBitmap[4][i] = 0; 

	mov	BYTE PTR _context$[ebp+eax+30220], 0
	mov	BYTE PTR _context$[ebp+eax+30156], 0
	mov	BYTE PTR _context$[ebp+eax+30092], 0
	mov	BYTE PTR _context$[ebp+eax+30028], 0
	mov	BYTE PTR _context$[ebp+eax+29964], 0
	inc	eax
	cmp	eax, 64					; 00000040H
	jl	SHORT $LL90@CPU_DES_Ma

; 1043 : 	for (int32_t i = 0; i < numTripcodeChunk; ++i) {

	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ecx, ecx
	test	edx, edx
	je	SHORT $LN80@CPU_DES_Ma
	mov	esi, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	npad	3
$LL7@CPU_DES_Ma:

; 1044 : 		context.tripcodeChunkBitmap[4][(tripcodeChunkArray[i] >> (6 * 4)) & 0x3f] = 0x1;

	movzx	eax, BYTE PTR [esi+ecx*4+3]
	and	eax, 63					; 0000003fH
	mov	BYTE PTR _context$[ebp+eax+30220], 1

; 1045 : 		context.tripcodeChunkBitmap[3][(tripcodeChunkArray[i] >> (6 * 3)) & 0x3f] = 0x1;

	mov	eax, DWORD PTR [esi+ecx*4]
	shr	eax, 18					; 00000012H
	and	eax, 63					; 0000003fH
	mov	BYTE PTR _context$[ebp+eax+30156], 1

; 1046 : 		context.tripcodeChunkBitmap[2][(tripcodeChunkArray[i] >> (6 * 2)) & 0x3f] = 0x1;

	mov	eax, DWORD PTR [esi+ecx*4]
	shr	eax, 12					; 0000000cH
	and	eax, 63					; 0000003fH
	mov	BYTE PTR _context$[ebp+eax+30092], 1

; 1047 : 		context.tripcodeChunkBitmap[1][(tripcodeChunkArray[i] >> (6 * 1)) & 0x3f] = 0x1;

	mov	eax, DWORD PTR [esi+ecx*4]
	shr	eax, 6
	and	eax, 63					; 0000003fH
	mov	BYTE PTR _context$[ebp+eax+30028], 1

; 1048 : 		context.tripcodeChunkBitmap[0][(tripcodeChunkArray[i] >> (6 * 0)) & 0x3f] = 0x1;

	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	and	eax, 63					; 0000003fH
	mov	BYTE PTR _context$[ebp+eax+29964], 1
	cmp	ecx, edx
	jb	SHORT $LL7@CPU_DES_Ma
$LN80@CPU_DES_Ma:

; 1049 : 	}
; 1050 : 
; 1051 : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN3@CPU_DES_Ma
	mov	esi, DWORD PTR __imp__Sleep@4
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL35@CPU_DES_Ma:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN34@CPU_DES_Ma
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN49@CPU_DES_Ma

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL35@CPU_DES_Ma
$LN49@CPU_DES_Ma:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL35@CPU_DES_Ma
$LN34@CPU_DES_Ma:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1633 : 	ret = isSearchPaused;

	mov	eax, DWORD PTR ?isSearchPaused@@3HA	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h

; 1052 : 		while (GetPauseState() && !GetTerminationState())

	test	eax, eax
	je	SHORT $LN1@CPU_DES_Ma
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN1@CPU_DES_Ma

; 1053 : 			Sleep(PAUSE_INTERVAL);

	push	100					; 00000064H
	call	esi
	jmp	SHORT $LL35@CPU_DES_Ma
$LN1@CPU_DES_Ma:

; 1054 : 
; 1055 : 		uint32_t numGeneratedTripcodes = SearchForTripcodes(&context);

	lea	ecx, DWORD PTR _context$[ebp]
	call	?SearchForTripcodes@@YAIPAUDES_Context@@@Z ; SearchForTripcodes

; 1056 : 		AddToNumGeneratedTripcodesByCPU(numGeneratedTripcodes);

	mov	ecx, eax
	call	?AddToNumGeneratedTripcodesByCPU@@YAXI@Z ; AddToNumGeneratedTripcodesByCPU
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	je	SHORT $LL35@CPU_DES_Ma
$LN3@CPU_DES_Ma:

; 1057 : 	}
; 1058 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?CPU_DES_MainLoop_AVX2@@YAXXZ ENDP			; CPU_DES_MainLoop_AVX2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _posix_category, eax
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _errno_ecat, eax
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	call	?system_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::system_category
	mov	DWORD PTR _native_ecat, eax
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_RewriteCrypt25@@YAXPAUDES_Context@@@Z
_TEXT	SEGMENT
_context$GSCopy$1$ = -340				; size = 4
_rewriteTable$ = -336					; size = 332
__$ArrayPad$ = -4					; size = 4
?DES_RewriteCrypt25@@YAXPAUDES_Context@@@Z PROC		; DES_RewriteCrypt25, COMDAT
; _context$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movdqa	xmm2, XMMWORD PTR __xmm@00000003000000020000000100000000
	xorps	xmm3, xmm3
	movdqa	xmm4, XMMWORD PTR __xmm@00000004000000040000000400000004
	movdqa	xmm0, xmm2
	paddd	xmm0, xmm3
	mov	edx, ecx

; 211  : 	// Rewrite the assembly function.
; 212  : #define SKIP 0x100
; 213  : 	int32_t rewriteTable[] = {
; 214  : 		0,    1,    2,    3,    4,    5,
; 215  : 		6,    7,    8,    9,    10,   11,
; 216  : 		SKIP, SKIP, SKIP, SKIP, SKIP, SKIP,
; 217  : 		SKIP, SKIP, SKIP, SKIP, SKIP,
; 218  : 		24,   25,   26,   27,   28,   29,
; 219  : 		30,   31,   32,   33,   34,   35,
; 220  : 		SKIP, SKIP, SKIP, SKIP, SKIP, 
; 221  : 		SKIP, SKIP, SKIP, SKIP, SKIP, SKIP,
; 222  : 
; 223  : 		48,   49,   50,   51,   52,   53,
; 224  : 		54,   55,   56,   57,   58,   59,
; 225  : 		SKIP, SKIP, SKIP, SKIP, SKIP, SKIP,   
; 226  : 		SKIP, SKIP, SKIP, SKIP, SKIP, SKIP,
; 227  : 		72,   73,   74,   75,   76,   77,
; 228  : 		78,   79,   80,   81,   82,   83,
; 229  : 		-1
; 230  : 	};

	movdqu	XMMWORD PTR _rewriteTable$[ebp], xmm0
	mov	DWORD PTR _context$GSCopy$1$[ebp], edx
	mov	eax, 8
	movdqa	xmm0, xmm2
	paddd	xmm0, xmm4
	movdqu	XMMWORD PTR _rewriteTable$[ebp+16], xmm0
$LL49@DES_Rewrit:
	mov	DWORD PTR _rewriteTable$[ebp+eax*4], eax
	inc	eax
	cmp	eax, 12					; 0000000cH
	jl	SHORT $LL49@DES_Rewrit
	movdqa	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	mov	ecx, 8
	movdqu	XMMWORD PTR _rewriteTable$[ebp+48], xmm0
	mov	DWORD PTR _rewriteTable$[ebp+80], 256	; 00000100H
	movdqa	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	movdqu	XMMWORD PTR _rewriteTable$[ebp+64], xmm0
	mov	DWORD PTR _rewriteTable$[ebp+84], 256	; 00000100H
	movdqa	xmm0, xmm2
	mov	DWORD PTR _rewriteTable$[ebp+88], 256	; 00000100H
	paddd	xmm0, xmm3
	paddd	xmm0, XMMWORD PTR __xmm@00000018000000180000001800000018
	movdqu	XMMWORD PTR _rewriteTable$[ebp+92], xmm0
	movdqa	xmm0, xmm2
	paddd	xmm0, xmm4
	paddd	xmm0, XMMWORD PTR __xmm@00000018000000180000001800000018
	movdqu	XMMWORD PTR _rewriteTable$[ebp+108], xmm0
$LL51@DES_Rewrit:
	lea	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _rewriteTable$[ebp+ecx*4+92], eax
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL51@DES_Rewrit
	movdqa	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	mov	ecx, 8
	movdqu	XMMWORD PTR _rewriteTable$[ebp+140], xmm0
	mov	DWORD PTR _rewriteTable$[ebp+172], 256	; 00000100H
	movdqa	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	movdqu	XMMWORD PTR _rewriteTable$[ebp+156], xmm0
	mov	DWORD PTR _rewriteTable$[ebp+176], 256	; 00000100H
	movdqa	xmm0, xmm2
	mov	DWORD PTR _rewriteTable$[ebp+180], 256	; 00000100H
	paddd	xmm0, xmm3
	paddd	xmm0, XMMWORD PTR __xmm@00000030000000300000003000000030
	movdqu	XMMWORD PTR _rewriteTable$[ebp+184], xmm0
	movdqa	xmm0, xmm2
	paddd	xmm0, xmm4
	paddd	xmm0, XMMWORD PTR __xmm@00000030000000300000003000000030
	movdqu	XMMWORD PTR _rewriteTable$[ebp+200], xmm0
	npad	10
$LL53@DES_Rewrit:
	lea	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR _rewriteTable$[ebp+ecx*4+184], eax
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL53@DES_Rewrit
	movdqa	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	mov	ecx, 8
	movdqu	XMMWORD PTR _rewriteTable$[ebp+232], xmm0
	movdqu	XMMWORD PTR _rewriteTable$[ebp+248], xmm0
	movdqu	XMMWORD PTR _rewriteTable$[ebp+264], xmm0
	movdqa	xmm0, xmm2
	paddd	xmm2, xmm4
	paddd	xmm2, XMMWORD PTR __xmm@00000048000000480000004800000048
	paddd	xmm0, xmm3
	paddd	xmm0, XMMWORD PTR __xmm@00000048000000480000004800000048
	movdqu	XMMWORD PTR _rewriteTable$[ebp+280], xmm0
	movdqu	XMMWORD PTR _rewriteTable$[ebp+296], xmm2
$LL55@DES_Rewrit:
	lea	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _rewriteTable$[ebp+ecx*4+280], eax
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL55@DES_Rewrit

; 231  : 	unsigned char *p = (unsigned char *)(context->crypt25);

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx+28928]

; 232  : 	unsigned char instructionBytes[3];
; 233  : 
; 234  : 	// Rewrite "movdqa/vmovdqa/movaps xmm*, [rbx + 0xffffffff]" based on context->ExpansionFunction[].
; 235  : 	for (int32_t i = 0; rewriteTable[i] >= 0; ++i) {

	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR _rewriteTable$[ebp]
	mov	DWORD PTR _rewriteTable$[ebp+328], -1
	test	edi, edi
	js	$LN100@DES_Rewrit
	npad	1
$LL20@DES_Rewrit:

; 236  : 		if (context->useAVX) {

	cmp	DWORD PTR [edx+28932], 0
	je	SHORT $LN17@DES_Rewrit
	npad	7
$LL16@DES_Rewrit:

; 237  : 			// vmovdqa xmm*, [rbx + 0xffffffff]
; 238  : 			for (; 
; 239  : 					*(p + 0) != 0xc5
; 240  : 				 || *(p + 1) != 0xf9
; 241  : 				 || *(p + 2) != 0x6f
; 242  : 				 || (   *(p + 3) != 0x83
; 243  : 					 && *(p + 3) != 0x8b
; 244  : 					 && *(p + 3) != 0x93
; 245  : 					 && *(p + 3) != 0x9b
; 246  : 					 && *(p + 3) != 0xa3
; 247  : 					 && *(p + 3) != 0xab);
; 248  : 				 ++p)

	cmp	BYTE PTR [esi], 197			; 000000c5H
	jne	SHORT $LN15@DES_Rewrit
	cmp	BYTE PTR [esi+1], 249			; 000000f9H
	jne	SHORT $LN15@DES_Rewrit
	cmp	BYTE PTR [esi+2], 111			; 0000006fH
	jne	SHORT $LN15@DES_Rewrit
	mov	al, BYTE PTR [esi+3]
	cmp	al, 131					; 00000083H
	je	SHORT $LN14@DES_Rewrit
	cmp	al, 139					; 0000008bH
	je	SHORT $LN14@DES_Rewrit
	cmp	al, 147					; 00000093H
	je	SHORT $LN14@DES_Rewrit
	cmp	al, 155					; 0000009bH
	je	SHORT $LN14@DES_Rewrit
	cmp	al, 163					; 000000a3H
	je	SHORT $LN14@DES_Rewrit
	cmp	al, 171					; 000000abH
	je	SHORT $LN14@DES_Rewrit
$LN15@DES_Rewrit:
	inc	esi
	jmp	SHORT $LL16@DES_Rewrit
$LN14@DES_Rewrit:

; 249  : 				;
; 250  : 			p+= 4;

	add	esi, 4
	jmp	SHORT $LN6@DES_Rewrit
$LN17@DES_Rewrit:

; 251  : 		} else if (IsCPUBasedOnNehalemMicroarchitecture()) {

	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture
	test	eax, eax
	je	SHORT $LL98@DES_Rewrit
	npad	3
$LL10@DES_Rewrit:

; 252  : 			// movdqa xmm*, [rbx + 0xffffffff]
; 253  : 			for (; 
; 254  : 					*(p + 0) != 0x66
; 255  : 				 || *(p + 1) != 0x0f
; 256  : 				 || *(p + 2) != 0x6f
; 257  : 				 || (   *(p + 3) != 0x83
; 258  : 					 && *(p + 3) != 0x8b
; 259  : 					 && *(p + 3) != 0x93
; 260  : 					 && *(p + 3) != 0x9b
; 261  : 					 && *(p + 3) != 0xa3
; 262  : 					 && *(p + 3) != 0xab);
; 263  : 				 ++p)

	cmp	BYTE PTR [esi], 102			; 00000066H
	jne	SHORT $LN9@DES_Rewrit
	cmp	BYTE PTR [esi+1], 15			; 0000000fH
	jne	SHORT $LN9@DES_Rewrit
	cmp	BYTE PTR [esi+2], 111			; 0000006fH
	jne	SHORT $LN9@DES_Rewrit
	mov	al, BYTE PTR [esi+3]
	cmp	al, 131					; 00000083H
	je	SHORT $LN8@DES_Rewrit
	cmp	al, 139					; 0000008bH
	je	SHORT $LN8@DES_Rewrit
	cmp	al, 147					; 00000093H
	je	SHORT $LN8@DES_Rewrit
	cmp	al, 155					; 0000009bH
	je	SHORT $LN8@DES_Rewrit
	cmp	al, 163					; 000000a3H
	je	SHORT $LN8@DES_Rewrit
	cmp	al, 171					; 000000abH
	je	SHORT $LN8@DES_Rewrit
$LN9@DES_Rewrit:
	inc	esi
	jmp	SHORT $LL10@DES_Rewrit
$LN8@DES_Rewrit:

; 264  : 				;
; 265  : 			p+= 4;

	add	esi, 4
	jmp	SHORT $LN102@DES_Rewrit
$LL98@DES_Rewrit:

; 266  : 		} else {
; 267  : 			// movaps xmm*, [rbx + 0xffffffff]
; 268  : 			for (; 
; 269  : 					*(p + 0) != 0x0f
; 270  : 				 || *(p + 1) != 0x28
; 271  : 				 || (   *(p + 2) != 0x83
; 272  : 					 && *(p + 2) != 0x8b
; 273  : 					 && *(p + 2) != 0x93
; 274  : 					 && *(p + 2) != 0x9b
; 275  : 					 && *(p + 2) != 0xa3
; 276  : 					 && *(p + 2) != 0xab);
; 277  : 				 ++p)

	cmp	BYTE PTR [esi], 15			; 0000000fH
	jne	SHORT $LN4@DES_Rewrit
	cmp	BYTE PTR [esi+1], 40			; 00000028H
	jne	SHORT $LN4@DES_Rewrit
	mov	al, BYTE PTR [esi+2]
	cmp	al, 131					; 00000083H
	je	SHORT $LN3@DES_Rewrit
	cmp	al, 139					; 0000008bH
	je	SHORT $LN3@DES_Rewrit
	cmp	al, 147					; 00000093H
	je	SHORT $LN3@DES_Rewrit
	cmp	al, 155					; 0000009bH
	je	SHORT $LN3@DES_Rewrit
	cmp	al, 163					; 000000a3H
	je	SHORT $LN3@DES_Rewrit
	cmp	al, 171					; 000000abH
	je	SHORT $LN3@DES_Rewrit
$LN4@DES_Rewrit:
	inc	esi
	jmp	SHORT $LL98@DES_Rewrit
$LN3@DES_Rewrit:

; 278  : 				;
; 279  : 			p += 3;

	add	esi, 3
$LN102@DES_Rewrit:
	mov	edx, DWORD PTR _context$GSCopy$1$[ebp]
$LN6@DES_Rewrit:

; 280  : 		}
; 281  : 		// printf("offset = %d\n", (unsigned char *)p - (unsigned char *)(context->crypt25));
; 282  : 		if (rewriteTable[i] != SKIP)

	cmp	edi, 256				; 00000100H
	je	SHORT $LN1@DES_Rewrit

; 283  : 			*(__int32 *)p = context->expansionFunction[rewriteTable[i]] * 8;

	movzx	eax, BYTE PTR [edi+edx]
	shl	eax, 3
	mov	DWORD PTR [esi], eax
$LN1@DES_Rewrit:

; 232  : 	unsigned char instructionBytes[3];
; 233  : 
; 234  : 	// Rewrite "movdqa/vmovdqa/movaps xmm*, [rbx + 0xffffffff]" based on context->ExpansionFunction[].
; 235  : 	for (int32_t i = 0; rewriteTable[i] >= 0; ++i) {

	mov	edi, DWORD PTR _rewriteTable$[ebp+ebx*4+4]
	inc	ebx

; 284  : 		p += 4;

	add	esi, 4
	test	edi, edi
	jns	$LL20@DES_Rewrit
$LN100@DES_Rewrit:

; 285  : 	}
; 286  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DES_RewriteCrypt25@@YAXPAUDES_Context@@@Z ENDP		; DES_RewriteCrypt25
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_RewriteCrypt25_x64_AVX2@@YAXPAUDES_Context@@@Z
_TEXT	SEGMENT
_rewriteTable$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?DES_RewriteCrypt25_x64_AVX2@@YAXPAUDES_Context@@@Z PROC ; DES_RewriteCrypt25_x64_AVX2, COMDAT
; _context$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movdqa	xmm3, XMMWORD PTR __xmm@00000003000000020000000100000000
	xorps	xmm1, xmm1
	movdqa	xmm2, XMMWORD PTR __xmm@00000004000000040000000400000004
	movdqa	xmm0, xmm1
	paddd	xmm0, xmm3

; 289  : 	// Rewrite the assembly function.
; 290  : #define SKIP 0x100
; 291  : 	int32_t rewriteTable[] = {
; 292  : 		0,    1,    2,    3,    4,    5,
; 293  : 		6,    7,    8,    9,    10,   11,
; 294  : 		24,   25,   26,   27,   28,   29,
; 295  : 		30,   31,   32,   33,   34,   35,
; 296  : 		-1
; 297  : 	};

	mov	eax, 8
	movdqu	XMMWORD PTR _rewriteTable$[ebp], xmm0
	push	esi
	movdqa	xmm0, xmm2
	mov	esi, ecx
	paddd	xmm0, xmm3
	movdqu	XMMWORD PTR _rewriteTable$[ebp+16], xmm0
$LL35@DES_Rewrit:
	mov	DWORD PTR _rewriteTable$[ebp+eax*4], eax
	inc	eax
	cmp	eax, 12					; 0000000cH
	jl	SHORT $LL35@DES_Rewrit
	paddd	xmm1, xmm3
	paddd	xmm2, xmm3
	paddd	xmm1, XMMWORD PTR __xmm@00000018000000180000001800000018
	mov	ecx, 8
	paddd	xmm2, XMMWORD PTR __xmm@00000018000000180000001800000018
	movdqu	XMMWORD PTR _rewriteTable$[ebp+48], xmm1
	movdqu	XMMWORD PTR _rewriteTable$[ebp+64], xmm2
$LL37@DES_Rewrit:
	lea	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _rewriteTable$[ebp+ecx*4+48], eax
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL37@DES_Rewrit

; 298  : 	unsigned char *p = (unsigned char *)(context->crypt25);
; 299  : 	unsigned char instructionBytes[3];
; 300  : 
; 301  : 	// Rewrite "vpxor xmm*/ymm*, [rbx + 0xffffffff]" based on context->ExpansionFunction[].
; 302  : 	for (int32_t i = 0; rewriteTable[i] >= 0; ++i) {

	cmp	DWORD PTR _rewriteTable$[ebp], 0
	mov	eax, DWORD PTR [esi+28928]
	mov	DWORD PTR _rewriteTable$[ebp+96], -1
	jl	$LN54@DES_Rewrit

; 289  : 	// Rewrite the assembly function.
; 290  : #define SKIP 0x100
; 291  : 	int32_t rewriteTable[] = {
; 292  : 		0,    1,    2,    3,    4,    5,
; 293  : 		6,    7,    8,    9,    10,   11,
; 294  : 		24,   25,   26,   27,   28,   29,
; 295  : 		30,   31,   32,   33,   34,   35,
; 296  : 		-1
; 297  : 	};

	lea	edx, DWORD PTR _rewriteTable$[ebp]
	npad	3
$LL22@DES_Rewrit:

; 303  : 		/*
; 304  : 			c5 f9 ef 83 ff ff ff ff 
; 305  : 			c5 f1 ef 8b ff ff ff ff 
; 306  : 			c5 e9 ef 93 ff ff ff ff 
; 307  : 			c5 e1 ef 9b ff ff ff ff 
; 308  : 			c5 d9 ef a3 ff ff ff ff 
; 309  : 			c5 d1 ef ab ff ff ff ff 
; 310  : 
; 311  : 			c5 c9 ef b3 ff ff ff ff 
; 312  : 			c5 c1 ef bb ff ff ff ff 
; 313  : 			c5 39 ef 83 ff ff ff ff 
; 314  : 			c5 31 ef 8b ff ff ff ff 
; 315  : 			c5 29 ef 93 ff ff ff ff xmm10
; 316  : 			c5 21 ef 9b ff ff ff ff 
; 317  : 			c5 19 ef a3 ff ff ff ff 
; 318  : 			c5 11 ef ab ff ff ff ff 
; 319  : 			c5 09 ef b3 ff ff ff ff 
; 320  : 			c5 01 ef bb ff ff ff ff
; 321  : 		*/
; 322  : 		/*
; 323  : 			c5 fd ef 83 ff ff ff ff 
; 324  : 			c5 f5 ef 8b ff ff ff ff 
; 325  : 			c5 ed ef 93 ff ff ff ff 
; 326  : 			c5 e5 ef 9b ff ff ff ff 
; 327  : 			c5 dd ef a3 ff ff ff ff 
; 328  : 			c5 d5 ef ab ff ff ff ff 
; 329  : 
; 330  : 			c5 cd ef b3 ff ff ff ff 
; 331  : 			c5 c5 ef bb ff ff ff ff 
; 332  : 			c5 3d ef 83 ff ff ff ff 
; 333  : 			c5 35 ef 8b ff ff ff ff 
; 334  : 			c5 2d ef 93 ff ff ff ff ymm10
; 335  : 			c5 25 ef 9b ff ff ff ff 
; 336  : 			c5 1d ef a3 ff ff ff ff 
; 337  : 			c5 15 ef ab ff ff ff ff 
; 338  : 			c5 0d ef b3 ff ff ff ff 
; 339  : 			c5 05 ef bb ff ff ff ff 
; 340  : 		*/
; 341  : 		for (; 
; 342  : 				   *(p + 0) != 0xc5
; 343  : 				|| *(p + 2) != 0xef
; 344  : 				|| !(   (*(p + 1) == 0xf9 && *(p + 3) == 0x83)
; 345  : 					 || (*(p + 1) == 0xf1 && *(p + 3) == 0x8b)
; 346  : 					 || (*(p + 1) == 0xe9 && *(p + 3) == 0x93)
; 347  : 					 || (*(p + 1) == 0xe1 && *(p + 3) == 0x9b)
; 348  : 					 || (*(p + 1) == 0xd9 && *(p + 3) == 0xa3)
; 349  : 					 || (*(p + 1) == 0xd1 && *(p + 3) == 0xab)
; 350  : 					 || (*(p + 1) == 0x29 && *(p + 3) == 0x93)
; 351  : 					 
; 352  : 					 || (*(p + 1) == 0xfd && *(p + 3) == 0x83)
; 353  : 					 || (*(p + 1) == 0xf5 && *(p + 3) == 0x8b)
; 354  : 					 || (*(p + 1) == 0xed && *(p + 3) == 0x93)
; 355  : 					 || (*(p + 1) == 0xe5 && *(p + 3) == 0x9b)
; 356  : 					 || (*(p + 1) == 0xdd && *(p + 3) == 0xa3)
; 357  : 					 || (*(p + 1) == 0xd5 && *(p + 3) == 0xab)
; 358  : 					 || (*(p + 1) == 0x2d && *(p + 3) == 0x93));
; 359  : 				++p)

	cmp	BYTE PTR [eax], 197			; 000000c5H
	jne	$LN18@DES_Rewrit
	cmp	BYTE PTR [eax+2], 239			; 000000efH
	jne	$LN18@DES_Rewrit
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 249					; 000000f9H
	jne	SHORT $LN15@DES_Rewrit
	cmp	BYTE PTR [eax+3], 131			; 00000083H
	je	$LN17@DES_Rewrit
$LN15@DES_Rewrit:
	cmp	cl, 241					; 000000f1H
	jne	SHORT $LN14@DES_Rewrit
	cmp	BYTE PTR [eax+3], 139			; 0000008bH
	je	$LN17@DES_Rewrit
$LN14@DES_Rewrit:
	cmp	cl, 233					; 000000e9H
	jne	SHORT $LN13@DES_Rewrit
	cmp	BYTE PTR [eax+3], 147			; 00000093H
	je	SHORT $LN17@DES_Rewrit
$LN13@DES_Rewrit:
	cmp	cl, 225					; 000000e1H
	jne	SHORT $LN12@DES_Rewrit
	cmp	BYTE PTR [eax+3], 155			; 0000009bH
	je	SHORT $LN17@DES_Rewrit
$LN12@DES_Rewrit:
	cmp	cl, 217					; 000000d9H
	jne	SHORT $LN11@DES_Rewrit
	cmp	BYTE PTR [eax+3], 163			; 000000a3H
	je	SHORT $LN17@DES_Rewrit
$LN11@DES_Rewrit:
	cmp	cl, 209					; 000000d1H
	jne	SHORT $LN10@DES_Rewrit
	cmp	BYTE PTR [eax+3], 171			; 000000abH
	je	SHORT $LN17@DES_Rewrit
$LN10@DES_Rewrit:
	cmp	cl, 41					; 00000029H
	jne	SHORT $LN9@DES_Rewrit
	cmp	BYTE PTR [eax+3], 147			; 00000093H
	je	SHORT $LN17@DES_Rewrit
$LN9@DES_Rewrit:
	cmp	cl, 253					; 000000fdH
	jne	SHORT $LN8@DES_Rewrit
	cmp	BYTE PTR [eax+3], 131			; 00000083H
	je	SHORT $LN17@DES_Rewrit
$LN8@DES_Rewrit:
	cmp	cl, 245					; 000000f5H
	jne	SHORT $LN7@DES_Rewrit
	cmp	BYTE PTR [eax+3], 139			; 0000008bH
	je	SHORT $LN17@DES_Rewrit
$LN7@DES_Rewrit:
	cmp	cl, 237					; 000000edH
	jne	SHORT $LN6@DES_Rewrit
	cmp	BYTE PTR [eax+3], 147			; 00000093H
	je	SHORT $LN17@DES_Rewrit
$LN6@DES_Rewrit:
	cmp	cl, 229					; 000000e5H
	jne	SHORT $LN5@DES_Rewrit
	cmp	BYTE PTR [eax+3], 155			; 0000009bH
	je	SHORT $LN17@DES_Rewrit
$LN5@DES_Rewrit:
	cmp	cl, 221					; 000000ddH
	jne	SHORT $LN4@DES_Rewrit
	cmp	BYTE PTR [eax+3], 163			; 000000a3H
	je	SHORT $LN17@DES_Rewrit
$LN4@DES_Rewrit:
	cmp	cl, 213					; 000000d5H
	jne	SHORT $LN3@DES_Rewrit
	cmp	BYTE PTR [eax+3], 171			; 000000abH
	je	SHORT $LN17@DES_Rewrit
$LN3@DES_Rewrit:
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN18@DES_Rewrit
	cmp	BYTE PTR [eax+3], 147			; 00000093H
	jne	SHORT $LN18@DES_Rewrit
$LN17@DES_Rewrit:

; 360  : 			;
; 361  : 		p+= 4;
; 362  : 
; 363  : 		if (rewriteTable[i] != SKIP)

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 256				; 00000100H
	je	SHORT $LN1@DES_Rewrit

; 364  : 			*(__int32 *)p = context->expansionFunction[rewriteTable[i]] * (VECTOR_SIZE / 2);

	movzx	ecx, BYTE PTR [ecx+esi]
	shl	ecx, 4
	mov	DWORD PTR [eax+4], ecx
$LN1@DES_Rewrit:

; 365  : 		p += 4;

	add	edx, 4
	add	eax, 8
	cmp	DWORD PTR [edx], 0
	jge	$LL22@DES_Rewrit
$LN54@DES_Rewrit:

; 366  : 	}
; 367  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@DES_Rewrit:

; 303  : 		/*
; 304  : 			c5 f9 ef 83 ff ff ff ff 
; 305  : 			c5 f1 ef 8b ff ff ff ff 
; 306  : 			c5 e9 ef 93 ff ff ff ff 
; 307  : 			c5 e1 ef 9b ff ff ff ff 
; 308  : 			c5 d9 ef a3 ff ff ff ff 
; 309  : 			c5 d1 ef ab ff ff ff ff 
; 310  : 
; 311  : 			c5 c9 ef b3 ff ff ff ff 
; 312  : 			c5 c1 ef bb ff ff ff ff 
; 313  : 			c5 39 ef 83 ff ff ff ff 
; 314  : 			c5 31 ef 8b ff ff ff ff 
; 315  : 			c5 29 ef 93 ff ff ff ff xmm10
; 316  : 			c5 21 ef 9b ff ff ff ff 
; 317  : 			c5 19 ef a3 ff ff ff ff 
; 318  : 			c5 11 ef ab ff ff ff ff 
; 319  : 			c5 09 ef b3 ff ff ff ff 
; 320  : 			c5 01 ef bb ff ff ff ff
; 321  : 		*/
; 322  : 		/*
; 323  : 			c5 fd ef 83 ff ff ff ff 
; 324  : 			c5 f5 ef 8b ff ff ff ff 
; 325  : 			c5 ed ef 93 ff ff ff ff 
; 326  : 			c5 e5 ef 9b ff ff ff ff 
; 327  : 			c5 dd ef a3 ff ff ff ff 
; 328  : 			c5 d5 ef ab ff ff ff ff 
; 329  : 
; 330  : 			c5 cd ef b3 ff ff ff ff 
; 331  : 			c5 c5 ef bb ff ff ff ff 
; 332  : 			c5 3d ef 83 ff ff ff ff 
; 333  : 			c5 35 ef 8b ff ff ff ff 
; 334  : 			c5 2d ef 93 ff ff ff ff ymm10
; 335  : 			c5 25 ef 9b ff ff ff ff 
; 336  : 			c5 1d ef a3 ff ff ff ff 
; 337  : 			c5 15 ef ab ff ff ff ff 
; 338  : 			c5 0d ef b3 ff ff ff ff 
; 339  : 			c5 05 ef bb ff ff ff ff 
; 340  : 		*/
; 341  : 		for (; 
; 342  : 				   *(p + 0) != 0xc5
; 343  : 				|| *(p + 2) != 0xef
; 344  : 				|| !(   (*(p + 1) == 0xf9 && *(p + 3) == 0x83)
; 345  : 					 || (*(p + 1) == 0xf1 && *(p + 3) == 0x8b)
; 346  : 					 || (*(p + 1) == 0xe9 && *(p + 3) == 0x93)
; 347  : 					 || (*(p + 1) == 0xe1 && *(p + 3) == 0x9b)
; 348  : 					 || (*(p + 1) == 0xd9 && *(p + 3) == 0xa3)
; 349  : 					 || (*(p + 1) == 0xd1 && *(p + 3) == 0xab)
; 350  : 					 || (*(p + 1) == 0x29 && *(p + 3) == 0x93)
; 351  : 					 
; 352  : 					 || (*(p + 1) == 0xfd && *(p + 3) == 0x83)
; 353  : 					 || (*(p + 1) == 0xf5 && *(p + 3) == 0x8b)
; 354  : 					 || (*(p + 1) == 0xed && *(p + 3) == 0x93)
; 355  : 					 || (*(p + 1) == 0xe5 && *(p + 3) == 0x9b)
; 356  : 					 || (*(p + 1) == 0xdd && *(p + 3) == 0xa3)
; 357  : 					 || (*(p + 1) == 0xd5 && *(p + 3) == 0xab)
; 358  : 					 || (*(p + 1) == 0x2d && *(p + 3) == 0x93));
; 359  : 				++p)

	inc	eax
	jmp	$LL22@DES_Rewrit
?DES_RewriteCrypt25_x64_AVX2@@YAXPAUDES_Context@@@Z ENDP ; DES_RewriteCrypt25_x64_AVX2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_SetSalt@@YAXPAUDES_Context@@H@Z
_TEXT	SEGMENT
?DES_SetSalt@@YAXPAUDES_Context@@H@Z PROC		; DES_SetSalt, COMDAT
; _context$ = ecx
; _salt$ = edx

; 370  : {

	push	ebx
	push	esi
	push	edi

; 371  : 	int32_t mask;
; 372  : 	int32_t src, dst;
; 373  : 
; 374  : 	mask = 1;

	mov	esi, 1
	mov	edi, ecx
	mov	ebx, edx

; 375  : 	for (dst = 0; dst < 48; dst++) {

	xor	eax, eax
	mov	ecx, esi
$LL10@DES_SetSal:

; 376  : 		if (dst == 24) mask = 1;

	cmp	eax, 24					; 00000018H
	cmove	esi, ecx

; 377  : 
; 378  : 		if (salt & mask) {

	test	esi, ebx
	je	SHORT $LN6@DES_SetSal

; 379  : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	cmp	eax, 24					; 00000018H
	jge	SHORT $LN5@DES_SetSal
	lea	ecx, DWORD PTR [eax+24]
	jmp	SHORT $LN3@DES_SetSal
$LN5@DES_SetSal:
	lea	ecx, DWORD PTR [eax-24]
	jmp	SHORT $LN3@DES_SetSal
$LN6@DES_SetSal:

; 380  : 		} else src = dst;

	mov	ecx, eax
$LN3@DES_SetSal:

; 381  : 
; 382  : 		context->expansionFunction[dst     ] = expansionTable[src];

	mov	dl, BYTE PTR ?expansionTable@@3QBEB[ecx]

; 383  : 		context->expansionFunction[dst + 48] = expansionTable[src] + 32;
; 384  : 
; 385  : #ifdef USE_ASSEMBLY_FUNCTION
; 386  : 		// Multiply the values for the assembly version of DES_Crypt25().
; 387  : 		context->expansionFunction[dst     ] *= 2;
; 388  : 		context->expansionFunction[dst + 48] *= 2;
; 389  : #endif
; 390  : 
; 391  : 		mask <<= 1;

	add	esi, esi
	mov	cl, dl
	add	dl, 32					; 00000020H
	add	cl, cl
	add	dl, dl
	mov	BYTE PTR [eax+edi], cl
	mov	ecx, 1
	mov	BYTE PTR [edi+eax+48], dl
	inc	eax
	cmp	eax, 48					; 00000030H
	jl	SHORT $LL10@DES_SetSal

; 392  : 	}
; 393  : 
; 394  : #ifdef USE_ASSEMBLY_FUNCTION
; 395  : 	if (context->useAVX2) {

	cmp	DWORD PTR [edi+28936], 0

; 396  : 		DES_RewriteCrypt25_x64_AVX2(context);

	mov	ecx, edi
	pop	edi
	pop	esi
	pop	ebx
	jne	?DES_RewriteCrypt25_x64_AVX2@@YAXPAUDES_Context@@@Z ; DES_RewriteCrypt25_x64_AVX2

; 397  : 	} else {
; 398  : 		DES_RewriteCrypt25(context);

	jmp	?DES_RewriteCrypt25@@YAXPAUDES_Context@@@Z ; DES_RewriteCrypt25
?DES_SetSalt@@YAXPAUDES_Context@@H@Z ENDP		; DES_SetSalt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_Crypt@@YAXPAUDES_Context@@@Z
_TEXT	SEGMENT
?DES_Crypt@@YAXPAUDES_Context@@@Z PROC			; DES_Crypt, COMDAT
; _context$ = ecx

; 449  : {

	mov	edx, ecx

; 450  : 	if (!context->useAVX2) {

	cmp	DWORD PTR [edx+28936], 0
	jne	$LN22@DES_Crypt

; 451  : 		for (int32_t i = 0; i < 0x300; ++i)

	push	esi
	xor	esi, esi
	lea	ecx, DWORD PTR [edx+128]
	npad	8
$LL9@DES_Crypt:

; 452  : 			context->expandedKeySchedule[i] = context->keys[keySchedule[i]];

	movzx	eax, BYTE PTR _keySchedule[esi]
	lea	ecx, DWORD PTR [ecx+192]
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-224], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movzx	eax, BYTE PTR _keySchedule[esi+1]
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	XMMWORD PTR [ecx-208], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-192], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movzx	eax, BYTE PTR _keySchedule[esi+2]
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	XMMWORD PTR [ecx-176], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-160], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movzx	eax, BYTE PTR _keySchedule[esi+3]
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	XMMWORD PTR [ecx-144], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-128], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movzx	eax, BYTE PTR _keySchedule[esi+4]
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	XMMWORD PTR [ecx-112], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-96], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movzx	eax, BYTE PTR _keySchedule[esi+5]
	add	esi, 6
	add	eax, 848				; 00000350H
	shl	eax, 5
	movdqu	XMMWORD PTR [ecx-80], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx]
	movdqu	XMMWORD PTR [ecx-64], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+edx+16]
	movdqu	XMMWORD PTR [ecx-48], xmm0
	cmp	esi, 768				; 00000300H
	jl	$LL9@DES_Crypt
	pop	esi
$LN22@DES_Crypt:
	push	edi

; 453  : 	}
; 454  : 
; 455  : 	for (int32_t i = 0; i < NUM_DATA_BLOCKS; ++i) {
; 456  : 		for (int32_t j = 0; j < NUM_ELEMENTS_IN_VECTOR; ++j)
; 457  : 			context->dataBlocks[i].VECTOR_ELEMENTS[j] = 0;

	xor	eax, eax
	lea	edi, DWORD PTR [edx+24672]
	mov	ecx, 512				; 00000200H
	rep stosd

; 458  : 	}
; 459  : 
; 460  : #ifdef USE_ASSEMBLY_FUNCTION
; 461  :  	(*(context->crypt25))(context);

	mov	eax, DWORD PTR [edx+28928]
	push	edx
	call	eax
	add	esp, 4
	pop	edi

; 462  : #else
; 463  : 	DES_Crypt25_SSE2Intrinsics(context);
; 464  : #endif
; 465  : }

	ret	0
?DES_Crypt@@YAXPAUDES_Context@@@Z ENDP			; DES_Crypt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_GetTripcodeChunks@@YAXPAUDES_Context@@HPAIH@Z
_TEXT	SEGMENT
_context$1$ = -4					; size = 4
_tripcodeChunkArray$ = 8				; size = 4
_searchMode$dead$ = 12					; size = 4
?DES_GetTripcodeChunks@@YAXPAUDES_Context@@HPAIH@Z PROC	; DES_GetTripcodeChunks, COMDAT
; _context$ = ecx
; _tripcodeIndex$ = edx

; 486  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR ?searchMode@@3HA		; searchMode
	push	ebx
	push	esi
	mov	ebx, edx
	push	edi
	mov	edi, ecx

; 487  : 	// Perform the final permutation here.
; 488  : 	if (searchMode == SEARCH_MODE_FORWARD_MATCHING) {
; 489  : 		tripcodeChunkArray[0] =   GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 4)
; 490  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 3)
; 491  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 2)
; 492  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 1)
; 493  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0);

	mov	ecx, ebx
	and	ecx, 31					; 0000001fH
	sar	ebx, 5
	mov	DWORD PTR _context$1$[ebp], edi
	test	eax, eax
	jne	$LN6@DES_GetTri
	mov	eax, DWORD PTR [edi+ebx*4+25664]
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edi+ebx*4+26688]
	and	ecx, esi
	neg	ecx
	sbb	ecx, ecx
	and	eax, esi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25888]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24864]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26144]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25120]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26400]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25376]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26656]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25632]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25856]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24832]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26112]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25088]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26368]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25344]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26624]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25600]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25824]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24800]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26080]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25056]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26336]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [edi+ebx*4+25312]
	and	eax, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26592]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25568]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25792]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24768]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26048]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25024]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	pop	edi
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR _tripcodeChunkArray$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 522  : 	}
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@DES_GetTri:

; 494  : 	} else if (searchMode == SEARCH_MODE_BACKWARD_MATCHING) {

	cmp	eax, 1
	jne	$LN4@DES_GetTri

; 495  : 		tripcodeChunkArray[0] =   GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 4)
; 496  : 		                        | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 3)
; 497  : 		                        | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 2)
; 498  : 		                        | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 1)
; 499  : 		                        | GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24);

	mov	edx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25280]
	shl	edx, cl
	mov	ecx, DWORD PTR [edi+ebx*4+26304]
	and	ecx, edx
	neg	ecx
	sbb	ecx, ecx
	and	eax, edx
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26560]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25536]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25760]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24736]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26016]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24992]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26272]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25248]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26528]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25504]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25728]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24704]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25984]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24960]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26240]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25216]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26496]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25472]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25696]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24672]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25952]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [edi+ebx*4+24928]
	and	eax, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26208]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25184]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26464]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25440]
	and	eax, edx
	add	ecx, ecx
	neg	eax
	pop	edi
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR _tripcodeChunkArray$[ebp]
	shl	ecx, 2
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 522  : 	}
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@DES_GetTri:

; 500  : 	} else if (searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) {

	cmp	eax, 2
	jne	$LN2@DES_GetTri

; 501  : 		tripcodeChunkArray[0] =   GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 4)
; 502  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 3)
; 503  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 2)
; 504  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 1)
; 505  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0);

	mov	eax, DWORD PTR [edi+ebx*4+25664]
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edi+ebx*4+26688]
	and	ecx, esi
	neg	ecx
	sbb	ecx, ecx
	and	eax, esi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25888]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24864]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26144]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25120]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26400]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25376]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26656]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25632]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25856]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24832]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26112]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25088]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26368]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25344]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26624]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25600]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25824]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24800]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26080]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25056]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26336]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [edi+ebx*4+25312]
	and	eax, esi
	mov	edx, DWORD PTR _tripcodeChunkArray$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26592]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25568]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25792]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24768]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26048]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25024]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax

; 506  : 		tripcodeChunkArray[1] =   GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 4)
; 507  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 3)
; 508  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 2)
; 509  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 1)
; 510  : 								| GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24);

	mov	eax, DWORD PTR [edi+ebx*4+25280]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [edi+ebx*4+26304]
	and	ecx, esi
	neg	ecx
	sbb	ecx, ecx
	and	eax, esi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26560]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25536]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25760]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24736]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26016]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24992]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26272]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25248]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26528]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25504]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25728]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24704]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25984]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24960]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26240]
	add	ecx, ecx
	and	eax, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25216]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26496]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25472]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25696]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24672]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25952]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+24928]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26208]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25184]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+26464]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edi+ebx*4+25440]
	and	eax, esi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	or	ecx, eax
	shl	ecx, 2
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 522  : 	}
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@DES_GetTri:

; 511  : 	} else {
; 512  : 		tripcodeChunkArray[0] =   GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 4)
; 513  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 3)
; 514  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 2)
; 515  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 1)
; 516  : 								| GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0);

	mov	edi, 1
	shl	edi, cl
	mov	ecx, DWORD PTR _context$1$[ebp]
	mov	edx, DWORD PTR [ecx+ebx*4+26688]
	and	edx, edi
	mov	eax, DWORD PTR [ecx+ebx*4+25664]
	neg	edx
	sbb	edx, edx
	and	eax, edi
	neg	edx
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25888]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24864]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26144]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25120]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26400]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25376]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26656]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25632]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25856]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24832]
	add	edx, edx
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26112]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25088]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26368]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25344]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26624]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25600]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25824]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24800]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26080]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25056]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26336]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25312]
	add	edx, edx
	and	eax, edi
	mov	esi, DWORD PTR _tripcodeChunkArray$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26592]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25568]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25792]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24768]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26048]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25024]

; 517  : 		tripcodeChunkArray[1] = ((tripcodeChunkArray[0] << 6) & 0x3fffffff) | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0);

	mov	ecx, DWORD PTR [ecx+ebx*4+26304]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	and	ecx, edi
	neg	eax
	or	edx, eax
	neg	ecx
	mov	DWORD PTR [esi], edx
	sbb	ecx, ecx
	and	edx, 16777215				; 00ffffffH
	neg	ecx
	add	edx, edx
	or	ecx, edx
	mov	edx, DWORD PTR _context$1$[ebp]
	add	ecx, ecx
	mov	eax, DWORD PTR [edx+ebx*4+25280]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+26560]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+25536]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+25760]
	add	ecx, ecx
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+24736]

; 518  : 		tripcodeChunkArray[2] = ((tripcodeChunkArray[1] << 6) & 0x3fffffff) | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0);

	mov	edx, DWORD PTR [edx+ebx*4+26016]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	and	edx, edi
	neg	eax
	or	ecx, eax
	neg	edx
	mov	DWORD PTR [esi+4], ecx
	sbb	edx, edx
	and	ecx, 16777215				; 00ffffffH
	neg	edx
	add	ecx, ecx
	or	edx, ecx
	mov	ecx, DWORD PTR _context$1$[ebp]
	add	edx, edx
	mov	eax, DWORD PTR [ecx+ebx*4+24992]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26272]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25248]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+26528]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25504]

; 519  : 		tripcodeChunkArray[3] = ((tripcodeChunkArray[2] << 6) & 0x3fffffff) | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0);

	mov	ecx, DWORD PTR [ecx+ebx*4+25728]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	and	ecx, edi
	neg	eax
	or	edx, eax
	neg	ecx
	mov	DWORD PTR [esi+8], edx
	sbb	ecx, ecx
	and	edx, 16777215				; 00ffffffH
	neg	ecx
	add	edx, edx
	or	ecx, edx
	mov	edx, DWORD PTR _context$1$[ebp]
	add	ecx, ecx
	mov	eax, DWORD PTR [edx+ebx*4+24704]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+25984]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+24960]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+26240]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+25216]

; 520  : 		tripcodeChunkArray[4] = ((tripcodeChunkArray[3] << 6) & 0x3fffffff) | GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0);

	mov	edx, DWORD PTR [edx+ebx*4+26496]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	and	edx, edi
	neg	eax
	or	ecx, eax
	neg	edx
	mov	DWORD PTR [esi+12], ecx
	sbb	edx, edx
	and	ecx, 16777215				; 00ffffffH
	neg	edx
	add	ecx, ecx
	or	edx, ecx
	mov	ecx, DWORD PTR _context$1$[ebp]
	add	edx, edx
	mov	eax, DWORD PTR [ecx+ebx*4+25472]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25696]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24672]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+25952]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ecx+ebx*4+24928]

; 521  : 		tripcodeChunkArray[5] = ((tripcodeChunkArray[4] << 6) & 0x3fffffff) | GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24);

	mov	ecx, DWORD PTR [ecx+ebx*4+26208]
	add	edx, edx
	and	eax, edi
	neg	eax
	sbb	eax, eax
	and	ecx, edi
	neg	eax
	or	edx, eax
	neg	ecx
	mov	DWORD PTR [esi+16], edx
	sbb	ecx, ecx
	and	edx, 16777215				; 00ffffffH
	neg	ecx
	add	edx, edx
	or	ecx, edx
	mov	edx, DWORD PTR _context$1$[ebp]
	add	ecx, ecx
	mov	eax, DWORD PTR [edx+ebx*4+25184]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+26464]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [edx+ebx*4+25440]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	pop	edi
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	shl	ecx, 2
	mov	DWORD PTR [esi+20], ecx
	pop	esi
	pop	ebx

; 522  : 	}
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DES_GetTripcodeChunks@@YAXPAUDES_Context@@HPAIH@Z ENDP	; DES_GetTripcodeChunks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z
_TEXT	SEGMENT
_tripcodeIndex$1$ = -4					; size = 4
_tripcode$ = 8						; size = 4
?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z PROC	; DES_GetTripcode, COMDAT
; _context$ = ecx
; _tripcodeIndex$ = edx

; 526  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, edx

; 527  : 	// Perform the final permutation as necessary.
; 528  :   	tripcode[0] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0)];

	mov	ecx, esi
	sar	esi, 5
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _tripcodeIndex$1$[ebp], esi
	push	edi
	mov	edi, 1
	mov	edx, DWORD PTR [ebx+esi*4+26688]
	shl	edi, cl
	mov	eax, DWORD PTR [ebx+esi*4+25664]
	and	edx, edi
	neg	edx
	sbb	edx, edx
	and	eax, edi
	neg	edx
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+esi*4+25888]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+esi*4+24864]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+esi*4+26144]
	and	eax, edi
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	mov	eax, DWORD PTR [ebx+esi*4+25120]
	and	eax, edi
	mov	esi, DWORD PTR _tripcode$[ebp]
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[edx]

; 529  :   	tripcode[1] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0)];

	mov	edx, DWORD PTR _tripcodeIndex$1$[ebp]
	mov	BYTE PTR [esi], al
	mov	ecx, DWORD PTR [ebx+edx*4+26400]
	mov	eax, DWORD PTR [ebx+edx*4+25376]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26656]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25632]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [ebx+edx*4+25856]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24832]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+1], al

; 530  :   	tripcode[2] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+26112]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+edx*4+25088]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26368]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25344]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26624]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25600]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+2], al

; 531  :   	tripcode[3] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+25824]
	mov	eax, DWORD PTR [ebx+edx*4+24800]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26080]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25056]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26336]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25312]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+3], al

; 532  :   	tripcode[4] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+26592]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+edx*4+25568]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25792]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24768]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26048]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25024]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+4], al

; 533  :   	tripcode[5] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+26304]
	mov	eax, DWORD PTR [ebx+edx*4+25280]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26560]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	add	ecx, ecx
	mov	eax, DWORD PTR [ebx+edx*4+25536]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25760]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24736]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+5], al

; 534  :   	tripcode[6] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+26016]
	and	ecx, edi
	mov	eax, DWORD PTR [ebx+edx*4+24992]
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26272]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25248]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26528]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25504]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+6], al

; 535  :   	tripcode[7] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+25728]
	mov	eax, DWORD PTR [ebx+edx*4+24704]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25984]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24960]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26240]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25216]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]
	mov	BYTE PTR [esi+7], al

; 536  :   	tripcode[8] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0)];

	mov	ecx, DWORD PTR [ebx+edx*4+26496]
	mov	eax, DWORD PTR [ebx+edx*4+25472]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25696]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24672]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25952]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24928]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	movzx	eax, BYTE PTR _DES_indexToCharTable[ecx]

; 537  : 	tripcode[9] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24)];

	mov	ecx, DWORD PTR _tripcodeIndex$1$[ebp]
	mov	BYTE PTR [esi+8], al
	mov	edx, DWORD PTR [ebx+edx*4+26208]
	and	edx, edi
	mov	eax, DWORD PTR [ebx+ecx*4+25184]
	neg	edx
	sbb	edx, edx
	and	eax, edi
	neg	edx
	add	edx, edx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	edx, eax
	add	edx, edx
	mov	eax, DWORD PTR [ebx+ecx*4+26464]
	mov	ecx, DWORD PTR [ebx+ecx*4+25440]
	and	eax, edi
	neg	eax

; 538  :  	tripcode[10] = '\0';

	mov	BYTE PTR [esi+10], 0
	sbb	eax, eax
	and	ecx, edi
	neg	eax
	or	edx, eax

; 539  : 
; 540  : 	return tripcode;

	mov	eax, esi
	add	edx, edx
	neg	ecx
	pop	edi
	sbb	ecx, ecx
	neg	ecx
	or	edx, ecx
	mov	cl, BYTE PTR _DES_indexToCharTable[edx*4]
	mov	BYTE PTR [esi+9], cl
	pop	esi
	pop	ebx

; 541  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z ENDP	; DES_GetTripcode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?SearchForTripcodes@@YAIPAUDES_Context@@@Z
_TEXT	SEGMENT
tv14480 = -144						; size = 4
_tableForKey6$1$ = -140					; size = 4
_randomValue$1 = -136					; size = 4
_indexKey4$1$ = -132					; size = 4
tv14478 = -128						; size = 4
_tableForKey4$1$ = -124					; size = 4
_isKey5SecondByte$1$ = -120				; size = 4
_isKey6SecondByte$1$ = -116				; size = 4
_numGeneratedTripcodes$1$ = -112			; size = 4
_isSecondByte$1$ = -108					; size = 4
_randomValue$2 = -104					; size = 4
_tableForKey5$1$ = -100					; size = 4
_randomValue$3 = -100					; size = 4
_indexKey5$1$ = -96					; size = 4
_randomValue$4 = -96					; size = 4
_maxPos$1$ = -92					; size = 4
_pos$1$ = -88						; size = 4
tv14479 = -88						; size = 4
_tripcodeIndex$1$ = -84					; size = 4
_tripcodeIndexUpper$1$ = -84				; size = 4
_context$GSCopy$1$ = -80				; size = 4
$T5 = -76						; size = 4
_found$1$ = -72						; size = 4
_generatedTripcodeChunkArray$ = -68			; size = 32
_key$ = -36						; size = 13
_tripcode$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?SearchForTripcodes@@YAIPAUDES_Context@@@Z PROC		; SearchForTripcodes, COMDAT
; _context$ = ecx

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 583  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE + 1], key[MAX_LEN_TRIPCODE_KEY + 1];
; 584  : 	uint32_t   generatedTripcodeChunkArray[MAX_LEN_TRIPCODE - MIN_LEN_EXPANDED_PATTERN + 1];
; 585  : 	uint32_t   numGeneratedTripcodes = 0;

	xor	eax, eax
	push	ebx
	mov	DWORD PTR _numGeneratedTripcodes$1$[ebp], eax
	mov	ebx, ecx

; 586  : 	uint32_t   indexKey4,     indexKey5;
; 587  : 	unsigned char *tableForKey4, *tableForKey5, *tableForKey6, *tableForKey7;
; 588  : 	uint32_t   tripcodeIndex;
; 589  : 	unsigned char  randomByteKey6, randomByteKey7, randomByteKey8, randomByteKey9;
; 590  : 
; 591  : 	tripcode[lenTripcode] = '\0';

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	mov	DWORD PTR _context$GSCopy$1$[ebp], ebx
	push	esi
	push	edi
	cmp	eax, 13					; 0000000dH
	jae	$LN1050@SearchForT
	mov	BYTE PTR _tripcode$[ebp+eax], 0

; 592  : 	key     [lenTripcode] = '\0';

	mov	BYTE PTR _key$[ebp+eax], 0
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$4[ebp]
	push	eax
	call	_rand_s
	add	esp, 4
	lea	eax, DWORD PTR _randomValue$3[ebp]
	push	eax
	call	_rand_s
	add	esp, 4
	lea	eax, DWORD PTR _randomValue$1[ebp]
	push	eax
	call	_rand_s
	add	esp, 4
	lea	eax, DWORD PTR _randomValue$2[ebp]
	push	eax
	call	_rand_s
	add	esp, 4
	npad	5
$LL393@SearchForT:
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h

; 600  : 		SetCharactersInTripcodeKey(key, 4);

	lea	eax, DWORD PTR _key$[ebp]
	push	4
	push	eax
	call	?SetCharactersInTripcodeKey@@YAXPAEH@Z	; SetCharactersInTripcodeKey

; 601  : 		for (int32_t i = 4; i < lenTripcode; ++i)

	mov	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	esp, 8
	cmp	ecx, 4
	jle	SHORT $LN392@SearchForT
	add	ecx, -4					; fffffffcH

; 602  : 			key[i] = 'A';

	lea	edi, DWORD PTR _key$[ebp+4]
	mov	edx, ecx
	mov	eax, 1094795585				; 41414141H
	shr	ecx, 2
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb
$LN392@SearchForT:

; 603  : 	} while (!IsValidKey(key));

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?IsValidKey@@YAHPAE@Z			; IsValidKey
	add	esp, 4
	test	eax, eax
	je	SHORT $LL393@SearchForT

; 604  : 
; 605  : 	DES_SetSalt(context,
; 606  : 		            DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(key[1])]
; 607  : 		        | (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(key[2])] << 6));	

	movzx	eax, BYTE PTR _key$[ebp+2]
	mov	ecx, ebx
	movzx	eax, BYTE PTR ?charTableForSeed@@3PAEA[eax]
	movsx	edx, BYTE PTR _DES_charToIndexTable[eax]
	movzx	eax, BYTE PTR _key$[ebp+1]
	shl	edx, 6
	movzx	eax, BYTE PTR ?charTableForSeed@@3PAEA[eax]
	movsx	eax, BYTE PTR _DES_charToIndexTable[eax]
	or	edx, eax
	call	?DES_SetSalt@@YAXPAUDES_Context@@H@Z	; DES_SetSalt

; 608  : 
; 609  : 	CLEAR_KEYS(0);

	xor	eax, eax
	lea	edi, DWORD PTR [ebx+27136]
	mov	ecx, 56					; 00000038H
	rep stosd

; 610  : 	SET_ALL_BITS_FOR_KEY( 0, 0, 0);

	mov	al, BYTE PTR _key$[ebp]
	test	al, 1
	je	SHORT $LN673@SearchForT
	mov	DWORD PTR [ebx+27136], -1
	mov	DWORD PTR [ebx+27140], -1
	mov	DWORD PTR [ebx+27144], -1
	mov	DWORD PTR [ebx+27148], -1
	mov	DWORD PTR [ebx+27152], -1
	mov	DWORD PTR [ebx+27156], -1
	mov	DWORD PTR [ebx+27160], -1
	mov	DWORD PTR [ebx+27164], -1
$LN673@SearchForT:

; 611  : 	SET_ALL_BITS_FOR_KEY( 1, 0, 1);

	test	al, 2
	je	SHORT $LN682@SearchForT
	mov	DWORD PTR [ebx+27168], -1
	mov	DWORD PTR [ebx+27172], -1
	mov	DWORD PTR [ebx+27176], -1
	mov	DWORD PTR [ebx+27180], -1
	mov	DWORD PTR [ebx+27184], -1
	mov	DWORD PTR [ebx+27188], -1
	mov	DWORD PTR [ebx+27192], -1
	mov	DWORD PTR [ebx+27196], -1
$LN682@SearchForT:

; 612  : 	SET_ALL_BITS_FOR_KEY( 2, 0, 2);

	test	al, 4
	je	SHORT $LN691@SearchForT
	mov	DWORD PTR [ebx+27200], -1
	mov	DWORD PTR [ebx+27204], -1
	mov	DWORD PTR [ebx+27208], -1
	mov	DWORD PTR [ebx+27212], -1
	mov	DWORD PTR [ebx+27216], -1
	mov	DWORD PTR [ebx+27220], -1
	mov	DWORD PTR [ebx+27224], -1
	mov	DWORD PTR [ebx+27228], -1
$LN691@SearchForT:

; 613  : 	SET_ALL_BITS_FOR_KEY( 3, 0, 3);

	test	al, 8
	je	SHORT $LN700@SearchForT
	mov	DWORD PTR [ebx+27232], -1
	mov	DWORD PTR [ebx+27236], -1
	mov	DWORD PTR [ebx+27240], -1
	mov	DWORD PTR [ebx+27244], -1
	mov	DWORD PTR [ebx+27248], -1
	mov	DWORD PTR [ebx+27252], -1
	mov	DWORD PTR [ebx+27256], -1
	mov	DWORD PTR [ebx+27260], -1
$LN700@SearchForT:

; 614  : 	SET_ALL_BITS_FOR_KEY( 4, 0, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN709@SearchForT
	mov	DWORD PTR [ebx+27264], -1
	mov	DWORD PTR [ebx+27268], -1
	mov	DWORD PTR [ebx+27272], -1
	mov	DWORD PTR [ebx+27276], -1
	mov	DWORD PTR [ebx+27280], -1
	mov	DWORD PTR [ebx+27284], -1
	mov	DWORD PTR [ebx+27288], -1
	mov	DWORD PTR [ebx+27292], -1
$LN709@SearchForT:

; 615  : 	SET_ALL_BITS_FOR_KEY( 5, 0, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN718@SearchForT
	mov	DWORD PTR [ebx+27296], -1
	mov	DWORD PTR [ebx+27300], -1
	mov	DWORD PTR [ebx+27304], -1
	mov	DWORD PTR [ebx+27308], -1
	mov	DWORD PTR [ebx+27312], -1
	mov	DWORD PTR [ebx+27316], -1
	mov	DWORD PTR [ebx+27320], -1
	mov	DWORD PTR [ebx+27324], -1
$LN718@SearchForT:

; 616  : 	SET_ALL_BITS_FOR_KEY( 6, 0, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN727@SearchForT
	mov	DWORD PTR [ebx+27328], -1
	mov	DWORD PTR [ebx+27332], -1
	mov	DWORD PTR [ebx+27336], -1
	mov	DWORD PTR [ebx+27340], -1
	mov	DWORD PTR [ebx+27344], -1
	mov	DWORD PTR [ebx+27348], -1
	mov	DWORD PTR [ebx+27352], -1
	mov	DWORD PTR [ebx+27356], -1
$LN727@SearchForT:

; 617  : 
; 618  : 	CLEAR_KEYS(1);

	xor	eax, eax
	lea	edi, DWORD PTR [ebx+27360]
	mov	ecx, 56					; 00000038H
	rep stosd

; 619  : 	SET_ALL_BITS_FOR_KEY( 7, 1, 0);

	mov	al, BYTE PTR _key$[ebp+1]
	test	al, 1
	je	SHORT $LN736@SearchForT
	mov	DWORD PTR [ebx+27360], -1
	mov	DWORD PTR [ebx+27364], -1
	mov	DWORD PTR [ebx+27368], -1
	mov	DWORD PTR [ebx+27372], -1
	mov	DWORD PTR [ebx+27376], -1
	mov	DWORD PTR [ebx+27380], -1
	mov	DWORD PTR [ebx+27384], -1
	mov	DWORD PTR [ebx+27388], -1
$LN736@SearchForT:

; 620  : 	SET_ALL_BITS_FOR_KEY( 8, 1, 1);

	test	al, 2
	je	SHORT $LN745@SearchForT
	mov	DWORD PTR [ebx+27392], -1
	mov	DWORD PTR [ebx+27396], -1
	mov	DWORD PTR [ebx+27400], -1
	mov	DWORD PTR [ebx+27404], -1
	mov	DWORD PTR [ebx+27408], -1
	mov	DWORD PTR [ebx+27412], -1
	mov	DWORD PTR [ebx+27416], -1
	mov	DWORD PTR [ebx+27420], -1
$LN745@SearchForT:

; 621  : 	SET_ALL_BITS_FOR_KEY( 9, 1, 2);

	test	al, 4
	je	SHORT $LN754@SearchForT
	mov	DWORD PTR [ebx+27424], -1
	mov	DWORD PTR [ebx+27428], -1
	mov	DWORD PTR [ebx+27432], -1
	mov	DWORD PTR [ebx+27436], -1
	mov	DWORD PTR [ebx+27440], -1
	mov	DWORD PTR [ebx+27444], -1
	mov	DWORD PTR [ebx+27448], -1
	mov	DWORD PTR [ebx+27452], -1
$LN754@SearchForT:

; 622  : 	SET_ALL_BITS_FOR_KEY(10, 1, 3);

	test	al, 8
	je	SHORT $LN763@SearchForT
	mov	DWORD PTR [ebx+27456], -1
	mov	DWORD PTR [ebx+27460], -1
	mov	DWORD PTR [ebx+27464], -1
	mov	DWORD PTR [ebx+27468], -1
	mov	DWORD PTR [ebx+27472], -1
	mov	DWORD PTR [ebx+27476], -1
	mov	DWORD PTR [ebx+27480], -1
	mov	DWORD PTR [ebx+27484], -1
$LN763@SearchForT:

; 623  : 	SET_ALL_BITS_FOR_KEY(11, 1, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN772@SearchForT
	mov	DWORD PTR [ebx+27488], -1
	mov	DWORD PTR [ebx+27492], -1
	mov	DWORD PTR [ebx+27496], -1
	mov	DWORD PTR [ebx+27500], -1
	mov	DWORD PTR [ebx+27504], -1
	mov	DWORD PTR [ebx+27508], -1
	mov	DWORD PTR [ebx+27512], -1
	mov	DWORD PTR [ebx+27516], -1
$LN772@SearchForT:

; 624  : 	SET_ALL_BITS_FOR_KEY(12, 1, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN781@SearchForT
	mov	DWORD PTR [ebx+27520], -1
	mov	DWORD PTR [ebx+27524], -1
	mov	DWORD PTR [ebx+27528], -1
	mov	DWORD PTR [ebx+27532], -1
	mov	DWORD PTR [ebx+27536], -1
	mov	DWORD PTR [ebx+27540], -1
	mov	DWORD PTR [ebx+27544], -1
	mov	DWORD PTR [ebx+27548], -1
$LN781@SearchForT:

; 625  : 	SET_ALL_BITS_FOR_KEY(13, 1, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN790@SearchForT
	mov	DWORD PTR [ebx+27552], -1
	mov	DWORD PTR [ebx+27556], -1
	mov	DWORD PTR [ebx+27560], -1
	mov	DWORD PTR [ebx+27564], -1
	mov	DWORD PTR [ebx+27568], -1
	mov	DWORD PTR [ebx+27572], -1
	mov	DWORD PTR [ebx+27576], -1
	mov	DWORD PTR [ebx+27580], -1
$LN790@SearchForT:

; 626  : 
; 627  : 	CLEAR_KEYS(2);

	xor	eax, eax
	lea	edi, DWORD PTR [ebx+27584]
	mov	ecx, 56					; 00000038H
	rep stosd

; 628  : 	SET_ALL_BITS_FOR_KEY(14, 2, 0);

	mov	al, BYTE PTR _key$[ebp+2]
	test	al, 1
	je	SHORT $LN799@SearchForT
	mov	DWORD PTR [ebx+27584], -1
	mov	DWORD PTR [ebx+27588], -1
	mov	DWORD PTR [ebx+27592], -1
	mov	DWORD PTR [ebx+27596], -1
	mov	DWORD PTR [ebx+27600], -1
	mov	DWORD PTR [ebx+27604], -1
	mov	DWORD PTR [ebx+27608], -1
	mov	DWORD PTR [ebx+27612], -1
$LN799@SearchForT:

; 629  : 	SET_ALL_BITS_FOR_KEY(15, 2, 1);

	test	al, 2
	je	SHORT $LN808@SearchForT
	mov	DWORD PTR [ebx+27616], -1
	mov	DWORD PTR [ebx+27620], -1
	mov	DWORD PTR [ebx+27624], -1
	mov	DWORD PTR [ebx+27628], -1
	mov	DWORD PTR [ebx+27632], -1
	mov	DWORD PTR [ebx+27636], -1
	mov	DWORD PTR [ebx+27640], -1
	mov	DWORD PTR [ebx+27644], -1
$LN808@SearchForT:

; 630  : 	SET_ALL_BITS_FOR_KEY(16, 2, 2);

	test	al, 4
	je	SHORT $LN817@SearchForT
	mov	DWORD PTR [ebx+27648], -1
	mov	DWORD PTR [ebx+27652], -1
	mov	DWORD PTR [ebx+27656], -1
	mov	DWORD PTR [ebx+27660], -1
	mov	DWORD PTR [ebx+27664], -1
	mov	DWORD PTR [ebx+27668], -1
	mov	DWORD PTR [ebx+27672], -1
	mov	DWORD PTR [ebx+27676], -1
$LN817@SearchForT:

; 631  : 	SET_ALL_BITS_FOR_KEY(17, 2, 3);

	test	al, 8
	je	SHORT $LN826@SearchForT
	mov	DWORD PTR [ebx+27680], -1
	mov	DWORD PTR [ebx+27684], -1
	mov	DWORD PTR [ebx+27688], -1
	mov	DWORD PTR [ebx+27692], -1
	mov	DWORD PTR [ebx+27696], -1
	mov	DWORD PTR [ebx+27700], -1
	mov	DWORD PTR [ebx+27704], -1
	mov	DWORD PTR [ebx+27708], -1
$LN826@SearchForT:

; 632  : 	SET_ALL_BITS_FOR_KEY(18, 2, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN835@SearchForT
	mov	DWORD PTR [ebx+27712], -1
	mov	DWORD PTR [ebx+27716], -1
	mov	DWORD PTR [ebx+27720], -1
	mov	DWORD PTR [ebx+27724], -1
	mov	DWORD PTR [ebx+27728], -1
	mov	DWORD PTR [ebx+27732], -1
	mov	DWORD PTR [ebx+27736], -1
	mov	DWORD PTR [ebx+27740], -1
$LN835@SearchForT:

; 633  : 	SET_ALL_BITS_FOR_KEY(19, 2, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN844@SearchForT
	mov	DWORD PTR [ebx+27744], -1
	mov	DWORD PTR [ebx+27748], -1
	mov	DWORD PTR [ebx+27752], -1
	mov	DWORD PTR [ebx+27756], -1
	mov	DWORD PTR [ebx+27760], -1
	mov	DWORD PTR [ebx+27764], -1
	mov	DWORD PTR [ebx+27768], -1
	mov	DWORD PTR [ebx+27772], -1
$LN844@SearchForT:

; 634  : 	SET_ALL_BITS_FOR_KEY(20, 2, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN853@SearchForT
	mov	DWORD PTR [ebx+27776], -1
	mov	DWORD PTR [ebx+27780], -1
	mov	DWORD PTR [ebx+27784], -1
	mov	DWORD PTR [ebx+27788], -1
	mov	DWORD PTR [ebx+27792], -1
	mov	DWORD PTR [ebx+27796], -1
	mov	DWORD PTR [ebx+27800], -1
	mov	DWORD PTR [ebx+27804], -1
$LN853@SearchForT:

; 635  : 
; 636  : 	CLEAR_KEYS(3);

	xor	eax, eax
	lea	edi, DWORD PTR [ebx+27808]
	mov	ecx, 56					; 00000038H
	rep stosd

; 637  : 	SET_ALL_BITS_FOR_KEY(21, 3, 0);

	mov	al, BYTE PTR _key$[ebp+3]
	test	al, 1
	je	SHORT $LN862@SearchForT
	mov	DWORD PTR [ebx+27808], -1
	mov	DWORD PTR [ebx+27812], -1
	mov	DWORD PTR [ebx+27816], -1
	mov	DWORD PTR [ebx+27820], -1
	mov	DWORD PTR [ebx+27824], -1
	mov	DWORD PTR [ebx+27828], -1
	mov	DWORD PTR [ebx+27832], -1
	mov	DWORD PTR [ebx+27836], -1
$LN862@SearchForT:

; 638  : 	SET_ALL_BITS_FOR_KEY(22, 3, 1);

	test	al, 2
	je	SHORT $LN871@SearchForT
	mov	DWORD PTR [ebx+27840], -1
	mov	DWORD PTR [ebx+27844], -1
	mov	DWORD PTR [ebx+27848], -1
	mov	DWORD PTR [ebx+27852], -1
	mov	DWORD PTR [ebx+27856], -1
	mov	DWORD PTR [ebx+27860], -1
	mov	DWORD PTR [ebx+27864], -1
	mov	DWORD PTR [ebx+27868], -1
$LN871@SearchForT:

; 639  : 	SET_ALL_BITS_FOR_KEY(23, 3, 2);

	test	al, 4
	je	SHORT $LN880@SearchForT
	mov	DWORD PTR [ebx+27872], -1
	mov	DWORD PTR [ebx+27876], -1
	mov	DWORD PTR [ebx+27880], -1
	mov	DWORD PTR [ebx+27884], -1
	mov	DWORD PTR [ebx+27888], -1
	mov	DWORD PTR [ebx+27892], -1
	mov	DWORD PTR [ebx+27896], -1
	mov	DWORD PTR [ebx+27900], -1
$LN880@SearchForT:

; 640  : 	SET_ALL_BITS_FOR_KEY(24, 3, 3);

	test	al, 8
	je	SHORT $LN889@SearchForT
	mov	DWORD PTR [ebx+27904], -1
	mov	DWORD PTR [ebx+27908], -1
	mov	DWORD PTR [ebx+27912], -1
	mov	DWORD PTR [ebx+27916], -1
	mov	DWORD PTR [ebx+27920], -1
	mov	DWORD PTR [ebx+27924], -1
	mov	DWORD PTR [ebx+27928], -1
	mov	DWORD PTR [ebx+27932], -1
$LN889@SearchForT:

; 641  : 	SET_ALL_BITS_FOR_KEY(25, 3, 4);

	test	al, 16					; 00000010H
	je	SHORT $LN898@SearchForT
	mov	DWORD PTR [ebx+27936], -1
	mov	DWORD PTR [ebx+27940], -1
	mov	DWORD PTR [ebx+27944], -1
	mov	DWORD PTR [ebx+27948], -1
	mov	DWORD PTR [ebx+27952], -1
	mov	DWORD PTR [ebx+27956], -1
	mov	DWORD PTR [ebx+27960], -1
	mov	DWORD PTR [ebx+27964], -1
$LN898@SearchForT:

; 642  : 	SET_ALL_BITS_FOR_KEY(26, 3, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN907@SearchForT
	mov	DWORD PTR [ebx+27968], -1
	mov	DWORD PTR [ebx+27972], -1
	mov	DWORD PTR [ebx+27976], -1
	mov	DWORD PTR [ebx+27980], -1
	mov	DWORD PTR [ebx+27984], -1
	mov	DWORD PTR [ebx+27988], -1
	mov	DWORD PTR [ebx+27992], -1
	mov	DWORD PTR [ebx+27996], -1
$LN907@SearchForT:

; 643  : 	SET_ALL_BITS_FOR_KEY(27, 3, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN916@SearchForT
	mov	DWORD PTR [ebx+28000], -1
	mov	DWORD PTR [ebx+28004], -1
	mov	DWORD PTR [ebx+28008], -1
	mov	DWORD PTR [ebx+28012], -1
	mov	DWORD PTR [ebx+28016], -1
	mov	DWORD PTR [ebx+28020], -1
	mov	DWORD PTR [ebx+28024], -1
	mov	DWORD PTR [ebx+28028], -1
$LN916@SearchForT:

; 644  : 
; 645  : 	BOOL isSecondByte = FALSE;

	xor	eax, eax

; 646  : 	for (int32_t i = 0; i < 4; ++i) {

	xor	ecx, ecx
	npad	2
$LL251@SearchForT:

; 647  : 		if (!isSecondByte) {

	test	eax, eax
	jne	SHORT $LN248@SearchForT

; 648  : 			isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);

	mov	al, BYTE PTR _key$[ebp+ecx]
	cmp	al, 129					; 00000081H
	jb	SHORT $LN400@SearchForT
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN402@SearchForT
$LN400@SearchForT:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN401@SearchForT
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN402@SearchForT
$LN401@SearchForT:
	cmp	al, 224					; 000000e0H
	jb	SHORT $LN248@SearchForT
	cmp	al, 234					; 000000eaH
	ja	SHORT $LN248@SearchForT
$LN402@SearchForT:
	mov	eax, 1
	jmp	SHORT $LN250@SearchForT
$LN248@SearchForT:

; 649  : 		} else {
; 650  : 			isSecondByte = FALSE;

	xor	eax, eax
$LN250@SearchForT:

; 646  : 	for (int32_t i = 0; i < 4; ++i) {

	inc	ecx
	cmp	ecx, 4
	jl	SHORT $LL251@SearchForT

; 651  : 		}
; 652  : 	}
; 653  : 	BOOL isKey4SecondByte = isSecondByte;
; 654  : 	tableForKey4 = (isKey4SecondByte) ? context->keyCharTable_SecondByte : context->keyCharTable_FirstByte;	

	mov	DWORD PTR _isSecondByte$1$[ebp], eax
	lea	edx, DWORD PTR [ebx+29452]
	test	eax, eax
	jne	SHORT $LN1036@SearchForT
	lea	edx, DWORD PTR [ebx+28940]
$LN1036@SearchForT:
	movzx	eax, BYTE PTR _randomValue$3[ebp]
	lea	edi, DWORD PTR [ebx+28032]
	mov	DWORD PTR tv14478[ebp], eax
	lea	esi, DWORD PTR [ebx+28256]
	movzx	eax, BYTE PTR _randomValue$4[ebp]

; 655  : 				
; 656  : 	for (indexKey4 = 0; indexKey4 <= CPU_DES_MAX_INDEX_FOR_KEYS; ++indexKey4) {

	xor	ecx, ecx
	mov	DWORD PTR _tableForKey4$1$[ebp], edx
	mov	DWORD PTR _indexKey4$1$[ebp], ecx
	mov	DWORD PTR tv14480[ebp], eax
	npad	6
$LL246@SearchForT:

; 657  : 		key[4] = tableForKey4[indexKey4];

	mov	dl, BYTE PTR [ecx+edx]

; 658  : 		CLEAR_KEYS(4);

	xor	eax, eax
	mov	BYTE PTR _key$[ebp+4], dl
	mov	ecx, 56					; 00000038H
	rep stosd

; 659  : 		SET_ALL_BITS_FOR_KEY(28, 4, 0);

	test	dl, 1
	je	SHORT $LN236@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28032], xmm0
	movdqu	XMMWORD PTR [ebx+28048], xmm0
$LN236@SearchForT:

; 660  : 		SET_ALL_BITS_FOR_KEY(29, 4, 1);

	test	dl, 2
	je	SHORT $LN232@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28064], xmm0
	movdqu	XMMWORD PTR [ebx+28080], xmm0
$LN232@SearchForT:

; 661  : 		SET_ALL_BITS_FOR_KEY(30, 4, 2);

	test	dl, 4
	je	SHORT $LN228@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28096], xmm0
	movdqu	XMMWORD PTR [ebx+28112], xmm0
$LN228@SearchForT:

; 662  : 		SET_ALL_BITS_FOR_KEY(31, 4, 3);

	test	dl, 8
	je	SHORT $LN224@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28128], xmm0
	movdqu	XMMWORD PTR [ebx+28144], xmm0
$LN224@SearchForT:

; 663  : 		SET_ALL_BITS_FOR_KEY(32, 4, 4);

	test	dl, 16					; 00000010H
	je	SHORT $LN220@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28160], xmm0
	movdqu	XMMWORD PTR [ebx+28176], xmm0
$LN220@SearchForT:

; 664  : 		SET_ALL_BITS_FOR_KEY(33, 4, 5);

	test	dl, 32					; 00000020H
	je	SHORT $LN216@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28192], xmm0
	movdqu	XMMWORD PTR [ebx+28208], xmm0
$LN216@SearchForT:

; 665  : 		SET_ALL_BITS_FOR_KEY(34, 4, 6);

	test	dl, 64					; 00000040H
	je	SHORT $LN212@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28224], xmm0
	movdqu	XMMWORD PTR [ebx+28240], xmm0
$LN212@SearchForT:

; 666  : 
; 667  : 		BOOL isKey5SecondByte = !isKey4SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[4]);

	cmp	DWORD PTR _isSecondByte$1$[ebp], eax
	jne	SHORT $LN411@SearchForT
	cmp	dl, 129					; 00000081H
	jb	SHORT $LN407@SearchForT
	cmp	dl, 132					; 00000084H
	jbe	SHORT $LN409@SearchForT
$LN407@SearchForT:
	cmp	dl, 136					; 00000088H
	jb	SHORT $LN408@SearchForT
	cmp	dl, 159					; 0000009fH
	jbe	SHORT $LN409@SearchForT
$LN408@SearchForT:
	add	dl, 32					; 00000020H
	cmp	dl, 10					; 0000000aH
	ja	SHORT $LN411@SearchForT
$LN409@SearchForT:
	mov	DWORD PTR _isKey5SecondByte$1$[ebp], 1

; 668  : 		tableForKey5 = (isKey5SecondByte) ? context->keyCharTable_SecondByte : context->keyCharTable_FirstByte;	

	lea	ecx, DWORD PTR [ebx+29452]
	jmp	SHORT $LN1037@SearchForT
$LN411@SearchForT:

; 666  : 
; 667  : 		BOOL isKey5SecondByte = !isKey4SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[4]);

	mov	DWORD PTR _isKey5SecondByte$1$[ebp], eax

; 668  : 		tableForKey5 = (isKey5SecondByte) ? context->keyCharTable_SecondByte : context->keyCharTable_FirstByte;	

	lea	ecx, DWORD PTR [ebx+28940]
$LN1037@SearchForT:

; 669  : 
; 670  : 		for (indexKey5 = 0; indexKey5 <= CPU_DES_MAX_INDEX_FOR_KEYS; ++indexKey5) {

	xor	eax, eax
	mov	DWORD PTR _tableForKey5$1$[ebp], ecx
	mov	DWORD PTR _indexKey5$1$[ebp], eax
	npad	5
$LL209@SearchForT:

; 671  : 			BOOL isKey6SecondByte;
; 672  : #if TRUE
; 673  : 			key[5] = tableForKey5[indexKey5];

	mov	dl, BYTE PTR [eax+ecx]

; 674  : 			CLEAR_KEYS(5);

	mov	edi, esi
	xor	eax, eax
	mov	BYTE PTR _key$[ebp+5], dl
	mov	ecx, 56					; 00000038H
	rep stosd

; 675  : 			SET_ALL_BITS_FOR_KEY(35, 5, 0);

	test	dl, 1
	je	SHORT $LN199@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [esi], xmm0
	movdqu	XMMWORD PTR [esi+16], xmm0
$LN199@SearchForT:

; 676  : 			SET_ALL_BITS_FOR_KEY(36, 5, 1);

	test	dl, 2
	je	SHORT $LN195@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28288], xmm0
	movdqu	XMMWORD PTR [ebx+28304], xmm0
$LN195@SearchForT:

; 677  : 			SET_ALL_BITS_FOR_KEY(37, 5, 2);

	test	dl, 4
	je	SHORT $LN191@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28320], xmm0
	movdqu	XMMWORD PTR [ebx+28336], xmm0
$LN191@SearchForT:

; 678  : 			SET_ALL_BITS_FOR_KEY(38, 5, 3);

	test	dl, 8
	je	SHORT $LN187@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28352], xmm0
	movdqu	XMMWORD PTR [ebx+28368], xmm0
$LN187@SearchForT:

; 679  : 			SET_ALL_BITS_FOR_KEY(39, 5, 4);

	test	dl, 16					; 00000010H
	je	SHORT $LN183@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28384], xmm0
	movdqu	XMMWORD PTR [ebx+28400], xmm0
$LN183@SearchForT:

; 680  : 			SET_ALL_BITS_FOR_KEY(40, 5, 5);

	test	dl, 32					; 00000020H
	je	SHORT $LN179@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28416], xmm0
	movdqu	XMMWORD PTR [ebx+28432], xmm0
$LN179@SearchForT:

; 681  : 			SET_ALL_BITS_FOR_KEY(41, 5, 6);

	test	dl, 64					; 00000040H
	je	SHORT $LN175@SearchForT
	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	movdqu	XMMWORD PTR [ebx+28448], xmm0
	movdqu	XMMWORD PTR [ebx+28464], xmm0
$LN175@SearchForT:

; 682  : 
; 683  : 			isKey6SecondByte = !isKey5SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[5]);

	cmp	DWORD PTR _isKey5SecondByte$1$[ebp], eax
	jne	SHORT $LN419@SearchForT
	cmp	dl, 129					; 00000081H
	jb	SHORT $LN415@SearchForT
	cmp	dl, 132					; 00000084H
	jbe	SHORT $LN417@SearchForT
$LN415@SearchForT:
	cmp	dl, 136					; 00000088H
	jb	SHORT $LN416@SearchForT
	cmp	dl, 159					; 0000009fH
	jbe	SHORT $LN417@SearchForT
$LN416@SearchForT:
	add	dl, 32					; 00000020H
	cmp	dl, 10					; 0000000aH
	ja	SHORT $LN419@SearchForT
$LN417@SearchForT:
	mov	esi, 1

; 684  : 			tableForKey6 = (isKey6SecondByte) ? context->keyCharTable_SecondByte : context->keyCharTable_FirstByte;	

	lea	edx, DWORD PTR [ebx+29452]
	jmp	SHORT $LN1038@SearchForT
$LN419@SearchForT:

; 682  : 
; 683  : 			isKey6SecondByte = !isKey5SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[5]);

	xor	esi, esi

; 684  : 			tableForKey6 = (isKey6SecondByte) ? context->keyCharTable_SecondByte : context->keyCharTable_FirstByte;	

	lea	edx, DWORD PTR [ebx+28940]
$LN1038@SearchForT:

; 685  : 
; 686  : 			CLEAR_KEYS(6);

	xor	eax, eax
	mov	DWORD PTR _tableForKey6$1$[ebp], edx

; 687  : 			CLEAR_KEYS(7);
; 688  : 
; 689  : #if FALSE
; 690  : 			for (tripcodeIndex = 0; tripcodeIndex < BITSLICE_DES_DEPTH; ++tripcodeIndex) {
; 691  : 				key[6] = tableForKey6[(int32_t)randomByteKey6 + (tripcodeIndex >> 5)];
; 692  : 				tableForKey7 = (!isKey6SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[6])) ? (context->keyCharTable_SecondByte) : (context->keyCharTable_FirstByte);	
; 693  : 				SET_BIT_FOR_KEY(42, 6, 0);
; 694  : 				SET_BIT_FOR_KEY(43, 6, 1);
; 695  : 				SET_BIT_FOR_KEY(44, 6, 2);
; 696  : 				SET_BIT_FOR_KEY(45, 6, 3);
; 697  : 				SET_BIT_FOR_KEY(46, 6, 4);
; 698  : 				SET_BIT_FOR_KEY(47, 6, 5);
; 699  : 				SET_BIT_FOR_KEY(48, 6, 6);
; 700  : 
; 701  : 				key[7] = tableForKey7[(int32_t)randomByteKey7 + (tripcodeIndex & 0x1f)];
; 702  : 				SET_BIT_FOR_KEY(49, 7, 0);
; 703  : 				SET_BIT_FOR_KEY(50, 7, 1);
; 704  : 				SET_BIT_FOR_KEY(51, 7, 2);
; 705  : 				SET_BIT_FOR_KEY(52, 7, 3);
; 706  : 				SET_BIT_FOR_KEY(53, 7, 4);
; 707  : 				SET_BIT_FOR_KEY(54, 7, 5);
; 708  : 				SET_BIT_FOR_KEY(55, 7, 6);
; 709  : 			}
; 710  : #else
; 711  : 			for (int32_t tripcodeIndexUpper = 0; tripcodeIndexUpper < (BITSLICE_DES_DEPTH >> 5); ++tripcodeIndexUpper) {

	add	edx, DWORD PTR tv14480[ebp]
	lea	edi, DWORD PTR [ebx+28480]
	mov	ecx, 56					; 00000038H
	mov	DWORD PTR _isKey6SecondByte$1$[ebp], esi
	rep stosd
	mov	ecx, 56					; 00000038H
	mov	DWORD PTR _tripcodeIndexUpper$1$[ebp], eax
	lea	edi, DWORD PTR [ebx+28704]
	mov	DWORD PTR tv14479[ebp], edx
	rep stosd
	lea	ecx, DWORD PTR [ebx+28512]
$LL160@SearchForT:

; 712  : 				key[6] = tableForKey6[(int32_t)randomByteKey6 + tripcodeIndexUpper];

	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _key$[ebp+6], dl

; 713  : 				tableForKey7 = (!isKey6SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[6])) ? (context->keyCharTable_SecondByte) : (context->keyCharTable_FirstByte);	

	test	esi, esi
	jne	SHORT $LN427@SearchForT
	cmp	dl, 129					; 00000081H
	jb	SHORT $LN423@SearchForT
	cmp	dl, 132					; 00000084H
	jbe	SHORT $LN425@SearchForT
$LN423@SearchForT:
	cmp	dl, 136					; 00000088H
	jb	SHORT $LN424@SearchForT
	cmp	dl, 159					; 0000009fH
	jbe	SHORT $LN425@SearchForT
$LN424@SearchForT:
	mov	al, dl
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	ja	SHORT $LN427@SearchForT
$LN425@SearchForT:
	lea	edi, DWORD PTR [ebx+29452]
	jmp	SHORT $LN428@SearchForT
$LN427@SearchForT:
	lea	edi, DWORD PTR [ebx+28940]
$LN428@SearchForT:

; 714  : 				if (key[6] & ((0x1 << 0))) context->keys[42].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 1
	je	SHORT $LN157@SearchForT
	mov	DWORD PTR [ecx-32], -1
$LN157@SearchForT:

; 715  : 				if (key[6] & ((0x1 << 1))) context->keys[43].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 2
	je	SHORT $LN156@SearchForT
	mov	DWORD PTR [ecx], -1
$LN156@SearchForT:

; 716  : 				if (key[6] & ((0x1 << 2))) context->keys[44].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 4
	je	SHORT $LN155@SearchForT
	mov	DWORD PTR [ecx+32], -1
$LN155@SearchForT:

; 717  : 				if (key[6] & ((0x1 << 3))) context->keys[45].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 8
	je	SHORT $LN154@SearchForT
	mov	DWORD PTR [ecx+64], -1
$LN154@SearchForT:

; 718  : 				if (key[6] & ((0x1 << 4))) context->keys[46].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 16					; 00000010H
	je	SHORT $LN153@SearchForT
	mov	DWORD PTR [ecx+96], -1
$LN153@SearchForT:

; 719  : 				if (key[6] & ((0x1 << 5))) context->keys[47].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 32					; 00000020H
	je	SHORT $LN152@SearchForT
	mov	DWORD PTR [ecx+128], -1
$LN152@SearchForT:

; 720  : 				if (key[6] & ((0x1 << 6))) context->keys[48].VECTOR_ELEMENTS[tripcodeIndexUpper] = 0xffffffff;

	test	dl, 64					; 00000040H
	je	SHORT $LN151@SearchForT
	mov	DWORD PTR [ecx+160], -1
$LN151@SearchForT:

; 721  : 
; 722  : #pragma unroll
; 723  : 				for (int32_t tripcodeIndexLower = 0; tripcodeIndexLower < 32; ++tripcodeIndexLower) {

	mov	edx, DWORD PTR tv14478[ebp]
	xor	esi, esi
	add	edi, edx
	lea	eax, DWORD PTR [esi+1]
	npad	7
$LL150@SearchForT:

; 724  : 					key[7] = tableForKey7[(int32_t)randomByteKey7 + tripcodeIndexLower];

	mov	dl, BYTE PTR [edi+esi]
	mov	BYTE PTR _key$[ebp+7], dl

; 725  : 					if (key[7] & ((0x1 << 0))) context->keys[49].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 1
	je	SHORT $LN147@SearchForT
	or	DWORD PTR [ecx+192], eax
$LN147@SearchForT:

; 726  : 					if (key[7] & ((0x1 << 1))) context->keys[50].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 2
	je	SHORT $LN146@SearchForT
	or	DWORD PTR [ecx+224], eax
$LN146@SearchForT:

; 727  : 					if (key[7] & ((0x1 << 2))) context->keys[51].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 4
	je	SHORT $LN145@SearchForT
	or	DWORD PTR [ecx+256], eax
$LN145@SearchForT:

; 728  : 					if (key[7] & ((0x1 << 3))) context->keys[52].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 8
	je	SHORT $LN144@SearchForT
	or	DWORD PTR [ecx+288], eax
$LN144@SearchForT:

; 729  : 					if (key[7] & ((0x1 << 4))) context->keys[53].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 16					; 00000010H
	je	SHORT $LN143@SearchForT
	or	DWORD PTR [ecx+320], eax
$LN143@SearchForT:

; 730  : 					if (key[7] & ((0x1 << 5))) context->keys[54].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 32					; 00000020H
	je	SHORT $LN142@SearchForT
	or	DWORD PTR [ecx+352], eax
$LN142@SearchForT:

; 731  : 					if (key[7] & ((0x1 << 6))) context->keys[55].VECTOR_ELEMENTS[tripcodeIndexUpper] |= (0x1 << tripcodeIndexLower);

	test	dl, 64					; 00000040H
	je	SHORT $LN149@SearchForT
	or	DWORD PTR [ecx+384], eax
$LN149@SearchForT:

; 721  : 
; 722  : #pragma unroll
; 723  : 				for (int32_t tripcodeIndexLower = 0; tripcodeIndexLower < 32; ++tripcodeIndexLower) {

	inc	esi
	rol	eax, 1
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL150@SearchForT

; 687  : 			CLEAR_KEYS(7);
; 688  : 
; 689  : #if FALSE
; 690  : 			for (tripcodeIndex = 0; tripcodeIndex < BITSLICE_DES_DEPTH; ++tripcodeIndex) {
; 691  : 				key[6] = tableForKey6[(int32_t)randomByteKey6 + (tripcodeIndex >> 5)];
; 692  : 				tableForKey7 = (!isKey6SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[6])) ? (context->keyCharTable_SecondByte) : (context->keyCharTable_FirstByte);	
; 693  : 				SET_BIT_FOR_KEY(42, 6, 0);
; 694  : 				SET_BIT_FOR_KEY(43, 6, 1);
; 695  : 				SET_BIT_FOR_KEY(44, 6, 2);
; 696  : 				SET_BIT_FOR_KEY(45, 6, 3);
; 697  : 				SET_BIT_FOR_KEY(46, 6, 4);
; 698  : 				SET_BIT_FOR_KEY(47, 6, 5);
; 699  : 				SET_BIT_FOR_KEY(48, 6, 6);
; 700  : 
; 701  : 				key[7] = tableForKey7[(int32_t)randomByteKey7 + (tripcodeIndex & 0x1f)];
; 702  : 				SET_BIT_FOR_KEY(49, 7, 0);
; 703  : 				SET_BIT_FOR_KEY(50, 7, 1);
; 704  : 				SET_BIT_FOR_KEY(51, 7, 2);
; 705  : 				SET_BIT_FOR_KEY(52, 7, 3);
; 706  : 				SET_BIT_FOR_KEY(53, 7, 4);
; 707  : 				SET_BIT_FOR_KEY(54, 7, 5);
; 708  : 				SET_BIT_FOR_KEY(55, 7, 6);
; 709  : 			}
; 710  : #else
; 711  : 			for (int32_t tripcodeIndexUpper = 0; tripcodeIndexUpper < (BITSLICE_DES_DEPTH >> 5); ++tripcodeIndexUpper) {

	mov	eax, DWORD PTR _tripcodeIndexUpper$1$[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR tv14479[ebp]
	inc	eax
	mov	esi, DWORD PTR _isKey6SecondByte$1$[ebp]
	mov	DWORD PTR _tripcodeIndexUpper$1$[ebp], eax
	cmp	eax, 8
	jl	$LL160@SearchForT

; 732  : 				}
; 733  : 			}
; 734  : #endif
; 735  : #endif
; 736  : 
; 737  : 		 	DES_Crypt(context);

	mov	ecx, ebx
	call	?DES_Crypt@@YAXPAUDES_Context@@@Z	; DES_Crypt

; 738  : 			numGeneratedTripcodes += BITSLICE_DES_DEPTH;

	add	DWORD PTR _numGeneratedTripcodes$1$[ebp], 256 ; 00000100H

; 739  : 
; 740  : 			// continue;
; 741  : 
; 742  : 			for (tripcodeIndex = 0; tripcodeIndex < BITSLICE_DES_DEPTH; ++tripcodeIndex) {

	mov	edi, 1
	xor	eax, eax
	mov	DWORD PTR $T5[ebp], edi
	mov	DWORD PTR _tripcodeIndex$1$[ebp], eax
	npad	1
$LL140@SearchForT:

; 743  : 				// if (tripcodeIndex == 0) printf("tripcode[] = \"%s\"\n", DES_GetTripcode(context, tripcodeIndex, tripcode));
; 744  : 
; 745  : 				// printf("[0x%08x, 0x%08x]\n", tripcodeChunkArray[0], generatedTripcodeChunkArray[0]);
; 746  : 				
; 747  : 				BOOL found = FALSE;

	xor	esi, esi

; 748  : 				if (searchMode == SEARCH_MODE_FORWARD_MATCHING && numTripcodeChunk == 1) {
; 749  : 					if (GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0) != ((tripcodeChunkArray[0] >> (6 * 4)) & 0x3f))

	mov	edx, eax
	mov	DWORD PTR _found$1$[ebp], esi
	cmp	DWORD PTR ?searchMode@@3HA, esi		; searchMode
	jne	$LN137@SearchForT
	shr	edx, 5
	mov	ecx, DWORD PTR [ebx+edx*4+26688]
	and	ecx, edi
	cmp	DWORD PTR ?numTripcodeChunk@@3IA, 1	; numTripcodeChunk
	jne	$LN971@SearchForT
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	esi, DWORD PTR [eax]
	add	ecx, ecx
	mov	eax, DWORD PTR [ebx+edx*4+25664]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25888]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24864]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26144]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25120]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 24					; 00000018H
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 750  : 						goto skip_final_permutation;
; 751  : 					if (GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0) != ((tripcodeChunkArray[0] >> (6 * 3)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26400]
	mov	eax, DWORD PTR [ebx+edx*4+25376]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26656]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25632]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25856]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24832]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 18					; 00000012H
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 752  : 						goto skip_final_permutation;
; 753  : 					if (GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0) != ((tripcodeChunkArray[0] >> (6 * 2)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26112]
	mov	eax, DWORD PTR [ebx+edx*4+25088]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26368]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25344]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26624]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25600]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 12					; 0000000cH
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 754  : 						goto skip_final_permutation;
; 755  : 					if (GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0) != ((tripcodeChunkArray[0] >> (6 * 1)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+25824]
	mov	eax, DWORD PTR [ebx+edx*4+24800]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26080]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25056]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26336]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25312]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 6
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 756  : 						goto skip_final_permutation;
; 757  : 					if (GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0) != ((tripcodeChunkArray[0] >> (6 * 0)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26592]
	mov	eax, DWORD PTR [ebx+edx*4+25568]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25792]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24768]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26048]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25024]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
$LN1047@SearchForT:
	and	esi, 63					; 0000003fH
	cmp	ecx, esi
	jne	$LN1025@SearchForT
$LN97@SearchForT:

; 758  : 						goto skip_final_permutation;
; 759  : 					found = TRUE;

	mov	esi, 1
	jmp	$LN28@SearchForT
$LN971@SearchForT:

; 773  : 
; 774  : 				} else if (searchMode == SEARCH_MODE_FORWARD_MATCHING) {
; 775  : 					generatedTripcodeChunkArray[0] = 0x00000000;
; 776  : 
; 777  : 					uint32_t tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25664]
	neg	ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], esi
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25888]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24864]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26144]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25120]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax

; 778  : 					if (!context->tripcodeChunkBitmap[4][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+ecx+30220], 0
	je	$LN972@SearchForT

; 779  : 						goto skip_final_permutation;
; 780  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 4);
; 781  : 
; 782  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0);

	mov	esi, DWORD PTR [ebx+edx*4+26400]
	mov	eax, DWORD PTR [ebx+edx*4+25376]
	and	esi, edi
	shl	ecx, 24					; 00000018H
	neg	esi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26656]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25632]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25856]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24832]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 783  : 					if (!context->tripcodeChunkBitmap[3][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30156], 0
	je	$LN1025@SearchForT

; 784  : 						goto skip_final_permutation;
; 785  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 3);

	shl	esi, 18					; 00000012H

; 786  : 
; 787  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25088]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26112]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26368]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25344]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26624]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25600]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 788  : 					if (!context->tripcodeChunkBitmap[2][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30092], 0
	je	$LN1025@SearchForT

; 789  : 						goto skip_final_permutation;
; 790  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 2);

	shl	esi, 12					; 0000000cH

; 791  : 
; 792  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0);

	mov	eax, DWORD PTR [ebx+edx*4+24800]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+25824]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26080]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25056]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26336]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25312]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 793  : 					if (!context->tripcodeChunkBitmap[1][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30028], 0
	je	$LN1025@SearchForT

; 794  : 						goto skip_final_permutation;
; 795  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 1);

	shl	esi, 6

; 796  : 
; 797  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25568]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26592]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25792]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24768]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26048]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25024]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 798  : 					if (!context->tripcodeChunkBitmap[0][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+29964], 0
	je	SHORT $LN1025@SearchForT

; 799  : 						goto skip_final_permutation;
; 800  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 0);

	or	ecx, esi

; 801  : 
; 802  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	mov	eax, ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN1025@SearchForT
	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	edi, edi
	dec	edx
	js	SHORT $LN998@SearchForT
$LL101@SearchForT:
	mov	esi, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [edx+edi]
	sar	eax, 1
	mov	esi, DWORD PTR [esi+eax*4]
	cmp	ecx, esi
	jbe	SHORT $LN1039@SearchForT
	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN96@SearchForT
$LN1039@SearchForT:
	jae	$LN97@SearchForT
	lea	edx, DWORD PTR [eax-1]
$LN96@SearchForT:
	cmp	edi, edx
	jle	SHORT $LL101@SearchForT
$LN998@SearchForT:
	mov	edi, DWORD PTR $T5[ebp]
$LN1025@SearchForT:
	mov	esi, DWORD PTR _found$1$[ebp]
$LN972@SearchForT:

; 901  : 				}
; 902  : 
; 903  : skip_final_permutation:
; 904  : 				// Construct a valid 10 character key if necessary.
; 905  : 				if (found || searchForSpecialPatternsOnCPU) {

	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	je	$LN139@SearchForT
$LN28@SearchForT:

; 906  : 					key[6] = tableForKey6[(int32_t)randomByteKey6 + (tripcodeIndex >> 5)];

	mov	edi, DWORD PTR _tripcodeIndex$1$[ebp]
	mov	eax, edi
	mov	ecx, DWORD PTR _tableForKey6$1$[ebp]
	shr	eax, 5
	add	eax, DWORD PTR tv14480[ebp]

; 907  : 					BOOL isKey7SecondByte = !isKey6SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[6]);

	cmp	DWORD PTR _isKey6SecondByte$1$[ebp], 0
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _key$[ebp+6], al
	jne	$LN435@SearchForT
	cmp	al, 129					; 00000081H
	jb	SHORT $LN431@SearchForT
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN433@SearchForT
$LN431@SearchForT:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN432@SearchForT
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN433@SearchForT
$LN432@SearchForT:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	ja	$LN435@SearchForT
$LN433@SearchForT:
	mov	ecx, 1

; 908  : 					tableForKey7 = (isKey7SecondByte) ? (context->keyCharTable_SecondByte) : (context->keyCharTable_FirstByte);

	lea	edx, DWORD PTR [ebx+29452]
	jmp	$LN438@SearchForT
$LN137@SearchForT:

; 760  : 					
; 761  : 				} else if (searchMode == SEARCH_MODE_BACKWARD_MATCHING && numTripcodeChunk == 1) {

	cmp	DWORD PTR ?searchMode@@3HA, 1		; searchMode
	jne	$LN94@SearchForT

; 762  : 					if (GET_TRIPCODE_CHAR_INDEX     (context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0) != ((tripcodeChunkArray[0] >> (6 * 4)) & 0x3f))

	shr	edx, 5
	mov	ecx, DWORD PTR [ebx+edx*4+26304]
	and	ecx, edi
	cmp	DWORD PTR ?numTripcodeChunk@@3IA, 1	; numTripcodeChunk
	jne	$LN973@SearchForT
	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	esi, DWORD PTR [eax]
	add	ecx, ecx
	mov	eax, DWORD PTR [ebx+edx*4+25280]
	and	eax, edi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26560]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25536]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25760]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24736]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 24					; 00000018H
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 763  : 						goto skip_final_permutation;
; 764  : 					if (GET_TRIPCODE_CHAR_INDEX     (context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0) != ((tripcodeChunkArray[0] >> (6 * 3)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26016]
	mov	eax, DWORD PTR [ebx+edx*4+24992]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26272]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25248]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26528]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25504]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 18					; 00000012H
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 765  : 						goto skip_final_permutation;
; 766  : 					if (GET_TRIPCODE_CHAR_INDEX     (context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0) != ((tripcodeChunkArray[0] >> (6 * 2)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+25728]
	mov	eax, DWORD PTR [ebx+edx*4+24704]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25984]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24960]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26240]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25216]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 12					; 0000000cH
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 767  : 						goto skip_final_permutation;
; 768  : 					if (GET_TRIPCODE_CHAR_INDEX     (context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0) != ((tripcodeChunkArray[0] >> (6 * 1)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26496]
	mov	eax, DWORD PTR [ebx+edx*4+25472]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25696]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24672]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25952]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24928]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, esi
	shr	eax, 6
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jne	$LN1025@SearchForT

; 769  : 						goto skip_final_permutation;
; 770  : 					if (GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24) != ((tripcodeChunkArray[0] >> (6 * 0)) & 0x3f))

	mov	ecx, DWORD PTR [ebx+edx*4+26208]
	mov	eax, DWORD PTR [ebx+edx*4+25184]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26464]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25440]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	shl	ecx, 2

; 771  : 						goto skip_final_permutation;
; 772  : 					found = TRUE;

	jmp	$LN1047@SearchForT
$LN973@SearchForT:

; 803  : 
; 804  : 				} else if (searchMode == SEARCH_MODE_BACKWARD_MATCHING) {
; 805  : 					generatedTripcodeChunkArray[0] = 0x00000000;
; 806  : 
; 807  : 					uint32_t tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25280]
	neg	ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], esi
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26560]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25536]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25760]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24736]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax

; 808  : 					if (!context->tripcodeChunkBitmap[4][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+ecx+30220], 0
	je	$LN972@SearchForT

; 809  : 						goto skip_final_permutation;
; 810  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 4);
; 811  : 
; 812  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0);

	mov	esi, DWORD PTR [ebx+edx*4+26016]
	mov	eax, DWORD PTR [ebx+edx*4+24992]
	and	esi, edi
	shl	ecx, 24					; 00000018H
	neg	esi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26272]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25248]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26528]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25504]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 813  : 					if (!context->tripcodeChunkBitmap[3][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30156], 0
	je	$LN1025@SearchForT

; 814  : 						goto skip_final_permutation;
; 815  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 3);

	shl	esi, 18					; 00000012H

; 816  : 
; 817  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0);

	mov	eax, DWORD PTR [ebx+edx*4+24704]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+25728]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25984]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24960]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26240]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25216]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 818  : 					if (!context->tripcodeChunkBitmap[2][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30092], 0
	je	$LN1025@SearchForT

; 819  : 						goto skip_final_permutation;
; 820  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 2);

	shl	esi, 12					; 0000000cH

; 821  : 
; 822  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25472]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26496]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25696]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24672]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25952]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24928]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 823  : 					if (!context->tripcodeChunkBitmap[1][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30028], 0
	je	$LN1025@SearchForT

; 824  : 						goto skip_final_permutation;
; 825  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 1);
; 826  : 
; 827  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24);

	mov	eax, DWORD PTR [ebx+edx*4+25184]
	shl	esi, 6
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26208]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26464]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25440]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	shl	esi, 2

; 828  : 					if (!context->tripcodeChunkBitmap[0][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+29964], 0
	je	$LN1025@SearchForT

; 829  : 						goto skip_final_permutation;
; 830  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 0);

	or	ecx, esi

; 831  : 
; 832  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	mov	eax, ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	$LN1025@SearchForT
	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	edi, edi
	dec	edx
	js	$LN998@SearchForT
	npad	5
$LL82@SearchForT:
	mov	esi, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [edx+edi]
	sar	eax, 1
	mov	esi, DWORD PTR [esi+eax*4]
	cmp	ecx, esi
	jbe	SHORT $LN1040@SearchForT
	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN77@SearchForT
$LN1040@SearchForT:
	jae	$LN97@SearchForT
	lea	edx, DWORD PTR [eax-1]
$LN77@SearchForT:
	cmp	edi, edx
	jle	SHORT $LL82@SearchForT

; 601  : 		for (int32_t i = 4; i < lenTripcode; ++i)

	jmp	$LN998@SearchForT
$LN94@SearchForT:

; 833  : 
; 834  : 				} else if (searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) {

	cmp	DWORD PTR ?searchMode@@3HA, 2		; searchMode
	jne	$LN75@SearchForT

; 835  : 					generatedTripcodeChunkArray[0] = 0x00000000;
; 836  : 
; 837  : 					uint32_t tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0);

	shr	edx, 5
	mov	ecx, DWORD PTR [ebx+edx*4+26688]
	mov	eax, DWORD PTR [ebx+edx*4+25664]
	and	ecx, edi
	neg	ecx
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25888]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24864]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26144]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25120]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax

; 838  : 					if (!context->tripcodeChunkBitmap[4][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+ecx+30220], 0
	je	$second_part$1052

; 839  : 						goto second_part;
; 840  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 4);
; 841  : 
; 842  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0);

	mov	esi, DWORD PTR [ebx+edx*4+26400]
	mov	eax, DWORD PTR [ebx+edx*4+25376]
	and	esi, edi
	shl	ecx, 24					; 00000018H
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26656]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25632]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25856]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24832]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 843  : 					if (!context->tripcodeChunkBitmap[3][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30156], 0
	je	$LN1034@SearchForT

; 844  : 						goto second_part;
; 845  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 3);

	shl	esi, 18					; 00000012H

; 846  : 
; 847  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25088]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26112]
	and	esi, edi
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26368]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25344]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26624]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25600]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 848  : 					if (!context->tripcodeChunkBitmap[2][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30092], 0
	je	$LN1034@SearchForT

; 849  : 						goto second_part;
; 850  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 2);

	shl	esi, 12					; 0000000cH

; 851  : 
; 852  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0);

	mov	eax, DWORD PTR [ebx+edx*4+24800]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+25824]
	and	esi, edi
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26080]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25056]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26336]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25312]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 853  : 					if (!context->tripcodeChunkBitmap[1][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30028], 0
	je	$LN1034@SearchForT

; 854  : 						goto second_part;
; 855  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 1);

	shl	esi, 6

; 856  : 
; 857  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25568]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26592]
	and	esi, edi
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25792]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24768]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26048]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25024]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 858  : 					if (!context->tripcodeChunkBitmap[0][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+29964], 0
	je	SHORT $LN1034@SearchForT

; 859  : 						goto second_part;
; 860  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 0);

	or	ecx, esi

; 861  : 
; 862  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	mov	eax, ecx
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN1034@SearchForT
	mov	esi, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	ebx, ebx
	dec	esi
	js	SHORT $LN989@SearchForT
	npad	2
$LL63@SearchForT:
	mov	edi, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [esi+ebx]
	sar	eax, 1
	mov	edi, DWORD PTR [edi+eax*4]
	cmp	ecx, edi
	jbe	SHORT $LN1041@SearchForT
	lea	ebx, DWORD PTR [eax+1]
	jmp	SHORT $LN58@SearchForT
$LN1041@SearchForT:
	jae	$LN59@SearchForT
	lea	esi, DWORD PTR [eax-1]
$LN58@SearchForT:
	cmp	ebx, esi
	jle	SHORT $LL63@SearchForT

; 601  : 		for (int32_t i = 4; i < lenTripcode; ++i)

	mov	edi, DWORD PTR $T5[ebp]
$LN989@SearchForT:
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]
$LN1034@SearchForT:
	mov	esi, DWORD PTR _found$1$[ebp]
$second_part$1052:

; 863  : 
; 864  : second_part:
; 865  : 					generatedTripcodeChunkArray[0] = 0x00000000;
; 866  : 
; 867  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0);

	mov	ecx, DWORD PTR [ebx+edx*4+26304]
	mov	eax, DWORD PTR [ebx+edx*4+25280]
	and	ecx, edi
	neg	ecx
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], 0
	sbb	ecx, ecx
	and	eax, edi
	neg	ecx
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+26560]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25536]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+25760]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax
	mov	eax, DWORD PTR [ebx+edx*4+24736]
	and	eax, edi
	add	ecx, ecx
	neg	eax
	sbb	eax, eax
	neg	eax
	or	ecx, eax

; 868  : 					if (!context->tripcodeChunkBitmap[4][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+ecx+30220], 0
	je	$skip_final_permutation$1053

; 869  : 						goto skip_final_permutation;
; 870  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 4);
; 871  : 
; 872  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0);

	mov	esi, DWORD PTR [ebx+edx*4+26016]
	mov	eax, DWORD PTR [ebx+edx*4+24992]
	and	esi, edi
	shl	ecx, 24					; 00000018H
	neg	esi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26272]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25248]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26528]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25504]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 873  : 					if (!context->tripcodeChunkBitmap[3][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30156], 0
	je	$LN1029@SearchForT

; 874  : 						goto skip_final_permutation;
; 875  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 3);

	shl	esi, 18					; 00000012H

; 876  : 
; 877  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0);

	mov	eax, DWORD PTR [ebx+edx*4+24704]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+25728]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25984]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24960]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26240]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25216]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 878  : 					if (!context->tripcodeChunkBitmap[2][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30092], 0
	je	$LN1029@SearchForT

; 879  : 						goto skip_final_permutation;
; 880  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 2);

	shl	esi, 12					; 0000000cH

; 881  : 
; 882  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0);

	mov	eax, DWORD PTR [ebx+edx*4+25472]
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26496]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25696]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24672]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25952]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+24928]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax

; 883  : 					if (!context->tripcodeChunkBitmap[1][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+30028], 0
	je	$LN1029@SearchForT

; 884  : 						goto skip_final_permutation;
; 885  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 1);
; 886  : 
; 887  : 					tripcodeCharIndex = GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24);

	mov	eax, DWORD PTR [ebx+edx*4+25184]
	shl	esi, 6
	or	ecx, esi
	mov	esi, DWORD PTR [ebx+edx*4+26208]
	and	esi, edi
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	neg	esi
	sbb	esi, esi
	and	eax, edi
	neg	esi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+26464]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	mov	eax, DWORD PTR [ebx+edx*4+25440]
	and	eax, edi
	add	esi, esi
	neg	eax
	sbb	eax, eax
	neg	eax
	or	esi, eax
	shl	esi, 2

; 888  : 					if (!context->tripcodeChunkBitmap[0][tripcodeCharIndex])

	cmp	BYTE PTR [ebx+esi+29964], 0
	je	$LN1029@SearchForT

; 889  : 						goto skip_final_permutation;
; 890  : 					generatedTripcodeChunkArray[0] |= tripcodeCharIndex << (6 * 0);

	or	ecx, esi

; 891  : 
; 892  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	mov	esi, DWORD PTR _found$1$[ebp]
	mov	DWORD PTR _generatedTripcodeChunkArray$[ebp], ecx
	test	esi, esi
	jne	$LN28@SearchForT
	mov	eax, ecx
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	$LN972@SearchForT
	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	xor	edi, edi
	dec	edx
	js	$LN996@SearchForT
	npad	4
$LL46@SearchForT:
	mov	esi, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [edx+edi]
	sar	eax, 1
	mov	esi, DWORD PTR [esi+eax*4]
	cmp	ecx, esi
	jbe	SHORT $LN1042@SearchForT
	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN41@SearchForT
$LN59@SearchForT:
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]

; 861  : 
; 862  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	mov	esi, 1
	mov	edi, DWORD PTR $T5[ebp]
	mov	DWORD PTR _found$1$[ebp], esi
	jmp	$second_part$1052
$LN1042@SearchForT:

; 891  : 
; 892  : 					QUICK_SEARCH_FOR_TRIPCODE_CHUNK(0)

	jae	$LN97@SearchForT
	lea	edx, DWORD PTR [eax-1]
$LN41@SearchForT:
	cmp	edi, edx
	jle	SHORT $LL46@SearchForT

; 601  : 		for (int32_t i = 4; i < lenTripcode; ++i)

	jmp	$LN998@SearchForT
$LN75@SearchForT:

; 893  : 
; 894  : 				} else {
; 895  : 					DES_GetTripcodeChunks(context, tripcodeIndex, generatedTripcodeChunkArray, searchMode);

	push	ecx
	lea	ecx, DWORD PTR _generatedTripcodeChunkArray$[ebp]
	push	ecx
	mov	ecx, ebx
	call	?DES_GetTripcodeChunks@@YAXPAUDES_Context@@HPAIH@Z ; DES_GetTripcodeChunks
	add	esp, 8

; 896  : 					int32_t maxPos = (searchMode == SEARCH_MODE_FLEXIBLE || searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING)
; 897  : 						                ? (lenTripcode - MIN_LEN_EXPANDED_PATTERN)
; 898  : 						                : (0);

	cmp	DWORD PTR ?searchMode@@3HA, 3		; searchMode
	je	SHORT $LN429@SearchForT
	xor	eax, eax
	jmp	SHORT $LN1043@SearchForT
$LN429@SearchForT:
	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	eax, -5					; fffffffbH
$LN1043@SearchForT:

; 899  : 					for (int32_t pos = 0; !found && pos <= maxPos; ++pos)

	xor	edx, edx
	mov	DWORD PTR _maxPos$1$[ebp], eax
	mov	DWORD PTR _pos$1$[ebp], edx
$LL985@SearchForT:
	cmp	edx, eax
	jg	SHORT $LN999@SearchForT

; 900  : 						QUICK_SEARCH_FOR_TRIPCODE_CHUNK(pos)

	test	esi, esi
	jne	SHORT $LN38@SearchForT
	mov	edi, DWORD PTR _generatedTripcodeChunkArray$[ebp+edx*4]
	mov	eax, edi
	shr	eax, 18					; 00000012H
	cmp	BYTE PTR ?smallChunkBitmap@@3PAEA[eax], 0
	jne	SHORT $LN1045@SearchForT
	mov	ecx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	dec	ecx
	js	SHORT $LN1005@SearchForT
	npad	5
$LL35@SearchForT:
	mov	edx, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	lea	eax, DWORD PTR [ecx+esi]
	sar	eax, 1
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edi, edx
	jbe	SHORT $LN1044@SearchForT
	lea	esi, DWORD PTR [eax+1]
	jmp	SHORT $LN30@SearchForT
$LN1044@SearchForT:
	jae	SHORT $LN31@SearchForT
	lea	ecx, DWORD PTR [eax-1]
$LN30@SearchForT:
	cmp	esi, ecx
	jle	SHORT $LL35@SearchForT

; 601  : 		for (int32_t i = 4; i < lenTripcode; ++i)

	mov	edx, DWORD PTR _pos$1$[ebp]
$LN1005@SearchForT:
	mov	esi, DWORD PTR _found$1$[ebp]
$LN1045@SearchForT:
	mov	eax, DWORD PTR _maxPos$1$[ebp]
$LN38@SearchForT:

; 899  : 					for (int32_t pos = 0; !found && pos <= maxPos; ++pos)

	inc	edx
	mov	DWORD PTR _pos$1$[ebp], edx
	test	esi, esi
	je	SHORT $LL985@SearchForT

; 901  : 				}
; 902  : 
; 903  : skip_final_permutation:
; 904  : 				// Construct a valid 10 character key if necessary.
; 905  : 				if (found || searchForSpecialPatternsOnCPU) {

	jmp	$LN28@SearchForT
$LN31@SearchForT:
	mov	edx, DWORD PTR _pos$1$[ebp]

; 900  : 						QUICK_SEARCH_FOR_TRIPCODE_CHUNK(pos)

	mov	esi, 1
	mov	DWORD PTR _found$1$[ebp], esi
	jmp	SHORT $LN1045@SearchForT
$LN999@SearchForT:
	mov	edi, DWORD PTR $T5[ebp]
	jmp	SHORT $skip_final_permutation$1053
$LN1029@SearchForT:
	mov	esi, DWORD PTR _found$1$[ebp]
$skip_final_permutation$1053:

; 901  : 				}
; 902  : 
; 903  : skip_final_permutation:
; 904  : 				// Construct a valid 10 character key if necessary.
; 905  : 				if (found || searchForSpecialPatternsOnCPU) {

	test	esi, esi
	jne	$LN28@SearchForT
	jmp	$LN972@SearchForT
$LN996@SearchForT:
	mov	edi, DWORD PTR $T5[ebp]
	jmp	$LN972@SearchForT
$LN435@SearchForT:

; 907  : 					BOOL isKey7SecondByte = !isKey6SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[6]);

	xor	ecx, ecx

; 908  : 					tableForKey7 = (isKey7SecondByte) ? (context->keyCharTable_SecondByte) : (context->keyCharTable_FirstByte);

	lea	edx, DWORD PTR [ebx+28940]
$LN438@SearchForT:

; 909  : 					key[7] = tableForKey7[(int32_t)randomByteKey7 + (tripcodeIndex & 0x1f)];

	mov	eax, edi
	and	eax, 31					; 0000001fH
	add	eax, DWORD PTR tv14478[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _key$[ebp+7], al

; 910  : 					if (!isKey7SecondByte && IS_FIRST_BYTE_SJIS_FULL(key[7])) {

	test	ecx, ecx
	jne	SHORT $LN27@SearchForT
	cmp	al, 129					; 00000081H
	jb	SHORT $LN25@SearchForT
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN26@SearchForT
$LN25@SearchForT:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN24@SearchForT
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN26@SearchForT
$LN24@SearchForT:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	ja	SHORT $LN27@SearchForT
$LN26@SearchForT:

; 911  : 						key[8] = keyCharTable_SecondByte [randomByteKey8];

	mov	eax, DWORD PTR _randomValue$1[ebp]
	movzx	eax, al
	mov	al, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[eax]
	mov	BYTE PTR _key$[ebp+8], al
$LN439@SearchForT:

; 917  : 									: keyCharTable_OneByte[randomByteKey9];

	mov	eax, DWORD PTR _randomValue$2[ebp]
	movzx	eax, al
	mov	al, BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax]
$LN440@SearchForT:
	mov	BYTE PTR _key$[ebp+9], al

; 918  : 					}
; 919  : 				}
; 920  : 				if (found) {

	test	esi, esi
	je	SHORT $LN22@SearchForT

; 921  : 					ProcessPossibleMatch(DES_GetTripcode(context, tripcodeIndex, tripcode), key);

	lea	eax, DWORD PTR _key$[ebp]
	mov	edx, edi
	push	eax
	lea	eax, DWORD PTR _tripcode$[ebp]
	mov	ecx, ebx
	push	eax
	call	?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z ; DES_GetTripcode
	add	esp, 4
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
	jmp	$LN995@SearchForT
$LN27@SearchForT:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1715 : 	if (options.maximizeKeySpace) {

	cmp	DWORD PTR ?options@@3UOptions@@A+88, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h

; 914  : 						key[8] = keyCharTable_FirstByte  [randomByteKey8];

	mov	eax, DWORD PTR _randomValue$1[ebp]
	movzx	eax, al
	mov	al, BYTE PTR ?keyCharTable_FirstByte@@3PAEA[eax]
	mov	BYTE PTR _key$[ebp+8], al
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1715 : 	if (options.maximizeKeySpace) {

	je	SHORT $LN450@SearchForT

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	al, 129					; 00000081H
	jb	SHORT $LN453@SearchForT
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN976@SearchForT
$LN453@SearchForT:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN454@SearchForT
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN976@SearchForT
$LN454@SearchForT:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN1048@SearchForT
$LN450@SearchForT:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	al, 137					; 00000089H
	jb	SHORT $LN458@SearchForT
	cmp	al, 151					; 00000097H
	jbe	SHORT $LN976@SearchForT
$LN458@SearchForT:
	cmp	al, 153					; 00000099H
	jb	SHORT $LN459@SearchForT
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN976@SearchForT
$LN459@SearchForT:
	add	al, 32					; 00000020H
	cmp	al, 9
$LN1048@SearchForT:
	ja	SHORT $LN439@SearchForT
$LN976@SearchForT:
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h

; 917  : 									: keyCharTable_OneByte[randomByteKey9];

	mov	eax, DWORD PTR _randomValue$2[ebp]
	movzx	eax, al
	mov	al, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[eax]
	jmp	SHORT $LN440@SearchForT
$LN22@SearchForT:

; 922  : 				} else if (!found && searchForSpecialPatternsOnCPU) {                                                                                                           \

	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	je	$LN995@SearchForT

; 923  : 					DES_GetTripcode(context, tripcodeIndex, tripcode);

	lea	eax, DWORD PTR _tripcode$[ebp]
	mov	edx, edi
	push	eax
	mov	ecx, ebx
	call	?DES_GetTripcode@@YAPAEPAUDES_Context@@HPAE@Z ; DES_GetTripcode

; 924  : 					if (   options.searchForKaibunOnCPU
; 925  : 						&& tripcode[0] == tripcode[ 9]
; 926  : 						&& tripcode[1] == tripcode[ 8]
; 927  : 						&& tripcode[2] == tripcode[ 7]
; 928  : 						&& tripcode[3] == tripcode[ 6]
; 929  : 						&& tripcode[4] == tripcode[ 5] ) {

	mov	dh, BYTE PTR _tripcode$[ebp+4]
	add	esp, 4
	cmp	DWORD PTR ?options@@3UOptions@@A+60, 0
	mov	ch, BYTE PTR _tripcode$[ebp+2]
	mov	cl, BYTE PTR _tripcode$[ebp+1]
	mov	dl, BYTE PTR _tripcode$[ebp]
	je	SHORT $LN19@SearchForT
	cmp	dl, BYTE PTR _tripcode$[ebp+9]
	jne	SHORT $LN19@SearchForT
	cmp	cl, BYTE PTR _tripcode$[ebp+8]
	jne	SHORT $LN19@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN19@SearchForT
	mov	al, BYTE PTR _tripcode$[ebp+3]
	cmp	al, BYTE PTR _tripcode$[ebp+6]
	jne	SHORT $LN19@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+5]
	je	$LN1049@SearchForT
$LN19@SearchForT:

; 930  : 						ProcessMatch(tripcode, key);
; 931  : 					} else if (   options.searchForKagamiOnCPU
; 932  : 								&& charTableForKagami[tripcode[0]] == tripcode[ 9]
; 933  :  								&& charTableForKagami[tripcode[1]] == tripcode[ 8]
; 934  : 								&& charTableForKagami[tripcode[2]] == tripcode[ 7]
; 935  : 								&& charTableForKagami[tripcode[3]] == tripcode[ 6]
; 936  : 								&& charTableForKagami[tripcode[4]] == tripcode[ 5]
; 937  : 					) {

	cmp	DWORD PTR ?options@@3UOptions@@A+72, 0
	je	SHORT $LN17@SearchForT
	mov	bl, BYTE PTR _tripcode$[ebp+9]
	movzx	eax, dl
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], bl
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]
	jne	SHORT $LN17@SearchForT
	mov	bl, BYTE PTR _tripcode$[ebp+8]
	movzx	eax, cl
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], bl
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]
	jne	SHORT $LN17@SearchForT
	mov	dh, BYTE PTR _tripcode$[ebp+7]
	movzx	eax, ch
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], dh
	mov	dh, BYTE PTR _tripcode$[ebp+4]
	jne	SHORT $LN17@SearchForT
	movzx	eax, BYTE PTR _tripcode$[ebp+3]
	mov	bl, BYTE PTR _tripcode$[ebp+6]
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], bl
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]
	jne	SHORT $LN17@SearchForT
	mov	bl, BYTE PTR _tripcode$[ebp+5]
	movzx	eax, dh
	cmp	BYTE PTR ?charTableForKagami@@3PAEA[eax], bl
	mov	ebx, DWORD PTR _context$GSCopy$1$[ebp]
	je	$LN1049@SearchForT
$LN17@SearchForT:

; 938  : 						ProcessMatch(tripcode, key);
; 939  : 					} else if (   options.searchForYamabikoOnCPU
; 940  : 								&& tripcode[0] == tripcode[ 5]
; 941  : 								&& tripcode[1] == tripcode[ 6]
; 942  : 								&& tripcode[2] == tripcode[ 7]
; 943  : 								&& tripcode[3] == tripcode[ 8]
; 944  : 								&& tripcode[4] == tripcode[ 9] ) {

	cmp	DWORD PTR ?options@@3UOptions@@A+64, 0
	mov	al, BYTE PTR _tripcode$[ebp+6]
	mov	ah, BYTE PTR _tripcode$[ebp+8]
	je	SHORT $LN15@SearchForT
	cmp	dl, BYTE PTR _tripcode$[ebp+5]
	jne	SHORT $LN15@SearchForT
	cmp	cl, al
	jne	SHORT $LN15@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN15@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], ah
	jne	SHORT $LN15@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+9]
	je	$LN1049@SearchForT
$LN15@SearchForT:

; 945  : 						ProcessMatch(tripcode, key);
; 946  : 					} else if (   options.searchForSourenOnCPU
; 947  : 								&& tripcode[ 0] == tripcode[ 1]
; 948  : 								&& tripcode[ 2] == tripcode[ 3]
; 949  : 								&& tripcode[ 4] == tripcode[ 5]
; 950  : 								&& tripcode[ 6] == tripcode[ 7]
; 951  : 								&& tripcode[ 8] == tripcode[ 9] ) {

	cmp	DWORD PTR ?options@@3UOptions@@A+68, 0
	je	SHORT $LN13@SearchForT
	cmp	dl, cl
	jne	SHORT $LN13@SearchForT
	cmp	ch, BYTE PTR _tripcode$[ebp+3]
	jne	SHORT $LN13@SearchForT
	cmp	dh, BYTE PTR _tripcode$[ebp+5]
	jne	SHORT $LN13@SearchForT
	cmp	al, BYTE PTR _tripcode$[ebp+7]
	jne	SHORT $LN13@SearchForT
	cmp	ah, BYTE PTR _tripcode$[ebp+9]
	je	$LN1049@SearchForT
$LN13@SearchForT:

; 952  : 						ProcessMatch(tripcode, key);
; 953  : 					} else if (   options.searchForHisekiOnCPU
; 954  : 								&& tripcode[ 0] == '.'
; 955  : 								&& tripcode[ 2] == '.'
; 956  : 								&& tripcode[ 4] == '.'
; 957  : 								&& tripcode[ 6] == '.'
; 958  : 								&& tripcode[ 8] == '.') {

	cmp	DWORD PTR ?options@@3UOptions@@A+52, 0
	je	SHORT $LN5@SearchForT
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN11@SearchForT
	cmp	ch, dl
	jne	SHORT $LN11@SearchForT
	cmp	dh, dl
	jne	SHORT $LN11@SearchForT
	cmp	al, dl
	jne	SHORT $LN11@SearchForT
	cmp	ah, dl
	je	SHORT $LN1049@SearchForT
$LN11@SearchForT:

; 959  : 						ProcessMatch(tripcode, key);
; 960  : 					} else if (   options.searchForHisekiOnCPU
; 961  : 								&& tripcode[ 1] == '.'
; 962  : 								&& tripcode[ 3] == '.'
; 963  : 								&& tripcode[ 5] == '.'
; 964  : 								&& tripcode[ 7] == '.'
; 965  : 								&& tripcode[ 9] == '.') {

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN9@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	je	SHORT $LN1049@SearchForT
$LN9@SearchForT:

; 966  : 						ProcessMatch(tripcode, key);
; 967  : 					} else if (   options.searchForHisekiOnCPU
; 968  : 								&& tripcode[ 0] == '/'
; 969  : 								&& tripcode[ 2] == '/'
; 970  : 								&& tripcode[ 4] == '/'
; 971  : 								&& tripcode[ 6] == '/'
; 972  : 								&& tripcode[ 8] == '/') {

	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN7@SearchForT
	cmp	ch, dl
	jne	SHORT $LN7@SearchForT
	cmp	dh, dl
	jne	SHORT $LN7@SearchForT
	cmp	al, dl
	jne	SHORT $LN7@SearchForT
	cmp	ah, dl
	je	SHORT $LN1049@SearchForT
$LN7@SearchForT:

; 973  : 						ProcessMatch(tripcode, key);
; 974  : 					} else if (   options.searchForHisekiOnCPU
; 975  : 								&& tripcode[ 1] == '/'
; 976  : 								&& tripcode[ 3] == '/'
; 977  : 								&& tripcode[ 5] == '/'
; 978  : 								&& tripcode[ 7] == '/'
; 979  : 								&& tripcode[ 9] == '/') {

	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN5@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	je	SHORT $LN1049@SearchForT
$LN5@SearchForT:

; 980  : 						ProcessMatch(tripcode, key);
; 981  : 					} else if (   options.searchForKakuhiOnCPU
; 982  : 								&& tripcode[ 2] == tripcode[0]
; 983  : 								&& tripcode[ 4] == tripcode[0]
; 984  : 								&& tripcode[ 6] == tripcode[0]
; 985  : 								&& tripcode[ 8] == tripcode[0]) {

	cmp	DWORD PTR ?options@@3UOptions@@A+56, 0
	je	SHORT $LN995@SearchForT
	cmp	ch, dl
	jne	SHORT $LN3@SearchForT
	cmp	dh, dl
	jne	SHORT $LN3@SearchForT
	cmp	al, dl
	jne	SHORT $LN3@SearchForT
	cmp	ah, dl
	je	SHORT $LN1049@SearchForT
$LN3@SearchForT:

; 986  : 						ProcessMatch(tripcode, key);
; 987  : 					} else if (   options.searchForKakuhiOnCPU
; 988  : 								&& tripcode[ 3] == tripcode[1]
; 989  : 								&& tripcode[ 5] == tripcode[1]
; 990  : 								&& tripcode[ 7] == tripcode[1]
; 991  : 								&& tripcode[ 9] == tripcode[1]) {

	cmp	BYTE PTR _tripcode$[ebp+3], cl
	jne	SHORT $LN995@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+5], cl
	jne	SHORT $LN995@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+7], cl
	jne	SHORT $LN995@SearchForT
	cmp	BYTE PTR _tripcode$[ebp+9], cl
	jne	SHORT $LN995@SearchForT
$LN1049@SearchForT:

; 992  : 						ProcessMatch(tripcode, key);

	lea	edx, DWORD PTR _key$[ebp]
	lea	ecx, DWORD PTR _tripcode$[ebp]
	call	?ProcessMatch@@YAXPAE0@Z		; ProcessMatch
$LN995@SearchForT:
	mov	edi, DWORD PTR $T5[ebp]
$LN139@SearchForT:

; 739  : 
; 740  : 			// continue;
; 741  : 
; 742  : 			for (tripcodeIndex = 0; tripcodeIndex < BITSLICE_DES_DEPTH; ++tripcodeIndex) {

	mov	eax, DWORD PTR _tripcodeIndex$1$[ebp]
	inc	eax
	rol	edi, 1
	mov	DWORD PTR _tripcodeIndex$1$[ebp], eax
	mov	DWORD PTR $T5[ebp], edi
	cmp	eax, 256				; 00000100H
	jb	$LL140@SearchForT

; 669  : 
; 670  : 		for (indexKey5 = 0; indexKey5 <= CPU_DES_MAX_INDEX_FOR_KEYS; ++indexKey5) {

	mov	eax, DWORD PTR _indexKey5$1$[ebp]
	lea	esi, DWORD PTR [ebx+28256]
	mov	ecx, DWORD PTR _tableForKey5$1$[ebp]
	inc	eax
	mov	DWORD PTR _indexKey5$1$[ebp], eax
	cmp	eax, 31					; 0000001fH
	jbe	$LL209@SearchForT

; 655  : 				
; 656  : 	for (indexKey4 = 0; indexKey4 <= CPU_DES_MAX_INDEX_FOR_KEYS; ++indexKey4) {

	mov	ecx, DWORD PTR _indexKey4$1$[ebp]
	lea	esi, DWORD PTR [ebx+28256]
	mov	edx, DWORD PTR _tableForKey4$1$[ebp]
	lea	edi, DWORD PTR [ebx+28032]
	inc	ecx
	mov	DWORD PTR _indexKey4$1$[ebp], ecx
	cmp	ecx, 31					; 0000001fH
	jbe	$LL246@SearchForT

; 993  : 					}
; 994  : 				}
; 995  : 			}
; 996  : 		}
; 997  : 	}
; 998  : 
; 999  : 	return numGeneratedTripcodes;
; 1000 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _numGeneratedTripcodes$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1050@SearchForT:

; 586  : 	uint32_t   indexKey4,     indexKey5;
; 587  : 	unsigned char *tableForKey4, *tableForKey5, *tableForKey6, *tableForKey7;
; 588  : 	uint32_t   tripcodeIndex;
; 589  : 	unsigned char  randomByteKey6, randomByteKey7, randomByteKey8, randomByteKey9;
; 590  : 
; 591  : 	tripcode[lenTripcode] = '\0';

	call	___report_rangecheckfailure
$LN1051@SearchForT:
$LN1035@SearchForT:
	int	3
?SearchForTripcodes@@YAIPAUDES_Context@@@Z ENDP		; SearchForTripcodes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\cpu10.h
;	COMDAT ?GetCrypt25Address@@YAPADPAUDES_Context@@@Z
_TEXT	SEGMENT
?GetCrypt25Address@@YAPADPAUDES_Context@@@Z PROC	; GetCrypt25Address, COMDAT
; _context$ = ecx

; 1004 : #ifdef _M_X64
; 1005 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x64_AVX2         :
; 1006 : 		            context->useAVX                        ? DES_Crypt25_x64_AVX          :
; 1007 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x64_SSE2_Nehalem :
; 1008 : 					                                         DES_Crypt25_x64_SSE2          );
; 1009 : #else
; 1010 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x86_AVX2         :
; 1011 : 		            context->useAVX                        ? DES_Crypt25_x86_AVX          :
; 1012 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x86_SSE2_Nehalem :
; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	cmp	DWORD PTR [ecx+28936], 0
	je	SHORT $LN5@GetCrypt25
	mov	eax, OFFSET _DES_Crypt25_x86_AVX2

; 1014 : #endif
; 1015 : }

	ret	0
$LN5@GetCrypt25:

; 1004 : #ifdef _M_X64
; 1005 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x64_AVX2         :
; 1006 : 		            context->useAVX                        ? DES_Crypt25_x64_AVX          :
; 1007 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x64_SSE2_Nehalem :
; 1008 : 					                                         DES_Crypt25_x64_SSE2          );
; 1009 : #else
; 1010 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x86_AVX2         :
; 1011 : 		            context->useAVX                        ? DES_Crypt25_x86_AVX          :
; 1012 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x86_SSE2_Nehalem :
; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	cmp	DWORD PTR [ecx+28932], 0
	je	SHORT $LN3@GetCrypt25
	mov	eax, OFFSET _DES_Crypt25_x86_AVX

; 1014 : #endif
; 1015 : }

	ret	0
$LN3@GetCrypt25:

; 1004 : #ifdef _M_X64
; 1005 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x64_AVX2         :
; 1006 : 		            context->useAVX                        ? DES_Crypt25_x64_AVX          :
; 1007 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x64_SSE2_Nehalem :
; 1008 : 					                                         DES_Crypt25_x64_SSE2          );
; 1009 : #else
; 1010 : 	return (char *)(context->useAVX2                       ? DES_Crypt25_x86_AVX2         :
; 1011 : 		            context->useAVX                        ? DES_Crypt25_x86_AVX          :
; 1012 : 		            IsCPUBasedOnNehalemMicroarchitecture() ? DES_Crypt25_x86_SSE2_Nehalem :
; 1013 : 				                                             DES_Crypt25_x86_SSE2          );

	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture
	test	eax, eax
	mov	ecx, OFFSET _DES_Crypt25_x86_SSE2
	mov	edx, OFFSET _DES_Crypt25_x86_SSE2_Nehalem
	cmovne	ecx, edx
	mov	eax, ecx

; 1014 : #endif
; 1015 : }

	ret	0
?GetCrypt25Address@@YAPADPAUDES_Context@@@Z ENDP	; GetCrypt25Address
_TEXT	ENDS
END
