; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	Z:\GitHub\merikens-tripcode-engine\SourceFiles\Main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?numAverageTrialsForOneMatch@@3NA		; numAverageTrialsForOneMatch
PUBLIC	?base64CharTable@@3PADA				; base64CharTable
PUBLIC	?lenTripcodeKey@@3HA				; lenTripcodeKey
PUBLIC	?keyCharTable_OneByte@@3PAEA			; keyCharTable_OneByte
PUBLIC	?keyCharTable_SecondByteAndOneByte@@3PAEA	; keyCharTable_SecondByteAndOneByte
PUBLIC	?options@@3UOptions@@A				; options
PUBLIC	?keyCharTable_SecondByte@@3PAEA			; keyCharTable_SecondByte
PUBLIC	?tripcodeFilePath@@3PADA			; tripcodeFilePath
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`vftable'
PUBLIC	?lenTripcode@@3HA				; lenTripcode
PUBLIC	?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?wasSearchAbortedWithError@@3HA			; wasSearchAbortedWithError
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Base Class Array'
PUBLIC	?prevTotalNumGeneratedTripcodes_GPU@@3NA	; prevTotalNumGeneratedTripcodes_GPU
PUBLIC	?CUDADeviceCount@@3HA				; CUDADeviceCount
PUBLIC	?openCLDeviceCount@@3HA				; openCLDeviceCount
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> > `RTTI Type Descriptor'
PUBLIC	?patternFilePathArray@@3PAY0EAB@DA		; patternFilePathArray
PUBLIC	??_R0?AV_Pad@std@@@8				; std::_Pad `RTTI Type Descriptor'
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?openCLRunChildProcesses@@3HA			; openCLRunChildProcesses
PUBLIC	??_R3_Pad@std@@8				; std::_Pad::`RTTI Class Hierarchy Descriptor'
PUBLIC	?totalNumGeneratedTripcodes_CPU@@3NA		; totalNumGeneratedTripcodes_CPU
PUBLIC	?prevNumValidTripcodes@@3IA			; prevNumValidTripcodes
PUBLIC	?numOneByte@@3HA				; numOneByte
PUBLIC	?eventForTerminating@@3PAXA			; eventForTerminating
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?applicationPath@@3PADA				; applicationPath
PUBLIC	?numOpenCLDeviceSearchThreads@@3HA		; numOpenCLDeviceSearchThreads
PUBLIC	?numPatternFiles@@3HA				; numPatternFiles
PUBLIC	??_R1A@?0A@EA@_Pad@std@@8			; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?nameEventForTerminating@@3PADA			; nameEventForTerminating
PUBLIC	?keyCharTable_FirstByte@@3PAEA			; keyCharTable_FirstByte
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?numGeneratedTripcodes_GPU@@3IA			; numGeneratedTripcodes_GPU
PUBLIC	?numGeneratedTripcodesByGPUInMillions@@3IA	; numGeneratedTripcodesByGPUInMillions
PUBLIC	?currentSpeed_CPU@@3NA				; currentSpeed_CPU
PUBLIC	??_R2_Pad@std@@8				; std::_Pad::`RTTI Base Class Array'
PUBLIC	?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
PUBLIC	?numFirstByte@@3HA				; numFirstByte
PUBLIC	?cpu_search_threads@@3PAPAVthread@std@@A	; cpu_search_threads
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`vftable'
PUBLIC	?numGeneratedTripcodes_CPU@@3IA			; numGeneratedTripcodes_CPU
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Complete Object Locator'
PUBLIC	?totalTime@@3NA					; totalTime
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Base Class Array'
PUBLIC	?currentSpeed_thisProcess@@3NA			; currentSpeed_thisProcess
PUBLIC	?searchMode@@3HA				; searchMode
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Complete Object Locator'
PUBLIC	?prevTotalNumGeneratedTripcodes@@3NA		; prevTotalNumGeneratedTripcodes
PUBLIC	?prevNumDiscardedTripcodes@@3IA			; prevNumDiscardedTripcodes
PUBLIC	?numValidTripcodes@@3IA				; numValidTripcodes
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Array'
PUBLIC	?isSearchPaused@@3HA				; isSearchPaused
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`vftable'
PUBLIC	?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
PUBLIC	?tripcodeFile@@3PAU_iobuf@@A			; tripcodeFile
PUBLIC	?numCUDADeviceSearchThreads@@3HA		; numCUDADeviceSearchThreads
PUBLIC	?wasSearchTerminated@@3HA			; wasSearchTerminated
PUBLIC	?numSecondByte@@3HA				; numSecondByte
PUBLIC	?nameMutexForPausing@@3PADA			; nameMutexForPausing
PUBLIC	?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
PUBLIC	?numGeneratedTripcodesByCPUInMillions@@3IA	; numGeneratedTripcodesByCPUInMillions
PUBLIC	?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A	; openCLDeviceIDArray
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> > `RTTI Type Descriptor'
PUBLIC	?currentSpeed_thisProcess_GPU@@3NA		; currentSpeed_thisProcess_GPU
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?totalNumGeneratedTripcodes_GPU@@3NA		; totalNumGeneratedTripcodes_GPU
PUBLIC	?totalNumGeneratedTripcodes@@3NA		; totalNumGeneratedTripcodes
PUBLIC	?maximumSpeed@@3NA				; maximumSpeed
PUBLIC	?numCPUSearchThreads@@3HA			; numCPUSearchThreads
PUBLIC	?numDiscardedTripcodes@@3IA			; numDiscardedTripcodes
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?prevTotalNumGeneratedTripcodes_CPU@@3NA	; prevTotalNumGeneratedTripcodes_CPU
PUBLIC	?prevLineCount@@3HA				; prevLineCount
PUBLIC	?matchingProb@@3NA				; matchingProb
PUBLIC	?applicationDirectory@@3PADA			; applicationDirectory
PUBLIC	?searchDevice@@3HA				; searchDevice
EXTRN	_getchar:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	_exit:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__OpenEventW@12:PROC
EXTRN	__imp__CreateToolhelp32Snapshot@8:PROC
EXTRN	__imp__cudaGetErrorString@4:PROC
EXTRN	__imp__SetConsoleCursorInfo@8:PROC
EXTRN	__imp__Process32NextW@8:PROC
EXTRN	?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForDESTripcodesOnCUDADevice
EXTRN	?terminate@@YAXXZ:PROC				; terminate
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__SetConsoleCtrlHandler@8:PROC
EXTRN	__imp__GetConsoleScreenBufferInfo@8:PROC
EXTRN	__imp__Process32FirstW@8:PROC
EXTRN	__fullpath:PROC
EXTRN	_rand_s:PROC
EXTRN	?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForSHA1TripcodesOnCUDADevice
EXTRN	?Thread_SearchForDESTripcodesOnCUDADevice_Registers@@YAXPAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForDESTripcodesOnCUDADevice_Registers
EXTRN	??3@YAXPAXABUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	__imp__OpenMutexW@12:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__clGetDeviceIDs@24:PROC
EXTRN	__imp__cudaGetDeviceProperties@8:PROC
EXTRN	__imp__SetConsoleCursorPosition@8:PROC
EXTRN	__imp__clGetPlatformInfo@20:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	?TestNewCode@@YAXXZ:PROC			; TestNewCode
EXTRN	__imp__clGetPlatformIDs@12:PROC
EXTRN	_atoi:PROC
EXTRN	__imp__cudaGetDeviceCount@4:PROC
EXTRN	__Thrd_detach:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	??_U@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??1_Pad@std@@QAE@XZ:PROC			; std::_Pad::~_Pad
EXTRN	??0_Pad@std@@QAE@XZ:PROC			; std::_Pad::_Pad
EXTRN	?_Release@_Pad@std@@QAEXXZ:PROC			; std::_Pad::_Release
EXTRN	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z:PROC	; std::_Pad::_Launch
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
?numAverageTrialsForOneMatch@@3NA DQ 01H DUP (?)	; numAverageTrialsForOneMatch
?keyCharTable_OneByte@@3PAEA DB 0200H DUP (?)		; keyCharTable_OneByte
?keyCharTable_SecondByteAndOneByte@@3PAEA DB 0200H DUP (?) ; keyCharTable_SecondByteAndOneByte
?keyCharTable_SecondByte@@3PAEA DB 0200H DUP (?)	; keyCharTable_SecondByte
?tripcodeFilePath@@3PADA DB 0401H DUP (?)		; tripcodeFilePath
	ALIGN	4

?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A DD 01H DUP (?) ; openCLDeviceSearchThreadInfoArray
?wasSearchAbortedWithError@@3HA DD 01H DUP (?)		; wasSearchAbortedWithError
	ALIGN	8

?prevTotalNumGeneratedTripcodes_GPU@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes_GPU
?CUDADeviceCount@@3HA DD 01H DUP (?)			; CUDADeviceCount
?openCLDeviceCount@@3HA DD 01H DUP (?)			; openCLDeviceCount
?patternFilePathArray@@3PAY0EAB@DA DB 040100H DUP (?)	; patternFilePathArray
?openCLRunChildProcesses@@3HA DD 01H DUP (?)		; openCLRunChildProcesses
	ALIGN	8

?totalNumGeneratedTripcodes_CPU@@3NA DQ 01H DUP (?)	; totalNumGeneratedTripcodes_CPU
?prevNumValidTripcodes@@3IA DD 01H DUP (?)		; prevNumValidTripcodes
?numOneByte@@3HA DD 01H DUP (?)				; numOneByte
?eventForTerminating@@3PAXA DD 01H DUP (?)		; eventForTerminating
?applicationPath@@3PADA DB 0401H DUP (?)		; applicationPath
	ALIGN	4

?numOpenCLDeviceSearchThreads@@3HA DD 01H DUP (?)	; numOpenCLDeviceSearchThreads
?numPatternFiles@@3HA DD 01H DUP (?)			; numPatternFiles
?nameEventForTerminating@@3PADA DB 0101H DUP (?)	; nameEventForTerminating
	ALIGN	4

?keyCharTable_FirstByte@@3PAEA DB 0200H DUP (?)		; keyCharTable_FirstByte
?numGeneratedTripcodes_GPU@@3IA DD 01H DUP (?)		; numGeneratedTripcodes_GPU
?numGeneratedTripcodesByGPUInMillions@@3IA DD 01H DUP (?) ; numGeneratedTripcodesByGPUInMillions
	ALIGN	8

?currentSpeed_CPU@@3NA DQ 01H DUP (?)			; currentSpeed_CPU
?opencl_device_search_threads@@3PAPAVthread@std@@A DD 01H DUP (?) ; opencl_device_search_threads
?numFirstByte@@3HA DD 01H DUP (?)			; numFirstByte
?cpu_search_threads@@3PAPAVthread@std@@A DD 01H DUP (?)	; cpu_search_threads
?numGeneratedTripcodes_CPU@@3IA DD 01H DUP (?)		; numGeneratedTripcodes_CPU
?totalTime@@3NA DQ 01H DUP (?)				; totalTime
?currentSpeed_thisProcess@@3NA DQ 01H DUP (?)		; currentSpeed_thisProcess
?prevTotalNumGeneratedTripcodes@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes
?prevNumDiscardedTripcodes@@3IA DD 01H DUP (?)		; prevNumDiscardedTripcodes
?numValidTripcodes@@3IA DD 01H DUP (?)			; numValidTripcodes
?isSearchPaused@@3HA DD 01H DUP (?)			; isSearchPaused
?cuda_device_search_threads@@3PAPAVthread@std@@A DD 01H DUP (?) ; cuda_device_search_threads
?tripcodeFile@@3PAU_iobuf@@A DD 01H DUP (?)		; tripcodeFile
?numCUDADeviceSearchThreads@@3HA DD 01H DUP (?)		; numCUDADeviceSearchThreads
?wasSearchTerminated@@3HA DD 01H DUP (?)		; wasSearchTerminated
?numSecondByte@@3HA DD 01H DUP (?)			; numSecondByte
?nameMutexForPausing@@3PADA DB 0101H DUP (?)		; nameMutexForPausing
	ALIGN	4

?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A DD 01H DUP (?) ; CUDADeviceSearchThreadInfoArray
?numGeneratedTripcodesByCPUInMillions@@3IA DD 01H DUP (?) ; numGeneratedTripcodesByCPUInMillions
?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A DD 01H DUP (?) ; openCLDeviceIDArray
_nameEventForTerminatingWC DW 0101H DUP (?)
	ALIGN	8

?currentSpeed_thisProcess_GPU@@3NA DQ 01H DUP (?)	; currentSpeed_thisProcess_GPU
?totalNumGeneratedTripcodes_GPU@@3NA DQ 01H DUP (?)	; totalNumGeneratedTripcodes_GPU
?totalNumGeneratedTripcodes@@3NA DQ 01H DUP (?)		; totalNumGeneratedTripcodes
?maximumSpeed@@3NA DQ 01H DUP (?)			; maximumSpeed
_nameMutexForPausingWC DW 0101H DUP (?)
	ALIGN	4

?numCPUSearchThreads@@3HA DD 01H DUP (?)		; numCPUSearchThreads
?numDiscardedTripcodes@@3IA DD 01H DUP (?)		; numDiscardedTripcodes
	ALIGN	8

?prevTotalNumGeneratedTripcodes_CPU@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes_CPU
?prevLineCount@@3HA DD 01H DUP (?)			; prevLineCount
	ALIGN	8

?matchingProb@@3NA DQ 01H DUP (?)			; matchingProb
?applicationDirectory@@3PADA DB 0401H DUP (?)		; applicationDirectory
	ALIGN	4

?searchDevice@@3HA DD 01H DUP (?)			; searchDevice
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchT'
	DB	'hreadInfo@@@ZPAU1@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ DD FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`vftable'
	DD	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ DD FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`vftable'
	DD	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R2_Pad@std@@8
rdata$r	SEGMENT
??_R2_Pad@std@@8 DD FLAT:??_R1A@?0A@EA@_Pad@std@@8	; std::_Pad::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Pad@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Pad@std@@8 DD FLAT:??_R0?AV_Pad@std@@@8	; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Pad@std@@8
rdata$r	SEGMENT
??_R3_Pad@std@@8 DD 00H					; std::_Pad::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Pad@std@@@8
data$r	SEGMENT
??_R0?AV_Pad@std@@@8 DD FLAT:??_7type_info@@6B@		; std::_Pad `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Pad@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThr'
	DB	'eadInfo@@@ZPAU1@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ DD FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::`vftable'
	DD	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ
	ORG $+1
?base64CharTable@@3PADA DB 041H				; base64CharTable
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02eH
	DB	02fH
?lenTripcodeKey@@3HA DD 0aH				; lenTripcodeKey
?lenTripcode@@3HA DD 0aH				; lenTripcode
?options@@3UOptions@@A DD 0ffffffffH			; options
	DD	080H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
?searchMode@@3HA DD 0ffffffffH				; searchMode
$SG4294899467 DB 00H
$SG4294899451 DB 00H
$SG4294899449 DB 00H
$SG4294899444 DB 00H
$SG4294899442 DB 00H
$SG4294899434 DB 00H
$SG4294899419 DB 00H
$SG4294899417 DB 00H
$SG4294899408 DB 00H
$SG4294899528 DB 'ERROR_INVALID_REGEX', 00H
$SG4294899525 DB 'CUDA fucnction call failed.', 00H
	ORG $+2
$SG4294899526 DB 'ERROR_PATTERN_TOO_SHORT', 00H
$SG4294899523 DB 'ERROR_PATTERN_FILE', 00H
	ORG $+2
$SG4294899527 DB 'ERROR_PATTERN_TOO_LONG', 00H
	ORG $+1
$SG4294899524 DB 'ERROR_NO_MEMORY', 00H
$SG4294899520 DB 'ERROR_CRYPTOGRAPHIC_SERVICE', 00H
	ORG $+2
$SG4294899522 DB 'ERROR_IGNORE_DIRECTIVE', 00H
	ORG $+1
$SG4294899521 DB 'ERROR_NO_TARGET_PATTERNS', 00H
	ORG $+2
$SG4294899518 DB 'ERROR_TRIPCODE_FILE', 00H
	ORG $+2
$SG4294899516 DB 'ERROR_MUTEX', 00H
	ORG $+2
$SG4294899517 DB 'ERROR_SEARCH_THREAD', 00H
	ORG $+2
$SG4294899515 DB 'Assertion failed.', 00H
	ORG $+2
$SG4294899512 DB 'ERROR_SHA1', 00H
	ORG $+2
$SG4294899513 DB 'ERROR_DES', 00H
	ORG $+2
$SG4294899510 DB 'ERROR_CHILD_PROCESS', 00H
	ORG $+2
$SG4294899511 DB 'ERROR_INTEL_HD_GRAPHICS', 00H
$SG4294899508 DB 'ERROR_EVENT', 00H
	ORG $+2
$SG4294899507 DB 'ERROR_SEARCH_THREAD_UNRESPONSIVE', 00H
	ORG $+2
$SG4294899504 DB 'MerikensTripcodeEngine', 00H
	ORG $+1
$SG4294899502 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899500 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899501 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899498 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899496 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899497 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899494 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899492 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+2
$SG4294899493 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899490 DB '%s English', 0aH, 00H
	ORG $+2
$SG4294899491 DB 'Meriken''s Tripcode Engine 2.1.2', 00H
$SG4294899488 DB '07:16:04', 00H
	ORG $+2
$SG4294899489 DB 'May  4 2016', 00H
	ORG $+2
$SG4294899484 DB 'This is free software, and you are welcome to redistrib'
	DB	'ute it', 0aH, 00H
	ORG $+1
$SG4294899485 DB 'This program comes with ABSOLUTELY NO WARRANTY.', 0aH, 00H
	ORG $+2
$SG4294899482 DB 0aH, 00H
	ORG $+2
$SG4294899483 DB 'under certain conditions.', 0aH, 00H
	ORG $+2
$SG4294899480 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899481 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899479 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899476 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899477 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899475 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899472 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899473 DB 'Restarting search thread...', 00H
	ORG $+2
$SG4294899470 DB 'Search thread became unresponsive.', 00H
	ORG $+2
$SG4294899471 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899469 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+2
$SG4294899465 DB 'STATUS', 00H
	ORG $+1
$SG4294899461 DB 'CPU', 00H
	ORG $+2
$SG4294899463 DB '======', 00H
	ORG $+1
$SG4294899458 DB 'forward-matching', 00H
	ORG $+2
$SG4294899460 DB 'GPU(s)', 00H
	ORG $+1
$SG4294899457 DB 'backward-matching', 00H
	ORG $+2
$SG4294899459 DB 'CPU and GPU(s)', 00H
	ORG $+1
$SG4294899455 DB 'flexible', 00H
	ORG $+2
$SG4294899456 DB 'forward- and backward-matching', 00H
	ORG $+1
$SG4294899452 DB ':', 00H
	ORG $+2
$SG4294899454 DB '  Performing a %s search on %s', 00H
	ORG $+1
$SG4294899453 DB '.', 00H
	ORG $+2
$SG4294899450 DB 's', 00H
	ORG $+2
$SG4294899448 DB 's', 00H
	ORG $+2
$SG4294899446 DB '.', 00H
	ORG $+2
$SG4294899447 DB '  for %d pattern%s (%d chunk%s) with %d to %d character'
	DB	's%s', 00H
	ORG $+2
$SG4294899445 DB ':', 00H
	ORG $+2
$SG4294899443 DB 's', 00H
	ORG $+2
$SG4294899441 DB 's', 00H
	ORG $+2
$SG4294899438 DB '      CUDA%d-%d:     %s', 00H
$SG4294899439 DB '      CUDA0:     %s', 00H
	ORG $+2
$SG4294899437 DB '      OpenCL0:   %s', 00H
	ORG $+2
$SG4294899432 DB '      %3.2lfM tripcode/s (current)', 00H
	ORG $+2
$SG4294899433 DB '  %.3lfT tripcodes were generated in %dd %dh %dm %02ds '
	DB	'at:', 00H
	ORG $+2
$SG4294899430 DB '          CPU: %7.2lfM tripcode/s', 00H
	ORG $+2
$SG4294899431 DB '          GPU: %7.2lfM tripcode/s', 00H
	ORG $+2
$SG4294899428 DB '          GPU: %7.2lfM tripcode/s', 00H
	ORG $+2
$SG4294899429 DB '      %3.2lfM tripcode/s (average)', 00H
	ORG $+2
$SG4294899427 DB '          CPU: %7.2lfM tripcode/s', 00H
	ORG $+2
$SG4294899416 DB 'es', 00H
	ORG $+2
$SG4294899410 DB '%-79s', 0aH, 00H
	ORG $+1
$SG4294899409 DB '+', 00H
	ORG $+2
$SG4294899404 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899405 DB 'NVIDIA %s (CUDA)', 0aH, 00H
	ORG $+2
$SG4294899402 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+2
$SG4294899403 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899400 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899401 DB '%d', 0aH, 00H
	ORG $+2
$SG4294899397 DB 'NVIDIA Corporation', 00H
	ORG $+2
$SG4294899394 DB '[error],%d', 0aH, 00H
	ORG $+2
$SG4294899395 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899514 DB 'OpenCL fucnction call failed.', 00H
	ORG $+2
$SG4294899392 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899506 DB 'GCN assembler failed.', 00H
	ORG $+2
$SG4294899393 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+3
$SG4294899505 DB 'ERROR_UNKNOWN', 00H
	ORG $+2
$SG4294899391 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899487 DB '[compiled at %s on %s (PST)]', 0aH, 00H
	ORG $+2
$SG4294899388 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899468 DB '[process] Restarting search thread...', 00H
	ORG $+2
$SG4294899386 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+3
$SG4294899466 DB '%-79s', 00H
	ORG $+2
$SG4294899387 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899464 DB '%-79s', 00H
	ORG $+2
$SG4294899384 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899462 DB '%-79s', 00H
	ORG $+2
$SG4294899385 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899435 DB '      OpenCL%d-%d: %s', 00H
	ORG $+2
$SG4294899380 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899381 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899376 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899377 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899370 DB 'NVIDIA Corporation', 00H
	ORG $+3
$SG4294899368 DB '%s ', 00H
	ORG $+3
$SG4294899369 DB 'NVIDIA ', 00H
$SG4294899366 DB '%s', 00H
	ORG $+3
$SG4294899367 DB '%s', 00H
	ORG $+3
$SG4294899364 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899365 DB ' (OpenCL)', 0aH, 00H
	ORG $+3
$SG4294899362 DB 'An invalid device was specified.', 00H
	ORG $+3
$SG4294899363 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899360 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899361 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+3
$SG4294899358 DB 'There is no GPU.', 00H
	ORG $+3
$SG4294899359 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899356 DB 'CUDA DEVICES', 0aH, 00H
	ORG $+2
$SG4294899357 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+3
$SG4294899354 DB '  CUDA Device Count:        %d', 0aH, 0aH, 00H
	ORG $+3
$SG4294899355 DB '============', 0aH, 00H
	ORG $+2
$SG4294899350 DB '  Device Name:              %s', 0aH, 00H
$SG4294899347 DB '  Compute Capability:       %d.%d', 0aH, 00H
	ORG $+3
$SG4294899351 DB '  Device No.:               %d', 0aH, 00H
$SG4294899344 DB 'cudaComputeModeProhibited', 00H
	ORG $+3
$SG4294899349 DB '  Multiprocessor Count:     %d', 0aH, 00H
$SG4294899345 DB 'cudaComputeModeExclusive', 00H
	ORG $+3
$SG4294899346 DB 'cudaComputeModeDefault', 00H
	ORG $+1
$SG4294899342 DB '(unknown)', 00H
	ORG $+3
$SG4294899343 DB 'cudaComputeModeExclusiveProcess', 00H
$SG4294899340 DB 0aH, 00H
	ORG $+3
$SG4294899341 DB '  Compute Mode:             %s', 0aH, 00H
$SG4294899337 DB '  OpenCL Device Count:      %d', 0aH, 0aH, 00H
	ORG $+3
$SG4294899338 DB '==============', 0aH, 00H
$SG4294899334 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899339 DB 'OPENCL DEVICES', 0aH, 00H
$SG4294899333 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899336 DB 'OPENCL DEVICE', 0aH, 00H
	ORG $+1
$SG4294899330 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899335 DB '=============', 0aH, 00H
	ORG $+1
$SG4294899329 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899326 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899325 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899322 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899321 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899318 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899317 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899314 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899313 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899310 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899309 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899306 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899305 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899302 DB '  Vendor:                   %s', 0aH, 00H
$SG4294899298 DB '  Clock Frequency:          %dMHz', 0aH, 00H
	ORG $+3
$SG4294899300 DB '  Name:                     %s', 0aH, 00H
$SG4294899293 DB 0aH, 00H
	ORG $+3
$SG4294899299 DB '  Number of Compute Units:  %d', 0aH, 00H
$SG4294899289 DB '  Processor Info:           0x%06x', 0aH, 00H
	ORG $+3
$SG4294899296 DB '  Max. Work Group Size:     %d', 0aH, 00H
$SG4294899286 DB 0aH, 00H
	ORG $+3
$SG4294899297 DB '  Global Memory Size:       %dM bytes', 0aH, 00H
	ORG $+1
$SG4294899294 DB '  Driver Version:           %s', 0aH, 00H
$SG4294899284 DB '-o', 00H
	ORG $+3
$SG4294899295 DB '  Version:                  %s', 0aH, 00H
$SG4294899282 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899290 DB '  Processor Info:           0x%06x (Nehalem)', 0aH, 00H
	ORG $+2
$SG4294899288 DB '  Number of Logical Cores:  %d', 0aH, 00H
$SG4294899278 DB '-f', 00H
	ORG $+3
$SG4294899287 DB '  Number of Search Threads: %d', 0aH, 00H
$SG4294899279 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899285 DB 'tripcodes.txt', 00H
	ORG $+2
$SG4294899283 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899280 DB 'The path of the tripcode file `%s'' is too long.', 00H
$SG4294899276 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899281 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899272 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899277 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899275 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899273 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899274 DB 'The path of the pattern file `%s'' is too long.', 00H
	ORG $+1
$SG4294899271 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899270 DB 'Too many pattern files were specified.', 00H
	ORG $+1
$SG4294899268 DB '-d', 00H
	ORG $+3
$SG4294899269 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+3
$SG4294899266 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899267 DB '-x', 00H
	ORG $+3
$SG4294899264 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899265 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899262 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899263 DB 'The number of blocks per SM must be at least %d.', 00H
	ORG $+3
$SG4294899260 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899261 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899259 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899256 DB '-y', 00H
	ORG $+3
$SG4294899258 DB 'The number of blocks per SM cannot exceed %d.', 00H
	ORG $+2
$SG4294899257 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899254 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899255 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899253 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899251 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899250 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899248 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899249 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899246 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899247 DB 'The number of work items per CU cannot exceed %d.', 00H
	ORG $+3
$SG4294899244 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899245 DB '-z', 00H
	ORG $+3
$SG4294899242 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899243 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899240 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899238 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899239 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899236 DB 'The number of work items per WG cannot exceed %d.', 00H
	ORG $+3
$SG4294899237 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899234 DB '%d', 0aH, 00H
	ORG $+3
$SG4294899235 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+3
$SG4294899232 DB 'The number of work items per WG must be a multiple of 8'
	DB	'.', 00H
	ORG $+3
$SG4294899233 DB '[error],%d', 0aH, 00H
	ORG $+3
$SG4294899230 DB '-a', 00H
	ORG $+3
$SG4294899231 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
$SG4294899529 DB 'ERROR_INVALID_TARGET_PATTERN', 00H
	ORG $+3
$SG4294899519 DB 'ERROR_INVALID_OPTION', 00H
	ORG $+3
$SG4294899509 DB 'A corrupt tripcode was generated.', 0aH, '  The hardwar'
	DB	'e or device driver may be malfunctioning.', 0aH, '  Please ch'
	DB	'eck the temperatures of CPU(s) and GPU(s).', 00H
	ORG $+1
$SG4294899503 DB 'Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] ['
	DB	'-y global_work_size] [-z local_work_size] [-o tripcode_file] '
	DB	'[-f pattern_file] [-i] [-w]', 0aH, 00H
	ORG $+3
$SG4294899228 DB '[error],%d', 0aH, 00H
$SG4294899499 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899227 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899225 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+2
$SG4294899495 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899222 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899223 DB '[error],%d', 0aH, 00H
$SG4294899486 DB 'Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@g'
	DB	'mail.com>', 0aH, 00H
	ORG $+2
$SG4294899229 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899220 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+2
$SG4294899478 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899221 DB 'The number of threads per AMD GPU cannot exceed %d.', 00H
$SG4294899474 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899440 DB '  for %d pattern%s (%d chunk%s) with %d characters%s', 00H
	ORG $+3
$SG4294899436 DB '      OpenCL%d:   %s', 00H
	ORG $+3
$SG4294899226 DB 'The number of threads per AMD GPU must be at least %d.', 00H
	ORG $+1
$SG4294899219 DB '-b', 00H
	ORG $+1
$SG4294899426 DB '  On average, it takes %.1lf centuries to find one matc'
	DB	'h at this speed.', 00H
$SG4294899424 DB '  On average, it takes %.1lf months to find one match a'
	DB	't this speed.', 00H
	ORG $+3
$SG4294899425 DB '  On average, it takes %.1lf years to find one match at'
	DB	' this speed.', 00H
$SG4294899217 DB '[error],%d', 0aH, 00H
$SG4294899422 DB '  On average, it takes %.1lf hours to find one match at'
	DB	' this speed.', 00H
$SG4294899214 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+2
$SG4294899423 DB '  On average, it takes %.1lf days to find one match at '
	DB	'this speed.', 00H
	ORG $+1
$SG4294899216 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899215 DB 'The number of processes per AMD GPU must be at least %d'
	DB	'.', 00H
	ORG $+3
$SG4294899420 DB '  On average, it takes %.1lf seconds to find one match '
	DB	'at this speed.', 00H
	ORG $+2
$SG4294899421 DB '  On average, it takes %.1lf minutes to find one match '
	DB	'at this speed.', 00H
	ORG $+2
$SG4294899418 DB '  No matches were found yet.', 00H
	ORG $+3
$SG4294899414 DB '  The actual matching probability is %.0f%% higher than'
	DB	' expected.', 00H
	ORG $+2
$SG4294899224 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899212 DB '[error],%d', 0aH, 00H
$SG4294899415 DB '  %ld match%s found at %.2lf matches/h and %.2lfG tripc'
	DB	'odes/match.', 00H
	ORG $+1
$SG4294899211 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294899208 DB '-l', 00H
	ORG $+1
$SG4294899412 DB '  The actual matching probability is about the same as '
	DB	'expected.', 00H
	ORG $+3
$SG4294899218 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899209 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+2
$SG4294899413 DB '  The actual matching probability is %.0f%% lower than '
	DB	'expected.', 00H
	ORG $+3
$SG4294899411 DB '  %.0f%% of matching tripcodes were invalid.', 00H
	ORG $+3
$SG4294899213 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294899206 DB '[error],%d', 0aH, 00H
$SG4294899406 DB '[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d'
	DB	',%.0lf,%.0lf,%u,%.0f%%', 0aH, 00H
	ORG $+1
$SG4294899407 DB '[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0'
	DB	'lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%', 0aH, 00H
$SG4294899398 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899399 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899396 DB 'Intel(R) Corporation', 00H
	ORG $+3
$SG4294899390 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899389 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899382 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899372 DB 'AMD ', 00H
	ORG $+3
$SG4294899383 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899378 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899371 DB 'Intel(R) Corporation', 00H
	ORG $+3
$SG4294899379 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899374 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899348 DB '  Clock Rate:               %.0fMHz', 0aH, 00H
	ORG $+3
$SG4294899375 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899373 DB 'Advanced Micro Devices, Inc.', 00H
	ORG $+3
$SG4294899352 DB '===========', 0aH, 00H
	ORG $+3
$SG4294899353 DB 'CUDA DEVICE', 0aH, 00H
	ORG $+3
$SG4294899301 DB '  Name:                     %s (%s)', 0aH, 00H
	ORG $+3
$SG4294899332 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899331 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899292 DB 'CPU', 0aH, 00H
	ORG $+3
$SG4294899328 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899327 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899291 DB '===', 0aH, 00H
	ORG $+3
$SG4294899324 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899323 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899252 DB 'The number of work items per CU must be at least %d.', 00H
	ORG $+3
$SG4294899320 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899319 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899241 DB 'The number of work items per WG must be at least %d.', 00H
	ORG $+3
$SG4294899316 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899315 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899210 DB 'The number of processes per AMD GPU cannot exceed %d.', 00H
	ORG $+2
$SG4294899312 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899311 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899207 DB '%d', 0aH, 00H
	ORG $+4
$SG4294899308 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899307 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899204 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294899303 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899202 DB '-i', 00H
	ORG $+5
$SG4294899304 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899205 DB 'The length of tripcodes must be either 10 or 12.', 00H
	ORG $+3
$SG4294899203 DB '-b', 00H
	ORG $+1
$SG4294899200 DB '-n', 00H
	ORG $+1
$SG4294899201 DB '-w', 00H
	ORG $+1
$SG4294899198 DB '-g', 00H
	ORG $+1
$SG4294899199 DB '-c', 00H
	ORG $+1
$SG4294899196 DB '%d', 0aH, 00H
$SG4294899197 DB '-t', 00H
	ORG $+1
$SG4294899194 DB 'The number of CPU search threads must be at least 1.', 00H
	ORG $+3
$SG4294899195 DB '[error],%d', 0aH, 00H
$SG4294899192 DB '--output-for-redirection', 00H
	ORG $+3
$SG4294899193 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899190 DB '-E', 00H
	ORG $+1
$SG4294899191 DB '-e', 00H
	ORG $+1
$SG4294899188 DB '--search-for-hiseki-on-cpu', 00H
	ORG $+1
$SG4294899189 DB '--use-one-byte-characters-for-keys', 00H
	ORG $+1
$SG4294899186 DB '--search-for-kaibun-on-cpu', 00H
	ORG $+1
$SG4294899187 DB '--search-for-kakuhi-on-cpu', 00H
	ORG $+1
$SG4294899184 DB '--search-for-yamabiko-on-cpu', 00H
	ORG $+3
$SG4294899185 DB '--search-for-kagami-on-cpu', 00H
	ORG $+1
$SG4294899182 DB '--use-opencl-for-cuda-devices', 00H
	ORG $+2
$SG4294899183 DB '--search-for-souren-on-cpu', 00H
	ORG $+1
$SG4294899180 DB '--disable-avx2', 00H
	ORG $+1
$SG4294899181 DB '--disable-avx', 00H
	ORG $+2
$SG4294899178 DB '--use-ascii-characters-for-keys', 00H
$SG4294899179 DB '--use-one-byte-characters-for-keys', 00H
	ORG $+1
$SG4294899176 DB '--maximize-key-space', 00H
	ORG $+3
$SG4294899177 DB '--use-one-and-two-byte-characters-for-keys', 00H
	ORG $+1
$SG4294899174 DB '--disable-gcn-assembler', 00H
$SG4294899175 DB '--disable-tripcode-checks', 00H
	ORG $+2
$SG4294899172 DB '--list-expanded-patterns', 00H
	ORG $+3
$SG4294899173 DB '--display-device-information', 00H
	ORG $+3
$SG4294899170 DB '%d', 0aH, 00H
$SG4294899171 DB '--gpu-list', 00H
	ORG $+1
$SG4294899168 DB 'An invalid option was specified.', 00H
	ORG $+3
$SG4294899169 DB '[error],%d', 0aH, 00H
$SG4294899166 DB 'patterns.txt', 00H
	ORG $+3
$SG4294899167 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899164 DB '[error],%d', 0aH, 00H
$SG4294899165 DB '%d', 0aH, 00H
$SG4294899162 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899163 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899160 DB '[error],%d', 0aH, 00H
$SG4294899161 DB '%d', 0aH, 00H
$SG4294899156 DB '%c', 00H
	ORG $+1
$SG4294899158 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899159 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899157 DB '!', 00H
	ORG $+2
$SG4294899154 DB '%c', 00H
	ORG $+1
$SG4294899155 DB ' #', 00H
	ORG $+1
$SG4294899152 DB '%02X', 00H
	ORG $+3
$SG4294899153 DB ' (', 00H
	ORG $+1
$SG4294899150 DB ')', 0aH, 00H
	ORG $+1
$SG4294899151 DB ' ', 00H
	ORG $+2
$SG4294899148 DB '%c', 00H
	ORG $+1
$SG4294899149 DB '  !', 00H
$SG4294899146 DB '%c', 00H
	ORG $+1
$SG4294899147 DB ' #', 00H
	ORG $+1
$SG4294899144 DB '%02X', 00H
	ORG $+3
$SG4294899145 DB ' (', 00H
	ORG $+1
$SG4294899142 DB ')', 00H
	ORG $+2
$SG4294899143 DB ' ', 00H
	ORG $+2
$SG4294899140 DB 0aH, 00H
	ORG $+2
$SG4294899141 DB ' ', 00H
	ORG $+2
$SG4294899138 DB '%c', 00H
	ORG $+1
$SG4294899139 DB '[tripcode],%c%c', 00H
$SG4294899136 DB '%c', 00H
	ORG $+1
$SG4294899137 DB ',#', 00H
	ORG $+1
$SG4294899134 DB '%02X', 00H
	ORG $+3
$SG4294899135 DB ',(', 00H
	ORG $+1
$SG4294899132 DB ')', 0aH, 00H
	ORG $+1
$SG4294899133 DB ' ', 00H
	ORG $+2
$SG4294899130 DB '!', 00H
	ORG $+2
$SG4294899131 DB 07H, 00H
	ORG $+2
$SG4294899128 DB '  ', 00H
	ORG $+1
$SG4294899129 DB '%c', 00H
	ORG $+1
$SG4294899126 DB ' (', 00H
	ORG $+1
$SG4294899127 DB ' ', 00H
	ORG $+2
$SG4294899124 DB ' ', 00H
	ORG $+2
$SG4294899125 DB '%02X', 00H
	ORG $+3
$SG4294899122 DB '  !', 00H
$SG4294899123 DB ')', 0aH, 00H
	ORG $+1
$SG4294899120 DB '  ', 00H
	ORG $+1
$SG4294899121 DB '%c', 00H
	ORG $+1
$SG4294899118 DB ' (', 00H
	ORG $+1
$SG4294899119 DB ' ', 00H
	ORG $+2
$SG4294899116 DB ' ', 00H
	ORG $+2
$SG4294899117 DB '%02X', 00H
	ORG $+3
$SG4294899114 DB ' ', 00H
	ORG $+2
$SG4294899115 DB ')', 00H
	ORG $+2
$SG4294899112 DB 'a', 00H
	ORG $+2
$SG4294899113 DB 0aH, 00H
	ORG $+2
$SG4294899110 DB '[error],%d', 0aH, 00H
$SG4294899111 DB '%d', 0aH, 00H
$SG4294899108 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899109 DB 'The output file cannot be opened.', 00H
	ORG $+2
$SG4294899106 DB '[error],%d', 0aH, 00H
$SG4294899107 DB '%d', 0aH, 00H
$SG4294899104 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899105 DB 'Failed to open an event.', 00H
	ORG $+3
$SG4294899102 DB '[error],%d', 0aH, 00H
$SG4294899103 DB '%d', 0aH, 00H
$SG4294899100 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899101 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899098 DB '[error],%d', 0aH, 00H
$SG4294899099 DB '%d', 0aH, 00H
$SG4294899096 DB '%d', 0aH, 00H
$SG4294899097 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899094 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899095 DB '[error],%d', 0aH, 00H
$SG4294899092 DB '[error],%d', 0aH, 00H
$SG4294899093 DB '%d', 0aH, 00H
$SG4294899088 DB '[error],%d', 0aH, 00H
$SG4294899090 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899091 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899089 DB '%d', 0aH, 00H
$SG4294899086 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  CUDA Function Call F'
	DB	'ailed: %s [%d] (file ''%s'', line %d)', 0aH, '  The video car'
	DB	'd may be low on resources.', 0aH, 07H, 0aH, '  Hit any key to'
	DB	' exit.', 00H
	ORG $+2
$SG4294899084 DB '[error],%d', 0aH, 00H
$SG4294899087 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899085 DB '%d', 0aH, 00H
$SG4294899080 DB '[error],%d', 0aH, 00H
$SG4294899082 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899083 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899081 DB '%d', 0aH, 00H
$SG4294899078 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  CUDA Function Call F'
	DB	'ailed: %s [%d] (file ''%s'', line %d)', 0aH, '  The video car'
	DB	'd may be low on resources.', 0aH, 07H, 0aH, '  Hit any key to'
	DB	' exit.', 00H
	ORG $+6
$SG4294899079 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899076 DB '[error],%d', 0aH, 00H
$SG4294899077 DB '%d', 0aH, 00H
$SG4294899074 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899075 DB 'Failed to start a CUDA device search thread.', 00H
	ORG $+3
$SG4294899072 DB '[error],%d', 0aH, 00H
$SG4294899073 DB '%d', 0aH, 00H
$SG4294899068 DB '[error],%d', 0aH, 00H
$SG4294899070 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899071 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899069 DB '%d', 0aH, 00H
$SG4294899066 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899067 DB 'Failed to start a CUDA device search thread.', 00H
	ORG $+3
$SG4294899064 DB '[error],%d', 0aH, 00H
$SG4294899065 DB '%d', 0aH, 00H
$SG4294899060 DB '[error],%d', 0aH, 00H
$SG4294899062 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899063 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899061 DB '%d', 0aH, 00H
$SG4294899058 DB '%d', 0aH, 00H
$SG4294899059 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899056 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899057 DB '[error],%d', 0aH, 00H
$SG4294899054 DB '[error],%d', 0aH, 00H
$SG4294899055 DB '%d', 0aH, 00H
$SG4294899052 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899053 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899050 DB '[error],%d', 0aH, 00H
$SG4294899051 DB '%d', 0aH, 00H
$SG4294899048 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899049 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899046 DB '[error],%d', 0aH, 00H
$SG4294899047 DB '%d', 0aH, 00H
$SG4294899042 DB '[error],%d', 0aH, 00H
$SG4294899044 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899045 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899043 DB '%d', 0aH, 00H
$SG4294899040 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899041 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899038 DB '[error],%d', 0aH, 00H
$SG4294899039 DB '%d', 0aH, 00H
$SG4294899034 DB '[error],%d', 0aH, 00H
$SG4294899036 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899037 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899035 DB '%d', 0aH, 00H
$SG4294899032 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294899030 DB '[error],%d', 0aH, 00H
$SG4294899031 DB '%d', 0aH, 00H
$SG4294899029 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899033 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899028 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899026 DB '[error],%d', 0aH, 00H
$SG4294899027 DB '%d', 0aH, 00H
$SG4294899022 DB '[error],%d', 0aH, 00H
$SG4294899024 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899025 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899023 DB '%d', 0aH, 00H
$SG4294899020 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899021 DB 'Failed to start a OpenCL device search thread.', 00H
	ORG $+1
$SG4294899018 DB '[error],%d', 0aH, 00H
$SG4294899019 DB '%d', 0aH, 00H
$SG4294899014 DB '[error],%d', 0aH, 00H
$SG4294899016 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899017 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899015 DB '%d', 0aH, 00H
$SG4294899012 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899013 DB 'Failed to start a OpenCL device search thread.', 00H
	ORG $+1
$SG4294899010 DB '[error],%d', 0aH, 00H
$SG4294899011 DB '%d', 0aH, 00H
$SG4294899006 DB '[error],%d', 0aH, 00H
$SG4294899008 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294899009 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899007 DB '%d', 0aH, 00H
$SG4294899004 DB '%d', 0aH, 00H
$SG4294899005 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294899002 DB '..\SourceFiles\Main.cpp', 00H
$SG4294899003 DB '[error],%d', 0aH, 00H
$SG4294899000 DB '%d', 0aH, 00H
$SG4294899001 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+1
$SG4294898998 DB 'Failed to start a CPU search thread.', 00H
	ORG $+3
$SG4294898999 DB '[error],%d', 0aH, 00H
$SG4294898996 DB '%d: `%s'' @ %d', 0aH, 00H
	ORG $+1
$SG4294898997 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294898994 DB '--list-expanded-patterns', 00H
	ORG $+3
$SG4294898995 DB '--display-device-information', 00H
	ORG $+3
$SG4294898992 DB '--output-for-redirection', 00H
	ORG $+3
$SG4294898993 DB '--gpu-list', 00H
	ORG $+1
$SG4294898990 DB '%d', 0aH, 00H
$SG4294898991 DB '--gpu-list', 00H
	ORG $+1
$SG4294898988 DB 'Failed to open an event.', 00H
	ORG $+3
$SG4294898989 DB '[error],%d', 0aH, 00H
$SG4294898986 DB 'TRIPCODES', 0aH, 00H
	ORG $+1
$SG4294898987 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+1
$SG4294898984 DB '[started]', 0aH, 00H
	ORG $+1
$SG4294898985 DB '=========', 0aH, 00H
	ORG $+1
$SG4294898983 DB 07H, 00H
PUBLIC	??$_Fixarg@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z ; std::_Fixarg<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *,std::tuple<OpenCLDeviceSearchThreadInfo *>,std::tuple<> >
PUBLIC	??$get@$0A@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@@Z ; std::get<0,OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$_Fixarg@AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z ; std::_Fixarg<void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *,std::tuple<CUDADeviceSearchThreadInfo *>,std::tuple<> >
PUBLIC	??$get@$0A@PAUCUDADeviceSearchThreadInfo@@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@@Z ; std::get<0,CUDADeviceSearchThreadInfo *>
PUBLIC	??$?0PAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo *>::_Tuple_val<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$?0PAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z ; std::_Tuple_val<CUDADeviceSearchThreadInfo *>::_Tuple_val<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *>
PUBLIC	??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>
PUBLIC	??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Do_call<,0>
PUBLIC	??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Do_call<,0>
PUBLIC	??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ		; std::tie<>
PUBLIC	??$forward@AAP6AXXZ@std@@YAAAP6AXXZAAP6AXXZ@Z	; std::forward<void (__cdecl*&)(void)>
PUBLIC	??$?0PAUOpenCLDeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>
PUBLIC	??$forward@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *)>
PUBLIC	??$?0PAUCUDADeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>
PUBLIC	??$forward@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*&)(CUDADeviceSearchThreadInfo *)>
PUBLIC	?_Get_rest@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<OpenCLDeviceSearchThreadInfo *>::_Get_rest
PUBLIC	?_Get_rest@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<CUDADeviceSearchThreadInfo *>::_Get_rest
PUBLIC	??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$forward@P6AXXZ@std@@YA$$QAP6AXXZAAP6AXXZ@Z	; std::forward<void (__cdecl*)(void)>
PUBLIC	??$?0PAUOpenCLDeviceSearchThreadInfo@@PAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>
PUBLIC	??$forward@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV10@@Z ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo *> >
PUBLIC	??$forward@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo *)>
PUBLIC	??$?0PAUCUDADeviceSearchThreadInfo@@PAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>
PUBLIC	??$forward@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV10@@Z ; std::forward<std::tuple<CUDADeviceSearchThreadInfo *> >
PUBLIC	??$forward@P6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo *)>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXXZ	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::operator()<>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::operator()<>
PUBLIC	??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$?0AAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@AAP6AXXZ@Z ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*&)(void)>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
PUBLIC	??$?0AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *><void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
PUBLIC	??$?0AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *><void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
PUBLIC	??0?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@$$QAV01@@Z	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>
PUBLIC	??0?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
PUBLIC	??0?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Run
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Run
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UAEIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Go
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Go
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z ; std::bind<void>
PUBLIC	??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z	; std::_Decay_copy<void (__cdecl&)(void)>
PUBLIC	??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z		; std::forward<void (__cdecl&)(void)>
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
PUBLIC	??$bind@XPAUOpenCLDeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::bind<void,OpenCLDeviceSearchThreadInfo *,OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$_Decay_copy@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAPAUOpenCLDeviceSearchThreadInfo@@$$QAPAU1@@Z ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$forward@PAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QAPAUOpenCLDeviceSearchThreadInfo@@AAPAU1@@Z ; std::forward<OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$_Decay_copy@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>
PUBLIC	??$forward@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
PUBLIC	??$bind@XPAUCUDADeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::bind<void,CUDADeviceSearchThreadInfo *,CUDADeviceSearchThreadInfo *>
PUBLIC	??$_Decay_copy@PAUCUDADeviceSearchThreadInfo@@@std@@YAPAUCUDADeviceSearchThreadInfo@@$$QAPAU1@@Z ; std::_Decay_copy<CUDADeviceSearchThreadInfo *>
PUBLIC	??$forward@PAUCUDADeviceSearchThreadInfo@@@std@@YA$$QAPAUCUDADeviceSearchThreadInfo@@AAPAU1@@Z ; std::forward<CUDADeviceSearchThreadInfo *>
PUBLIC	??$_Decay_copy@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>
PUBLIC	??$forward@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>
PUBLIC	??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z	; std::thread::thread<void (__cdecl&)(void)>
PUBLIC	??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
PUBLIC	??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
PUBLIC	_main
PUBLIC	?ListExpandedPatterns@@YAXXZ			; ListExpandedPatterns
PUBLIC	?GetParentProcessID@@YAHXZ			; GetParentProcessID
PUBLIC	?StartCPUSearchThreads@@YAXXZ			; StartCPUSearchThreads
PUBLIC	?StartGPUSearchThreads@@YAXXZ			; StartGPUSearchThreads
PUBLIC	?StartOpenCLDeviceSearchThreads@@YAXXZ		; StartOpenCLDeviceSearchThreads
PUBLIC	?StartCUDADeviceSearchThreads@@YAXXZ		; StartCUDADeviceSearchThreads
PUBLIC	?UpdateCurrentStatus@@YAN_K@Z			; UpdateCurrentStatus
PUBLIC	?SetTerminationState@@YAXXZ			; SetTerminationState
PUBLIC	?SetPauseState@@YAXH@Z				; SetPauseState
PUBLIC	?GetNumGeneratedTripcodesByGPU@@YANXZ		; GetNumGeneratedTripcodesByGPU
PUBLIC	?GetNumGeneratedTripcodesByCPU@@YANXZ		; GetNumGeneratedTripcodesByCPU
PUBLIC	?AddToNumGeneratedTripcodesByGPU@@YAXI@Z	; AddToNumGeneratedTripcodesByGPU
PUBLIC	?OpenTripcodeFile@@YAXXZ			; OpenTripcodeFile
PUBLIC	?ObtainOptions@@YAXHPAPAD@Z			; ObtainOptions
PUBLIC	?InitSearchDevices@@YAXH@Z			; InitSearchDevices
PUBLIC	?ListGPUsAndExit@@YAXXZ				; ListGPUsAndExit
PUBLIC	?ListOpenCLDevices@@YAXXZ			; ListOpenCLDevices
PUBLIC	?CountOpenCLDevices@@YAXXZ			; CountOpenCLDevices
PUBLIC	?ListCUDADevices@@YAXXZ				; ListCUDADevices
PUBLIC	?InitProcess@@YAXXZ				; InitProcess
PUBLIC	?ControlHandler@@YGHK@Z				; ControlHandler
PUBLIC	?PrintStatus@@YAXXZ				; PrintStatus
PUBLIC	?KeepSearchThreadsAlive@@YAXXZ			; KeepSearchThreadsAlive
PUBLIC	??_Gthread@std@@QAEPAXI@Z			; std::thread::`scalar deleting destructor'
PUBLIC	?CheckSearchThreads@@YAXXZ			; CheckSearchThreads
PUBLIC	?UpdateCUDADeviceStatus@@YAXPAUCUDADeviceSearchThreadInfo@@PAD@Z ; UpdateCUDADeviceStatus
PUBLIC	?DisplayCopyrights@@YAXXZ			; DisplayCopyrights
PUBLIC	?CreateCharacterTables@@YAXXZ			; CreateCharacterTables
PUBLIC	?CreateKey8AndKey9@@YAXPAE@Z			; CreateKey8AndKey9
PUBLIC	?hide_cursor@@YAXXZ				; hide_cursor
PUBLIC	?ReleaseResources@@YAXXZ			; ReleaseResources
PUBLIC	?native_handle@thread@std@@QAEPAXXZ		; std::thread::native_handle
PUBLIC	?detach@thread@std@@QAEXXZ			; std::thread::detach
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z		; std::_Thrd_detachX
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	??0?$tuple@$$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	??0?$tuple@$$$V@std@@QAE@XZ			; std::tuple<>::tuple<>
PUBLIC	?ProcessValidTripcodePair@@YAXPAE0@Z		; ProcessValidTripcodePair
PUBLIC	?ProcessInvalidTripcodePair@@YAXPAE0@Z		; ProcessInvalidTripcodePair
PUBLIC	?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPAUOpenCLDeviceSearchThreadInfo@@PADNNNIPAVchild@windows@process@boost@@@Z ; UpdateOpenCLDeviceStatus_ChildProcess
PUBLIC	?SetErrorState@@YAXXZ				; SetErrorState
PUBLIC	?UpdateOpenCLDeviceStatus@@YAXPAUOpenCLDeviceSearchThreadInfo@@PAD@Z ; UpdateOpenCLDeviceStatus
PUBLIC	?GetErrorMessage@@YAPADH@Z			; GetErrorMessage
PUBLIC	?GetErrorState@@YAHXZ				; GetErrorState
PUBLIC	?reset_cursor_pos@@YAXH@Z			; reset_cursor_pos
PUBLIC	?show_cursor@@YAXXZ				; show_cursor
PUBLIC	?ProcessGPUOutput@@YANPAEPAUGPUOutput@@IH@Z	; ProcessGPUOutput
PUBLIC	?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z ; SetCharactersInTripcodeKeyForSHA1Tripcode
PUBLIC	?GetPauseState@@YAHXZ				; GetPauseState
PUBLIC	?AddToNumGeneratedTripcodesByCPU@@YAXI@Z	; AddToNumGeneratedTripcodesByCPU
PUBLIC	?IsValidKey@@YAHPAE@Z				; IsValidKey
PUBLIC	?GetTerminationState@@YAHXZ			; GetTerminationState
PUBLIC	?RandomByte@@YAEXZ				; RandomByte
PUBLIC	?IsFirstByteSJIS@@YAHE@Z			; IsFirstByteSJIS
PUBLIC	?SetCharactersInTripcodeKey@@YAXPAEH@Z		; SetCharactersInTripcodeKey
PUBLIC	?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
PUBLIC	?process_tripcode_pair_spinlock@@3Vspinlock@@A	; process_tripcode_pair_spinlock
PUBLIC	?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
PUBLIC	?current_state_spinlock@@3Vspinlock@@A		; current_state_spinlock
PUBLIC	?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
PUBLIC	?boost_process_spinlock@@3Vspinlock@@A		; boost_process_spinlock
PUBLIC	?system_command_spinlock@@3Vspinlock@@A		; system_command_spinlock
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_errno_ecat DD	01H DUP (?)
_ignore	DB	01H DUP (?)
	ALIGN	4

?num_generated_tripcodes_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; num_generated_tripcodes_spinlock
_allocator_arg DB 01H DUP (?)
	ALIGN	4

?process_tripcode_pair_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; process_tripcode_pair_spinlock
_native_ecat DD	01H DUP (?)
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; cuda_device_search_thread_info_array_spinlock
?current_state_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; current_state_spinlock
_posix_category DD 01H DUP (?)
?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; opencl_device_search_thread_info_array_spinlock
?boost_process_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; boost_process_spinlock
?system_command_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; system_command_spinlock
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CheckSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?CheckSearchThreads@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CheckSearchThreads@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSearchThreads@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CheckSearchThreads@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSearchThreads@@YAXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?CheckSearchThreads@@YAXXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?StartCUDADeviceSearchThreads@@YAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?StartCUDADeviceSearchThreads@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?StartCUDADeviceSearchThreads@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$2
	DD	04H
	DD	FLAT:__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?StartOpenCLDeviceSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?StartOpenCLDeviceSearchThreads@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?StartOpenCLDeviceSearchThreads@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?StartCPUSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?StartCPUSearchThreads@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?StartCPUSearchThreads@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z$0
_posix_category$initializer$ DD FLAT:??__Eposix_category@system@boost@@YAXXZ
_errno_ecat$initializer$ DD FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
_native_ecat$initializer$ DD FLAT:??__Enative_ecat@system@boost@@YAXXZ
_num_generated_tripcodes_spinlock$initializer$ DD FLAT:??__Enum_generated_tripcodes_spinlock@@YAXXZ
_process_tripcode_pair_spinlock$initializer$ DD FLAT:??__Eprocess_tripcode_pair_spinlock@@YAXXZ
_current_state_spinlock$initializer$ DD FLAT:??__Ecurrent_state_spinlock@@YAXXZ
_cuda_device_search_thread_info_array_spinlock$initializer$ DD FLAT:??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ
_opencl_device_search_thread_info_array_spinlock$initializer$ DD FLAT:??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ
_system_command_spinlock$initializer$ DD FLAT:??__Esystem_command_spinlock@@YAXXZ
_boost_process_spinlock$initializer$ DD FLAT:??__Eboost_process_spinlock@@YAXXZ
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetCharactersInTripcodeKey@@YAXPAEH@Z
_TEXT	SEGMENT
_randomValue$1 = -16					; size = 4
_randomValue$2 = -12					; size = 4
_randomValue$3 = -8					; size = 4
_randomValue$4 = -8					; size = 4
_randomValue$5 = -8					; size = 4
_randomValue$6 = -4					; size = 4
_randomValue$7 = -4					; size = 4
_randomValue$8 = -4					; size = 4
_key$ = 8						; size = 4
_n$ = 12						; size = 4
?SetCharactersInTripcodeKey@@YAXPAEH@Z PROC		; SetCharactersInTripcodeKey, COMDAT

; 1723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 1724 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1725 : 		for (int32_t i = 0; i < n; i++){

	xor	esi, esi
	push	edi
	cmp	DWORD PTR ?options@@3UOptions@@A+84, esi
	je	SHORT $LN72@SetCharact
	mov	ebx, DWORD PTR _n$[ebp]
	test	ebx, ebx
	jle	$LN151@SetCharact
	mov	edi, DWORD PTR _key$[ebp]
$LL71@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$8[ebp]
	push	eax
	call	_rand_s

; 1726 : 			key[i] = RandomByte();

	mov	al, BYTE PTR _randomValue$8[ebp]
$LN152@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1726 : 			key[i] = RandomByte();

	mov	BYTE PTR [esi+edi], al

; 1727 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))

	test	esi, esi
	jne	SHORT $LN65@SetCharact
	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN61@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN61@SetCharact
$LN65@SetCharact:
	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	je	SHORT $LN70@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN70@SetCharact
	cmp	al, 39					; 00000027H
	jb	SHORT $LN64@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN70@SetCharact
$LN64@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN63@SetCharact
	cmp	al, 59					; 0000003bH
	jbe	SHORT $LN70@SetCharact
$LN63@SetCharact:
	cmp	al, 61					; 0000003dH
	jb	SHORT $LN62@SetCharact
	jbe	SHORT $LN70@SetCharact
$LN62@SetCharact:
	cmp	al, 63					; 0000003fH
	jb	SHORT $LN61@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN70@SetCharact
$LN61@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$5[ebp]
	push	eax
	call	_rand_s

; 1728 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$5[ebp]
	jmp	SHORT $LN152@SetCharact
$LN70@SetCharact:

; 1724 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1725 : 		for (int32_t i = 0; i < n; i++){

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL71@SetCharact
	pop	edi
	pop	esi
	pop	ebx

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@SetCharact:

; 1729 : 		}
; 1730 : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	je	SHORT $LN59@SetCharact

; 1731 : 		for (int32_t i = 0; i < n; i++){

	mov	ebx, DWORD PTR _n$[ebp]
	test	ebx, ebx
	jle	$LN151@SetCharact
	mov	edi, DWORD PTR _key$[ebp]
	npad	5
$LL58@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$4[ebp]
	push	eax
	call	_rand_s

; 1732 : 			key[i] = RandomByte();

	mov	al, BYTE PTR _randomValue$4[ebp]
$LN153@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1732 : 			key[i] = RandomByte();

	mov	BYTE PTR [esi+edi], al

; 1733 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))

	test	esi, esi
	jne	SHORT $LN52@SetCharact
	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN48@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN48@SetCharact
$LN52@SetCharact:
	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	jb	SHORT $LN51@SetCharact
	cmp	al, 36					; 00000024H
	jbe	SHORT $LN57@SetCharact
$LN51@SetCharact:
	cmp	al, 38					; 00000026H
	jb	SHORT $LN50@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN57@SetCharact
$LN50@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN49@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN57@SetCharact
$LN49@SetCharact:
	cmp	al, 161					; 000000a1H
	jb	SHORT $LN48@SetCharact
	cmp	al, 223					; 000000dfH
	jbe	SHORT $LN57@SetCharact
$LN48@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$7[ebp]
	push	eax
	call	_rand_s

; 1734 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$7[ebp]
	jmp	SHORT $LN153@SetCharact
$LN57@SetCharact:

; 1731 : 		for (int32_t i = 0; i < n; i++){

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL58@SetCharact
	pop	edi
	pop	esi
	pop	ebx

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@SetCharact:

; 1735 : 		}
; 1736 : 	} else {
; 1737 : 		BOOL isSecondByteSJIS = FALSE;
; 1738 : 		for (int32_t i = 0; i < n; i++){

	xor	edi, edi
	cmp	DWORD PTR _n$[ebp], esi
	jle	$LN151@SetCharact
	mov	ebx, DWORD PTR _key$[ebp]
	npad	5
$LL46@SetCharact:

; 1739 : 			if (!isSecondByteSJIS) {

	test	esi, esi
	jne	$LN43@SetCharact

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$3[ebp]
	push	eax
	call	_rand_s

; 1740 : 				key[i] = RandomByte();

	mov	al, BYTE PTR _randomValue$3[ebp]
$LN155@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1740 : 				key[i] = RandomByte();

	mov	BYTE PTR [edi+ebx], al

; 1741 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))

	test	edi, edi
	jne	SHORT $LN39@SetCharact
	mov	al, BYTE PTR [ebx]
	cmp	al, 35					; 00000023H
	je	SHORT $LN40@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN40@SetCharact
$LN39@SetCharact:
	mov	al, BYTE PTR [edi+ebx]
	mov	ecx, DWORD PTR ?options@@3UOptions@@A+88
	cmp	al, 33					; 00000021H
	jb	SHORT $LN38@SetCharact
	cmp	al, 36					; 00000024H
	jbe	SHORT $LN91@SetCharact
$LN38@SetCharact:
	cmp	al, 38					; 00000026H
	jb	SHORT $LN37@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN91@SetCharact
$LN37@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN36@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN91@SetCharact
$LN36@SetCharact:
	cmp	al, 161					; 000000a1H
	jb	SHORT $LN35@SetCharact
	cmp	al, 223					; 000000dfH
	jbe	SHORT $LN91@SetCharact
$LN35@SetCharact:

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	ecx, ecx
	je	SHORT $LN86@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	al, 129					; 00000081H
	jb	SHORT $LN89@SetCharact
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN91@SetCharact
$LN89@SetCharact:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN90@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN91@SetCharact
$LN90@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN154@SetCharact
$LN86@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	al, 137					; 00000089H
	jb	SHORT $LN94@SetCharact
	cmp	al, 151					; 00000097H
	jbe	SHORT $LN91@SetCharact
$LN94@SetCharact:
	cmp	al, 153					; 00000099H
	jb	SHORT $LN95@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN91@SetCharact
$LN95@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 9
$LN154@SetCharact:
	jbe	SHORT $LN91@SetCharact
$LN40@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$6[ebp]
	push	eax
	call	_rand_s

; 1742 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$6[ebp]
	jmp	SHORT $LN155@SetCharact
$LN91@SetCharact:

; 1743 : 				if (IsFirstByteSJIS(key[i]))

	mov	al, BYTE PTR [edi+ebx]

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	ecx, ecx
	je	SHORT $LN102@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	al, 129					; 00000081H
	jb	SHORT $LN105@SetCharact
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN143@SetCharact
$LN105@SetCharact:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN106@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN143@SetCharact
$LN106@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN156@SetCharact
$LN102@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	al, 137					; 00000089H
	jb	SHORT $LN110@SetCharact
	cmp	al, 151					; 00000097H
	jbe	SHORT $LN143@SetCharact
$LN110@SetCharact:
	cmp	al, 153					; 00000099H
	jb	SHORT $LN111@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN143@SetCharact
$LN111@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 9
$LN156@SetCharact:
	ja	$LN45@SetCharact
$LN143@SetCharact:

; 1744 : 					isSecondByteSJIS = TRUE;

	mov	esi, 1

; 1745 : 			} else {

	jmp	$LN45@SetCharact
$LN43@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$2[ebp]
	push	eax
	call	_rand_s

; 1746 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$2[ebp]
$LN169@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1746 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	BYTE PTR [edi+ebx], al

; 1747 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))

	test	edi, edi
	jne	SHORT $LN29@SetCharact
	mov	al, BYTE PTR [ebx]
	cmp	al, 35					; 00000023H
	je	$LN20@SetCharact
	cmp	al, 36					; 00000024H
	je	$LN20@SetCharact
$LN29@SetCharact:
	mov	al, BYTE PTR [edi+ebx]
	cmp	al, 64					; 00000040H
	jb	SHORT $LN27@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN28@SetCharact
$LN27@SetCharact:
	cmp	al, 129					; 00000081H
	jb	$LN20@SetCharact
	cmp	al, 252					; 000000fcH
	ja	$LN20@SetCharact
$LN28@SetCharact:
	mov	cl, BYTE PTR [edi+ebx-1]
	cmp	cl, 129					; 00000081H
	jb	SHORT $LN24@SetCharact
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN25@SetCharact
$LN24@SetCharact:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN23@SetCharact
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN25@SetCharact
$LN23@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	$LN20@SetCharact
	cmp	cl, 234					; 000000eaH
	ja	$LN20@SetCharact
$LN25@SetCharact:
	cmp	al, 64					; 00000040H
	jb	SHORT $LN21@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN22@SetCharact
$LN21@SetCharact:
	cmp	al, 129					; 00000081H
	jb	$LN20@SetCharact
	cmp	al, 252					; 000000fcH
	ja	$LN20@SetCharact
$LN22@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 173					; 000000adH
	jb	SHORT $LN19@SetCharact
	cmp	al, 183					; 000000b7H
	jbe	$LN20@SetCharact
$LN19@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 192					; 000000c0H
	jb	SHORT $LN18@SetCharact
	cmp	al, 199					; 000000c7H
	jbe	$LN20@SetCharact
$LN18@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 207					; 000000cfH
	jb	SHORT $LN17@SetCharact
	cmp	al, 217					; 000000d9H
	jbe	$LN20@SetCharact
$LN17@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 233					; 000000e9H
	jb	SHORT $LN16@SetCharact
	cmp	al, 239					; 000000efH
	jbe	$LN20@SetCharact
$LN16@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 248					; 000000f8H
	jb	SHORT $LN15@SetCharact
	cmp	al, 251					; 000000fbH
	jbe	$LN20@SetCharact
$LN15@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 64					; 00000040H
	jb	SHORT $LN14@SetCharact
	cmp	al, 78					; 0000004eH
	jbe	$LN20@SetCharact
$LN14@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 89					; 00000059H
	jb	SHORT $LN13@SetCharact
	cmp	al, 95					; 0000005fH
	jbe	$LN20@SetCharact
$LN13@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 122					; 0000007aH
	jb	SHORT $LN12@SetCharact
	cmp	al, 128					; 00000080H
	jbe	$LN20@SetCharact
$LN12@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 155					; 0000009bH
	jb	SHORT $LN11@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	$LN20@SetCharact
$LN11@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 242					; 000000f2H
	jb	SHORT $LN10@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN10@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 151					; 00000097H
	jb	SHORT $LN9@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN9@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 183					; 000000b7H
	jb	SHORT $LN8@SetCharact
	cmp	al, 190					; 000000beH
	jbe	SHORT $LN20@SetCharact
$LN8@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 215					; 000000d7H
	jb	SHORT $LN7@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN7@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 97					; 00000061H
	jb	SHORT $LN6@SetCharact
	cmp	al, 111					; 0000006fH
	jbe	SHORT $LN20@SetCharact
$LN6@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 146					; 00000092H
	jb	SHORT $LN5@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN5@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 191					; 000000bfH
	jb	SHORT $LN4@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN4@SetCharact:
	cmp	cl, 136					; 00000088H
	jne	SHORT $LN3@SetCharact
	cmp	al, 64					; 00000040H
	jb	SHORT $LN3@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN3@SetCharact:
	cmp	cl, 152					; 00000098H
	jne	SHORT $LN2@SetCharact
	cmp	al, 115					; 00000073H
	jb	SHORT $LN2@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN2@SetCharact:
	cmp	cl, 234					; 000000eaH
	jne	SHORT $LN1@SetCharact
	cmp	al, 165					; 000000a5H
	jb	SHORT $LN1@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN1@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN31@SetCharact
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN31@SetCharact
$LN20@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$1[ebp]
	push	eax
	call	_rand_s

; 1748 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$1[ebp]
	jmp	$LN169@SetCharact
$LN31@SetCharact:

; 1749 : 				isSecondByteSJIS = FALSE;

	xor	esi, esi
$LN45@SetCharact:

; 1735 : 		}
; 1736 : 	} else {
; 1737 : 		BOOL isSecondByteSJIS = FALSE;
; 1738 : 		for (int32_t i = 0; i < n; i++){

	inc	edi
	cmp	edi, DWORD PTR _n$[ebp]
	jl	$LL46@SetCharact
$LN151@SetCharact:
	pop	edi
	pop	esi
	pop	ebx

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCharactersInTripcodeKey@@YAXPAEH@Z ENDP		; SetCharactersInTripcodeKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?IsFirstByteSJIS@@YAHE@Z
_TEXT	SEGMENT
?IsFirstByteSJIS@@YAHE@Z PROC				; IsFirstByteSJIS, COMDAT
; _ch$ = cl

; 1715 : 	if (options.maximizeKeySpace) {

	cmp	DWORD PTR ?options@@3UOptions@@A+88, 0
	je	SHORT $LN2@IsFirstByt

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	cl, 129					; 00000081H
	jb	SHORT $LN5@IsFirstByt
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN12@IsFirstByt
$LN5@IsFirstByt:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN6@IsFirstByt
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN12@IsFirstByt
$LN6@IsFirstByt:
	add	cl, 32					; 00000020H
	cmp	cl, 10					; 0000000aH
	jmp	SHORT $LN15@IsFirstByt
$LN2@IsFirstByt:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	cl, 137					; 00000089H
	jb	SHORT $LN10@IsFirstByt
	cmp	cl, 151					; 00000097H
	jbe	SHORT $LN12@IsFirstByt
$LN10@IsFirstByt:
	cmp	cl, 153					; 00000099H
	jb	SHORT $LN11@IsFirstByt
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN12@IsFirstByt
$LN11@IsFirstByt:
	add	cl, 32					; 00000020H
	cmp	cl, 9
$LN15@IsFirstByt:
	ja	SHORT $LN13@IsFirstByt
$LN12@IsFirstByt:
	mov	eax, 1

; 1719 : 	}
; 1720 : }

	ret	0
$LN13@IsFirstByt:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	xor	eax, eax

; 1719 : 	}
; 1720 : }

	ret	0
?IsFirstByteSJIS@@YAHE@Z ENDP				; IsFirstByteSJIS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?RandomByte@@YAEXZ
_TEXT	SEGMENT
_randomValue$ = -4					; size = 4
?RandomByte@@YAEXZ PROC					; RandomByte, COMDAT

; 226  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 227  : 	uint32_t randomValue;
; 228  : 
; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$[ebp]
	push	eax
	call	_rand_s

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);

	mov	al, BYTE PTR _randomValue$[ebp]
	add	esp, 4

; 231  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RandomByte@@YAEXZ ENDP					; RandomByte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetTerminationState@@YAHXZ
_TEXT	SEGMENT
?GetTerminationState@@YAHXZ PROC			; GetTerminationState, COMDAT

; 1662 : {

	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL9@GetTermina:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN8@GetTermina
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN23@GetTermina

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL9@GetTermina
$LN23@GetTermina:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL9@GetTermina
$LN8@GetTermina:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	pop	esi
	je	$LN4@GetTermina
	cmp	WORD PTR _nameEventForTerminatingWC, 0
	je	$LN4@GetTermina
	mov	eax, DWORD PTR ?eventForTerminating@@3PAXA ; eventForTerminating
	test	eax, eax
	jne	$LN53@GetTermina

; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);

	push	OFFSET _nameEventForTerminatingWC
	push	eax
	push	2031619					; 001f0003H
	call	DWORD PTR __imp__OpenEventW@12
	mov	DWORD PTR ?eventForTerminating@@3PAXA, eax ; eventForTerminating

; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 

	test	eax, eax
	jne	$LN53@GetTermina
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN4@GetTermina
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN3@GetTermina
	push	21					; 00000015H
	push	OFFSET $SG4294899107
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	push	21					; 00000015H
	push	OFFSET $SG4294899106
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN2@GetTermina
$LN3@GetTermina:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	push	OFFSET $SG4294899105
	push	OFFSET $SG4294899104
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN2@GetTermina:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN57@GetTermina:
$LN4@GetTermina:

; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)

	mov	eax, DWORD PTR ?eventForTerminating@@3PAXA ; eventForTerminating
	test	eax, eax
	je	SHORT $LN54@GetTermina
$LN53@GetTermina:
	push	0
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR ?wasSearchTerminated@@3HA ; wasSearchTerminated
	test	eax, eax
	mov	edx, 1
	cmove	ecx, edx
	mov	DWORD PTR ?wasSearchTerminated@@3HA, ecx ; wasSearchTerminated
	jmp	SHORT $LN1@GetTermina
$LN54@GetTermina:
	mov	ecx, DWORD PTR ?wasSearchTerminated@@3HA ; wasSearchTerminated
$LN1@GetTermina:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1681 : 	return ret;

	mov	eax, ecx

; 1682 : }

	ret	0
$LN56@GetTermina:
?GetTerminationState@@YAHXZ ENDP			; GetTerminationState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?IsValidKey@@YAHPAE@Z
_TEXT	SEGMENT
_results$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
?IsValidKey@@YAHPAE@Z PROC				; IsValidKey, COMDAT

; 371  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {

	mov	ecx, DWORD PTR _key$[ebp]
	push	edi
	xor	edi, edi
	mov	al, BYTE PTR [ecx]
	cmp	al, 35					; 00000023H
	je	$LN46@IsValidKey
	cmp	al, 36					; 00000024H
	je	$LN46@IsValidKey

; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	push	ebx
	push	esi
	xor	esi, esi
	test	eax, eax
	jle	$LN43@IsValidKey
	lea	ebx, DWORD PTR _results$[ebp]
	mov	edx, ecx
	sub	ebx, ecx
$LL45@IsValidKey:

; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {

	test	edi, edi
	jne	SHORT $LN55@IsValidKey
	mov	cl, BYTE PTR [edx]
	cmp	cl, 33					; 00000021H
	jb	SHORT $LN40@IsValidKey
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN41@IsValidKey
$LN40@IsValidKey:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN39@IsValidKey
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN41@IsValidKey
$LN39@IsValidKey:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN38@IsValidKey
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN41@IsValidKey
$LN38@IsValidKey:
	cmp	cl, 161					; 000000a1H
	jb	SHORT $LN56@IsValidKey
	cmp	cl, 223					; 000000dfH
	ja	SHORT $LN56@IsValidKey
$LN41@IsValidKey:

; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';

	mov	BYTE PTR [ebx+edx], 79			; 0000004fH
	jmp	$LN44@IsValidKey
$LN56@IsValidKey:

; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {

	dec	eax
	cmp	esi, eax
	jge	$LN31@IsValidKey
	cmp	cl, 129					; 00000081H
	jb	SHORT $LN34@IsValidKey
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN35@IsValidKey
$LN34@IsValidKey:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN33@IsValidKey
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN35@IsValidKey
$LN33@IsValidKey:
	cmp	cl, 224					; 000000e0H
	jb	$LN31@IsValidKey
	cmp	cl, 234					; 000000eaH
	ja	$LN31@IsValidKey
$LN35@IsValidKey:

; 388  : 			isSecondByteSJIS = TRUE;

	mov	edi, 1

; 389  : 			results[i] = '1';

	mov	BYTE PTR [ebx+edx], 49			; 00000031H
	jmp	$LN59@IsValidKey
$LN55@IsValidKey:

; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {

	mov	al, BYTE PTR [edx]
	cmp	al, 64					; 00000040H
	jb	SHORT $LN29@IsValidKey
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN30@IsValidKey
$LN29@IsValidKey:
	cmp	al, 129					; 00000081H
	jb	$LN31@IsValidKey
	cmp	al, 252					; 000000fcH
	ja	$LN31@IsValidKey
$LN30@IsValidKey:

; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {

	mov	cl, BYTE PTR [esi+ecx-1]
	xor	edi, edi
	cmp	cl, 129					; 00000081H
	jb	SHORT $LN25@IsValidKey
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN26@IsValidKey
$LN25@IsValidKey:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN24@IsValidKey
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN26@IsValidKey
$LN24@IsValidKey:
	cmp	cl, 224					; 000000e0H
	jb	$LN31@IsValidKey
	cmp	cl, 234					; 000000eaH
	ja	$LN31@IsValidKey
$LN26@IsValidKey:
	cmp	al, 64					; 00000040H
	jb	SHORT $LN22@IsValidKey
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN23@IsValidKey
$LN22@IsValidKey:
	cmp	al, 129					; 00000081H
	jb	$LN31@IsValidKey
	cmp	al, 252					; 000000fcH
	ja	$LN31@IsValidKey
$LN23@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	cmp	al, 173					; 000000adH
	jb	SHORT $LN20@IsValidKey
	cmp	al, 183					; 000000b7H
	jbe	$LN31@IsValidKey
$LN20@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	cmp	al, 192					; 000000c0H
	jb	SHORT $LN19@IsValidKey
	cmp	al, 199					; 000000c7H
	jbe	$LN31@IsValidKey
$LN19@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	cmp	al, 207					; 000000cfH
	jb	SHORT $LN18@IsValidKey
	cmp	al, 217					; 000000d9H
	jbe	$LN31@IsValidKey
$LN18@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	cmp	al, 233					; 000000e9H
	jb	SHORT $LN17@IsValidKey
	cmp	al, 239					; 000000efH
	jbe	$LN31@IsValidKey
$LN17@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	cmp	al, 248					; 000000f8H
	jb	SHORT $LN16@IsValidKey
	cmp	al, 251					; 000000fbH
	jbe	$LN31@IsValidKey
$LN16@IsValidKey:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	cmp	al, 64					; 00000040H
	jb	SHORT $LN15@IsValidKey
	cmp	al, 78					; 0000004eH
	jbe	$LN31@IsValidKey
$LN15@IsValidKey:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	cmp	al, 89					; 00000059H
	jb	SHORT $LN14@IsValidKey
	cmp	al, 95					; 0000005fH
	jbe	$LN31@IsValidKey
$LN14@IsValidKey:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	cmp	al, 122					; 0000007aH
	jb	SHORT $LN13@IsValidKey
	cmp	al, 128					; 00000080H
	jbe	$LN31@IsValidKey
$LN13@IsValidKey:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	cmp	al, 155					; 0000009bH
	jb	SHORT $LN12@IsValidKey
	cmp	al, 158					; 0000009eH
	jbe	$LN31@IsValidKey
$LN12@IsValidKey:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	cmp	al, 242					; 000000f2H
	jb	SHORT $LN11@IsValidKey
	cmp	al, 252					; 000000fcH
	jbe	$LN31@IsValidKey
$LN11@IsValidKey:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN8@IsValidKey
	cmp	al, 151					; 00000097H
	jb	SHORT $LN10@IsValidKey
	cmp	al, 158					; 0000009eH
	jbe	$LN31@IsValidKey
$LN10@IsValidKey:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN8@IsValidKey
	cmp	al, 183					; 000000b7H
	jb	SHORT $LN9@IsValidKey
	cmp	al, 190					; 000000beH
	jbe	$LN31@IsValidKey
$LN9@IsValidKey:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN8@IsValidKey
	cmp	al, 215					; 000000d7H
	jb	SHORT $LN8@IsValidKey
	cmp	al, 252					; 000000fcH
	jbe	$LN31@IsValidKey
$LN8@IsValidKey:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN5@IsValidKey
	cmp	al, 97					; 00000061H
	jb	SHORT $LN7@IsValidKey
	cmp	al, 111					; 0000006fH
	jbe	SHORT $LN31@IsValidKey
$LN7@IsValidKey:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN5@IsValidKey
	cmp	al, 146					; 00000092H
	jb	SHORT $LN6@IsValidKey
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN31@IsValidKey
$LN6@IsValidKey:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN5@IsValidKey
	cmp	al, 191					; 000000bfH
	jb	SHORT $LN5@IsValidKey
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN31@IsValidKey
$LN5@IsValidKey:
	cmp	cl, 136					; 00000088H
	jne	SHORT $LN4@IsValidKey
	cmp	al, 64					; 00000040H
	jb	SHORT $LN4@IsValidKey
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN31@IsValidKey
$LN4@IsValidKey:
	cmp	cl, 152					; 00000098H
	jne	SHORT $LN3@IsValidKey
	cmp	al, 115					; 00000073H
	jb	SHORT $LN3@IsValidKey
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN31@IsValidKey
$LN3@IsValidKey:
	cmp	cl, 234					; 000000eaH
	jne	SHORT $LN2@IsValidKey
	cmp	al, 165					; 000000a5H
	jb	SHORT $LN2@IsValidKey
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN31@IsValidKey
$LN2@IsValidKey:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN28@IsValidKey
	cmp	al, 240					; 000000f0H
	je	SHORT $LN31@IsValidKey
$LN28@IsValidKey:

; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';

	mov	BYTE PTR [ebx+edx], 50			; 00000032H
$LN59@IsValidKey:
	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
$LN44@IsValidKey:

; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {

	mov	ecx, DWORD PTR _key$[ebp]
	inc	esi
	inc	edx
	cmp	esi, eax
	jl	$LL45@IsValidKey
$LN43@IsValidKey:
	pop	esi
	pop	ebx

; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;

	mov	eax, 1
	pop	edi

; 409  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@IsValidKey:
	pop	esi
	pop	ebx

; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;

	xor	eax, eax
	pop	edi

; 409  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@IsValidKey:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?IsValidKey@@YAHPAE@Z ENDP				; IsValidKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?AddToNumGeneratedTripcodesByCPU@@YAXI@Z
_TEXT	SEGMENT
?AddToNumGeneratedTripcodesByCPU@@YAXI@Z PROC		; AddToNumGeneratedTripcodesByCPU, COMDAT
; _num$ = ecx

; 1573 : {

	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, OFFSET ?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
	npad	7
$LL5@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN4@AddToNumGe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN19@AddToNumGe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@AddToNumGe
$LN19@AddToNumGe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@AddToNumGe
$LN4@AddToNumGe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1575 : 	numGeneratedTripcodes_CPU += num;

	mov	ecx, DWORD PTR ?numGeneratedTripcodes_CPU@@3IA ; numGeneratedTripcodes_CPU
	add	ecx, esi
	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, ecx ; numGeneratedTripcodes_CPU
	pop	edi
	pop	esi

; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {

	cmp	ecx, 1000000				; 000f4240H
	jb	SHORT $LN49@AddToNumGe

; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;

	mov	eax, 1125899907				; 431bde83H
	mul	ecx
	shr	edx, 18					; 00000012H
	add	DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA, edx ; numGeneratedTripcodesByCPUInMillions

; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;

	imul	eax, edx, -1000000
	add	ecx, eax
	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, ecx ; numGeneratedTripcodes_CPU
$LN49@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1581 : }

	ret	0
?AddToNumGeneratedTripcodesByCPU@@YAXI@Z ENDP		; AddToNumGeneratedTripcodesByCPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetPauseState@@YAHXZ
_TEXT	SEGMENT
?GetPauseState@@YAHXZ PROC				; GetPauseState, COMDAT

; 1630 : {

	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL4@GetPauseSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@GetPauseSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@GetPauseSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetPauseSt
$LN18@GetPauseSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetPauseSt
$LN3@GetPauseSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1633 : 	ret = isSearchPaused;

	mov	eax, DWORD PTR ?isSearchPaused@@3HA	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1636 : }

	ret	0
?GetPauseState@@YAHXZ ENDP				; GetPauseState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z
_TEXT	SEGMENT
_randomValue$1 = -20					; size = 4
_randomValue$2 = -16					; size = 4
_randomValue$3 = -12					; size = 4
_randomValue$4 = -8					; size = 4
_randomValue$5 = -8					; size = 4
_randomValue$6 = -8					; size = 4
_randomValue$7 = -4					; size = 4
_randomValue$8 = -4					; size = 4
_randomValue$9 = -4					; size = 4
_key$ = 8						; size = 4
?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z PROC ; SetCharactersInTripcodeKeyForSHA1Tripcode, COMDAT

; 1756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1757 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1758 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	xor	esi, esi
	push	edi
	cmp	DWORD PTR ?options@@3UOptions@@A+84, esi
	je	SHORT $LN79@SetCharact
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	$LN177@SetCharact
	mov	edi, DWORD PTR _key$[ebp]
$LL78@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$9[ebp]
	push	eax
	call	_rand_s

; 1759 : 			key[i] = RandomByte();

	mov	al, BYTE PTR _randomValue$9[ebp]
$LN181@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1759 : 			key[i] = RandomByte();

	mov	BYTE PTR [esi+edi], al

; 1760 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))

	test	esi, esi
	jne	SHORT $LN72@SetCharact
	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN68@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN68@SetCharact
$LN72@SetCharact:
	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	je	SHORT $LN77@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN77@SetCharact
	cmp	al, 39					; 00000027H
	jb	SHORT $LN71@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN77@SetCharact
$LN71@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN70@SetCharact
	cmp	al, 59					; 0000003bH
	jbe	SHORT $LN77@SetCharact
$LN70@SetCharact:
	cmp	al, 61					; 0000003dH
	jb	SHORT $LN69@SetCharact
	jbe	SHORT $LN77@SetCharact
$LN69@SetCharact:
	cmp	al, 63					; 0000003fH
	jb	SHORT $LN68@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN77@SetCharact
$LN68@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$6[ebp]
	push	eax
	call	_rand_s

; 1761 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$6[ebp]
	jmp	SHORT $LN181@SetCharact
$LN77@SetCharact:

; 1757 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1758 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	esi
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL78@SetCharact
	pop	edi
	pop	esi

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@SetCharact:

; 1762 : 		}
; 1763 : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	je	SHORT $LN66@SetCharact

; 1764 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	$LN177@SetCharact
	mov	edi, DWORD PTR _key$[ebp]
	npad	1
$LL65@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$5[ebp]
	push	eax
	call	_rand_s

; 1765 : 			key[i] = RandomByte();

	mov	al, BYTE PTR _randomValue$5[ebp]
$LN182@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1765 : 			key[i] = RandomByte();

	mov	BYTE PTR [esi+edi], al

; 1766 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))

	test	esi, esi
	jne	SHORT $LN59@SetCharact
	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN55@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN55@SetCharact
$LN59@SetCharact:
	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	jb	SHORT $LN58@SetCharact
	cmp	al, 36					; 00000024H
	jbe	SHORT $LN64@SetCharact
$LN58@SetCharact:
	cmp	al, 38					; 00000026H
	jb	SHORT $LN57@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN64@SetCharact
$LN57@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN56@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN64@SetCharact
$LN56@SetCharact:
	cmp	al, 161					; 000000a1H
	jb	SHORT $LN55@SetCharact
	cmp	al, 223					; 000000dfH
	jbe	SHORT $LN64@SetCharact
$LN55@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$8[ebp]
	push	eax
	call	_rand_s

; 1767 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$8[ebp]
	jmp	SHORT $LN182@SetCharact
$LN64@SetCharact:

; 1764 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	esi
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL65@SetCharact
	pop	edi
	pop	esi

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@SetCharact:

; 1768 : 		}
; 1769 : 	} else {
; 1770 : 		BOOL isSecondByteSJIS = FALSE;

	xor	eax, eax

; 1771 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, eax	; lenTripcodeKey
	jle	$LN177@SetCharact
	mov	edi, DWORD PTR _key$[ebp]
$LL53@SetCharact:

; 1772 : 			if (!isSecondByteSJIS) {

	test	eax, eax
	jne	$LN50@SetCharact

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$4[ebp]
	push	eax
	call	_rand_s

; 1773 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$4[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1773 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	BYTE PTR [esi+edi], al

; 1774 : 				if (i == 3 || i == lenTripcodeKey - 1) {

	cmp	esi, 3
	je	$LL47@SetCharact
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	dec	eax
	cmp	esi, eax
	je	$LL47@SetCharact
$LL40@SetCharact:

; 1777 : 				} else {
; 1778 : 					while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))

	test	esi, esi
	jne	SHORT $LN37@SetCharact
	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN38@SetCharact
	cmp	al, 36					; 00000024H
	je	SHORT $LN38@SetCharact
$LN37@SetCharact:
	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	jb	SHORT $LN36@SetCharact
	cmp	al, 36					; 00000024H
	jbe	$LN178@SetCharact
$LN36@SetCharact:
	cmp	al, 38					; 00000026H
	jb	SHORT $LN35@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	$LN178@SetCharact
$LN35@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN34@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	$LN178@SetCharact
$LN34@SetCharact:
	cmp	al, 161					; 000000a1H
	jb	SHORT $LN33@SetCharact
	cmp	al, 223					; 000000dfH
	jbe	$LN178@SetCharact
$LN33@SetCharact:

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	mov	ecx, DWORD PTR ?options@@3UOptions@@A+88
	test	ecx, ecx
	je	SHORT $LN95@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	al, 129					; 00000081H
	jb	SHORT $LN98@SetCharact
	cmp	al, 132					; 00000084H
	jbe	$LN46@SetCharact
$LN98@SetCharact:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN99@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN46@SetCharact
$LN99@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN183@SetCharact
$LN95@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	al, 137					; 00000089H
	jb	SHORT $LN103@SetCharact
	cmp	al, 151					; 00000097H
	jbe	SHORT $LN46@SetCharact
$LN103@SetCharact:
	cmp	al, 153					; 00000099H
	jb	SHORT $LN104@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN46@SetCharact
$LN104@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 9
$LN183@SetCharact:
	jbe	SHORT $LN46@SetCharact
$LN38@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$7[ebp]
	push	eax
	call	_rand_s

; 1779 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$7[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1779 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	BYTE PTR [esi+edi], al
	jmp	$LL40@SetCharact
$LL47@SetCharact:

; 1775 : 					while (!IS_ONE_BYTE_KEY_CHAR(key[i]))

	mov	al, BYTE PTR [esi+edi]
	cmp	al, 33					; 00000021H
	jb	SHORT $LN45@SetCharact
	cmp	al, 36					; 00000024H
	jbe	SHORT $LN178@SetCharact
$LN45@SetCharact:
	cmp	al, 38					; 00000026H
	jb	SHORT $LN44@SetCharact
	cmp	al, 42					; 0000002aH
	jbe	SHORT $LN178@SetCharact
$LN44@SetCharact:
	cmp	al, 45					; 0000002dH
	jb	SHORT $LN43@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN178@SetCharact
$LN43@SetCharact:
	cmp	al, 161					; 000000a1H
	jb	SHORT $LN42@SetCharact
	cmp	al, 223					; 000000dfH
	jbe	SHORT $LN178@SetCharact
$LN42@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$3[ebp]
	push	eax
	call	_rand_s

; 1776 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$3[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1776 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	BYTE PTR [esi+edi], al
	jmp	SHORT $LL47@SetCharact
$LN178@SetCharact:
	mov	ecx, DWORD PTR ?options@@3UOptions@@A+88
$LN46@SetCharact:

; 1780 : 				}
; 1781 : 				isSecondByteSJIS = IsFirstByteSJIS(key[i]);

	mov	al, BYTE PTR [esi+edi]

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	ecx, ecx
	je	SHORT $LN111@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	al, 129					; 00000081H
	jb	SHORT $LN114@SetCharact
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN121@SetCharact
$LN114@SetCharact:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN115@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN121@SetCharact
$LN115@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 10					; 0000000aH
	ja	$LN30@SetCharact
	mov	eax, 1
	jmp	$LN52@SetCharact
$LN111@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	al, 137					; 00000089H
	jb	SHORT $LN119@SetCharact
	cmp	al, 151					; 00000097H
	jbe	SHORT $LN121@SetCharact
$LN119@SetCharact:
	cmp	al, 153					; 00000099H
	jb	SHORT $LN120@SetCharact
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN121@SetCharact
$LN120@SetCharact:
	add	al, 32					; 00000020H
	cmp	al, 9
	ja	$LN30@SetCharact
$LN121@SetCharact:
	mov	eax, 1
	jmp	$LN52@SetCharact
$LN50@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$2[ebp]
	push	eax
	call	_rand_s

; 1782 : 			} else {
; 1783 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$2[ebp]
$LN196@SetCharact:

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 1782 : 			} else {
; 1783 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	BYTE PTR [esi+edi], al

; 1784 : 				while (!IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))

	cmp	al, 64					; 00000040H
	jb	SHORT $LN27@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN28@SetCharact
$LN27@SetCharact:
	cmp	al, 129					; 00000081H
	jb	$LN20@SetCharact
	cmp	al, 252					; 000000fcH
	ja	$LN20@SetCharact
$LN28@SetCharact:
	mov	cl, BYTE PTR [esi+edi-1]
	cmp	cl, 129					; 00000081H
	jb	SHORT $LN24@SetCharact
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN25@SetCharact
$LN24@SetCharact:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN23@SetCharact
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN25@SetCharact
$LN23@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	$LN20@SetCharact
	cmp	cl, 234					; 000000eaH
	ja	$LN20@SetCharact
$LN25@SetCharact:
	cmp	al, 64					; 00000040H
	jb	SHORT $LN21@SetCharact
	cmp	al, 126					; 0000007eH
	jbe	SHORT $LN22@SetCharact
$LN21@SetCharact:
	cmp	al, 129					; 00000081H
	jb	$LN20@SetCharact
	cmp	al, 252					; 000000fcH
	ja	$LN20@SetCharact
$LN22@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 173					; 000000adH
	jb	SHORT $LN19@SetCharact
	cmp	al, 183					; 000000b7H
	jbe	$LN20@SetCharact
$LN19@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 192					; 000000c0H
	jb	SHORT $LN18@SetCharact
	cmp	al, 199					; 000000c7H
	jbe	$LN20@SetCharact
$LN18@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 207					; 000000cfH
	jb	SHORT $LN17@SetCharact
	cmp	al, 217					; 000000d9H
	jbe	$LN20@SetCharact
$LN17@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 233					; 000000e9H
	jb	SHORT $LN16@SetCharact
	cmp	al, 239					; 000000efH
	jbe	$LN20@SetCharact
$LN16@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	cmp	al, 248					; 000000f8H
	jb	SHORT $LN15@SetCharact
	cmp	al, 251					; 000000fbH
	jbe	$LN20@SetCharact
$LN15@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 64					; 00000040H
	jb	SHORT $LN14@SetCharact
	cmp	al, 78					; 0000004eH
	jbe	$LN20@SetCharact
$LN14@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 89					; 00000059H
	jb	SHORT $LN13@SetCharact
	cmp	al, 95					; 0000005fH
	jbe	$LN20@SetCharact
$LN13@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 122					; 0000007aH
	jb	SHORT $LN12@SetCharact
	cmp	al, 128					; 00000080H
	jbe	$LN20@SetCharact
$LN12@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 155					; 0000009bH
	jb	SHORT $LN11@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	$LN20@SetCharact
$LN11@SetCharact:
	cmp	cl, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	cmp	al, 242					; 000000f2H
	jb	SHORT $LN10@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	$LN20@SetCharact
$LN10@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 151					; 00000097H
	jb	SHORT $LN9@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN9@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 183					; 000000b7H
	jb	SHORT $LN8@SetCharact
	cmp	al, 190					; 000000beH
	jbe	SHORT $LN20@SetCharact
$LN8@SetCharact:
	cmp	cl, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	cmp	al, 215					; 000000d7H
	jb	SHORT $LN7@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN7@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 97					; 00000061H
	jb	SHORT $LN6@SetCharact
	cmp	al, 111					; 0000006fH
	jbe	SHORT $LN20@SetCharact
$LN6@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 146					; 00000092H
	jb	SHORT $LN5@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN5@SetCharact:
	cmp	cl, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	cmp	al, 191					; 000000bfH
	jb	SHORT $LN4@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN4@SetCharact:
	cmp	cl, 136					; 00000088H
	jne	SHORT $LN3@SetCharact
	cmp	al, 64					; 00000040H
	jb	SHORT $LN3@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN3@SetCharact:
	cmp	cl, 152					; 00000098H
	jne	SHORT $LN2@SetCharact
	cmp	al, 115					; 00000073H
	jb	SHORT $LN2@SetCharact
	cmp	al, 158					; 0000009eH
	jbe	SHORT $LN20@SetCharact
$LN2@SetCharact:
	cmp	cl, 234					; 000000eaH
	jne	SHORT $LN1@SetCharact
	cmp	al, 165					; 000000a5H
	jb	SHORT $LN1@SetCharact
	cmp	al, 252					; 000000fcH
	jbe	SHORT $LN20@SetCharact
$LN1@SetCharact:
	cmp	cl, 129					; 00000081H
	jne	SHORT $LN30@SetCharact
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN30@SetCharact
$LN20@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$1[ebp]
	push	eax
	call	_rand_s

; 1785 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	mov	al, BYTE PTR _randomValue$1[ebp]
	jmp	$LN196@SetCharact
$LN30@SetCharact:

; 1786 : 				isSecondByteSJIS = FALSE;

	xor	eax, eax
$LN52@SetCharact:

; 1771 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	esi
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	$LL53@SetCharact
$LN177@SetCharact:
	pop	edi
	pop	esi

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPAE@Z ENDP ; SetCharactersInTripcodeKeyForSHA1Tripcode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessGPUOutput@@YANPAEPAUGPUOutput@@IH@Z
_TEXT	SEGMENT
_numGeneratedTripcodesInThisOutput$ = -56		; size = 8
_numGeneratedTripcodesInThisOutput$1$ = -48		; size = 8
_key$ = -36						; size = 13
_tripcode$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_partialKey$ = 8					; size = 4
_outputArray$ = 12					; size = 4
_sizeOutputArray$ = 16					; size = 4
_newFormat$ = 20					; size = 4
?ProcessGPUOutput@@YANPAEPAUGPUOutput@@IH@Z PROC	; ProcessGPUOutput, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+60], eax

; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _partialKey$[ebp]
	movsd	QWORD PTR _numGeneratedTripcodesInThisOutput$1$[esp+60], xmm0
	movsd	QWORD PTR _numGeneratedTripcodesInThisOutput$[esp+60], xmm0
	push	ebx
	push	esi
	mov	esi, DWORD PTR _outputArray$[ebp]
	push	edi
	cmp	eax, 13					; 0000000dH
	jae	$LN59@ProcessGPU
	mov	BYTE PTR _tripcode$[esp+eax+72], 0

; 341  : 	key     [lenTripcodeKey] = '\0';

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	cmp	eax, 13					; 0000000dH
	jae	$LN59@ProcessGPU

; 342  : 	memcpy(key, partialKey, lenTripcodeKey);

	push	eax
	mov	BYTE PTR _key$[esp+eax+76], 0
	lea	eax, DWORD PTR _key$[esp+76]
	push	ecx
	push	eax
	call	_memcpy

; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _sizeOutputArray$[ebp], ebx
	jbe	$LN57@ProcessGPU

; 341  : 	key     [lenTripcodeKey] = '\0';

	add	esi, 5
	npad	1
$LL14@ProcessGPU:

; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);

	push	DWORD PTR [esi-5]
	call	?AddToNumGeneratedTripcodesByGPU@@YAXI@Z ; AddToNumGeneratedTripcodesByGPU

; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;

	mov	eax, DWORD PTR [esi-5]
	add	esp, 4
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 347  : 		if (output->numMatchingTripcodes > 0) {

	cmp	BYTE PTR [esi-1], 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm0, QWORD PTR _numGeneratedTripcodesInThisOutput$1$[esp+72]
	movsd	QWORD PTR _numGeneratedTripcodesInThisOutput$1$[esp+72], xmm0
	movsd	QWORD PTR _numGeneratedTripcodesInThisOutput$[esp+72], xmm0
	jbe	$LN13@ProcessGPU

; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);

	mov	edi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	lea	eax, DWORD PTR _tripcode$[esp+72]
	push	edi
	push	esi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 349  : 			if (lenTripcode == 12 && newFormat) {

	cmp	edi, 12					; 0000000cH
	jne	SHORT $LN8@ProcessGPU
	cmp	DWORD PTR _newFormat$[ebp], 0
	je	SHORT $LN56@ProcessGPU

; 350  : 				memcpy(key, output->pair.key.c, 4);

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _key$[esp+72], eax

; 351  : 				key[7]  = output->pair.key.c[7];

	movzx	eax, BYTE PTR [esi+19]
	mov	BYTE PTR _key$[esp+79], al

; 352  : 				key[11] = output->pair.key.c[11];

	movzx	eax, BYTE PTR [esi+23]
	mov	BYTE PTR _key$[esp+83], al
	jmp	SHORT $LN7@ProcessGPU
$LN56@ProcessGPU:

; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);

	mov	eax, DWORD PTR [esi+19]
	mov	DWORD PTR _key$[esp+79], eax
	mov	al, BYTE PTR [esi+23]
	mov	BYTE PTR _key$[esp+83], al

; 355  : 			} else {

	jmp	SHORT $LN7@ProcessGPU
$LN8@ProcessGPU:

; 356  : 				ASSERT(lenTripcode == 10);

	cmp	edi, 10					; 0000000aH
	je	SHORT $LN6@ProcessGPU
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN51@ProcessGPU
$LN6@ProcessGPU:

; 357  : 				memcpy(key,  output->pair.key.c, 8);

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _key$[esp+72], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _key$[esp+76], eax

; 358  : 				CreateKey8AndKey9(key);

	lea	eax, DWORD PTR _key$[esp+72]
	push	eax
	call	?CreateKey8AndKey9@@YAXPAE@Z		; CreateKey8AndKey9
	add	esp, 4
$LN7@ProcessGPU:

; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	lea	eax, DWORD PTR _tripcode$[esp+72]
	push	eax
	call	?IsTripcodeChunkValid@@YAHPAE@Z		; IsTripcodeChunkValid
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@ProcessGPU
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN52@ProcessGPU
$LN3@ProcessGPU:

; 364  : 			ProcessPossibleMatch(tripcode, key);

	lea	eax, DWORD PTR _key$[esp+72]
	push	eax
	lea	eax, DWORD PTR _tripcode$[esp+76]
	push	eax
	call	?ProcessPossibleMatch@@YAXPAE0@Z	; ProcessPossibleMatch
	add	esp, 8
$LN13@ProcessGPU:

; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){

	inc	ebx
	add	esi, 32					; 00000020H
	cmp	ebx, DWORD PTR _sizeOutputArray$[ebp]
	jb	$LL14@ProcessGPU
$LN57@ProcessGPU:

; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+72]
	fld	QWORD PTR _numGeneratedTripcodesInThisOutput$[esp+72]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@ProcessGPU:

; 356  : 				ASSERT(lenTripcode == 10);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN5@ProcessGPU
	push	14					; 0000000eH
	push	OFFSET $SG4294899498
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899497
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@ProcessGPU
$LN5@ProcessGPU:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	356					; 00000164H
	push	OFFSET $SG4294899496
	push	OFFSET $SG4294899495
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN4@ProcessGPU:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN60@ProcessGPU:
$LN52@ProcessGPU:

; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@ProcessGPU
	push	20					; 00000014H
	push	OFFSET $SG4294899494
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	20					; 00000014H
	push	OFFSET $SG4294899493
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@ProcessGPU
$LN2@ProcessGPU:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899509
	push	OFFSET $SG4294899492
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN1@ProcessGPU:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN61@ProcessGPU:
$LN59@ProcessGPU:

; 341  : 	key     [lenTripcodeKey] = '\0';

	call	___report_rangecheckfailure
$LN62@ProcessGPU:
$LN58@ProcessGPU:
	int	3
?ProcessGPUOutput@@YANPAEPAUGPUOutput@@IH@Z ENDP	; ProcessGPUOutput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?show_cursor@@YAXXZ
_TEXT	SEGMENT
_info$ = -8						; size = 8
?show_cursor@@YAXXZ PROC				; show_cursor, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _info$[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?show_cursor@@YAXXZ ENDP				; show_cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?reset_cursor_pos@@YAXH@Z
_TEXT	SEGMENT
_cursorPos$ = -32					; size = 4
_scrnBufInfo$ = -28					; size = 22
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
?reset_cursor_pos@@YAXH@Z PROC				; reset_cursor_pos, COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$[ebp]
	push	eax
	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN2@reset_curs

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$[ebp+6]
	xor	eax, eax
	mov	edx, DWORD PTR _n$[ebp]
	mov	WORD PTR _cursorPos$[ebp], ax
	movsx	eax, cx
	add	eax, edx
	js	SHORT $LN4@reset_curs
	lea	eax, DWORD PTR [edx+ecx]
	jmp	SHORT $LN6@reset_curs
$LN4@reset_curs:
	xor	eax, eax
$LN6@reset_curs:
	mov	WORD PTR _cursorPos$[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$[ebp]
	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN2@reset_curs:

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?reset_cursor_pos@@YAXH@Z ENDP				; reset_cursor_pos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetErrorState@@YAHXZ
_TEXT	SEGMENT
?GetErrorState@@YAHXZ PROC				; GetErrorState, COMDAT

; 1646 : {

	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL4@GetErrorSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@GetErrorSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@GetErrorSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetErrorSt
$LN18@GetErrorSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetErrorSt
$LN3@GetErrorSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1652 : }

	ret	0
?GetErrorState@@YAHXZ ENDP				; GetErrorState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetErrorMessage@@YAPADH@Z
_TEXT	SEGMENT
_errorCode$ = 8						; size = 4
?GetErrorMessage@@YAPADH@Z PROC				; GetErrorMessage, COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  : 	switch (errorCode) {

	mov	eax, DWORD PTR _errorCode$[ebp]
	cmp	eax, 24					; 00000018H
	ja	$LN1@GetErrorMe
	jmp	DWORD PTR $LN31@GetErrorMe[eax*4]
$LN25@GetErrorMe:

; 173  :     case ERROR_INVALID_TARGET_PATTERN: 
; 174  : 		return "ERROR_INVALID_TARGET_PATTERN";

	mov	eax, OFFSET $SG4294899529

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN24@GetErrorMe:

; 175  :     case ERROR_INVALID_REGEX: 
; 176  : 		return "ERROR_INVALID_REGEX";

	mov	eax, OFFSET $SG4294899528

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN23@GetErrorMe:

; 177  :     case ERROR_PATTERN_TOO_LONG: 
; 178  : 		return "ERROR_PATTERN_TOO_LONG";

	mov	eax, OFFSET $SG4294899527

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN22@GetErrorMe:

; 179  :     case ERROR_PATTERN_TOO_SHORT: 
; 180  : 		return "ERROR_PATTERN_TOO_SHORT";

	mov	eax, OFFSET $SG4294899526

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN21@GetErrorMe:

; 181  :     case ERROR_CUDA:
; 182  : 		return "CUDA fucnction call failed.";

	mov	eax, OFFSET $SG4294899525

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN20@GetErrorMe:

; 183  :     case ERROR_NO_MEMORY: 
; 184  : 		return "ERROR_NO_MEMORY";

	mov	eax, OFFSET $SG4294899524

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN19@GetErrorMe:

; 185  :     case ERROR_PATTERN_FILE: 
; 186  : 		return "ERROR_PATTERN_FILE";

	mov	eax, OFFSET $SG4294899523

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN18@GetErrorMe:

; 187  :     case ERROR_IGNORE_DIRECTIVE:
; 188  : 		return "ERROR_IGNORE_DIRECTIVE";

	mov	eax, OFFSET $SG4294899522

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN17@GetErrorMe:

; 189  :     case ERROR_NO_TARGET_PATTERNS: 
; 190  : 		return "ERROR_NO_TARGET_PATTERNS";

	mov	eax, OFFSET $SG4294899521

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN16@GetErrorMe:

; 191  :     case ERROR_CRYPTOGRAPHIC_SERVICE: 
; 192  : 		return "ERROR_CRYPTOGRAPHIC_SERVICE";

	mov	eax, OFFSET $SG4294899520

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN15@GetErrorMe:

; 193  :     case ERROR_INVALID_OPTION: 
; 194  : 		return "ERROR_INVALID_OPTION";

	mov	eax, OFFSET $SG4294899519

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN14@GetErrorMe:

; 195  :     case ERROR_TRIPCODE_FILE:
; 196  : 		return "ERROR_TRIPCODE_FILE";

	mov	eax, OFFSET $SG4294899518

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN13@GetErrorMe:

; 197  :     case ERROR_SEARCH_THREAD: 
; 198  : 		return "ERROR_SEARCH_THREAD";

	mov	eax, OFFSET $SG4294899517

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN12@GetErrorMe:

; 199  :     case ERROR_MUTEX:
; 200  : 		return "ERROR_MUTEX";

	mov	eax, OFFSET $SG4294899516

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN11@GetErrorMe:

; 201  :     case ERROR_ASSERTION:
; 202  : 		return "Assertion failed.";

	mov	eax, OFFSET $SG4294899515

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN10@GetErrorMe:

; 203  :     case ERROR_OPENCL:
; 204  : 		return "OpenCL fucnction call failed.";

	mov	eax, OFFSET $SG4294899514

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN9@GetErrorMe:

; 205  :     case ERROR_DES: 
; 206  : 		return "ERROR_DES";

	mov	eax, OFFSET $SG4294899513

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN8@GetErrorMe:

; 207  :     case ERROR_SHA1: 
; 208  : 		return "ERROR_SHA1";

	mov	eax, OFFSET $SG4294899512

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN7@GetErrorMe:

; 209  :     case ERROR_INTEL_HD_GRAPHICS:
; 210  : 		return "ERROR_INTEL_HD_GRAPHICS";

	mov	eax, OFFSET $SG4294899511

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN6@GetErrorMe:

; 211  :     case ERROR_CHILD_PROCESS:
; 212  : 		return "ERROR_CHILD_PROCESS";

	mov	eax, OFFSET $SG4294899510

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN5@GetErrorMe:

; 213  :     case ERROR_TRIPCODE_VERIFICATION_FAILED: 
; 214  : 		return "A corrupt tripcode was generated.\n  The hardware or device driver may be malfunctioning.\n  Please check the temperatures of CPU(s) and GPU(s).";

	mov	eax, OFFSET $SG4294899509

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN4@GetErrorMe:

; 215  :     case ERROR_EVENT: 
; 216  : 		return "ERROR_EVENT";

	mov	eax, OFFSET $SG4294899508

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN3@GetErrorMe:

; 217  :     case ERROR_SEARCH_THREAD_UNRESPONSIVE:
; 218  : 		return "ERROR_SEARCH_THREAD_UNRESPONSIVE";

	mov	eax, OFFSET $SG4294899507

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN2@GetErrorMe:

; 219  :     case ERROR_GCN_ASSEMBLER: 
; 220  : 		return "GCN assembler failed.";

	mov	eax, OFFSET $SG4294899506

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
$LN1@GetErrorMe:

; 221  :     default: return "ERROR_UNKNOWN";

	mov	eax, OFFSET $SG4294899505

; 222  : 	}
; 223  : }

	pop	ebp
	ret	0
	npad	3
$LN31@GetErrorMe:
	DD	$LN25@GetErrorMe
	DD	$LN24@GetErrorMe
	DD	$LN23@GetErrorMe
	DD	$LN22@GetErrorMe
	DD	$LN21@GetErrorMe
	DD	$LN20@GetErrorMe
	DD	$LN19@GetErrorMe
	DD	$LN18@GetErrorMe
	DD	$LN17@GetErrorMe
	DD	$LN16@GetErrorMe
	DD	$LN15@GetErrorMe
	DD	$LN14@GetErrorMe
	DD	$LN13@GetErrorMe
	DD	$LN12@GetErrorMe
	DD	$LN11@GetErrorMe
	DD	$LN10@GetErrorMe
	DD	$LN9@GetErrorMe
	DD	$LN8@GetErrorMe
	DD	$LN7@GetErrorMe
	DD	$LN6@GetErrorMe
	DD	$LN5@GetErrorMe
	DD	$LN4@GetErrorMe
	DD	$LN3@GetErrorMe
	DD	$LN1@GetErrorMe
	DD	$LN2@GetErrorMe
?GetErrorMessage@@YAPADH@Z ENDP				; GetErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateOpenCLDeviceStatus@@YAXPAUOpenCLDeviceSearchThreadInfo@@PAD@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
_info$2 = -8						; size = 8
?UpdateOpenCLDeviceStatus@@YAXPAUOpenCLDeviceSearchThreadInfo@@PAD@Z PROC ; UpdateOpenCLDeviceStatus, COMDAT
; _info$ = ecx
; _status$ = edx

; 550  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	mov	ebx, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
$LL8@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [ebx], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN7@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN22@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL8@UpdateOpen
$LN22@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL8@UpdateOpen
$LN7@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 552  : 	ASSERT(!info->runChildProcess);

	cmp	DWORD PTR [edi+1072], 0
	je	$LN3@UpdateOpen
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN3@UpdateOpen
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@UpdateOpen
	push	14					; 0000000eH
	push	OFFSET $SG4294899481
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899480
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN25@UpdateOpen
$LN2@UpdateOpen:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	552					; 00000228H
	push	OFFSET $SG4294899479
	push	OFFSET $SG4294899478
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN25@UpdateOpen:

; 552  : 	ASSERT(!info->runChildProcess);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN93@UpdateOpen:
$LN3@UpdateOpen:

; 553  : 	strcpy(info->status, status);

	lea	ecx, DWORD PTR [edi+12]
	sub	ecx, esi
$LL6@UpdateOpen:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL6@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [edi+1080], eax
	mov	DWORD PTR [edi+1084], edx

; 556  : }

	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 556  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@UpdateOpen:
?UpdateOpenCLDeviceStatus@@YAXPAUOpenCLDeviceSearchThreadInfo@@PAD@Z ENDP ; UpdateOpenCLDeviceStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetErrorState@@YAXXZ
_TEXT	SEGMENT
?SetErrorState@@YAXXZ PROC				; SetErrorState, COMDAT

; 1639 : {

	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL4@SetErrorSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@SetErrorSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@SetErrorSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetErrorSt
$LN18@SetErrorSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetErrorSt
$LN3@SetErrorSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1643 : }

	ret	0
?SetErrorState@@YAXXZ ENDP				; SetErrorState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPAUOpenCLDeviceSearchThreadInfo@@PADNNNIPAVchild@windows@process@boost@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
_info$2 = -8						; size = 8
_numDiscardedTripcodes$ = 8				; size = 4
_child_process$ = 12					; size = 4
_currentSpeed$ = 16					; size = 8
_averageSpeed$ = 24					; size = 8
_totalNumGeneratedTripcodes$ = 32			; size = 8
?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPAUOpenCLDeviceSearchThreadInfo@@PADNNNIPAVchild@windows@process@boost@@@Z PROC ; UpdateOpenCLDeviceStatus_ChildProcess, COMDAT
; _info$ = ecx
; _status$ = edx

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	mov	ebx, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
$LL8@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [ebx], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN7@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN22@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL8@UpdateOpen
$LN22@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL8@UpdateOpen
$LN7@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 561  : 	ASSERT(info->runChildProcess);

	cmp	DWORD PTR [edi+1072], 0
	jne	$LN3@UpdateOpen
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN3@UpdateOpen
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@UpdateOpen
	push	14					; 0000000eH
	push	OFFSET $SG4294899477
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899476
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN25@UpdateOpen
$LN2@UpdateOpen:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	561					; 00000231H
	push	OFFSET $SG4294899475
	push	OFFSET $SG4294899474
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN25@UpdateOpen:

; 561  : 	ASSERT(info->runChildProcess);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN93@UpdateOpen:
$LN3@UpdateOpen:

; 562  : 	strcpy(info->status, status);

	lea	ecx, DWORD PTR [edi+12]
	sub	ecx, esi
$LL6@UpdateOpen:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL6@UpdateOpen

; 563  : 	info->currentSpeed = currentSpeed;

	movsd	xmm0, QWORD PTR _currentSpeed$[ebp]

; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;

	mov	eax, DWORD PTR _numDiscardedTripcodes$[ebp]
	movsd	QWORD PTR [edi+1040], xmm0
	movsd	xmm0, QWORD PTR _averageSpeed$[ebp]
	movsd	QWORD PTR [edi+1048], xmm0
	movsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes$[ebp]
	mov	DWORD PTR [edi+1064], eax

; 567  : 	info->child_process = child_process;

	mov	eax, DWORD PTR _child_process$[ebp]
	movsd	QWORD PTR [edi+1056], xmm0
	mov	DWORD PTR [edi+1076], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [edi+1080], eax
	mov	DWORD PTR [edi+1084], edx

; 570  : }

	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 570  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@UpdateOpen:
?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPAUOpenCLDeviceSearchThreadInfo@@PADNNNIPAVchild@windows@process@boost@@@Z ENDP ; UpdateOpenCLDeviceStatus_ChildProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessInvalidTripcodePair@@YAXPAE0@Z
_TEXT	SEGMENT
?ProcessInvalidTripcodePair@@YAXPAE0@Z PROC		; ProcessInvalidTripcodePair, COMDAT
; _tripcode$ = ecx
; _key$ = edx

; 1509 : {

	push	ebx
	push	esi
	push	edi
	mov	ebx, edx
	mov	edi, ecx
	mov	esi, OFFSET ?process_tripcode_pair_spinlock@@3Vspinlock@@A ; process_tripcode_pair_spinlock
	npad	4
$LL29@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN28@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN43@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL29@ProcessInv
$LN43@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL29@ProcessInv
$LN28@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {

	cmp	DWORD PTR ?options@@3UOptions@@A+12, 0
	je	$LN25@ProcessInv
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	$LN25@ProcessInv
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN25@ProcessInv
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN25@ProcessInv

; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");

	push	OFFSET $SG4294899130
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR ?lenTripcode@@3HA, esi	; lenTripcode
	jle	SHORT $LN22@ProcessInv
	npad	8
$LL24@ProcessInv:

; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	push	OFFSET $SG4294899129
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL24@ProcessInv
$LN22@ProcessInv:

; 1519 : 		fprintf(tripcodeFile, "  ");

	push	OFFSET $SG4294899128
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	SHORT $LN19@ProcessInv
	npad	2
$LL21@ProcessInv:

; 1521 : 			fprintf(tripcodeFile, " ");

	push	OFFSET $SG4294899127
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL21@ProcessInv
$LN19@ProcessInv:

; 1522 : 		fprintf(tripcodeFile, " (");

	push	OFFSET $SG4294899126
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	add	esp, 8

; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, 0	; lenTripcodeKey
	jle	SHORT $LN16@ProcessInv

; 1522 : 		fprintf(tripcodeFile, " (");

	mov	esi, 1
	npad	3
$LL18@ProcessInv:

; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);

	movzx	eax, BYTE PTR [ebx+esi-1]
	push	eax
	push	OFFSET $SG4294899125
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1525 : 			if (i + 1 < lenTripcodeKey)

	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	jge	SHORT $LN17@ProcessInv

; 1526 : 				fprintf(tripcodeFile, " ");

	push	OFFSET $SG4294899124
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 8
$LN17@ProcessInv:

; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, ecx
	jl	SHORT $LL18@ProcessInv
$LN16@ProcessInv:

; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");

	push	OFFSET $SG4294899123
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1529 : 		fflush(tripcodeFile);

	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fflush

; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");

	push	OFFSET $SG4294899122
	call	_printf

; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	xor	esi, esi
	add	esp, 16					; 00000010H
	cmp	DWORD PTR ?lenTripcode@@3HA, esi	; lenTripcode
	jle	SHORT $LN12@ProcessInv
$LL14@ProcessInv:

; 1537 : 			printf("%c", tripcode[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	push	OFFSET $SG4294899121
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL14@ProcessInv
$LN12@ProcessInv:

; 1538 : 		printf("  ");

	push	OFFSET $SG4294899120
	call	_printf

; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	xor	esi, esi
	add	esp, 4
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	SHORT $LN9@ProcessInv
	npad	8
$LL11@ProcessInv:

; 1540 : 			printf(" ");

	push	OFFSET $SG4294899119
	call	_printf
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL11@ProcessInv
$LN9@ProcessInv:

; 1541 : 		printf(" (");

	push	OFFSET $SG4294899118
	call	_printf
	add	esp, 4

; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, 0	; lenTripcodeKey
	jle	SHORT $LN6@ProcessInv

; 1541 : 		printf(" (");

	mov	esi, 1
$LL8@ProcessInv:

; 1543 : 			printf("%02X", key[i]);

	movzx	eax, BYTE PTR [esi+ebx-1]
	push	eax
	push	OFFSET $SG4294899117
	call	_printf

; 1544 : 			if (i + 1 < lenTripcodeKey)

	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 8
	cmp	esi, ecx
	jge	SHORT $LN7@ProcessInv

; 1545 : 				printf(" ");

	push	OFFSET $SG4294899116
	call	_printf
	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 4
$LN7@ProcessInv:

; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, ecx
	jl	SHORT $LL8@ProcessInv
$LN6@ProcessInv:

; 1546 : 		}
; 1547 : 		printf(")");

	push	OFFSET $SG4294899115
	call	_printf

; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 4
	mov	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	eax, 2
	lea	eax, DWORD PTR [ecx+eax*4]

; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {

	cmp	eax, 79					; 0000004fH
	jge	SHORT $LN2@ProcessInv

; 1546 : 		}
; 1547 : 		printf(")");

	mov	esi, 79					; 0000004fH
	sub	esi, eax
$LL4@ProcessInv:

; 1551 : 			printf(" ");

	push	OFFSET $SG4294899114
	call	_printf
	add	esp, 4
	dec	esi
	jne	SHORT $LL4@ProcessInv
$LN2@ProcessInv:

; 1552 : 		}
; 1553 : 		printf("\n");

	push	OFFSET $SG4294899113
	call	_printf

; 1554 : 		fflush(stdout);

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 8
$LN25@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, 0 ; process_tripcode_pair_spinlock
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	npad	3
$LL71@ProcessInv:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN70@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN85@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL71@ProcessInv
$LN85@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL71@ProcessInv
$LN70@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1559 : 	++numDiscardedTripcodes;

	inc	DWORD PTR ?numDiscardedTripcodes@@3IA	; numDiscardedTripcodes

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	cmp	DWORD PTR ?options@@3UOptions@@A+12, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	je	SHORT $LN1@ProcessInv
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	SHORT $LN1@ProcessInv
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN1@ProcessInv
$LL115@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN114@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN129@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL115@ProcessInv
$LN129@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL115@ProcessInv
$LN114@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	test	eax, eax
	jne	SHORT $LN1@ProcessInv

; 1564 : }

	pop	edi
	pop	esi
	pop	ebx

; 1563 : 		PrintStatus();

	jmp	?PrintStatus@@YAXXZ			; PrintStatus
$LN1@ProcessInv:

; 1564 : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?ProcessInvalidTripcodePair@@YAXPAE0@Z ENDP		; ProcessInvalidTripcodePair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessValidTripcodePair@@YAXPAE0@Z
_TEXT	SEGMENT
?ProcessValidTripcodePair@@YAXPAE0@Z PROC		; ProcessValidTripcodePair, COMDAT
; _tripcode$ = ecx
; _key$ = edx

; 1430 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx

; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	edi, edx
	cmp	eax, 10					; 0000000aH
	je	$LN45@ProcessVal
	cmp	eax, 12					; 0000000cH
	je	$LN45@ProcessVal
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN45@ProcessVal
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN44@ProcessVal
	push	14					; 0000000eH
	push	OFFSET $SG4294899165
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899164
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN43@ProcessVal
$LN44@ProcessVal:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1431					; 00000597H
	push	OFFSET $SG4294899163
	push	OFFSET $SG4294899162
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN43@ProcessVal:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN320@ProcessVal:
$LN45@ProcessVal:

; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	cmp	eax, 10					; 0000000aH
	je	$LN304@ProcessVal
	cmp	eax, 12					; 0000000cH
	je	$LN304@ProcessVal
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN304@ProcessVal
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN41@ProcessVal
	push	14					; 0000000eH
	push	OFFSET $SG4294899161
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899160
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN40@ProcessVal
$LN41@ProcessVal:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1432					; 00000598H
	push	OFFSET $SG4294899159
	push	OFFSET $SG4294899158
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN40@ProcessVal:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN321@ProcessVal:
$LN304@ProcessVal:
	mov	esi, OFFSET ?process_tripcode_pair_spinlock@@3Vspinlock@@A ; process_tripcode_pair_spinlock
$LL49@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN48@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN63@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL49@ProcessVal
$LN63@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL49@ProcessVal
$LN48@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1435 : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	$LN264@ProcessVal

; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");

	push	OFFSET $SG4294899157
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR ?lenTripcode@@3HA, esi	; lenTripcode
	jle	SHORT $LN36@ProcessVal
$LL38@ProcessVal:

; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);

	movzx	eax, BYTE PTR [esi+ebx]
	push	eax
	push	OFFSET $SG4294899156
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL38@ProcessVal
$LN36@ProcessVal:

; 1443 : 		fprintf(tripcodeFile, " #");

	push	OFFSET $SG4294899155
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	SHORT $LN33@ProcessVal
$LL35@ProcessVal:

; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	push	OFFSET $SG4294899154
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL35@ProcessVal
$LN33@ProcessVal:

; 1446 : 		fprintf(tripcodeFile, " (");

	push	OFFSET $SG4294899153
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	add	esp, 8

; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, 0	; lenTripcodeKey
	jle	SHORT $LN30@ProcessVal

; 1446 : 		fprintf(tripcodeFile, " (");

	mov	esi, 1
	npad	10
$LL32@ProcessVal:

; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);

	movzx	eax, BYTE PTR [edi+esi-1]
	push	eax
	push	OFFSET $SG4294899152
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1449 : 			if (i + 1 < lenTripcodeKey)

	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	jge	SHORT $LN31@ProcessVal

; 1450 : 				fprintf(tripcodeFile, " ");

	push	OFFSET $SG4294899151
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf
	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 8
$LN31@ProcessVal:

; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, ecx
	jl	SHORT $LL32@ProcessVal
$LN30@ProcessVal:

; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");

	push	OFFSET $SG4294899150
	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fprintf

; 1453 : 		fflush(tripcodeFile);

	push	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A	; tripcodeFile
	call	_fflush
	add	esp, 12					; 0000000cH

; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	$LN264@ProcessVal
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN28@ProcessVal
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL69@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN68@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN83@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL69@ProcessVal
$LN83@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL69@ProcessVal
$LN68@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {

	test	eax, eax
	jne	$LN28@ProcessVal

; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");

	push	OFFSET $SG4294899149
	call	_printf

; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	xor	esi, esi
	add	esp, 4
	cmp	DWORD PTR ?lenTripcode@@3HA, esi	; lenTripcode
	jle	SHORT $LN25@ProcessVal
$LL27@ProcessVal:

; 1463 : 			printf("%c", tripcode[i]);

	movzx	eax, BYTE PTR [esi+ebx]
	push	eax
	push	OFFSET $SG4294899148
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL27@ProcessVal
$LN25@ProcessVal:

; 1464 : 		printf(" #");

	push	OFFSET $SG4294899147
	call	_printf

; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	xor	esi, esi
	add	esp, 4
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	SHORT $LN22@ProcessVal
	npad	8
$LL24@ProcessVal:

; 1466 : 			printf("%c", key[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	push	OFFSET $SG4294899146
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL24@ProcessVal
$LN22@ProcessVal:

; 1467 : 		printf(" (");

	push	OFFSET $SG4294899145
	call	_printf
	add	esp, 4

; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, 0	; lenTripcodeKey
	jle	SHORT $LN19@ProcessVal

; 1467 : 		printf(" (");

	mov	esi, 1
	npad	10
$LL21@ProcessVal:

; 1469 : 			printf("%02X", key[i]);

	movzx	eax, BYTE PTR [esi+edi-1]
	push	eax
	push	OFFSET $SG4294899144
	call	_printf

; 1470 : 			if (i + 1 < lenTripcodeKey)

	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 8
	cmp	esi, ecx
	jge	SHORT $LN20@ProcessVal

; 1471 : 				printf(" ");

	push	OFFSET $SG4294899143
	call	_printf
	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 4
$LN20@ProcessVal:

; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, ecx
	jl	SHORT $LL21@ProcessVal
$LN19@ProcessVal:

; 1472 : 		}
; 1473 : 		printf(")");

	push	OFFSET $SG4294899142
	call	_printf

; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 4
	mov	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	eax, 2
	lea	eax, DWORD PTR [ecx+eax*4]

; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {

	cmp	eax, 79					; 0000004fH
	jge	SHORT $LN15@ProcessVal

; 1472 : 		}
; 1473 : 		printf(")");

	mov	esi, 79					; 0000004fH
	sub	esi, eax
$LL17@ProcessVal:

; 1477 : 			printf(" ");

	push	OFFSET $SG4294899141
	call	_printf
	add	esp, 4
	dec	esi
	jne	SHORT $LL17@ProcessVal
$LN15@ProcessVal:

; 1478 : 		}
; 1479 : 		printf("\n");

	push	OFFSET $SG4294899140
	jmp	$LN318@ProcessVal
$LN28@ProcessVal:

; 1480 : 	} else if (options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN13@ProcessVal
$LN264@ProcessVal:

; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);

	push	159					; 0000009fH
	push	129					; 00000081H
	push	OFFSET $SG4294899139
	call	_printf

; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	xor	esi, esi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR ?lenTripcode@@3HA, esi	; lenTripcode
	jle	SHORT $LN10@ProcessVal
	npad	6
$LL12@ProcessVal:

; 1483 : 			printf("%c", tripcode[i]);

	movzx	eax, BYTE PTR [esi+ebx]
	push	eax
	push	OFFSET $SG4294899138
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL12@ProcessVal
$LN10@ProcessVal:

; 1484 : 		printf(",#");

	push	OFFSET $SG4294899137
	call	_printf

; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	xor	esi, esi
	add	esp, 4
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	SHORT $LN7@ProcessVal
$LL9@ProcessVal:

; 1486 : 			printf("%c", key[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	push	OFFSET $SG4294899136
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL9@ProcessVal
$LN7@ProcessVal:

; 1487 : 		printf(",(");

	push	OFFSET $SG4294899135
	call	_printf
	add	esp, 4

; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, 0	; lenTripcodeKey
	jle	SHORT $LN4@ProcessVal

; 1487 : 		printf(",(");

	mov	esi, 1
	npad	8
$LL6@ProcessVal:

; 1489 : 			printf("%02X", key[i]);

	movzx	eax, BYTE PTR [esi+edi-1]
	push	eax
	push	OFFSET $SG4294899134
	call	_printf

; 1490 : 			if (i + 1 < lenTripcodeKey)

	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 8
	cmp	esi, ecx
	jge	SHORT $LN5@ProcessVal

; 1491 : 				printf(" ");

	push	OFFSET $SG4294899133
	call	_printf
	mov	ecx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	esp, 4
$LN5@ProcessVal:

; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, ecx
	jl	SHORT $LL6@ProcessVal
$LN4@ProcessVal:

; 1492 : 		}
; 1493 : 		printf(")\n");

	push	OFFSET $SG4294899132
$LN318@ProcessVal:
	call	_printf
	add	esp, 4
$LN13@ProcessVal:

; 1494 : 	}
; 1495 : 	fflush(stdout);

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, 0 ; process_tripcode_pair_spinlock
$LL135@ProcessVal:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	mov	eax, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	lock	 bts	 DWORD PTR [eax], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN134@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN149@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL135@ProcessVal
$LN149@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL135@ProcessVal
$LN134@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1499 : 	++numValidTripcodes;

	inc	DWORD PTR ?numValidTripcodes@@3IA	; numValidTripcodes

; 1502 : 	if (!options.redirection)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1502 : 	if (!options.redirection)

	jne	SHORT $LN1@ProcessVal

; 1503 : 		PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus

; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	SHORT $LN1@ProcessVal
	cmp	DWORD PTR ?options@@3UOptions@@A+8, 0
	je	SHORT $LN1@ProcessVal

; 1505 : 		printf("\a");

	push	OFFSET $SG4294899131
	call	_printf
	add	esp, 4
$LN1@ProcessVal:

; 1506 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN319@ProcessVal:
?ProcessValidTripcodePair@@YAXPAE0@Z ENDP		; ProcessValidTripcodePair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$$V@std@@QAE@XZ
_TEXT	SEGMENT
??0?$tuple@$$$V@std@@QAE@XZ PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 136  : 		{	// default construct
; 137  : 		}

	mov	eax, ecx
	ret	0
??0?$tuple@$$$V@std@@QAE@XZ ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$tuple@$$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 145  : 		{	// copy construct
; 146  : 		}

	mov	eax, ecx
	ret	4
??0?$tuple@$$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
__Res$ = 8						; size = 4
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 31   : 	{	// throw exception on failure

	push	ebp
	mov	ebp, esp
	push	esi

; 32   : 	if (_Res != _Thrd_success)

	mov	esi, DWORD PTR __Res$[ebp]
	test	esi, esi
	je	SHORT $LN4@Check_C_re

; 33   : 		_Throw_C_error(_Res);

	push	esi
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
	add	esp, 4
$LN4@Check_C_re:

; 34   : 	return (_Res);

	mov	eax, esi
	pop	esi

; 35   : 	}

	pop	ebp
	ret	0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z
_TEXT	SEGMENT
__Thr$ = 8						; size = 8
?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z PROC		; std::_Thrd_detachX, COMDAT

; 52   : 	{	// throw exception on failure

	push	ebp
	mov	ebp, esp
	push	esi

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	push	DWORD PTR __Thr$[ebp+4]
	push	DWORD PTR __Thr$[ebp]
	call	__Thrd_detach
	mov	esi, eax
	add	esp, 8

; 32   : 	if (_Res != _Thrd_success)

	test	esi, esi
	je	SHORT $LN3@Thrd_detac

; 33   : 		_Throw_C_error(_Res);

	push	esi
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
	add	esp, 4

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	mov	eax, esi
$LN3@Thrd_detac:

; 54   : 	}

	pop	esi
	pop	ebp
	ret	0
?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z ENDP		; std::_Thrd_detachX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 58   : 
; 59   : 	thread(thread&& _Other) _NOEXCEPT
; 60   : 		: _Thr(_Other._Thr)
; 61   : 		{	// move from _Other
; 62   : 		_Thr_set_null(_Other._Thr);
; 63   : 		}
; 64   : 
; 65   : 	thread& operator=(thread&& _Other) _NOEXCEPT
; 66   : 		{	// move from _Other
; 67   : 		return (_Move_thread(_Other));
; 68   : 		}
; 69   : 
; 70   : 	thread(const thread&) = delete;
; 71   : 	thread& operator=(const thread&) = delete;
; 72   : 
; 73   : 	void swap(thread& _Other) _NOEXCEPT
; 74   : 		{	// swap with _Other
; 75   : 		_STD swap(_Thr, _Other._Thr);
; 76   : 		}
; 77   : 
; 78   : 	bool joinable() const _NOEXCEPT
; 79   : 		{	// return true if this thread can be joined
; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [ecx+4], 0

; 55   : 		if (joinable())

	jne	?terminate@@YAXXZ			; terminate

; 56   : 			_XSTD terminate();
; 57   : 		}

	ret	0
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?joinable@thread@std@@QBE_NXZ
_TEXT	SEGMENT
?joinable@thread@std@@QBE_NXZ PROC			; std::thread::joinable, COMDAT
; _this$ = ecx

; 80   : 		return (!_Thr_is_null(_Thr));

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	setne	al

; 81   : 		}

	ret	0
?joinable@thread@std@@QBE_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?detach@thread@std@@QAEXXZ
_TEXT	SEGMENT
?detach@thread@std@@QAEXXZ PROC				; std::thread::detach, COMDAT
; _this$ = ecx

; 86   : 		{	// detach thread

	push	esi
	mov	esi, ecx

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [esi+4], 0

; 87   : 		if (!joinable())

	jne	SHORT $LN1@detach

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	add	esp, 4
$LN1@detach:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	__Thrd_detach
	add	esp, 8

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN11@detach

; 33   : 		_Throw_C_error(_Res);

	push	eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
	add	esp, 4
$LN11@detach:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	DWORD PTR [esi+4], 0

; 91   : 		}

	pop	esi
	ret	0
?detach@thread@std@@QAEXXZ ENDP				; std::thread::detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?native_handle@thread@std@@QAEPAXXZ
_TEXT	SEGMENT
?native_handle@thread@std@@QAEPAXXZ PROC		; std::thread::native_handle, COMDAT
; _this$ = ecx

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR [ecx]

; 103  : 		}

	ret	0
?native_handle@thread@std@@QAEPAXXZ ENDP		; std::thread::native_handle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _posix_category, eax
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	call	?generic_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::generic_category
	mov	DWORD PTR _errno_ecat, eax
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	call	?system_category@system@boost@@YAABVerror_category@12@XZ ; boost::system::system_category
	mov	DWORD PTR _native_ecat, eax
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Enum_generated_tripcodes_spinlock@@YAXXZ
text$di	SEGMENT
??__Enum_generated_tripcodes_spinlock@@YAXXZ PROC	; `dynamic initializer for 'num_generated_tripcodes_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 152  : spinlock num_generated_tripcodes_spinlock;

	ret	0
??__Enum_generated_tripcodes_spinlock@@YAXXZ ENDP	; `dynamic initializer for 'num_generated_tripcodes_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eprocess_tripcode_pair_spinlock@@YAXXZ
text$di	SEGMENT
??__Eprocess_tripcode_pair_spinlock@@YAXXZ PROC		; `dynamic initializer for 'process_tripcode_pair_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?process_tripcode_pair_spinlock@@3Vspinlock@@A ; process_tripcode_pair_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 153  : spinlock process_tripcode_pair_spinlock;

	ret	0
??__Eprocess_tripcode_pair_spinlock@@YAXXZ ENDP		; `dynamic initializer for 'process_tripcode_pair_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Ecurrent_state_spinlock@@YAXXZ
text$di	SEGMENT
??__Ecurrent_state_spinlock@@YAXXZ PROC			; `dynamic initializer for 'current_state_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 154  : spinlock current_state_spinlock;

	ret	0
??__Ecurrent_state_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'current_state_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ
text$di	SEGMENT
??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ PROC ; `dynamic initializer for 'cuda_device_search_thread_info_array_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 155  : spinlock cuda_device_search_thread_info_array_spinlock;

	ret	0
??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ ENDP ; `dynamic initializer for 'cuda_device_search_thread_info_array_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ
text$di	SEGMENT
??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ PROC ; `dynamic initializer for 'opencl_device_search_thread_info_array_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 156  : spinlock opencl_device_search_thread_info_array_spinlock;

	ret	0
??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ ENDP ; `dynamic initializer for 'opencl_device_search_thread_info_array_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Esystem_command_spinlock@@YAXXZ
text$di	SEGMENT
??__Esystem_command_spinlock@@YAXXZ PROC		; `dynamic initializer for 'system_command_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?system_command_spinlock@@3Vspinlock@@A ; system_command_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 157  : spinlock system_command_spinlock;

	ret	0
??__Esystem_command_spinlock@@YAXXZ ENDP		; `dynamic initializer for 'system_command_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eboost_process_spinlock@@YAXXZ
text$di	SEGMENT
??__Eboost_process_spinlock@@YAXXZ PROC			; `dynamic initializer for 'boost_process_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	mov	ecx, OFFSET ?boost_process_spinlock@@3Vspinlock@@A ; boost_process_spinlock
	xchg	DWORD PTR [ecx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 158  : spinlock boost_process_spinlock;

	ret	0
??__Eboost_process_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'boost_process_spinlock''
text$di	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ReleaseResources@@YAXXZ
_TEXT	SEGMENT
?ReleaseResources@@YAXXZ PROC				; ReleaseResources, COMDAT

; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);

	mov	eax, DWORD PTR ?expandedPatternArray@@3PAUExpandedPattern@@A ; expandedPatternArray
	test	eax, eax
	je	SHORT $LN6@ReleaseRes
	push	eax
	call	_free
	add	esp, 4
	mov	DWORD PTR ?expandedPatternArray@@3PAUExpandedPattern@@A, 0 ; expandedPatternArray
$LN6@ReleaseRes:

; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);

	mov	eax, DWORD PTR ?tripcodeChunkArray@@3PAIA ; tripcodeChunkArray
	test	eax, eax
	je	SHORT $LN5@ReleaseRes
	push	eax
	call	_free
	add	esp, 4
	mov	DWORD PTR ?tripcodeChunkArray@@3PAIA, 0	; tripcodeChunkArray
$LN5@ReleaseRes:

; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);

	mov	eax, DWORD PTR ?regexPatternArray@@3PAURegexPattern@@A ; regexPatternArray
	test	eax, eax
	je	SHORT $LN4@ReleaseRes
	push	eax
	call	_free
	add	esp, 4
	mov	DWORD PTR ?regexPatternArray@@3PAURegexPattern@@A, 0 ; regexPatternArray
$LN4@ReleaseRes:

; 238  : 	if (tripcodeFile) {

	mov	eax, DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A ; tripcodeFile
	test	eax, eax
	je	SHORT $LN2@ReleaseRes

; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);

	push	eax
	call	_fclose
	add	esp, 4
	mov	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A, 0 ; tripcodeFile
$LN2@ReleaseRes:

; 240  : 	}
; 241  : 	if (eventForTerminating) {

	mov	eax, DWORD PTR ?eventForTerminating@@3PAXA ; eventForTerminating
	test	eax, eax
	je	SHORT $LN1@ReleaseRes

; 242  : 		CloseHandle(eventForTerminating);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 243  : 		eventForTerminating = NULL;

	mov	DWORD PTR ?eventForTerminating@@3PAXA, 0 ; eventForTerminating
$LN1@ReleaseRes:

; 244  : 	}
; 245  : }

	ret	0
?ReleaseResources@@YAXXZ ENDP				; ReleaseResources
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?hide_cursor@@YAXXZ
_TEXT	SEGMENT
_info$ = -8						; size = 8
?hide_cursor@@YAXXZ PROC				; hide_cursor, COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	lea	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _info$[ebp+4], 0
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hide_cursor@@YAXXZ ENDP				; hide_cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CreateKey8AndKey9@@YAXPAE@Z
_TEXT	SEGMENT
_info$1 = -8						; size = 8
_randomValue$2 = -4					; size = 4
_randomValue$3 = -4					; size = 4
_randomValue$4 = -4					; size = 4
_randomValue$5 = -4					; size = 4
_randomValue$6 = -4					; size = 4
_randomValue$7 = -4					; size = 4
_key$ = 8						; size = 4
?CreateKey8AndKey9@@YAXPAE@Z PROC			; CreateKey8AndKey9, COMDAT

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 309  : 	ASSERT(lenTripcode == 10);

	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode, 0000000aH
	je	$LN12@CreateKey8
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN12@CreateKey8
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN11@CreateKey8
	push	14					; 0000000eH
	push	OFFSET $SG4294899502
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	push	14					; 0000000eH
	push	OFFSET $SG4294899501
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN25@CreateKey8
$LN11@CreateKey8:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	push	309					; 00000135H
	push	OFFSET $SG4294899500
	push	OFFSET $SG4294899499
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$1[ebp]
	mov	DWORD PTR _info$1[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$1[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN25@CreateKey8:

; 309  : 	ASSERT(lenTripcode == 10);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN49@CreateKey8:
$LN12@CreateKey8:

; 310  : 	if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	push	esi
	je	SHORT $LN9@CreateKey8

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$7[ebp]
	push	eax
	call	_rand_s

; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];

	movzx	eax, BYTE PTR _randomValue$7[ebp]
	mov	esi, DWORD PTR _key$[ebp]
	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax]
$LN47@CreateKey8:
	mov	BYTE PTR [esi+8], al

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$6[ebp]
	push	eax
	call	_rand_s

; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];

	movzx	eax, BYTE PTR _randomValue$6[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 8

; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];

	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax]

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	mov	BYTE PTR [esi+9], al
	pop	esi

; 330  : 		}
; 331  : 	}
; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@CreateKey8:

; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {

	mov	esi, DWORD PTR _key$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	npad	6
$LL7@CreateKey8:

; 316  : 			if (!isSecondByte) {

	test	eax, eax
	jne	SHORT $LN4@CreateKey8

; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);

	mov	al, BYTE PTR [ecx+esi]
	cmp	al, 129					; 00000081H
	jb	SHORT $LN15@CreateKey8
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN17@CreateKey8
$LN15@CreateKey8:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN16@CreateKey8
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN17@CreateKey8
$LN16@CreateKey8:
	cmp	al, 224					; 000000e0H
	jb	SHORT $LN4@CreateKey8
	cmp	al, 234					; 000000eaH
	ja	SHORT $LN4@CreateKey8
$LN17@CreateKey8:
	mov	eax, 1
	jmp	SHORT $LN6@CreateKey8
$LN4@CreateKey8:

; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;

	xor	eax, eax
$LN6@CreateKey8:

; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {

	inc	ecx
	cmp	ecx, 8
	jl	SHORT $LL7@CreateKey8

; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {

	test	eax, eax

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$5[ebp]
	push	eax

; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {

	je	SHORT $LN2@CreateKey8

; 229  : 	rand_s(&randomValue);

	call	_rand_s

; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];

	movzx	eax, BYTE PTR _randomValue$5[ebp]
	movzx	eax, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[eax]

; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {

	jmp	SHORT $LN47@CreateKey8
$LN2@CreateKey8:

; 229  : 	rand_s(&randomValue);

	call	_rand_s

; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];

	movzx	eax, BYTE PTR _randomValue$4[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];

	mov	al, BYTE PTR ?keyCharTable_FirstByte@@3PAEA[eax]
	mov	BYTE PTR [esi+8], al

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	cmp	al, 129					; 00000081H
	jb	SHORT $LN20@CreateKey8
	cmp	al, 132					; 00000084H
	jbe	SHORT $LN22@CreateKey8
$LN20@CreateKey8:
	cmp	al, 136					; 00000088H
	jb	SHORT $LN21@CreateKey8
	cmp	al, 159					; 0000009fH
	jbe	SHORT $LN22@CreateKey8
$LN21@CreateKey8:
	cmp	al, 224					; 000000e0H
	jb	SHORT $LN23@CreateKey8
	cmp	al, 234					; 000000eaH
	ja	SHORT $LN23@CreateKey8
$LN22@CreateKey8:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$2[ebp]
	push	eax
	call	_rand_s

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	movzx	eax, BYTE PTR _randomValue$2[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	mov	al, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[eax]
	mov	BYTE PTR [esi+9], al
	pop	esi

; 330  : 		}
; 331  : 	}
; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@CreateKey8:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$3[ebp]
	push	eax
	call	_rand_s

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	movzx	eax, BYTE PTR _randomValue$3[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	mov	al, BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax]
	mov	BYTE PTR [esi+9], al
	pop	esi

; 330  : 		}
; 331  : 	}
; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@CreateKey8:
?CreateKey8AndKey9@@YAXPAE@Z ENDP			; CreateKey8AndKey9
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CreateCharacterTables@@YAXXZ
_TEXT	SEGMENT
_randomValue$1 = -4					; size = 4
_randomValue$2 = -4					; size = 4
_randomValue$3 = -4					; size = 4
_randomValue$4 = -4					; size = 4
_randomValue$5 = -4					; size = 4
?CreateCharacterTables@@YAXXZ PROC			; CreateCharacterTables, COMDAT

; 412  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+84, 0
	mov	DWORD PTR ?numOneByte@@3HA, 0		; numOneByte
	mov	DWORD PTR ?numSecondByte@@3HA, 0	; numSecondByte
	mov	DWORD PTR ?numFirstByte@@3HA, 0		; numFirstByte
	je	$LL112@CreateChar
	npad	1
$LL129@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$5[ebp]
	push	eax
	call	_rand_s

; 428  : 		do {
; 429  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR _randomValue$5[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));

	cmp	cl, 33					; 00000021H
	je	SHORT $LN126@CreateChar
	cmp	cl, 36					; 00000024H
	je	SHORT $LN126@CreateChar
	cmp	cl, 39					; 00000027H
	jb	SHORT $LN125@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN126@CreateChar
$LN125@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN124@CreateChar
	cmp	cl, 59					; 0000003bH
	jbe	SHORT $LN126@CreateChar
$LN124@CreateChar:
	cmp	cl, 61					; 0000003dH
	jb	SHORT $LN123@CreateChar
	jbe	SHORT $LN126@CreateChar
$LN123@CreateChar:
	lea	eax, DWORD PTR [ecx-63]
	cmp	al, 63					; 0000003fH
	ja	SHORT $LL129@CreateChar
$LN126@CreateChar:

; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	eax, eax
	npad	3
$LL243@CreateChar:

; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))

	cmp	cl, 33					; 00000021H
	je	SHORT $LN405@CreateChar
$LL244@CreateChar:
	cmp	cl, 36					; 00000024H
	je	SHORT $LN405@CreateChar
	cmp	cl, 39					; 00000027H
	jb	SHORT $LN245@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN405@CreateChar
$LN245@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN246@CreateChar
	cmp	cl, 59					; 0000003bH
	jbe	SHORT $LN405@CreateChar
$LN246@CreateChar:
	cmp	cl, 61					; 0000003dH
	jb	SHORT $LN247@CreateChar
	jbe	SHORT $LN405@CreateChar
$LN247@CreateChar:
	cmp	cl, 63					; 0000003fH
	jb	SHORT $LN248@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN405@CreateChar
$LN248@CreateChar:

; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	cmp	cl, 33					; 00000021H
	jne	SHORT $LL244@CreateChar
$LN405@CreateChar:

; 435  : 			keyCharTable_OneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax], cl
	inc	eax
	cmp	eax, 512				; 00000200H
	jl	SHORT $LL243@CreateChar

; 436  : 		}

	jmp	SHORT $LN103@CreateChar
	npad	8
$LL112@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$4[ebp]
	push	eax
	call	_rand_s

; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR _randomValue$4[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));

	cmp	cl, 33					; 00000021H
	jb	SHORT $LN108@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN109@CreateChar
$LN108@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN107@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN109@CreateChar
$LN107@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN106@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN109@CreateChar
$LN106@CreateChar:
	lea	eax, DWORD PTR [ecx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL112@CreateChar
$LN109@CreateChar:

; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	eax, eax
$LL251@CreateChar:

; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))

	cmp	cl, 33					; 00000021H
	jb	SHORT $LN253@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN257@CreateChar
$LN253@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN254@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN257@CreateChar
$LN254@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN255@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN257@CreateChar
$LN255@CreateChar:
	cmp	cl, 161					; 000000a1H
	jb	SHORT $LL251@CreateChar
	cmp	cl, 223					; 000000dfH
	ja	SHORT $LL251@CreateChar
$LN257@CreateChar:

; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_OneByte@@3PAEA[eax], cl
	inc	eax
	cmp	eax, 512				; 00000200H
	jl	SHORT $LL251@CreateChar
$LN103@CreateChar:

; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+84, 0
	push	esi
	push	edi
	je	SHORT $LN96@CreateChar

; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	ecx, ecx
	npad	5
$LL259@CreateChar:

; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];

	mov	al, BYTE PTR ?keyCharTable_OneByte@@3PAEA[ecx]
	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[ecx], al

; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[ecx], al

; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[ecx], al
	inc	ecx
	cmp	ecx, 512				; 00000200H
	jl	SHORT $LL259@CreateChar

; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	edx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	xor	ecx, ecx
	mov	esi, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	edi, DWORD PTR ?numOneByte@@3HA		; numOneByte
$LL92@CreateChar:

; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {

	cmp	ecx, 33					; 00000021H
	je	SHORT $LN88@CreateChar
	cmp	ecx, 36					; 00000024H
	je	SHORT $LN88@CreateChar
	cmp	ecx, 39					; 00000027H
	jl	SHORT $LN87@CreateChar
	cmp	ecx, 42					; 0000002aH
	jle	SHORT $LN88@CreateChar
$LN87@CreateChar:
	cmp	ecx, 45					; 0000002dH
	jl	SHORT $LN86@CreateChar
	cmp	ecx, 59					; 0000003bH
	jle	SHORT $LN88@CreateChar
$LN86@CreateChar:
	cmp	ecx, 61					; 0000003dH
	jl	SHORT $LN85@CreateChar
	jle	SHORT $LN88@CreateChar
$LN85@CreateChar:
	lea	eax, DWORD PTR [ecx-63]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN91@CreateChar
$LN88@CreateChar:

; 458  : 				++numFirstByte;

	inc	edx

; 459  : 				++numSecondByte;

	inc	esi

; 460  : 				++numOneByte;

	inc	edi
$LN91@CreateChar:

; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ecx
	cmp	ecx, 256				; 00000100H
	jl	SHORT $LL92@CreateChar

; 461  : 			}
; 462  : 		}

	jmp	$LN423@CreateChar
$LN96@CreateChar:

; 463  : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	je	SHORT $LL70@CreateChar

; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	ecx, ecx
	npad	2
$LL261@CreateChar:

; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];

	mov	al, BYTE PTR ?keyCharTable_OneByte@@3PAEA[ecx]
	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[ecx], al

; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[ecx], al

; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[ecx], al
	inc	ecx
	cmp	ecx, 512				; 00000200H
	jl	SHORT $LL261@CreateChar

; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	edx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	xor	ecx, ecx
	mov	esi, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	edi, DWORD PTR ?numOneByte@@3HA		; numOneByte
$LL79@CreateChar:

; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {

	cmp	ecx, 33					; 00000021H
	jl	SHORT $LN74@CreateChar
	cmp	ecx, 36					; 00000024H
	jle	SHORT $LN75@CreateChar
$LN74@CreateChar:
	cmp	ecx, 38					; 00000026H
	jl	SHORT $LN73@CreateChar
	cmp	ecx, 42					; 0000002aH
	jle	SHORT $LN75@CreateChar
$LN73@CreateChar:
	cmp	ecx, 45					; 0000002dH
	jl	SHORT $LN72@CreateChar
	cmp	ecx, 126				; 0000007eH
	jle	SHORT $LN75@CreateChar
$LN72@CreateChar:
	lea	eax, DWORD PTR [ecx-161]
	cmp	eax, 62					; 0000003eH
	ja	SHORT $LN78@CreateChar
$LN75@CreateChar:

; 471  : 				++numFirstByte;

	inc	edx

; 472  : 				++numSecondByte;

	inc	esi

; 473  : 				++numOneByte;

	inc	edi
$LN78@CreateChar:

; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ecx
	cmp	ecx, 256				; 00000100H
	jl	SHORT $LL79@CreateChar

; 474  : 			}
; 475  : 		}

	jmp	$LN423@CreateChar
	npad	1
$LL70@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$3[ebp]
	push	eax
	call	_rand_s

; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR _randomValue$3[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));

	mov	edx, DWORD PTR ?options@@3UOptions@@A+88
	cmp	cl, 33					; 00000021H
	jb	SHORT $LN66@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN67@CreateChar
$LN66@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN65@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN67@CreateChar
$LN65@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN64@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN67@CreateChar
$LN64@CreateChar:
	cmp	cl, 161					; 000000a1H
	jb	SHORT $LN63@CreateChar
	cmp	cl, 223					; 000000dfH
	jbe	SHORT $LN67@CreateChar
$LN63@CreateChar:

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN140@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	cl, 129					; 00000081H
	jb	SHORT $LN143@CreateChar
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN67@CreateChar
$LN143@CreateChar:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN144@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN67@CreateChar
$LN144@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN424@CreateChar
$LN140@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	cl, 137					; 00000089H
	jb	SHORT $LN148@CreateChar
	cmp	cl, 151					; 00000097H
	jbe	SHORT $LN67@CreateChar
$LN148@CreateChar:
	cmp	cl, 153					; 00000099H
	jb	SHORT $LN149@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN67@CreateChar
$LN149@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 9
$LN424@CreateChar:
	ja	SHORT $LL70@CreateChar
$LN67@CreateChar:

; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	esi, esi
	npad	7
$LL62@CreateChar:

; 482  : 			keyCharTable_FirstByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[esi], cl
$LL59@CreateChar:

; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));

	cmp	cl, 33					; 00000021H
	jb	SHORT $LN55@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN56@CreateChar
$LN55@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN54@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN56@CreateChar
$LN54@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN53@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN56@CreateChar
$LN53@CreateChar:
	cmp	cl, 161					; 000000a1H
	jb	SHORT $LN52@CreateChar
	cmp	cl, 223					; 000000dfH
	jbe	SHORT $LN56@CreateChar
$LN52@CreateChar:

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN154@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	cl, 129					; 00000081H
	jb	SHORT $LN157@CreateChar
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN56@CreateChar
$LN157@CreateChar:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN158@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN56@CreateChar
$LN158@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN425@CreateChar
$LN154@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	cl, 137					; 00000089H
	jb	SHORT $LN162@CreateChar
	cmp	cl, 151					; 00000097H
	jbe	SHORT $LN56@CreateChar
$LN162@CreateChar:
	cmp	cl, 153					; 00000099H
	jb	SHORT $LN163@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN56@CreateChar
$LN163@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 9
$LN425@CreateChar:
	ja	SHORT $LL59@CreateChar
$LN56@CreateChar:

; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	esi
	cmp	esi, 512				; 00000200H
	jl	SHORT $LL62@CreateChar
$LL51@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$2[ebp]
	push	eax
	call	_rand_s

; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR _randomValue$2[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));

	cmp	cl, 64					; 00000040H
	jb	SHORT $LN47@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN48@CreateChar
$LN47@CreateChar:
	lea	eax, DWORD PTR [ecx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL51@CreateChar
$LN48@CreateChar:

; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	edx, edx
$LL263@CreateChar:

; 493  : 			keyCharTable_SecondByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[edx], cl
	npad	5
$LL264@CreateChar:

; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));

	cmp	cl, 64					; 00000040H
	jb	SHORT $LN265@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN266@CreateChar
$LN265@CreateChar:
	lea	eax, DWORD PTR [ecx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL264@CreateChar
$LN266@CreateChar:

; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	edx
	cmp	edx, 512				; 00000200H
	jl	SHORT $LL263@CreateChar
	npad	4
$LL38@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	eax, DWORD PTR _randomValue$1[ebp]
	push	eax
	call	_rand_s

; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR _randomValue$1[ebp]

; 229  : 	rand_s(&randomValue);

	add	esp, 4

; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));

	cmp	cl, 64					; 00000040H
	jb	SHORT $LN34@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN35@CreateChar
$LN34@CreateChar:
	lea	eax, DWORD PTR [ecx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL38@CreateChar
$LN35@CreateChar:
	cmp	cl, 33					; 00000021H
	jb	SHORT $LN32@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN33@CreateChar
$LN32@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN31@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN33@CreateChar
$LN31@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN30@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN33@CreateChar
$LN30@CreateChar:
	lea	eax, DWORD PTR [ecx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL38@CreateChar
$LN33@CreateChar:

; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	xor	edx, edx
	npad	9
$LL268@CreateChar:

; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[edx], cl
$LL269@CreateChar:

; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));

	cmp	cl, 64					; 00000040H
	jb	SHORT $LN270@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN271@CreateChar
$LN270@CreateChar:
	lea	eax, DWORD PTR [ecx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL269@CreateChar
$LN271@CreateChar:
	cmp	cl, 33					; 00000021H
	jb	SHORT $LN272@CreateChar
	cmp	cl, 36					; 00000024H
	jbe	SHORT $LN275@CreateChar
$LN272@CreateChar:
	cmp	cl, 38					; 00000026H
	jb	SHORT $LN273@CreateChar
	cmp	cl, 42					; 0000002aH
	jbe	SHORT $LN275@CreateChar
$LN273@CreateChar:
	cmp	cl, 45					; 0000002dH
	jb	SHORT $LN274@CreateChar
	cmp	cl, 126					; 0000007eH
	jbe	SHORT $LN275@CreateChar
$LN274@CreateChar:
	lea	eax, DWORD PTR [ecx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL269@CreateChar
$LN275@CreateChar:

; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	edx
	cmp	edx, 512				; 00000200H
	jl	SHORT $LL268@CreateChar

; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	edx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	xor	ecx, ecx
	mov	esi, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	edi, DWORD PTR ?numOneByte@@3HA		; numOneByte
	push	ebx
	mov	ebx, DWORD PTR ?options@@3UOptions@@A+88
$LL17@CreateChar:

; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;

	cmp	ecx, 33					; 00000021H
	jl	SHORT $LN12@CreateChar
	cmp	ecx, 36					; 00000024H
	jle	SHORT $LN13@CreateChar
$LN12@CreateChar:
	cmp	ecx, 38					; 00000026H
	jl	SHORT $LN11@CreateChar
	cmp	ecx, 42					; 0000002aH
	jle	SHORT $LN13@CreateChar
$LN11@CreateChar:
	cmp	ecx, 45					; 0000002dH
	jl	SHORT $LN10@CreateChar
	cmp	ecx, 126				; 0000007eH
	jle	SHORT $LN13@CreateChar
$LN10@CreateChar:
	cmp	ecx, 161				; 000000a1H
	jl	SHORT $LN9@CreateChar
	cmp	ecx, 223				; 000000dfH
	jle	SHORT $LN13@CreateChar
$LN9@CreateChar:

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	ebx, ebx
	je	SHORT $LN172@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	cmp	cl, 129					; 00000081H
	jb	SHORT $LN175@CreateChar
	cmp	cl, 132					; 00000084H
	jbe	SHORT $LN13@CreateChar
$LN175@CreateChar:
	cmp	cl, 136					; 00000088H
	jb	SHORT $LN176@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN13@CreateChar
$LN176@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 10					; 0000000aH
	jmp	SHORT $LN426@CreateChar
$LN172@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	cmp	cl, 137					; 00000089H
	jb	SHORT $LN180@CreateChar
	cmp	cl, 151					; 00000097H
	jbe	SHORT $LN13@CreateChar
$LN180@CreateChar:
	cmp	cl, 153					; 00000099H
	jb	SHORT $LN181@CreateChar
	cmp	cl, 159					; 0000009fH
	jbe	SHORT $LN13@CreateChar
$LN181@CreateChar:
	lea	eax, DWORD PTR [ecx+32]
	cmp	al, 9
$LN426@CreateChar:
	ja	SHORT $LN14@CreateChar
$LN13@CreateChar:

; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;

	inc	edx
$LN14@CreateChar:

; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;

	cmp	ecx, 64					; 00000040H
	jl	SHORT $LN6@CreateChar
	cmp	ecx, 126				; 0000007eH
	jle	SHORT $LN7@CreateChar
$LN6@CreateChar:
	lea	eax, DWORD PTR [ecx-129]
	cmp	eax, 123				; 0000007bH
	ja	SHORT $LN8@CreateChar
$LN7@CreateChar:
	inc	esi
$LN8@CreateChar:

; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;

	cmp	ecx, 33					; 00000021H
	jl	SHORT $LN3@CreateChar
	cmp	ecx, 36					; 00000024H
	jle	SHORT $LN4@CreateChar
$LN3@CreateChar:
	cmp	ecx, 38					; 00000026H
	jl	SHORT $LN2@CreateChar
	cmp	ecx, 42					; 0000002aH
	jle	SHORT $LN4@CreateChar
$LN2@CreateChar:
	cmp	ecx, 45					; 0000002dH
	jl	SHORT $LN1@CreateChar
	cmp	ecx, 126				; 0000007eH
	jle	SHORT $LN4@CreateChar
$LN1@CreateChar:
	lea	eax, DWORD PTR [ecx-161]
	cmp	eax, 62					; 0000003eH
	ja	SHORT $LN16@CreateChar
$LN4@CreateChar:
	inc	edi
$LN16@CreateChar:

; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ecx
	cmp	ecx, 256				; 00000100H
	jl	$LL17@CreateChar
	pop	ebx
$LN423@CreateChar:

; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;

	mov	DWORD PTR ?numOneByte@@3HA, edi		; numOneByte
	pop	edi
	mov	DWORD PTR ?numSecondByte@@3HA, esi	; numSecondByte
	mov	DWORD PTR ?numFirstByte@@3HA, edx	; numFirstByte
	pop	esi

; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCharacterTables@@YAXXZ ENDP			; CreateCharacterTables
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?DisplayCopyrights@@YAXXZ
_TEXT	SEGMENT
?DisplayCopyrights@@YAXXZ PROC				; DisplayCopyrights, COMDAT

; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);

	push	OFFSET $SG4294899491
	push	OFFSET $SG4294899490
	call	_printf

; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);

	push	OFFSET $SG4294899489
	push	OFFSET $SG4294899488
	push	OFFSET $SG4294899487
	call	_printf

; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");

	push	OFFSET $SG4294899486
	call	_printf

; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");

	push	OFFSET $SG4294899485
	call	_printf

; 536  :     printf("This is free software, and you are welcome to redistribute it\n");

	push	OFFSET $SG4294899484
	call	_printf

; 537  :     printf("under certain conditions.\n");

	push	OFFSET $SG4294899483
	call	_printf

; 538  :     printf("\n");

	push	OFFSET $SG4294899482
	call	_printf
	add	esp, 40					; 00000028H

; 539  : }

	ret	0
?DisplayCopyrights@@YAXXZ ENDP				; DisplayCopyrights
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateCUDADeviceStatus@@YAXPAUCUDADeviceSearchThreadInfo@@PAD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_info$ = 8						; size = 4
_status$ = 12						; size = 4
?UpdateCUDADeviceStatus@@YAXPAUCUDADeviceSearchThreadInfo@@PAD@Z PROC ; UpdateCUDADeviceStatus, COMDAT

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, OFFSET ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
	npad	4
$LL5@UpdateCUDA:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN4@UpdateCUDA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN19@UpdateCUDA

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@UpdateCUDA
$LN19@UpdateCUDA:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@UpdateCUDA
$LN4@UpdateCUDA:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 544  : 	strcpy(info->status, status);

	mov	esi, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _status$[ebp]
	lea	edx, DWORD PTR [esi+604]
	sub	edx, eax
$LL3@UpdateCUDA:
	mov	cl, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	mov	BYTE PTR [edx+eax-1], cl
	test	cl, cl
	jne	SHORT $LL3@UpdateCUDA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [esi+1632], eax
	mov	DWORD PTR [esi+1636], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 547  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCUDADeviceStatus@@YAXPAUCUDADeviceSearchThreadInfo@@PAD@Z ENDP ; UpdateCUDADeviceStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CheckSearchThreads@@YAXXZ
_TEXT	SEGMENT
__Launcher$2 = -152					; size = 24
$T3 = -128						; size = 8
__Launcher$4 = -120					; size = 24
__real@0000000000000000$1$ = -96			; size = 8
$T5 = -88						; size = 8
$T6 = -80						; size = 8
$T7 = -72						; size = 8
_deltaTime$8 = -72					; size = 8
_info$9 = -64						; size = 8
_deltaTime$10 = -56					; size = 8
_native_handle$1$ = -52					; size = 4
_native_handle$1$ = -52					; size = 4
$T11 = -52						; size = 4
$T12 = -52						; size = 4
_this$1$ = -48						; size = 4
tv934 = -48						; size = 4
_index$1$ = -44						; size = 4
_index$1$ = -44						; size = 4
_cursorPos$13 = -44					; size = 4
_scrnBufInfo$14 = -40					; size = 22
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CheckSearchThreads@@YAXXZ PROC				; CheckSearchThreads, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckSearchThreads@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, OFFSET ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
$LL25@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN24@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN39@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL25@CheckSearc
$LN39@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL25@CheckSearc
$LN24@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {

	xor	esi, esi
	mov	DWORD PTR _index$1$[ebp], esi
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, esi ; numCUDADeviceSearchThreads
	jle	$LN428@CheckSearc
	xor	edi, edi
	mov	DWORD PTR tv934[ebp], edi
$LL11@CheckSearc:

; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];

	mov	ebx, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T3[ebp], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sub	eax, DWORD PTR [edi+ebx+1632]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T3[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sbb	edx, DWORD PTR [edi+ebx+1636]
	mov	DWORD PTR _deltaTime$8[ebp+4], edx

; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {

	jne	SHORT $LN430@CheckSearc
	cmp	eax, 60000				; 0000ea60H
	jbe	$LN10@CheckSearc
$LN430@CheckSearc:

; 584  : 			strcpy(info->status, "Restarting search thread...");

	movdqu	xmm0, XMMWORD PTR $SG4294899473
	movdqu	XMMWORD PTR [edi+ebx+604], xmm0
	movq	xmm0, QWORD PTR $SG4294899473+16
	movq	QWORD PTR [edi+ebx+620], xmm0
	mov	eax, DWORD PTR $SG4294899473+24
	mov	DWORD PTR [edi+ebx+628], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
	mov	ebx, DWORD PTR [eax+esi*4]

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [ebx+4], 0

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _native_handle$1$[ebp], eax

; 81   : 		}
; 82   : 
; 83   : 	void join();
; 84   : 
; 85   : 	void detach()
; 86   : 		{	// detach thread
; 87   : 		if (!joinable())

	jne	SHORT $LN78@CheckSearc

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	add	esp, 4
$LN78@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	__Thrd_detach
	add	esp, 8

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN85@CheckSearc

; 33   : 		_Throw_C_error(_Res);

	push	eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
	add	esp, 4
$LN85@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 587  : 			delete cuda_device_search_threads[index];

	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	DWORD PTR [ebx+4], 0
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 587  : 			delete cuda_device_search_threads[index];

	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN88@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [eax+4], 0

; 55   : 		if (joinable())

	jne	$LN407@CheckSearc
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 589  : 			TerminateThread(native_handle, 0);

	push	0
	push	DWORD PTR _native_handle$1$[ebp]
	call	DWORD PTR __imp__TerminateThread@8

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T12[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	SHORT $LN16@CheckSearc
	add	edi, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$4[ebp]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode, 0000000aH
	mov	eax, OFFSET ?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice
	mov	esi, OFFSET ?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnCUDADevice
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR $T6[ebp+4], edi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	cmove	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	DWORD PTR $T6[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$4[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$4[ebp+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$4[ebp+20], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	ebx
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	mov	esi, DWORD PTR _index$1$[ebp]
	mov	edi, DWORD PTR tv934[ebp]
	jmp	SHORT $LN17@CheckSearc
$LN16@CheckSearc:
	xor	ebx, ebx
$LN17@CheckSearc:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
	mov	DWORD PTR [eax+esi*4], ebx
$LN10@CheckSearc:

; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {

	inc	esi
	add	edi, 1640				; 00000668H
	mov	DWORD PTR _index$1$[ebp], esi
	mov	DWORD PTR tv934[ebp], edi
	cmp	esi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	$LL11@CheckSearc
$LN428@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
	mov	esi, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
$LL189@CheckSearc:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN188@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN203@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL189@CheckSearc
$LN407@CheckSearc:

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
$LN435@CheckSearc:
$LN203@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL189@CheckSearc
$LN188@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {

	xor	edi, edi
	mov	DWORD PTR _index$1$[ebp], edi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, edi ; numOpenCLDeviceSearchThreads
	jle	$LN429@CheckSearc
	xorps	xmm0, xmm0
	xor	ebx, ebx
	movsd	QWORD PTR __real@0000000000000000$1$[ebp], xmm0
	npad	1
$LL7@CheckSearc:

; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];

	mov	esi, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T5[ebp], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sub	eax, DWORD PTR [ebx+esi+1080]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T5[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sbb	edx, DWORD PTR [ebx+esi+1084]
	mov	DWORD PTR _deltaTime$10[ebp+4], edx

; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {

	jne	SHORT $LN431@CheckSearc
	cmp	eax, 60000				; 0000ea60H
	jbe	$LN6@CheckSearc
$LN431@CheckSearc:

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	cmp	DWORD PTR [ebx+esi+1072], 0
	jne	SHORT $LN3@CheckSearc
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	npad	4
$LL243@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN242@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN257@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL243@CheckSearc
$LN257@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL243@CheckSearc
$LN242@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	mov	edi, DWORD PTR _index$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	test	eax, eax
	je	$LN408@CheckSearc
$LN3@CheckSearc:

; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");

	movdqu	xmm0, XMMWORD PTR $SG4294899468
	movdqu	XMMWORD PTR [ebx+esi+12], xmm0
	movdqu	xmm0, XMMWORD PTR $SG4294899468+16
	movdqu	XMMWORD PTR [ebx+esi+28], xmm0
	mov	eax, DWORD PTR $SG4294899468+32
	mov	DWORD PTR [ebx+esi+44], eax
	mov	ax, WORD PTR $SG4294899468+36
	mov	WORD PTR [ebx+esi+48], ax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _this$1$[ebp], eax

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [eax+4], 0

; 102  : 		return (_Thr._Hnd);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _native_handle$1$[ebp], ecx

; 81   : 		}
; 82   : 
; 83   : 	void join();
; 84   : 
; 85   : 	void detach()
; 86   : 		{	// detach thread
; 87   : 		if (!joinable())

	jne	SHORT $LN293@CheckSearc

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 4
$LN293@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	__Thrd_detach
	add	esp, 8

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN300@CheckSearc

; 33   : 		_Throw_C_error(_Res);

	push	eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
	add	esp, 4
$LN300@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+4], 0
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 617  : 			delete opencl_device_search_threads[index];

	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN303@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [eax+4], 0

; 55   : 		if (joinable())

	jne	$LN407@CheckSearc
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN303@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 627  : 			TerminateThread(native_handle, 0);

	push	0
	push	DWORD PTR _native_handle$1$[ebp]
	mov	DWORD PTR [ebx+esi+1076], 0
	call	DWORD PTR __imp__TerminateThread@8

; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000$1$[ebp]

; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;

	inc	DWORD PTR [ebx+esi+1068]
	unpcklpd xmm0, xmm0

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	push	8
	movups	XMMWORD PTR [ebx+esi+1040], xmm0
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN20@CheckSearc
	mov	edi, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	add	edi, ebx
	mov	eax, OFFSET ?Thread_SearchForDESTripcodesOnOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnOpenCLDevice
	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode, 0000000aH
	mov	esi, OFFSET ?Thread_SearchForSHA1TripcodesOnOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnOpenCLDevice
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR $T7[ebp+4], edi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	cmove	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	DWORD PTR $T7[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$2[ebp+20], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 205  : 	_LaunchPad<_Target> _Launcher(_STD forward<_Target>(_Tg));

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 206  : 	_Launcher._Launch(_Thr);

	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	esi, DWORD PTR $T11[ebp]
	push	esi
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	mov	edi, DWORD PTR _index$1$[ebp]
	jmp	SHORT $LN21@CheckSearc
$LN20@CheckSearc:
	xor	esi, esi
$LN21@CheckSearc:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
	mov	DWORD PTR [eax+edi*4], esi
$LN6@CheckSearc:

; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {

	inc	edi
	add	ebx, 1088				; 00000440H
	mov	DWORD PTR _index$1$[ebp], edi
	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	$LL7@CheckSearc
$LN429@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 645  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN408@CheckSearc:

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@CheckSearc
	push	22					; 00000016H
	push	OFFSET $SG4294899472
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	22					; 00000016H
	push	OFFSET $SG4294899471
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN289@CheckSearc
$LN2@CheckSearc:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$14[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN285@CheckSearc

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$14[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$13[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN287@CheckSearc
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN434@CheckSearc
$LN287@CheckSearc:
	xor	eax, eax
$LN434@CheckSearc:
	mov	WORD PTR _cursorPos$13[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$13[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN285@CheckSearc:

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	push	OFFSET $SG4294899470
	push	OFFSET $SG4294899469
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$9[ebp]
	mov	DWORD PTR _info$9[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$9[ebp], 100		; 00000064H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN289@CheckSearc:

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN436@CheckSearc:
$LN433@CheckSearc:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckSearchThreads@@YAXXZ$0:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CheckSearchThreads@@YAXXZ$2:
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__unwindfunclet$?CheckSearchThreads@@YAXXZ$1:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CheckSearchThreads@@YAXXZ$4:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$?CheckSearchThreads@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckSearchThreads@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckSearchThreads@@YAXXZ ENDP				; CheckSearchThreads
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??_Gthread@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_Gthread@std@@QAEPAXI@Z PROC				; std::thread::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [esi+4], 0

; 55   : 		if (joinable())

	jne	SHORT $LN11@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	pop	esi
	ret	4
$LN11@scalar:

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
$LN13@scalar:
$LN10@scalar:
	int	3
??_Gthread@std@@QAEPAXI@Z ENDP				; std::thread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?KeepSearchThreadsAlive@@YAXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
?KeepSearchThreadsAlive@@YAXXZ PROC			; KeepSearchThreadsAlive, COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	esi, OFFSET ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
	npad	3
$LL10@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN9@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN24@KeepSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL10@KeepSearch
$LN24@KeepSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL10@KeepSearch
$LN9@KeepSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)

	xor	edi, edi
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, edi ; numCUDADeviceSearchThreads
	jle	SHORT $LN4@KeepSearch
	xor	esi, esi
$LL6@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	lea	esi, DWORD PTR [esi+1640]
	inc	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [esi+ecx-8], eax
	mov	DWORD PTR [esi+ecx-4], edx
	cmp	edi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LL6@KeepSearch
$LN4@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
	mov	esi, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
$LL86@KeepSearch:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN85@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN100@KeepSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL86@KeepSearch
$LN100@KeepSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL86@KeepSearch
$LN85@KeepSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)

	xor	edi, edi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, edi ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN179@KeepSearch
	xor	esi, esi
	npad	5
$LL3@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	lea	esi, DWORD PTR [esi+1088]
	inc	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [esi+ecx-8], eax
	mov	DWORD PTR [esi+ecx-4], edx
	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LL3@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 658  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN179@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, edi ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 658  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?KeepSearchThreadsAlive@@YAXXZ ENDP			; KeepSearchThreadsAlive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?PrintStatus@@YAXXZ
_TEXT	SEGMENT
_averageSpeed$1$ = -41080				; size = 8
_lineCount$1$ = -41080					; size = 4
tv1099 = -41080						; size = 4
_cursorPos$1 = -41080					; size = 4
__real@40ac200000000000$1$ = -41072			; size = 8
__real@412e848000000000$1$ = -41072			; size = 8
_matchingProbDiff$1$ = -41072				; size = 8
_totalTimeDays$1$ = -41072				; size = 4
_i$1$ = -41060						; size = 4
_numDiscardedTripcodes_childProcesses$1$ = -41060	; size = 4
_timeForOneMatch$1$ = -41056				; size = 8
_matchingProbDiff$ = -41056				; size = 8
_timeForOneMatch$ = -41056				; size = 8
_averageSpeed_CPU$ = -41056				; size = 8
_averageSpeed_GPU$ = -41056				; size = 8
_averageSpeed$ = -41056					; size = 8
_averageSpeed_CPU$1$ = -41048				; size = 8
_averageSpeed_childProcesses$1$ = -41048		; size = 8
__real@4059000000000000$1$ = -41040			; size = 8
_totalNumGeneratedTripcodes_childProcesses$1$ = -41032	; size = 8
_currentSpeed_childProcesses$1$ = -41024		; size = 8
__real@0000000000000000$1$ = -41016			; size = 8
_averageSpeed_GPU$1$ = -41008				; size = 8
_invalidTripcodeRatio$1$ = -41000			; size = 8
_scrnBufInfo$2 = -40992					; size = 22
_msg$ = -40968						; size = 40960
__$ArrayPad$ = -4					; size = 4
?PrintStatus@@YAXXZ PROC				; PrintStatus, COMDAT

; 661  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	mov	eax, 41140				; 0000a0b4H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+41140], eax
	push	ebx
	push	esi
	push	edi

; 662  : 	if (GetErrorState() || GetTerminationState())

	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN157@PrintStatu
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN157@PrintStatu

; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();

	mov	ecx, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	call	?lock@spinlock@@QAEXXZ			; spinlock::lock

; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");

	push	OFFSET $SG4294899467
	lea	eax, DWORD PTR _msg$[esp+41156]
	push	OFFSET $SG4294899466
	push	eax
	call	_sprintf

; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");

	push	OFFSET $SG4294899465
	lea	eax, DWORD PTR _msg$[esp+42192]
	push	OFFSET $SG4294899464
	push	eax
	call	_sprintf

; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");

	push	OFFSET $SG4294899463
	lea	eax, DWORD PTR _msg$[esp+43228]
	push	OFFSET $SG4294899462
	push	eax
	call	_sprintf

; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	add	esp, 36					; 00000024H
	cmp	eax, 3
	jne	SHORT $LN59@PrintStatu
	mov	ecx, OFFSET $SG4294899461
	jmp	SHORT $LN60@PrintStatu
$LN59@PrintStatu:
	cmp	eax, 2
	mov	ecx, OFFSET $SG4294899460
	mov	edx, OFFSET $SG4294899459
	cmovne	ecx, edx
$LN60@PrintStatu:
	mov	edx, DWORD PTR ?searchMode@@3HA		; searchMode
	test	edx, edx
	jne	SHORT $LN63@PrintStatu
	mov	eax, OFFSET $SG4294899458
	jmp	SHORT $LN62@PrintStatu
$LN63@PrintStatu:
	cmp	edx, 1
	jne	SHORT $LN61@PrintStatu
	mov	eax, OFFSET $SG4294899457
	jmp	SHORT $LN62@PrintStatu
$LN61@PrintStatu:
	cmp	edx, 2
	mov	eax, OFFSET $SG4294899456
	mov	esi, OFFSET $SG4294899455
	cmovne	eax, esi
$LN62@PrintStatu:
	push	ecx
	push	eax
	lea	eax, DWORD PTR _msg$[esp+44232]
	push	OFFSET $SG4294899454
	push	eax
	call	_sprintf

; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {

	mov	ecx, DWORD PTR ?minLenExpandedPattern@@3HA ; minLenExpandedPattern
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR ?maxLenExpandedPattern@@3HA ; maxLenExpandedPattern
	cmp	ecx, edx
	je	SHORT $LN54@PrintStatu

; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");

	cmp	DWORD PTR ?searchDevice@@3HA, 3		; searchDevice
	mov	eax, OFFSET $SG4294899453
	mov	esi, OFFSET $SG4294899452
	cmovne	eax, esi
	push	eax
	mov	eax, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	cmp	eax, 1
	push	edx
	push	ecx
	mov	edx, OFFSET $SG4294899450
	mov	ecx, OFFSET $SG4294899451
	cmovne	ecx, edx
	mov	edx, OFFSET $SG4294899448
	push	ecx
	push	eax
	mov	eax, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	mov	ecx, OFFSET $SG4294899449
	cmp	eax, 1
	cmovne	ecx, edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _msg$[esp+45276]
	push	OFFSET $SG4294899447
	push	eax
	call	_sprintf
	add	esp, 36					; 00000024H

; 693  : 		
; 694  : 	} else {

	jmp	SHORT $LN187@PrintStatu
$LN54@PrintStatu:

; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");

	cmp	DWORD PTR ?searchDevice@@3HA, 3		; searchDevice
	mov	edx, OFFSET $SG4294899445
	mov	eax, OFFSET $SG4294899446
	cmovne	eax, edx
	mov	edx, OFFSET $SG4294899443
	push	eax
	mov	eax, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	cmp	eax, 1
	push	ecx
	mov	ecx, OFFSET $SG4294899444
	cmovne	ecx, edx
	mov	edx, OFFSET $SG4294899441
	push	ecx
	push	eax
	mov	eax, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	mov	ecx, OFFSET $SG4294899442
	cmp	eax, 1
	cmovne	ecx, edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _msg$[esp+45272]
	push	OFFSET $SG4294899440
	push	eax
	call	_sprintf
	add	esp, 32					; 00000020H
$LN187@PrintStatu:

; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	mov	ebx, 5
	mov	DWORD PTR _lineCount$1$[esp+41152], ebx
	cmp	eax, 3
	je	$LN184@PrintStatu
	cmp	DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A, 0 ; CUDADeviceSearchThreadInfoArray
	je	$LN80@PrintStatu

; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();

	mov	ecx, OFFSET ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
	call	?lock@spinlock@@QAEXXZ			; spinlock::lock

; 706  : 		if (numCUDADeviceSearchThreads == 1) {

	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	cmp	eax, 1
	jne	SHORT $LN51@PrintStatu

; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);

	mov	eax, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	add	eax, 604				; 0000025cH
	push	eax
	lea	eax, DWORD PTR _msg$[esp+46276]
	push	OFFSET $SG4294899439
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, 6

; 708  : 		} else {

	jmp	SHORT $LN188@PrintStatu
$LN51@PrintStatu:

; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN47@PrintStatu
	lea	edx, DWORD PTR _msg$[esp+46272]
	xor	esi, esi
	mov	DWORD PTR tv1099[esp+41152], edx
	npad	7
$LL49@PrintStatu:

; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);

	mov	ecx, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	lea	eax, DWORD PTR [ecx+604]
	add	eax, esi
	push	eax
	push	DWORD PTR [esi+ecx+4]
	push	DWORD PTR [esi+ecx]
	push	OFFSET $SG4294899438
	push	edx
	call	_sprintf
	mov	edx, DWORD PTR tv1099[esp+41172]
	inc	edi
	add	edx, 1024				; 00000400H
	add	esp, 20					; 00000014H
	inc	ebx
	mov	DWORD PTR tv1099[esp+41152], edx
	add	esi, 1640				; 00000668H
	cmp	edi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LL49@PrintStatu
$LN188@PrintStatu:
	mov	DWORD PTR _lineCount$1$[esp+41152], ebx
$LN47@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
$LN80@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {

	cmp	eax, 3
	je	$LN184@PrintStatu
	cmp	DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A, 0 ; openCLDeviceSearchThreadInfoArray
	je	$LN184@PrintStatu

; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();

	mov	ecx, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
	call	?lock@spinlock@@QAEXXZ			; spinlock::lock

; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {

	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	cmp	eax, 1
	jne	SHORT $LN45@PrintStatu

; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);

	mov	eax, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	add	eax, 12					; 0000000cH
	push	eax
	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	push	OFFSET $SG4294899437
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	inc	ebx

; 718  : 		} else {

	jmp	SHORT $LN189@PrintStatu
$LN45@PrintStatu:

; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	DWORD PTR _i$1$[esp+41152], 0
	test	eax, eax
	jle	SHORT $LN41@PrintStatu
	mov	eax, ebx
	lea	edi, DWORD PTR _msg$[esp+41152]
	shl	eax, 10					; 0000000aH
	xor	esi, esi
	add	edi, eax
$LL43@PrintStatu:

; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	mov	edx, DWORD PTR [esi+ecx+8]

; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);

	lea	eax, DWORD PTR [ecx+12]
	add	eax, esi
	push	eax
	test	edx, edx
	jns	SHORT $LN40@PrintStatu
	push	DWORD PTR [esi+ecx+4]
	push	OFFSET $SG4294899436
	push	edi
	call	_sprintf
	add	esp, 16					; 00000010H

; 722  : 				} else {

	jmp	SHORT $LN190@PrintStatu
$LN40@PrintStatu:

; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);

	push	edx
	push	DWORD PTR [esi+ecx+4]
	push	OFFSET $SG4294899435
	push	edi
	call	_sprintf
	add	esp, 20					; 00000014H
$LN190@PrintStatu:
	mov	edx, DWORD PTR _i$1$[esp+41152]
	inc	ebx
	inc	edx
	add	edi, 1024				; 00000400H
	add	esi, 1088				; 00000440H
	mov	DWORD PTR _i$1$[esp+41152], edx
	cmp	edx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LL43@PrintStatu
$LN189@PrintStatu:
	mov	DWORD PTR _lineCount$1$[esp+41152], ebx
$LN41@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
$LN184@PrintStatu:
	xorps	xmm5, xmm5
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;

	xor	esi, esi
	movsd	QWORD PTR __real@0000000000000000$1$[esp+41152], xmm5
	movsd	QWORD PTR _currentSpeed_childProcesses$1$[esp+41152], xmm5
	movsd	QWORD PTR _averageSpeed_childProcesses$1$[esp+41152], xmm5
	movsd	QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152], xmm5
	mov	DWORD PTR _numDiscardedTripcodes_childProcesses$1$[esp+41152], esi

; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A, esi ; openCLDeviceSearchThreadInfoArray
	je	$LN128@PrintStatu
	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, esi ; openCLRunChildProcesses
	je	$LN128@PrintStatu

; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();

	mov	ecx, OFFSET ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
	call	?lock@spinlock@@QAEXXZ			; spinlock::lock

; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	ecx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	test	ecx, ecx
	jle	SHORT $LN35@PrintStatu

; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();

	mov	eax, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	add	eax, 1040				; 00000410H
$LL37@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN36@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	movsd	xmm0, QWORD PTR [eax]
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41152]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	esi, DWORD PTR [eax+24]
	movsd	QWORD PTR _currentSpeed_childProcesses$1$[esp+41152], xmm0
	movsd	xmm0, QWORD PTR [eax+8]
	addsd	xmm0, QWORD PTR _averageSpeed_childProcesses$1$[esp+41152]
	movsd	QWORD PTR _averageSpeed_childProcesses$1$[esp+41152], xmm0
	movsd	xmm0, QWORD PTR [eax+16]
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152]
	movsd	QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152], xmm0
$LN36@PrintStatu:

; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	add	eax, 1088				; 00000440H
	dec	ecx
	jne	SHORT $LL37@PrintStatu
	mov	DWORD PTR _numDiscardedTripcodes_childProcesses$1$[esp+41152], esi
$LN35@PrintStatu:
	movsd	xmm5, QWORD PTR __real@0000000000000000$1$[esp+41152]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
$LN128@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 761  : 										: 0;

	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	lea	ecx, DWORD PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN65@PrintStatu
	movd	xmm1, eax
	movd	xmm0, ecx
	cvtdq2pd xmm1, xmm1
	shr	eax, 31					; 0000001fH
	shr	ecx, 31					; 0000001fH
	cvtdq2pd xmm0, xmm0
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _invalidTripcodeRatio$1$[esp+41152], xmm1
	jmp	SHORT $LN66@PrintStatu
$LN65@PrintStatu:
	movsd	QWORD PTR _invalidTripcodeRatio$1$[esp+41152], xmm5
$LN66@PrintStatu:

; 762  : 	if (totalTime > 0) {

	movsd	xmm3, QWORD PTR ?totalTime@@3NA
	comisd	xmm3, xmm5
	movsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR __real@4059000000000000$1$[esp+41152], xmm0
	jbe	$LN186@PrintStatu

; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;

	movaps	xmm0, xmm3
	call	__dtoui3
	mov	ebx, eax

; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;

	mov	eax, -1037155065			; c22e4507H
	mul	ebx

; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");

	push	OFFSET $SG4294899434
	mov	eax, edx
	shr	eax, 16					; 00000010H
	imul	ecx, eax, -86400
	mov	DWORD PTR _totalTimeDays$1$[esp+41156], eax
	mov	eax, -1851608123			; 91a2b3c5H
	add	ebx, ecx
	mul	ebx
	mov	edi, edx
	shr	edi, 11					; 0000000bH
	imul	eax, edi, -3600
	add	ebx, eax
	mov	eax, -2004318071			; 88888889H
	mul	ebx
	mov	eax, DWORD PTR _lineCount$1$[esp+41156]
	shl	eax, 10					; 0000000aH
	mov	esi, edx
	shr	esi, 5
	lea	eax, DWORD PTR _msg$[esp+eax+41156]
	push	eax
	call	_sprintf

; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);

	movsd	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	add	esp, 8
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152]
	inc	DWORD PTR _lineCount$1$[esp+41152]
	mov	eax, esi
	shl	eax, 4
	sub	eax, esi
	shl	eax, 2
	mulsd	xmm0, QWORD PTR __real@3d719799812dea11
	sub	ebx, eax
	push	ebx
	mov	ebx, DWORD PTR _lineCount$1$[esp+41156]
	mov	eax, ebx
	push	esi
	push	edi
	push	DWORD PTR _totalTimeDays$1$[esp+41164]
	shl	eax, 10					; 0000000aH
	sub	esp, 8
	lea	eax, DWORD PTR _msg$[esp+eax+41176]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899433
	push	eax
	call	_sprintf

; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);

	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess@@3NA
	lea	eax, DWORD PTR [ebx+1]
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41184]
	movsd	xmm1, QWORD PTR __real@412e848000000000
	add	esp, 24					; 00000018H
	shl	eax, 10					; 0000000aH
	movsd	QWORD PTR __real@412e848000000000$1$[esp+41160], xmm1
	divsd	xmm0, xmm1
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899432
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	add	ebx, 2

; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	jne	SHORT $LN32@PrintStatu

; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);

	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA
	sub	esp, 8
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41160]
	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	divsd	xmm0, QWORD PTR __real@412e848000000000$1$[esp+41160]
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899431
	push	eax
	call	_sprintf

; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);

	movsd	xmm0, QWORD PTR ?currentSpeed_CPU@@3NA
	lea	eax, DWORD PTR [ebx+1]
	divsd	xmm0, QWORD PTR __real@412e848000000000$1$[esp+41168]
	add	esp, 8
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899430
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	add	ebx, 2
$LN32@PrintStatu:

; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;

	movsd	xmm0, QWORD PTR ?totalTime@@3NA

; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);

	sub	esp, 8
	movsd	xmm2, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	mov	eax, ebx
	divsd	xmm2, xmm0
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	xmm3, QWORD PTR ?prevTotalNumGeneratedTripcodes_GPU@@3NA
	addsd	xmm2, QWORD PTR _averageSpeed_childProcesses$1$[esp+41160]
	movsd	xmm1, QWORD PTR ?prevTotalNumGeneratedTripcodes_CPU@@3NA
	divsd	xmm3, xmm0
	divsd	xmm1, xmm0
	movaps	xmm0, xmm2
	movsd	QWORD PTR _averageSpeed$1$[esp+41160], xmm2
	divsd	xmm0, QWORD PTR __real@412e848000000000$1$[esp+41160]
	addsd	xmm3, QWORD PTR _averageSpeed_childProcesses$1$[esp+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899429
	push	eax
	movsd	QWORD PTR _averageSpeed_CPU$1$[esp+41168], xmm1
	movsd	QWORD PTR _averageSpeed_GPU$1$[esp+41168], xmm3
	call	_sprintf
	add	esp, 16					; 00000010H
	inc	ebx

; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	jne	SHORT $LN31@PrintStatu

; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);

	movsd	xmm0, QWORD PTR _averageSpeed_GPU$1$[esp+41152]
	sub	esp, 8
	divsd	xmm0, QWORD PTR __real@412e848000000000$1$[esp+41160]
	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899428
	push	eax
	call	_sprintf

; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);

	movsd	xmm0, QWORD PTR _averageSpeed_CPU$1$[esp+41168]
	lea	eax, DWORD PTR [ebx+1]
	divsd	xmm0, QWORD PTR __real@412e848000000000$1$[esp+41168]
	add	esp, 8
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR _msg$[esp+eax+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899427
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	add	ebx, 2
$LN31@PrintStatu:

; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;

	movsd	xmm1, QWORD PTR _averageSpeed$1$[esp+41152]

; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {

	comisd	xmm1, QWORD PTR __real@0000000000000000$1$[esp+41152]
	movsd	xmm0, QWORD PTR ?numAverageTrialsForOneMatch@@3NA
	divsd	xmm0, xmm1
	movsd	xmm2, QWORD PTR __real@40ac200000000000
	movsd	QWORD PTR _timeForOneMatch$1$[esp+41152], xmm0
	movsd	QWORD PTR __real@40ac200000000000$1$[esp+41152], xmm2
	jbe	$LN18@PrintStatu
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	jne	$LN18@PrintStatu

; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {

	movsd	xmm1, QWORD PTR __real@41e77f03c0000000

; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			

	sub	esp, 8
	comisd	xmm0, xmm1
	jb	SHORT $LN29@PrintStatu
	divsd	xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899426
	jmp	$LN191@PrintStatu
$LN29@PrintStatu:

; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {

	movsd	xmm1, QWORD PTR __real@417e133800000000
	comisd	xmm0, xmm1
	jb	SHORT $LN27@PrintStatu

; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			

	divsd	xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899425
	jmp	$LN191@PrintStatu
$LN27@PrintStatu:

; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {

	movsd	xmm1, QWORD PTR __real@414409ffffffffff
	comisd	xmm0, xmm1
	jb	SHORT $LN25@PrintStatu

; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			

	divsd	xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899424
	jmp	SHORT $LN191@PrintStatu
$LN25@PrintStatu:

; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {

	movsd	xmm1, QWORD PTR __real@40f5180000000000
	comisd	xmm0, xmm1
	jb	SHORT $LN23@PrintStatu

; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			

	divsd	xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899423
	jmp	SHORT $LN191@PrintStatu
$LN23@PrintStatu:

; 803  : 			} else if (timeForOneMatch >= 60 * 60) {

	comisd	xmm0, xmm2
	jb	SHORT $LN21@PrintStatu

; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			

	divsd	xmm0, xmm2
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899422
	jmp	SHORT $LN191@PrintStatu
$LN21@PrintStatu:

; 805  : 			} else if (timeForOneMatch >= 60) {

	movsd	xmm1, QWORD PTR __real@404e000000000000
	comisd	xmm0, xmm1
	jb	SHORT $LN19@PrintStatu

; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			

	divsd	xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899421

; 807  : 			} else {

	jmp	SHORT $LN191@PrintStatu
$LN19@PrintStatu:

; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			

	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899420
$LN191@PrintStatu:
	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR _msg$[esp+eax+41164]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	inc	ebx
$LN18@PrintStatu:

; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");

	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	push	OFFSET $SG4294899419
	lea	eax, DWORD PTR _msg$[esp+eax+41156]
	push	eax
	call	_sprintf
	add	esp, 8
	inc	ebx

; 812  : 		if (numValidTripcodes <= 0) {

	cmp	DWORD PTR ?numValidTripcodes@@3IA, 0	; numValidTripcodes
	ja	SHORT $LN17@PrintStatu

; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");

	mov	eax, ebx
	lea	edx, DWORD PTR _msg$[esp+41152]
	shl	eax, 10					; 0000000aH
	add	eax, edx
	push	OFFSET $SG4294899418
	push	eax
	call	_sprintf

; 814  : 		} else {

	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	add	esp, 8
	movsd	xmm3, QWORD PTR ?totalTime@@3NA
	inc	ebx
	movsd	xmm4, QWORD PTR _averageSpeed$1$[esp+41152]
	movsd	xmm5, QWORD PTR __real@0000000000000000$1$[esp+41152]
	movsd	xmm6, QWORD PTR _averageSpeed_GPU$1$[esp+41152]
	movsd	xmm7, QWORD PTR _averageSpeed_CPU$1$[esp+41152]
	movsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41152]
	jmp	$LN192@PrintStatu
$LN17@PrintStatu:

; 815  : 			if (prevNumValidTripcodes > 0) {

	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	test	edx, edx
	je	$LN15@PrintStatu

; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);

	movsd	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	mov	eax, edx
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152]
	movd	xmm1, edx
	sub	esp, 16					; 00000010H
	shr	eax, 31					; 0000001fH
	mov	ecx, OFFSET $SG4294899416
	cvtdq2pd xmm1, xmm1
	cmp	edx, 1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, OFFSET $SG4294899417
	cmovne	eax, ecx
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3e112e0be826d695
	movsd	QWORD PTR [esp+8], xmm0
	movsd	xmm0, QWORD PTR ?totalTime@@3NA
	divsd	xmm0, QWORD PTR __real@40ac200000000000$1$[esp+41168]
	divsd	xmm1, xmm0
	movsd	QWORD PTR [esp], xmm1
	push	eax
	push	edx
	mov	eax, ebx
	lea	edx, DWORD PTR _msg$[esp+41176]
	shl	eax, 10					; 0000000aH
	add	eax, edx
	push	OFFSET $SG4294899415
	push	eax
	call	_sprintf
	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	add	esp, 32					; 00000020H
	inc	ebx
$LN15@PrintStatu:

; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);

	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movsd	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	add	eax, edx
	add	eax, DWORD PTR _numDiscardedTripcodes_childProcesses$1$[esp+41152]
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41152]
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	shr	eax, 31					; 0000001fH

; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {

	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	addsd	xmm2, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm2, xmm0
	subsd	xmm2, QWORD PTR ?matchingProb@@3NA
	divsd	xmm2, QWORD PTR ?matchingProb@@3NA
	movsd	QWORD PTR _matchingProbDiff$1$[esp+41152], xmm2
	jne	$LN10@PrintStatu

; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);

	mov	eax, ebx
	lea	edx, DWORD PTR _msg$[esp+41152]
	shl	eax, 10					; 0000000aH
	add	eax, edx
	comisd	xmm2, QWORD PTR __real@3f847ae147ae147b
	jbe	SHORT $LN13@PrintStatu
	movaps	xmm0, xmm2
	sub	esp, 8
	mulsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41160]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899414
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN193@PrintStatu
$LN13@PrintStatu:

; 830  : 				} else if (matchingProbDiff < -0.01) {

	movsd	xmm0, QWORD PTR __real@bf847ae147ae147b
	comisd	xmm0, xmm2
	jbe	SHORT $LN11@PrintStatu

; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);

	movaps	xmm0, xmm2
	sub	esp, 8
	mulsd	xmm0, QWORD PTR __real@c059000000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899413
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 833  : 				} else {

	jmp	SHORT $LN193@PrintStatu
$LN11@PrintStatu:

; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");

	push	OFFSET $SG4294899412
	push	eax
	call	_sprintf
	add	esp, 8
$LN193@PrintStatu:
	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	inc	ebx
	movsd	xmm2, QWORD PTR _matchingProbDiff$1$[esp+41152]
$LN10@PrintStatu:

; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {

	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	add	eax, edx
	je	SHORT $LN185@PrintStatu

; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);

	movsd	xmm0, QWORD PTR _invalidTripcodeRatio$1$[esp+41152]
	lea	edx, DWORD PTR _msg$[esp+41152]
	mulsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41152]
	sub	esp, 8
	mov	eax, ebx
	shl	eax, 10					; 0000000aH
	add	eax, edx
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899411
	push	eax
	call	_sprintf
	mov	edx, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	add	esp, 16					; 00000010H
	movsd	xmm3, QWORD PTR ?totalTime@@3NA
	inc	ebx
	movsd	xmm2, QWORD PTR _matchingProbDiff$1$[esp+41152]
	movsd	xmm4, QWORD PTR _averageSpeed$1$[esp+41152]
	movsd	xmm5, QWORD PTR __real@0000000000000000$1$[esp+41152]
	movsd	xmm6, QWORD PTR _averageSpeed_GPU$1$[esp+41152]
	movsd	xmm7, QWORD PTR _averageSpeed_CPU$1$[esp+41152]
	movsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41152]
	jmp	SHORT $LN194@PrintStatu
$LN185@PrintStatu:
	movsd	xmm3, QWORD PTR ?totalTime@@3NA
	movsd	xmm4, QWORD PTR _averageSpeed$1$[esp+41152]
	movsd	xmm5, QWORD PTR __real@0000000000000000$1$[esp+41152]
	movsd	xmm6, QWORD PTR _averageSpeed_GPU$1$[esp+41152]
	movsd	xmm7, QWORD PTR _averageSpeed_CPU$1$[esp+41152]
	movsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41152]
	jmp	SHORT $LN194@PrintStatu
$LN186@PrintStatu:
	movsd	xmm4, QWORD PTR _averageSpeed$[esp+41152]
	movsd	xmm6, QWORD PTR _averageSpeed_GPU$[esp+41152]
	movsd	xmm7, QWORD PTR _averageSpeed_CPU$[esp+41152]
$LN192@PrintStatu:
	movsd	xmm2, QWORD PTR _matchingProbDiff$[esp+41152]
$LN194@PrintStatu:

; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	movsd	xmm1, QWORD PTR _timeForOneMatch$[esp+41152]
	jne	$LN8@PrintStatu

; 845  : 		for (int32_t i = 0; i < lineCount; ++i)

	test	ebx, ebx
	jle	SHORT $LN5@PrintStatu
	lea	esi, DWORD PTR _msg$[esp+41152]
	mov	edi, ebx
	npad	5
$LL7@PrintStatu:

; 846  : 			printf("%-79s\n", &(msg[i][0]));

	push	esi
	push	OFFSET $SG4294899410
	call	_printf
	add	esp, 8
	add	esi, 1024				; 00000400H
	dec	edi
	jne	SHORT $LL7@PrintStatu
$LN5@PrintStatu:

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	mov	edi, DWORD PTR __imp__GetStdHandle@4
	lea	eax, DWORD PTR _scrnBufInfo$2[esp+41152]
	push	eax

; 847  : 		reset_cursor_pos(-lineCount);

	mov	esi, ebx

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	push	-11					; fffffff5H

; 847  : 		reset_cursor_pos(-lineCount);

	neg	esi

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	call	edi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN140@PrintStatu

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$2[esp+41158]
	xor	eax, eax
	mov	WORD PTR _cursorPos$1[esp+41152], ax
	movsx	eax, cx
	add	eax, esi
	js	SHORT $LN142@PrintStatu
	lea	eax, DWORD PTR [esi+ecx]
	jmp	SHORT $LN195@PrintStatu
$LN142@PrintStatu:
	xor	eax, eax
$LN195@PrintStatu:
	mov	WORD PTR _cursorPos$1[esp+41154], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$1[esp+41152]
	push	-11					; fffffff5H
	call	edi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN140@PrintStatu:

; 848  : 		prevLineCount = lineCount;

	mov	DWORD PTR ?prevLineCount@@3HA, ebx	; prevLineCount
	jmp	$LN4@PrintStatu
$LN8@PrintStatu:

; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {

	comisd	xmm3, xmm5
	jbe	$LN1@PrintStatu

; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);

	sub	esp, 8
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, 0 ; searchForSpecialPatternsOnCPU
	jne	$LN3@PrintStatu
	mulsd	xmm2, xmm0
	mov	eax, OFFSET $SG4294899409
	movsd	xmm0, QWORD PTR _invalidTripcodeRatio$1$[esp+41160]
	mulsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41160]
	cvttsd2si ecx, xmm2
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movsd	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41164]
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm7
	movsd	QWORD PTR [esp], xmm6
	push	0
	push	edx
	sub	esp, 8
	mov	edx, OFFSET $SG4294899408
	test	ecx, ecx
	cmovle	eax, edx
	movsd	QWORD PTR [esp], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_CPU@@3NA
	push	ecx
	push	eax
	sub	esp, 48					; 00000030H
	movsd	QWORD PTR [esp+40], xmm1
	movsd	QWORD PTR [esp+32], xmm4
	movsd	QWORD PTR [esp+24], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41252]
	movsd	QWORD PTR [esp+16], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess@@3NA
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41252]
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm3
	push	OFFSET $SG4294899407
	call	_printf
	add	esp, 104				; 00000068H
	jmp	$LN1@PrintStatu
$LN3@PrintStatu:

; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);

	movsd	xmm0, QWORD PTR _invalidTripcodeRatio$1$[esp+41160]
	mulsd	xmm0, QWORD PTR __real@4059000000000000$1$[esp+41160]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movsd	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA
	addsd	xmm0, QWORD PTR _totalNumGeneratedTripcodes_childProcesses$1$[esp+41164]
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm7
	movsd	QWORD PTR [esp], xmm6
	push	0
	push	edx
	sub	esp, 48					; 00000030H
	movsd	QWORD PTR [esp+40], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_CPU@@3NA
	movsd	QWORD PTR [esp+32], xmm4
	movsd	QWORD PTR [esp+24], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41236]
	movsd	QWORD PTR [esp+16], xmm0
	movsd	xmm0, QWORD PTR ?currentSpeed_thisProcess@@3NA
	addsd	xmm0, QWORD PTR _currentSpeed_childProcesses$1$[esp+41236]
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm3
	push	OFFSET $SG4294899406
	call	_printf
	add	esp, 88					; 00000058H
$LN1@PrintStatu:

; 881  : 		}
; 882  : 		fflush(stdout);

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 4
$LN4@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
$LN157@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 887  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+41152]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintStatus@@YAXXZ ENDP				; PrintStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ControlHandler@@YGHK@Z
_TEXT	SEGMENT
_dwCtrlType$ = 8					; size = 4
?ControlHandler@@YGHK@Z PROC				; ControlHandler, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp

; 891  : 	switch (dwCtrlType) {

	mov	eax, DWORD PTR _dwCtrlType$[ebp]
	push	esi
	cmp	eax, 6
	ja	SHORT $LN1@ControlHan
	movzx	eax, BYTE PTR $LN12@ControlHan[eax]
	jmp	DWORD PTR $LN14@ControlHan[eax*4]
$LN4@ControlHan:

; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();

	call	?SetTerminationState@@YAXXZ		; SetTerminationState
	mov	esi, DWORD PTR __imp__Sleep@4
$LL3@ControlHan:

; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);

	push	1000					; 000003e8H
	call	esi
	jmp	SHORT $LL3@ControlHan
$LN1@ControlHan:

; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;

	xor	eax, eax

; 902  : 	}
; 903  : }

	pop	esi
	pop	ebp
	ret	4
	npad	3
$LN14@ControlHan:
	DD	$LN4@ControlHan
	DD	$LN1@ControlHan
$LN12@ControlHan:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
?ControlHandler@@YGHK@Z ENDP				; ControlHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?InitProcess@@YAXXZ
_TEXT	SEGMENT
_info$1 = -8						; size = 8
?InitProcess@@YAXXZ PROC				; InitProcess, COMDAT

; 906  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	lea	eax, DWORD PTR _info$1[ebp]
	mov	DWORD PTR _info$1[ebp+4], 0
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$1[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8

; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);

	push	1
	push	OFFSET ?ControlHandler@@YGHK@Z		; ControlHandler
	call	DWORD PTR __imp__SetConsoleCtrlHandler@8

; 909  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitProcess@@YAXXZ ENDP				; InitProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListCUDADevices@@YAXXZ
_TEXT	SEGMENT
_CUDADeviceProperties$ = -600				; size = 596
__$ArrayPad$ = -4					; size = 4
?ListCUDADevices@@YAXXZ PROC				; ListCUDADevices, COMDAT

; 912  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);

	push	OFFSET ?CUDADeviceCount@@3HA		; CUDADeviceCount
	call	DWORD PTR __imp__cudaGetDeviceCount@4

; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {

	xor	esi, esi
	cmp	DWORD PTR ?CUDADeviceCount@@3HA, esi	; CUDADeviceCount
	jle	SHORT $LN1@ListCUDADe
	push	edi
	mov	edi, DWORD PTR __imp__cudaGetDeviceProperties@8
$LL3@ListCUDADe:

; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);

	push	esi
	lea	eax, DWORD PTR _CUDADeviceProperties$[ebp]
	push	eax
	call	edi

; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 

	lea	eax, DWORD PTR _CUDADeviceProperties$[ebp]
	push	eax
	push	OFFSET $SG4294899405
	call	_printf
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jl	SHORT $LL3@ListCUDADe
	pop	edi
$LN1@ListCUDADe:

; 921  : 	}
; 922  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ListCUDADevices@@YAXXZ ENDP				; ListCUDADevices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CountOpenCLDevices@@YAXXZ
_TEXT	SEGMENT
_platformIndex$1$ = -1056				; size = 4
_numPlatforms$ = -1052					; size = 4
_platforms$1$ = -1048					; size = 4
_deviceCount$ = -1044					; size = 4
_info$1 = -1040						; size = 8
_info$2 = -1040						; size = 8
_pass$1$ = -1036					; size = 4
_platformVendor$3 = -1032				; size = 1024
__$ArrayPad$ = -4					; size = 4
?CountOpenCLDevices@@YAXXZ PROC				; CountOpenCLDevices, COMDAT

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);

	mov	edi, DWORD PTR __imp__clGetPlatformIDs@12
	lea	eax, DWORD PTR _numPlatforms$[ebp]
	push	eax
	push	0
	push	0
	mov	DWORD PTR ?openCLDeviceCount@@3HA, 0	; openCLDeviceCount
	call	edi

; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)

	test	eax, eax
	jne	$LN44@CountOpenC
	mov	esi, DWORD PTR _numPlatforms$[ebp]
	test	esi, esi
	je	$LN44@CountOpenC

; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);

	lea	eax, DWORD PTR [esi*4]
	push	eax
	call	_malloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _platforms$1$[ebp], ebx

; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	ebx, ebx
	jne	$LN43@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN173@CountOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	SHORT $LN42@CountOpenC
	push	5
	push	OFFSET $SG4294899404
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899403
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN41@CountOpenC
$LN42@CountOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899402
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN41@CountOpenC:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN180@CountOpenC:
$LN173@CountOpenC:
	mov	esi, DWORD PTR _numPlatforms$[ebp]
$LN43@CountOpenC:

; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);

	push	0
	push	ebx
	push	esi
	call	edi

; 940  :     OPENCL_ERROR(errorCode);

	mov	esi, eax
	test	esi, esi
	je	$LN40@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN40@CountOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN39@CountOpenC
	push	15					; 0000000fH
	push	OFFSET $SG4294899401
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899400
$LN178@CountOpenC:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN77@CountOpenC
$LN39@CountOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899399
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
	npad	3
$LL37@CountOpenC:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN33@CountOpenC
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN36@CountOpenC
$LN33@CountOpenC:
	lea	edx, DWORD PTR [ecx+1]
$LN36@CountOpenC:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL37@CountOpenC
	push	940					; 000003acH
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899398
	call	_printf
	add	esp, 16					; 00000010H
$LN177@CountOpenC:
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN77@CountOpenC:

; 940  :     OPENCL_ERROR(errorCode);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN181@CountOpenC:
$LN40@CountOpenC:

; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;

	xor	ebx, ebx

; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {

	xor	esi, esi
	mov	DWORD PTR _pass$1$[ebp], esi
	npad	1
$LL32@CountOpenC:

; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {

	xor	edi, edi
	mov	DWORD PTR _platformIndex$1$[ebp], edi
	cmp	DWORD PTR _numPlatforms$[ebp], edi
	jbe	$LN27@CountOpenC
	mov	esi, DWORD PTR _platforms$1$[ebp]
	npad	6
$LL29@CountOpenC:

; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);

	push	0
	lea	eax, DWORD PTR _platformVendor$3[ebp]
	push	eax
	push	1024					; 00000400H
	push	2307					; 00000903H
	push	DWORD PTR [esi+edi*4]
	call	DWORD PTR __imp__clGetPlatformInfo@20

; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)

	test	eax, eax
	jne	$LN28@CountOpenC

; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )

	mov	ecx, OFFSET $SG4294899397
	lea	eax, DWORD PTR _platformVendor$3[ebp]
	npad	1
$LL165@CountOpenC:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN166@CountOpenC
	test	dl, dl
	je	SHORT $LN167@CountOpenC
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN166@CountOpenC
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL165@CountOpenC
$LN167@CountOpenC:
	xor	eax, eax
	jmp	SHORT $LN168@CountOpenC
$LN166@CountOpenC:
	sbb	eax, eax
	or	eax, 1
$LN168@CountOpenC:
	test	eax, eax
	jne	SHORT $LN23@CountOpenC
	cmp	DWORD PTR ?options@@3UOptions@@A+76, eax
	je	$LN28@CountOpenC
$LN23@CountOpenC:
	mov	ecx, OFFSET $SG4294899396
	lea	eax, DWORD PTR _platformVendor$3[ebp]
$LL169@CountOpenC:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN170@CountOpenC
	test	dl, dl
	je	SHORT $LN171@CountOpenC
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN170@CountOpenC
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL169@CountOpenC
$LN171@CountOpenC:
	xor	eax, eax
	jmp	SHORT $LN172@CountOpenC
$LN170@CountOpenC:
	sbb	eax, eax
	or	eax, 1
$LN172@CountOpenC:
	test	eax, eax
	je	$LN28@CountOpenC

; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);

	lea	eax, DWORD PTR _deviceCount$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	-1
	push	DWORD PTR [esi+edi*4]
	call	DWORD PTR __imp__clGetDeviceIDs@24

; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)

	test	eax, eax
	jne	$LN28@CountOpenC

; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);

	mov	edi, DWORD PTR _deviceCount$[ebp]
	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	_malloc
	mov	esi, eax
	add	esp, 4

; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	esi, esi
	jne	SHORT $LN21@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN146@CountOpenC
	mov	edi, DWORD PTR _deviceCount$[ebp]
$LN21@CountOpenC:

; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);

	mov	ecx, DWORD PTR _platforms$1$[ebp]
	lea	eax, DWORD PTR _deviceCount$[ebp]
	push	eax
	mov	eax, DWORD PTR _platformIndex$1$[ebp]
	push	esi
	push	edi
	push	0
	push	12					; 0000000cH
	push	DWORD PTR [ecx+eax*4]
	call	DWORD PTR __imp__clGetDeviceIDs@24
	mov	edi, eax

; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {

	cmp	edi, -1
	je	SHORT $LN174@CountOpenC

; 966  : 				OPENCL_ERROR(errorCode);

	test	edi, edi
	je	SHORT $LN17@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN147@CountOpenC
$LN17@CountOpenC:

; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {

	mov	ecx, DWORD PTR _deviceCount$[ebp]
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN174@CountOpenC
	mov	edx, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	mov	edi, DWORD PTR _pass$1$[ebp]
	npad	2
$LL9@CountOpenC:

; 968  : 					if (pass == 0) {

	test	edi, edi
	jne	SHORT $LN6@CountOpenC

; 969  : 						++openCLDeviceCount;

	inc	DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount

; 970  : 					} else {

	jmp	SHORT $LN8@CountOpenC
$LN6@CountOpenC:

; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];

	mov	ecx, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ebx*4], ecx
	inc	ebx
	mov	ecx, DWORD PTR _deviceCount$[ebp]
$LN8@CountOpenC:

; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {

	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL9@CountOpenC
$LN174@CountOpenC:

; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);

	push	esi
	call	_free
	mov	edi, DWORD PTR _platformIndex$1$[ebp]
	add	esp, 4
	mov	esi, DWORD PTR _platforms$1$[ebp]
$LN28@CountOpenC:

; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {

	inc	edi
	mov	DWORD PTR _platformIndex$1$[ebp], edi
	cmp	edi, DWORD PTR _numPlatforms$[ebp]
	jb	$LL29@CountOpenC
	mov	esi, DWORD PTR _pass$1$[ebp]
$LN27@CountOpenC:

; 976  : 		}
; 977  : 		if (pass == 0) {

	test	esi, esi
	jne	SHORT $LN31@CountOpenC

; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);

	mov	eax, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A, eax ; openCLDeviceIDArray

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	SHORT $LN31@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN148@CountOpenC
$LN31@CountOpenC:

; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {

	inc	esi
	mov	DWORD PTR _pass$1$[ebp], esi
	cmp	esi, 1
	jle	$LL32@CountOpenC

; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);

	mov	ecx, DWORD PTR _platforms$1$[ebp]
	push	ecx
	call	_free
	add	esp, 4
$LN44@CountOpenC:

; 984  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@CountOpenC:

; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN20@CountOpenC
	push	5
	push	OFFSET $SG4294899395
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899394
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN19@CountOpenC
$LN20@CountOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899393
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN19@CountOpenC:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN182@CountOpenC:
$LN147@CountOpenC:

; 966  : 				OPENCL_ERROR(errorCode);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN16@CountOpenC
	push	15					; 0000000fH
	push	OFFSET $SG4294899392
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899391
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN108@CountOpenC
$LN16@CountOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899390
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
	npad	4
$LL14@CountOpenC:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN10@CountOpenC
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN13@CountOpenC
$LN10@CountOpenC:
	lea	edx, DWORD PTR [ecx+1]
$LN13@CountOpenC:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL14@CountOpenC
	push	966					; 000003c6H
	push	edx
	mov	ecx, edi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899389
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$1[ebp]
	mov	DWORD PTR _info$1[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$1[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN108@CountOpenC:

; 966  : 				OPENCL_ERROR(errorCode);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN183@CountOpenC:
$LN148@CountOpenC:

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@CountOpenC
	push	5
	push	OFFSET $SG4294899388
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899387
	jmp	$LN178@CountOpenC
$LN2@CountOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899386
	call	_printf
	add	esp, 8
	jmp	$LN177@CountOpenC
$LN179@CountOpenC:
?CountOpenCLDevices@@YAXXZ ENDP				; CountOpenCLDevices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListOpenCLDevices@@YAXXZ
_TEXT	SEGMENT
_info$1 = -2160						; size = 8
_info$2 = -2152						; size = 8
_info$3 = -2144						; size = 8
_numComputeUnits$ = -2136				; size = 4
_cursorPos$4 = -2132					; size = 4
_cursorPos$5 = -2132					; size = 4
_cursorPos$6 = -2132					; size = 4
_scrnBufInfo$7 = -2128					; size = 22
_scrnBufInfo$8 = -2104					; size = 22
_scrnBufInfo$9 = -2080					; size = 22
_deviceName$ = -2056					; size = 1024
_deviceVendor$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
?ListOpenCLDevices@@YAXXZ PROC				; ListOpenCLDevices, COMDAT

; 987  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2164				; 00000874H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();

	call	?CountOpenCLDevices@@YAXXZ		; CountOpenCLDevices

; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  

	xor	edi, edi
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, edi	; openCLDeviceCount
	jle	$LN125@ListOpenCL
	mov	ebx, DWORD PTR __imp__clGetDeviceInfo@20
$LN140@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	push	0
	lea	eax, DWORD PTR _deviceVendor$[ebp]
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4140					; 0000102cH
	push	DWORD PTR [eax+edi*4]
	call	ebx
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN32@ListOpenCL
$LL41@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	cl
	movzx	ecx, cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	ecx, ecx
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN40@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN55@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL41@ListOpenCL
$LN55@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL41@ListOpenCL
$LN40@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	test	eax, eax
	je	$LN108@ListOpenCL
$LN32@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	mov	ebx, DWORD PTR __imp__clGetDeviceInfo@20
	lea	eax, DWORD PTR _deviceName$[ebp]
	push	0
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4139					; 0000102bH
	push	DWORD PTR [eax+edi*4]
	call	ebx
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN24@ListOpenCL
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN109@ListOpenCL
$LN24@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	push	0
	lea	eax, DWORD PTR _numComputeUnits$[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	4
	push	4098					; 00001002H
	push	DWORD PTR [eax+edi*4]
	call	ebx
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN16@ListOpenCL
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN110@ListOpenCL
$LN16@ListOpenCL:

; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {

	mov	ecx, OFFSET $SG4294899373
	lea	eax, DWORD PTR _deviceVendor$[ebp]
$LL126@ListOpenCL:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN127@ListOpenCL
	test	dl, dl
	je	SHORT $LN128@ListOpenCL
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN127@ListOpenCL
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL126@ListOpenCL
$LN128@ListOpenCL:
	xor	eax, eax
	jmp	SHORT $LN129@ListOpenCL
$LN127@ListOpenCL:
	sbb	eax, eax
	or	eax, 1
$LN129@ListOpenCL:
	test	eax, eax
	jne	SHORT $LN8@ListOpenCL

; 1003 : 			printf("AMD ");

	push	OFFSET $SG4294899372
	call	_printf
	add	esp, 4
	jmp	$LN3@ListOpenCL
$LN8@ListOpenCL:

; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {

	mov	ecx, OFFSET $SG4294899371
	lea	eax, DWORD PTR _deviceVendor$[ebp]
	npad	7
$LL130@ListOpenCL:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN131@ListOpenCL
	test	dl, dl
	je	SHORT $LN132@ListOpenCL
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN131@ListOpenCL
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL130@ListOpenCL
$LN132@ListOpenCL:
	xor	eax, eax
	jmp	SHORT $LN133@ListOpenCL
$LN131@ListOpenCL:
	sbb	eax, eax
	or	eax, 1
$LN133@ListOpenCL:
	test	eax, eax
	je	SHORT $LN3@ListOpenCL

; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {

	mov	ecx, OFFSET $SG4294899370
	lea	eax, DWORD PTR _deviceVendor$[ebp]
$LL134@ListOpenCL:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN135@ListOpenCL
	test	dl, dl
	je	SHORT $LN136@ListOpenCL
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN135@ListOpenCL
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL134@ListOpenCL
$LN136@ListOpenCL:
	xor	eax, eax
	jmp	SHORT $LN137@ListOpenCL
$LN135@ListOpenCL:
	sbb	eax, eax
	or	eax, 1
$LN137@ListOpenCL:
	test	eax, eax
	jne	SHORT $LN4@ListOpenCL

; 1007 : 			printf("NVIDIA ");

	push	OFFSET $SG4294899369
	call	_printf
	add	esp, 4

; 1008 : 		} else {

	jmp	SHORT $LN3@ListOpenCL
$LN4@ListOpenCL:

; 1009 : 			printf("%s ", deviceVendor);

	lea	eax, DWORD PTR _deviceVendor$[ebp]
	push	eax
	push	OFFSET $SG4294899368
	call	_printf
	add	esp, 8
$LN3@ListOpenCL:

; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);

	push	DWORD PTR _numComputeUnits$[ebp]
	lea	edx, DWORD PTR _deviceName$[ebp]
	lea	ecx, DWORD PTR _deviceVendor$[ebp]
	call	?GetProductNameForOpenCLDevice@@YAPADPAD0I@Z ; GetProductNameForOpenCLDevice
	add	esp, 4

; 1012 : 		if (productName) {

	test	eax, eax
	je	SHORT $LN2@ListOpenCL

; 1013 : 			printf("%s", productName);

	push	eax
	push	OFFSET $SG4294899367

; 1014 : 		} else {

	jmp	SHORT $LN139@ListOpenCL
$LN2@ListOpenCL:

; 1015 : 			printf("%s", deviceName);

	lea	eax, DWORD PTR _deviceName$[ebp]
	push	eax
	push	OFFSET $SG4294899366
$LN139@ListOpenCL:
	call	_printf
	add	esp, 8

; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");

	push	OFFSET $SG4294899365
	call	_printf
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	$LN140@ListOpenCL
$LN125@ListOpenCL:

; 1018 : 	}
; 1019 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN31@ListOpenCL
	push	15					; 0000000fH
	push	OFFSET $SG4294899385
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899384
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN87@ListOpenCL
$LN31@ListOpenCL:
	mov	esi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$9[ebp]
	mov	edi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	edi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN83@ListOpenCL

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$9[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$6[ebp], ax
	movsx	eax, cx
	add	eax, esi
	js	SHORT $LN85@ListOpenCL
	lea	eax, DWORD PTR [esi+ecx]
	jmp	SHORT $LN141@ListOpenCL
$LN85@ListOpenCL:
	xor	eax, eax
$LN141@ListOpenCL:
	mov	WORD PTR _cursorPos$6[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$6[ebp]
	push	-11					; fffffff5H
	call	edi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN83@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	mov	ecx, OFFSET $SG4294899383
	mov	al, 46					; 0000002eH
	mov	edx, ecx
	npad	2
$LL29@ListOpenCL:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN25@ListOpenCL
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN28@ListOpenCL
$LN25@ListOpenCL:
	lea	edx, DWORD PTR [ecx+1]
$LN28@ListOpenCL:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL29@ListOpenCL
	push	998					; 000003e6H
	push	edx
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899382
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H
	call	edi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN87@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN145@ListOpenCL:
$LN109@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN23@ListOpenCL
	push	15					; 0000000fH
	push	OFFSET $SG4294899381
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899380
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN94@ListOpenCL
$LN23@ListOpenCL:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$8[ebp]
	mov	ebx, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN90@ListOpenCL

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$8[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$5[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN92@ListOpenCL
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN142@ListOpenCL
$LN92@ListOpenCL:
	xor	eax, eax
$LN142@ListOpenCL:
	mov	WORD PTR _cursorPos$5[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$5[ebp]
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN90@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	mov	ecx, OFFSET $SG4294899379
	mov	al, 46					; 0000002eH
	mov	edx, ecx
	npad	6
$LL21@ListOpenCL:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN17@ListOpenCL
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN20@ListOpenCL
$LN17@ListOpenCL:
	lea	edx, DWORD PTR [ecx+1]
$LN20@ListOpenCL:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL21@ListOpenCL
	push	999					; 000003e7H
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899378
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$1[ebp]
	mov	DWORD PTR _info$1[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$1[ebp], 100		; 00000064H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN94@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN146@ListOpenCL:
$LN110@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN15@ListOpenCL
	push	15					; 0000000fH
	push	OFFSET $SG4294899377
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899376
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN101@ListOpenCL
$LN15@ListOpenCL:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$7[ebp]
	mov	ebx, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN97@ListOpenCL

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$7[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$4[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN99@ListOpenCL
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN143@ListOpenCL
$LN99@ListOpenCL:
	xor	eax, eax
$LN143@ListOpenCL:
	mov	WORD PTR _cursorPos$4[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$4[ebp]
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN97@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	mov	ecx, OFFSET $SG4294899375
	mov	al, 46					; 0000002eH
	mov	edx, ecx
	npad	6
$LL13@ListOpenCL:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN9@ListOpenCL
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN12@ListOpenCL
$LN9@ListOpenCL:
	lea	edx, DWORD PTR [ecx+1]
$LN12@ListOpenCL:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL13@ListOpenCL
	push	1000					; 000003e8H
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899374
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$3[ebp]
	mov	DWORD PTR _info$3[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$3[ebp], 100		; 00000064H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN101@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN147@ListOpenCL:
$LN144@ListOpenCL:
	int	3
?ListOpenCLDevices@@YAXXZ ENDP				; ListOpenCLDevices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListGPUsAndExit@@YAXXZ
_TEXT	SEGMENT
?ListGPUsAndExit@@YAXXZ PROC				; ListGPUsAndExit, COMDAT

; 1022 : {

	push	ecx

; 1023 : 	if (!options.useOpenCLForCUDADevices)

	cmp	DWORD PTR ?options@@3UOptions@@A+76, 0
	jne	SHORT $LN1@ListGPUsAn

; 1024 : 		ListCUDADevices();

	call	?ListCUDADevices@@YAXXZ			; ListCUDADevices
$LN1@ListGPUsAn:

; 1025 : 	ListOpenCLDevices();

	call	?ListOpenCLDevices@@YAXXZ		; ListOpenCLDevices

; 1026 : 	exit(0);

	push	0
	call	_exit
$LN5@ListGPUsAn:
$LN4@ListGPUsAn:
	int	3
?ListGPUsAndExit@@YAXXZ ENDP				; ListGPUsAndExit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?InitSearchDevices@@YAXH@Z
_TEXT	SEGMENT
_sysInfo$1 = -4780					; size = 36
_results$2 = -4744					; size = 16
_globalMemorySize$3 = -4736				; size = 8
_clockFrequency$4 = -4728				; size = 4
_maxWorkGroupSize$5 = -4724				; size = 4
_displayDeviceInformation$1$ = -4720			; size = 4
_numComputeUnits$6 = -4716				; size = 4
_info$7 = -4712						; size = 8
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
__errorCode$1$ = -4708					; size = 4
_CUDADeviceProperties$ = -4704				; size = 596
_deviceVersion$8 = -4104				; size = 1024
_driverVersion$9 = -3080				; size = 1024
_deviceVendor$10 = -2056				; size = 1024
_deviceName$11 = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
?InitSearchDevices@@YAXH@Z PROC				; InitSearchDevices, COMDAT
; _displayDeviceInformation$ = ecx

; 1030 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4780				; 000012acH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {

	cmp	DWORD PTR ?options@@3UOptions@@A+76, 0
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _displayDeviceInformation$1$[ebp], ebx
	je	SHORT $LN110@InitSearch

; 1035 : 		CUDADeviceCount = 0;

	mov	DWORD PTR ?CUDADeviceCount@@3HA, 0	; CUDADeviceCount

; 1036 : 	} else {

	jmp	SHORT $LN109@InitSearch
$LN110@InitSearch:

; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);

	push	OFFSET ?CUDADeviceCount@@3HA		; CUDADeviceCount
	call	DWORD PTR __imp__cudaGetDeviceCount@4
$LN109@InitSearch:

; 1038 : 	}
; 1039 : 	CountOpenCLDevices();

	call	?CountOpenCLDevices@@YAXXZ		; CountOpenCLDevices

; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");

	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	cmp	ecx, -1
	je	$LN197@InitSearch
	test	ecx, ecx
	js	SHORT $LN107@InitSearch
	mov	eax, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	eax, edx
	cmp	eax, ecx
	jg	$LN108@InitSearch
$LN107@InitSearch:
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN198@InitSearch
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN106@InitSearch
	push	10					; 0000000aH
	push	OFFSET $SG4294899364
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899363
$LN208@InitSearch:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN130@InitSearch
$LN106@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899362
	push	OFFSET $SG4294899361
	call	_printf
	add	esp, 8
$LN207@InitSearch:
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$7[ebp]
	mov	DWORD PTR _info$7[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$7[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN130@InitSearch:

; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN210@InitSearch:
$LN198@InitSearch:
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
$LN197@InitSearch:
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
$LN108@InitSearch:

; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {

	mov	eax, DWORD PTR ?options@@3UOptions@@A+20
	test	eax, eax
	jne	SHORT $LN104@InitSearch

; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);

	test	edx, edx
	jg	SHORT $LN113@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, eax	; openCLDeviceCount
	jg	SHORT $LN113@InitSearch
	mov	eax, 3
	mov	DWORD PTR ?searchDevice@@3HA, eax	; searchDevice
	jmp	$LN102@InitSearch
$LN113@InitSearch:
	mov	eax, 2
	mov	DWORD PTR ?searchDevice@@3HA, eax	; searchDevice

; 1046 : 	} else {

	jmp	SHORT $LN101@InitSearch
$LN104@InitSearch:

; 1047 : 		searchDevice = options.searchDevice;

	mov	DWORD PTR ?searchDevice@@3HA, eax	; searchDevice

; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");

	cmp	eax, 2
	je	SHORT $LN101@InitSearch
	cmp	eax, 1
	jne	$LN102@InitSearch
$LN101@InitSearch:
	test	edx, edx
	jg	$LN102@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 0	; openCLDeviceCount
	jg	$LN102@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN199@InitSearch
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN100@InitSearch
	push	10					; 0000000aH
	push	OFFSET $SG4294899360
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899359
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN99@InitSearch
$LN100@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899358
	push	OFFSET $SG4294899357
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN99@InitSearch:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN211@InitSearch:
$LN199@InitSearch:
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN102@InitSearch:

; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;

	mov	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads

; 1070 : 	numOpenCLDeviceSearchThreads = 0;

	mov	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads

; 1071 : 	numCPUSearchThreads          = 0;

	mov	DWORD PTR ?numCPUSearchThreads@@3HA, 0	; numCPUSearchThreads

; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {

	cmp	eax, 2
	je	SHORT $LN97@InitSearch
	cmp	eax, 1
	jne	$LN90@InitSearch
$LN97@InitSearch:
	test	edx, edx
	jle	$LN90@InitSearch
	cmp	DWORD PTR ?options@@3UOptions@@A+76, 0
	jne	$LN90@InitSearch
	cmp	ecx, -1
	je	SHORT $LN96@InitSearch
	cmp	ecx, edx
	jge	$LN90@InitSearch
$LN96@InitSearch:

; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {

	test	ebx, ebx
	je	SHORT $LN93@InitSearch
	cmp	edx, 1
	jle	SHORT $LN95@InitSearch
	cmp	ecx, -1
	jne	SHORT $LN95@InitSearch

; 1079 : 			printf("CUDA DEVICES\n");

	push	OFFSET $SG4294899356
	call	_printf
	add	esp, 4

; 1080 : 			printf("============\n");

	push	OFFSET $SG4294899355
	call	_printf
	add	esp, 4

; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);

	push	DWORD PTR ?CUDADeviceCount@@3HA		; CUDADeviceCount
	push	OFFSET $SG4294899354
	call	_printf
	add	esp, 8
	jmp	SHORT $LN203@InitSearch
$LN95@InitSearch:

; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");

	push	OFFSET $SG4294899353
	call	_printf
	add	esp, 4

; 1084 : 			printf("===========\n");

	push	OFFSET $SG4294899352
	call	_printf
	add	esp, 4
$LN203@InitSearch:
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
$LN93@InitSearch:

; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );

	mov	edi, DWORD PTR __imp__cudaGetDeviceProperties@8
	xor	eax, eax
	cmp	ecx, -1
	mov	esi, ecx
	cmove	esi, eax
$LL92@InitSearch:

; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {

	mov	eax, edx
	cmp	ecx, -1
	je	SHORT $LN116@InitSearch
	lea	eax, DWORD PTR [ecx+1]
$LN116@InitSearch:
	cmp	esi, eax
	jge	$LN200@InitSearch

; 1089 : 			if (displayDeviceInformation) {

	test	ebx, ebx
	je	$LN89@InitSearch

; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);

	push	esi
	lea	eax, DWORD PTR _CUDADeviceProperties$[ebp]
	push	eax
	call	edi

; 1091 : 				printf(    "  Device No.:               %d\n",      i);

	push	esi
	push	OFFSET $SG4294899351
	call	_printf

; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);

	lea	eax, DWORD PTR _CUDADeviceProperties$[ebp]
	push	eax
	push	OFFSET $SG4294899350
	call	_printf

; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);

	push	DWORD PTR _CUDADeviceProperties$[ebp+332]
	push	OFFSET $SG4294899349
	call	_printf
	movd	xmm0, DWORD PTR _CUDADeviceProperties$[ebp+304]

; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);

	add	esp, 16					; 00000010H
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3a83126f
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG4294899348
	call	_printf
	add	esp, 12					; 0000000cH

; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);

	push	DWORD PTR _CUDADeviceProperties$[ebp+316]
	push	DWORD PTR _CUDADeviceProperties$[ebp+312]
	push	OFFSET $SG4294899347
	call	_printf

; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );

	mov	ecx, DWORD PTR _CUDADeviceProperties$[ebp+348]
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	jne	SHORT $LN121@InitSearch
	mov	eax, OFFSET $SG4294899346
	jmp	SHORT $LN118@InitSearch
$LN121@InitSearch:
	cmp	ecx, 1
	jne	SHORT $LN119@InitSearch
	mov	eax, OFFSET $SG4294899345
	jmp	SHORT $LN118@InitSearch
$LN119@InitSearch:
	cmp	ecx, 2
	jne	SHORT $LN117@InitSearch
	mov	eax, OFFSET $SG4294899344
	jmp	SHORT $LN118@InitSearch
$LN117@InitSearch:
	cmp	ecx, 3
	mov	eax, OFFSET $SG4294899343
	mov	ecx, OFFSET $SG4294899342
	cmovne	eax, ecx
$LN118@InitSearch:
	push	eax
	push	OFFSET $SG4294899341
	call	_printf

; 1102 : 				printf("\n");

	push	OFFSET $SG4294899340
	call	_printf
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
$LN89@InitSearch:

; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;

	add	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 2 ; numCUDADeviceSearchThreads
	inc	esi
	jmp	$LL92@InitSearch
$LN200@InitSearch:

; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN90@InitSearch:

; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {

	cmp	eax, 2
	je	SHORT $LN87@InitSearch
	cmp	eax, 1
	jne	$LN80@InitSearch
$LN87@InitSearch:
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 0	; openCLDeviceCount
	jle	$LN80@InitSearch
	cmp	ecx, -1
	je	SHORT $LN86@InitSearch
	cmp	edx, ecx
	jg	$LN80@InitSearch
$LN86@InitSearch:

; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {

	test	ebx, ebx
	je	SHORT $LN83@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 1	; openCLDeviceCount
	jle	SHORT $LN85@InitSearch
	cmp	ecx, -1
	jne	SHORT $LN85@InitSearch

; 1113 : 			printf("OPENCL DEVICES\n");

	push	OFFSET $SG4294899339
	call	_printf
	add	esp, 4

; 1114 : 			printf("==============\n");

	push	OFFSET $SG4294899338
	call	_printf
	add	esp, 4

; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);

	push	DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	push	OFFSET $SG4294899337
	call	_printf
	add	esp, 8
	jmp	SHORT $LN204@InitSearch
$LN85@InitSearch:

; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");

	push	OFFSET $SG4294899336
	call	_printf
	add	esp, 4

; 1118 : 			printf("=============\n");

	push	OFFSET $SG4294899335
	call	_printf
	add	esp, 4
$LN204@InitSearch:
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
$LN83@InitSearch:

; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;

	cmp	DWORD PTR ?options@@3UOptions@@A+96, 0
	je	SHORT $LN123@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 1	; openCLDeviceCount
	jle	SHORT $LN123@InitSearch
	cmp	ecx, -1
	je	SHORT $LN124@InitSearch
$LN123@InitSearch:
	cmp	DWORD PTR ?options@@3UOptions@@A+100, 1
	mov	DWORD PTR ?openCLRunChildProcesses@@3HA, 0 ; openCLRunChildProcesses
	jle	SHORT $LN125@InitSearch
$LN124@InitSearch:
	mov	DWORD PTR ?openCLRunChildProcesses@@3HA, 1 ; openCLRunChildProcesses
$LN125@InitSearch:

; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));

	mov	edi, DWORD PTR __imp__clGetDeviceInfo@20
	cmp	ecx, -1
	mov	ebx, ecx
	cmove	ebx, edx
$LL82@InitSearch:

; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {

	cmp	ecx, -1
	jne	SHORT $LN126@InitSearch
	mov	ecx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	add	ecx, edx
	jmp	SHORT $LN127@InitSearch
$LN126@InitSearch:
	inc	ecx
$LN127@InitSearch:
	cmp	ebx, ecx
	jge	$LN201@InitSearch

; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	push	0
	lea	eax, DWORD PTR _deviceVendor$10[ebp]
	mov	esi, ebx
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	sub	esi, edx
	push	1024					; 00000400H
	push	4140					; 0000102cH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN79@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN158@InitSearch
$LN79@InitSearch:

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	push	0
	lea	eax, DWORD PTR _deviceName$11[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4139					; 0000102bH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN71@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN159@InitSearch
$LN71@InitSearch:

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	push	0
	lea	eax, DWORD PTR _deviceVersion$8[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4143					; 0000102fH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN63@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN160@InitSearch
$LN63@InitSearch:

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	push	0
	lea	eax, DWORD PTR _driverVersion$9[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4141					; 0000102dH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN55@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN161@InitSearch
$LN55@InitSearch:

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	push	0
	lea	eax, DWORD PTR _globalMemorySize$3[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	8
	push	4127					; 0000101fH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN47@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN162@InitSearch
$LN47@InitSearch:

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	push	0
	lea	eax, DWORD PTR _clockFrequency$4[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	4
	push	4108					; 0000100cH
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN39@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN163@InitSearch
$LN39@InitSearch:

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	push	0
	lea	eax, DWORD PTR _numComputeUnits$6[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	4
	push	4098					; 00001002H
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN31@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN164@InitSearch
$LN31@InitSearch:

; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));

	push	0
	lea	eax, DWORD PTR _maxWorkGroupSize$5[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	4
	push	4100					; 00001004H
	push	DWORD PTR [eax+esi*4]
	call	edi
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN23@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN165@InitSearch
$LN23@InitSearch:

; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);

	push	DWORD PTR _numComputeUnits$6[ebp]
	lea	edx, DWORD PTR _deviceName$11[ebp]
	lea	ecx, DWORD PTR _deviceVendor$10[ebp]
	call	?GetProductNameForOpenCLDevice@@YAPADPAD0I@Z ; GetProductNameForOpenCLDevice
	add	esp, 4
	mov	esi, eax

; 1147 : 			if (displayDeviceInformation) {

	cmp	DWORD PTR _displayDeviceInformation$1$[ebp], 0
	je	$LN15@InitSearch

; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);

	lea	eax, DWORD PTR _deviceVendor$10[ebp]
	push	eax
	push	OFFSET $SG4294899302
	call	_printf
	add	esp, 8

; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);

	lea	eax, DWORD PTR _deviceName$11[ebp]
	test	esi, esi
	je	SHORT $LN14@InitSearch
	push	esi
	push	eax
	push	OFFSET $SG4294899301
	call	_printf
	add	esp, 12					; 0000000cH

; 1151 : 				} else {

	jmp	SHORT $LN13@InitSearch
$LN14@InitSearch:

; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);

	push	eax
	push	OFFSET $SG4294899300
	call	_printf
	add	esp, 8
$LN13@InitSearch:

; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);

	push	DWORD PTR _numComputeUnits$6[ebp]
	push	OFFSET $SG4294899299
	call	_printf

; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);

	push	DWORD PTR _clockFrequency$4[ebp]
	push	OFFSET $SG4294899298
	call	_printf

; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));

	mov	ecx, DWORD PTR _globalMemorySize$3[ebp]
	mov	eax, DWORD PTR _globalMemorySize$3[ebp+4]
	shrd	ecx, eax, 20
	push	ecx
	shr	eax, 20					; 00000014H
	push	OFFSET $SG4294899297
	call	_printf

; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);

	push	DWORD PTR _maxWorkGroupSize$5[ebp]
	push	OFFSET $SG4294899296
	call	_printf

; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);

	lea	eax, DWORD PTR _deviceVersion$8[ebp]
	push	eax
	push	OFFSET $SG4294899295
	call	_printf

; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);

	lea	eax, DWORD PTR _driverVersion$9[ebp]
	push	eax
	push	OFFSET $SG4294899294
	call	_printf

; 1160 : 				printf("\n");

	push	OFFSET $SG4294899293
	call	_printf
	add	esp, 52					; 00000034H
$LN15@InitSearch:

; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, 0 ; openCLRunChildProcesses

; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;

	mov	eax, DWORD PTR ?options@@3UOptions@@A+100
	jne	SHORT $LN205@InitSearch

; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;

	mov	eax, DWORD PTR ?options@@3UOptions@@A+44
$LN205@InitSearch:
	add	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, eax ; numOpenCLDeviceSearchThreads
	inc	ebx
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jmp	$LL82@InitSearch
$LN158@InitSearch:

; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN78@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899334
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899333
	jmp	$LN208@InitSearch
$LN78@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899332
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
	npad	4
$LL76@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN72@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN75@InitSearch
$LN72@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN75@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL76@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1138					; 00000472H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899331
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN159@InitSearch:

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN70@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899330
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899329
	jmp	$LN208@InitSearch
$LN70@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899328
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL68@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN64@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN67@InitSearch
$LN64@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN67@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL68@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1139					; 00000473H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899327
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN160@InitSearch:

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN62@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899326
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899325
	jmp	$LN208@InitSearch
$LN62@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899324
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL60@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN56@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN59@InitSearch
$LN56@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN59@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL60@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1140					; 00000474H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899323
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN161@InitSearch:

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN54@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899322
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899321
	jmp	$LN208@InitSearch
$LN54@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899320
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL52@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN48@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN51@InitSearch
$LN48@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN51@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL52@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1141					; 00000475H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899319
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN162@InitSearch:

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN46@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899318
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899317
	jmp	$LN208@InitSearch
$LN46@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899316
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL44@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN40@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN43@InitSearch
$LN40@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN43@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL44@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1142					; 00000476H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899315
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN163@InitSearch:

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN38@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899314
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899313
	jmp	$LN208@InitSearch
$LN38@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899312
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL36@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN32@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN35@InitSearch
$LN32@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN35@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL36@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1143					; 00000477H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899311
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN164@InitSearch:

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN30@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899310
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899309
	jmp	$LN208@InitSearch
$LN30@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899308
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL28@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN24@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN27@InitSearch
$LN24@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN27@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL28@InitSearch
	mov	ecx, DWORD PTR __errorCode$1$[ebp]
	push	1144					; 00000478H
	push	edx
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899307
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN165@InitSearch:

; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN22@InitSearch
	push	15					; 0000000fH
	push	OFFSET $SG4294899306
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899305
	jmp	$LN208@InitSearch
$LN22@InitSearch:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899304
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL20@InitSearch:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN16@InitSearch
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN19@InitSearch
$LN16@InitSearch:
	lea	edx, DWORD PTR [ecx+1]
$LN19@InitSearch:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL20@InitSearch
	push	1145					; 00000479H
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899303
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN207@InitSearch
$LN201@InitSearch:
	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	mov	ebx, DWORD PTR _displayDeviceInformation$1$[ebp]
$LN80@InitSearch:

; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {

	cmp	eax, 3
	je	SHORT $LN9@InitSearch
	cmp	eax, 1
	jne	$LN3@InitSearch
$LN9@InitSearch:

; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);

	lea	eax, DWORD PTR _sysInfo$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemInfo@4

; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 

	mov	eax, DWORD PTR ?options@@3UOptions@@A+28

; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;

	mov	ecx, DWORD PTR _sysInfo$1[ebp+20]
	cmp	eax, -1
	jne	SHORT $LN8@InitSearch

; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jne	$LN5@InitSearch

; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;

	mov	edx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	mov	esi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	lea	eax, DWORD PTR [edx+esi]
	cmp	ecx, eax
	jle	SHORT $LN128@InitSearch
	sub	ecx, edx
	sub	ecx, esi
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jmp	SHORT $LN195@InitSearch
$LN128@InitSearch:
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, 0	; numCPUSearchThreads

; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;

	mov	DWORD PTR ?searchDevice@@3HA, 2		; searchDevice

; 1202 : 		}
; 1203 : 	}
; 1204 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@InitSearch:

; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;

	cmp	eax, ecx
	cmovb	ecx, eax

; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jne	SHORT $LN5@InitSearch
$LN195@InitSearch:
	test	ecx, ecx
	jg	SHORT $LN5@InitSearch

; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;

	mov	DWORD PTR ?searchDevice@@3HA, 2		; searchDevice

; 1202 : 		}
; 1203 : 	}
; 1204 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@InitSearch:

; 1188 : 		} else 	if (displayDeviceInformation) {

	test	ebx, ebx
	je	$LN3@InitSearch

; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);

	lea	esi, DWORD PTR _results$2[ebp]
	xor	ecx, ecx
	mov	eax, 1
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx

; 1191 : 
; 1192 : 			printf("CPU\n");

	push	OFFSET $SG4294899292
	mov	DWORD PTR [esi+12], edx
	call	_printf
	add	esp, 4

; 1193 : 			printf("===\n");

	push	OFFSET $SG4294899291
	call	_printf
	add	esp, 4

; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {

	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture

; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);

	push	DWORD PTR _results$2[ebp]
	test	eax, eax
	je	SHORT $LN2@InitSearch
	push	OFFSET $SG4294899290

; 1196 : 			} else {

	jmp	SHORT $LN206@InitSearch
$LN2@InitSearch:

; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);

	push	OFFSET $SG4294899289
$LN206@InitSearch:
	call	_printf
	add	esp, 8

; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);

	push	DWORD PTR _sysInfo$1[ebp+20]
	push	OFFSET $SG4294899288
	call	_printf

; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);

	push	DWORD PTR ?numCPUSearchThreads@@3HA	; numCPUSearchThreads
	push	OFFSET $SG4294899287
	call	_printf

; 1201 : 			printf("\n");

	push	OFFSET $SG4294899286
	call	_printf
	add	esp, 20					; 00000014H
$LN3@InitSearch:

; 1202 : 		}
; 1203 : 	}
; 1204 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@InitSearch:
?InitSearchDevices@@YAXH@Z ENDP				; InitSearchDevices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ObtainOptions@@YAXHPAPAD@Z
_TEXT	SEGMENT
_info$1 = -3240						; size = 8
_info$2 = -3232						; size = 8
_info$3 = -3224						; size = 8
_info$4 = -3216						; size = 8
_info$5 = -3208						; size = 8
_info$6 = -3200						; size = 8
_info$7 = -3192						; size = 8
_info$8 = -3184						; size = 8
_info$9 = -3176						; size = 8
_info$10 = -3168					; size = 8
_info$11 = -3160					; size = 8
_info$12 = -3152					; size = 8
_indexArg$1$ = -3144					; size = 4
_info$13 = -3140					; size = 8
_cursorPos$14 = -3136					; size = 4
_cursorPos$15 = -3136					; size = 4
_arguments$GSCopy$1$ = -3132				; size = 4
_scrnBufInfo$16 = -3128					; size = 22
_scrnBufInfo$17 = -3104					; size = 22
_line$18 = -3080					; size = 256
_line$19 = -2824					; size = 256
_line$20 = -2568					; size = 256
_line$21 = -2312					; size = 256
_line$22 = -2056					; size = 256
_line$23 = -1800					; size = 256
_line$24 = -1544					; size = 256
_line$25 = -1288					; size = 256
_line$26 = -1032					; size = 256
_line$27 = -776						; size = 256
_line$28 = -520						; size = 256
_line$29 = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
?ObtainOptions@@YAXHPAPAD@Z PROC			; ObtainOptions, COMDAT
; _argCount$ = ecx
; _arguments$ = edx

; 1207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3244				; 00000cacH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));

	push	1025					; 00000401H
	mov	DWORD PTR _arguments$GSCopy$1$[ebp], esi
	push	DWORD PTR [esi]
	push	OFFSET ?applicationPath@@3PADA		; applicationPath
	call	__fullpath
	add	esp, 12					; 0000000cH

; 1213 : 	strcpy(applicationDirectory, applicationPath);

	xor	ecx, ecx
	npad	10
$LL142@ObtainOpti:
	mov	al, BYTE PTR ?applicationPath@@3PADA[ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR ?applicationDirectory@@3PADA[ecx-1], al
	test	al, al
	jne	SHORT $LL142@ObtainOpti

; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {

	mov	ecx, OFFSET ?applicationPath@@3PADA	; applicationPath
	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL287@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL287@ObtainOpti
	sub	ecx, edx
	lea	eax, DWORD PTR [ecx-1]
	test	eax, eax
	jle	SHORT $LN475@ObtainOpti
$LL139@ObtainOpti:

; 1215 : 		if (applicationDirectory[i] == '\\')

	cmp	BYTE PTR ?applicationDirectory@@3PADA[eax], 92 ; 0000005cH
	je	SHORT $LN249@ObtainOpti

; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {

	dec	eax
	test	eax, eax
	jg	SHORT $LL139@ObtainOpti
$LN249@ObtainOpti:

; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)

	test	eax, eax
$LN475@ObtainOpti:
	jns	SHORT $LN135@ObtainOpti

; 1219 : 		i = 0;

	xor	eax, eax

; 1220 : 	applicationDirectory[i] = '\0';

	jmp	SHORT $LN285@ObtainOpti
$LN135@ObtainOpti:
	cmp	eax, 1025				; 00000401H
	jae	$LN481@ObtainOpti
$LN285@ObtainOpti:

; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));

	push	1025					; 00000401H
	push	OFFSET $SG4294899285
	push	OFFSET ?tripcodeFilePath@@3PADA		; tripcodeFilePath
	mov	BYTE PTR ?applicationDirectory@@3PADA[eax], 0
	call	_strncpy

; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {

	mov	ebx, 1
	add	esp, 12					; 0000000cH
	cmp	edi, ebx
	jle	$LN467@ObtainOpti
	npad	4
$LL134@ObtainOpti:

; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {

	mov	esi, DWORD PTR [esi+ebx*4]
	mov	ecx, OFFSET $SG4294899284
	mov	eax, esi
	npad	6
$LL288@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN289@ObtainOpti
	test	dl, dl
	je	SHORT $LN290@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN289@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL288@ObtainOpti
$LN290@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN291@ObtainOpti
$LN289@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN291@ObtainOpti:
	test	eax, eax
	jne	$LN131@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN131@ObtainOpti

; 1236 : 			       arguments[indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR _indexArg$1$[ebp], ebx
	mov	ecx, DWORD PTR [esi+ebx*4]
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL292@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL292@ObtainOpti
	sub	ecx, edx
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, 1025				; 00000401H
	jbe	SHORT $LN130@ObtainOpti
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL164@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN163@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN178@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL164@ObtainOpti
$LN178@ObtainOpti:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL164@ObtainOpti
$LN163@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError

; 1236 : 			       arguments[indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1236 : 			       arguments[indexArg]);

	test	eax, eax
	je	$LN250@ObtainOpti
$LN130@ObtainOpti:

; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	mov	edx, OFFSET ?tripcodeFilePath@@3PADA	; tripcodeFilePath
$LL145@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $LL145@ObtainOpti
	jmp	$LN133@ObtainOpti
$LN131@ObtainOpti:

; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899278
	mov	eax, esi
	npad	4
$LL293@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN294@ObtainOpti
	test	dl, dl
	je	SHORT $LN295@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN294@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL293@ObtainOpti
$LN295@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN296@ObtainOpti
$LN294@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN296@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN126@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	SHORT $LN126@ObtainOpti

; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR _indexArg$1$[ebp], ebx
	mov	ecx, DWORD PTR [esi+ebx*4]
	lea	edx, DWORD PTR [ecx+1]
$LL297@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL297@ObtainOpti
	sub	ecx, edx
	cmp	ecx, 1024				; 00000400H
	jbe	SHORT $LN125@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN251@ObtainOpti
$LN125@ObtainOpti:

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	cmp	DWORD PTR ?numPatternFiles@@3HA, 256	; numPatternFiles, 00000100H
	jl	SHORT $LN122@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN252@ObtainOpti
$LN122@ObtainOpti:

; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);

	imul	ecx, DWORD PTR ?numPatternFiles@@3HA, 1025 ; numPatternFiles
	mov	edx, DWORD PTR [esi+ebx*4]
	add	ecx, OFFSET ?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
	inc	DWORD PTR ?numPatternFiles@@3HA		; numPatternFiles
$LL146@ObtainOpti:
	mov	al, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+1]
	inc	edx
	mov	BYTE PTR [ecx-1], al
	test	al, al
	jne	SHORT $LL146@ObtainOpti
	jmp	$LN133@ObtainOpti
$LN126@ObtainOpti:

; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899268
	mov	eax, esi
	npad	3
$LL298@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN299@ObtainOpti
	test	dl, dl
	je	SHORT $LN300@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN299@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL298@ObtainOpti
$LN300@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN301@ObtainOpti
$LN299@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN301@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN118@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	SHORT $LN118@ObtainOpti

; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A, eax
	jmp	$LN133@ObtainOpti
$LN118@ObtainOpti:

; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899267
	mov	eax, esi
$LL302@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN303@ObtainOpti
	test	dl, dl
	je	SHORT $LN304@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN303@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL302@ObtainOpti
$LN304@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN305@ObtainOpti
$LN303@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN305@ObtainOpti:
	test	eax, eax
	jne	$LN116@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN116@ObtainOpti

; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+4, eax

; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	cmp	eax, 1
	jge	SHORT $LN115@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN253@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+4
$LN115@ObtainOpti:

; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	cmp	eax, 256				; 00000100H
	jle	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN111@ObtainOpti
	push	256					; 00000100H
	push	10					; 0000000aH
	push	OFFSET $SG4294899261
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899260
	jmp	$LN480@ObtainOpti
$LN116@ObtainOpti:

; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899256
	mov	eax, esi
$LL306@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN307@ObtainOpti
	test	dl, dl
	je	SHORT $LN308@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN307@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL306@ObtainOpti
$LN308@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN309@ObtainOpti
$LN307@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN309@ObtainOpti:
	test	eax, eax
	jne	$LN108@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN108@ObtainOpti

; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+36, eax

; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	cmp	eax, 1
	jge	SHORT $LN107@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN255@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+36
$LN107@ObtainOpti:

; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	cmp	eax, 16384				; 00004000H
	jle	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN103@ObtainOpti
	push	16384					; 00004000H
	push	10					; 0000000aH
	push	OFFSET $SG4294899250
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899249
	jmp	$LN480@ObtainOpti
$LN108@ObtainOpti:

; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899245
	mov	eax, esi
$LL310@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN311@ObtainOpti
	test	dl, dl
	je	SHORT $LN312@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN311@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL310@ObtainOpti
$LN312@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN313@ObtainOpti
$LN311@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN313@ObtainOpti:
	test	eax, eax
	jne	$LN100@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN100@ObtainOpti

; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+40, eax

; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	cmp	eax, 1
	jge	SHORT $LN99@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN257@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+40
$LN99@ObtainOpti:

; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	cmp	eax, 256				; 00000100H
	jle	SHORT $LN96@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN258@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+40
$LN96@ObtainOpti:

; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN473@ObtainOpti
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN473@ObtainOpti:
	je	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN92@ObtainOpti
	push	10					; 0000000aH
	push	OFFSET $SG4294899234
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899233
	jmp	$LN480@ObtainOpti
$LN100@ObtainOpti:

; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899230
	mov	eax, esi
	npad	1
$LL314@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN315@ObtainOpti
	test	dl, dl
	je	SHORT $LN316@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN315@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL314@ObtainOpti
$LN316@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN317@ObtainOpti
$LN315@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN317@ObtainOpti:
	test	eax, eax
	jne	$LN89@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN89@ObtainOpti

; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+44, eax

; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	cmp	eax, 1
	jge	SHORT $LN88@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN260@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+44
$LN88@ObtainOpti:

; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);

	cmp	eax, 32					; 00000020H
	jle	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN84@ObtainOpti
	push	32					; 00000020H
	push	10					; 0000000aH
	push	OFFSET $SG4294899224
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899223
	jmp	$LN480@ObtainOpti
$LN89@ObtainOpti:

; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899219
	mov	eax, esi
	npad	6
$LL318@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN319@ObtainOpti
	test	dl, dl
	je	SHORT $LN320@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN319@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL318@ObtainOpti
$LN320@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN321@ObtainOpti
$LN319@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN321@ObtainOpti:
	test	eax, eax
	jne	$LN81@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN81@ObtainOpti

; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+100, eax

; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);

	cmp	eax, 1
	jge	SHORT $LN80@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN262@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+100
$LN80@ObtainOpti:

; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);

	cmp	eax, 32					; 00000020H
	jle	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN76@ObtainOpti
	push	32					; 00000020H
	push	10					; 0000000aH
	push	OFFSET $SG4294899213
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899212
	jmp	$LN480@ObtainOpti
$LN81@ObtainOpti:

; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899208
	mov	eax, esi
	npad	6
$LL322@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN323@ObtainOpti
	test	dl, dl
	je	SHORT $LN324@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN323@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL322@ObtainOpti
$LN324@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN325@ObtainOpti
$LN323@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN325@ObtainOpti:
	test	eax, eax
	jne	$LN73@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	$LN73@ObtainOpti

; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?lenTripcode@@3HA, eax	; lenTripcode

; 1302 : 			lenTripcodeKey = lenTripcode;

	mov	DWORD PTR ?lenTripcodeKey@@3HA, eax	; lenTripcodeKey

; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");

	cmp	eax, 10					; 0000000aH
	je	$LN133@ObtainOpti
	cmp	eax, 12					; 0000000cH
	je	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN71@ObtainOpti
	push	10					; 0000000aH
	push	OFFSET $SG4294899207
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899206
	jmp	$LN480@ObtainOpti
$LN73@ObtainOpti:

; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {

	mov	ecx, OFFSET $SG4294899203
	mov	eax, esi
$LL326@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN327@ObtainOpti
	test	dl, dl
	je	SHORT $LN328@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN327@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL326@ObtainOpti
$LN328@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN329@ObtainOpti
$LN327@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN329@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN68@ObtainOpti

; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+8, 1
	jmp	$LN472@ObtainOpti
$LN68@ObtainOpti:

; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {

	mov	ecx, OFFSET $SG4294899202
	mov	eax, esi
$LL330@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN331@ObtainOpti
	test	dl, dl
	je	SHORT $LN332@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN331@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL330@ObtainOpti
$LN332@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN333@ObtainOpti
$LN331@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN333@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN66@ObtainOpti

; 1311 : 			options.outputInvalidTripcode = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+12, 1
	jmp	$LN472@ObtainOpti
$LN66@ObtainOpti:

; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {

	mov	ecx, OFFSET $SG4294899201
	mov	eax, esi
$LL334@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN335@ObtainOpti
	test	dl, dl
	je	SHORT $LN336@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN335@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL334@ObtainOpti
$LN336@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN337@ObtainOpti
$LN335@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN337@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN64@ObtainOpti

; 1314 : 			options.warnSpeedDrop= TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+16, 1
	jmp	$LN472@ObtainOpti
$LN64@ObtainOpti:

; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {

	mov	ecx, OFFSET $SG4294899200
	mov	eax, esi
	npad	1
$LL338@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN339@ObtainOpti
	test	dl, dl
	je	SHORT $LN340@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN339@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL338@ObtainOpti
$LN340@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN341@ObtainOpti
$LN339@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN341@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN62@ObtainOpti

; 1317 : 			options.testNewCode = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+24, 1
	jmp	$LN472@ObtainOpti
$LN62@ObtainOpti:

; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {

	mov	ecx, OFFSET $SG4294899199
	mov	eax, esi
	npad	1
$LL342@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN343@ObtainOpti
	test	dl, dl
	je	SHORT $LN344@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN343@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL342@ObtainOpti
$LN344@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN345@ObtainOpti
$LN343@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN345@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN60@ObtainOpti

; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	cmp	DWORD PTR ?options@@3UOptions@@A+20, eax
	jne	SHORT $LN147@ObtainOpti
	mov	DWORD PTR ?options@@3UOptions@@A+20, 3
	jmp	$LN133@ObtainOpti
$LN147@ObtainOpti:
	mov	eax, DWORD PTR ?options@@3UOptions@@A+20
	mov	ecx, 1
	cmp	eax, 2
	cmove	eax, ecx
	mov	DWORD PTR ?options@@3UOptions@@A+20, eax
	jmp	$LN133@ObtainOpti
$LN60@ObtainOpti:

; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {

	mov	ecx, OFFSET $SG4294899198
	mov	eax, esi
$LL346@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN347@ObtainOpti
	test	dl, dl
	je	SHORT $LN348@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN347@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL346@ObtainOpti
$LN348@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN349@ObtainOpti
$LN347@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN349@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN58@ObtainOpti

; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	cmp	DWORD PTR ?options@@3UOptions@@A+20, eax
	jne	SHORT $LN149@ObtainOpti
	mov	DWORD PTR ?options@@3UOptions@@A+20, 2
	jmp	$LN133@ObtainOpti
$LN149@ObtainOpti:
	mov	eax, DWORD PTR ?options@@3UOptions@@A+20
	mov	ecx, 1
	cmp	eax, 3
	cmove	eax, ecx
	mov	DWORD PTR ?options@@3UOptions@@A+20, eax
	jmp	$LN133@ObtainOpti
$LN58@ObtainOpti:

; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899197
	mov	eax, esi
	npad	2
$LL350@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN351@ObtainOpti
	test	dl, dl
	je	SHORT $LN352@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN351@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL350@ObtainOpti
$LN352@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN353@ObtainOpti
$LN351@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN353@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN56@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	SHORT $LN56@ObtainOpti

; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR [esi+ebx*4]
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?options@@3UOptions@@A+28, eax

; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");

	test	eax, eax
	jg	$LN133@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN133@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN54@ObtainOpti
	push	10					; 0000000aH
	push	OFFSET $SG4294899196
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899195
	jmp	$LN480@ObtainOpti
$LN56@ObtainOpti:

; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {

	mov	ecx, OFFSET $SG4294899192
	mov	eax, esi
	npad	5
$LL354@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN355@ObtainOpti
	test	dl, dl
	je	SHORT $LN356@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN355@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL354@ObtainOpti
$LN356@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN357@ObtainOpti
$LN355@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN357@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN51@ObtainOpti

; 1336 : 			options.redirection = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+32, 1
	jmp	$LN472@ObtainOpti
$LN51@ObtainOpti:

; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899191
	mov	eax, esi
	npad	1
$LL358@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN359@ObtainOpti
	test	dl, dl
	je	SHORT $LN360@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN359@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL358@ObtainOpti
$LN360@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN361@ObtainOpti
$LN359@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN361@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN49@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	SHORT $LN49@ObtainOpti

; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	mov	edx, OFFSET ?nameMutexForPausing@@3PADA	; nameMutexForPausing
	mov	ecx, DWORD PTR [esi+ebx*4]
$LL151@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $LL151@ObtainOpti

; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);

	push	256					; 00000100H
	push	OFFSET _nameMutexForPausingWC
	push	-1
	push	DWORD PTR [esi+ebx*4]
	push	0
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 1342 : 			if (len < 0) {

	cmp	eax, 256				; 00000100H
	ja	SHORT $LN46@ObtainOpti

; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;

	add	eax, eax
	cmp	eax, 514				; 00000202H
	jae	$LN481@ObtainOpti
	xor	ecx, ecx
	mov	WORD PTR _nameMutexForPausingWC[eax], cx
$LN46@ObtainOpti:

; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;

	xor	eax, eax
	mov	WORD PTR _nameMutexForPausingWC+512, ax
	jmp	$LN133@ObtainOpti
$LN49@ObtainOpti:

; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {

	mov	ecx, OFFSET $SG4294899190
	mov	eax, esi
$LL362@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN363@ObtainOpti
	test	dl, dl
	je	SHORT $LN364@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN363@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL362@ObtainOpti
$LN364@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN365@ObtainOpti
$LN363@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN365@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN44@ObtainOpti
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edi
	jge	SHORT $LN44@ObtainOpti

; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);

	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
	mov	ebx, eax
	mov	edx, OFFSET ?nameEventForTerminating@@3PADA ; nameEventForTerminating
	mov	ecx, DWORD PTR [esi+ebx*4]
$LL156@ObtainOpti:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $LL156@ObtainOpti

; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);

	push	256					; 00000100H
	push	OFFSET _nameEventForTerminatingWC
	push	-1
	push	DWORD PTR [esi+ebx*4]
	push	0
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 1353 : 			if (len < 0) {

	cmp	eax, 256				; 00000100H
	ja	SHORT $LN41@ObtainOpti

; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;

	add	eax, eax
	cmp	eax, 514				; 00000202H
	jae	$LN481@ObtainOpti
	xor	ecx, ecx
	mov	WORD PTR _nameEventForTerminatingWC[eax], cx
$LN41@ObtainOpti:

; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;

	xor	eax, eax
	mov	WORD PTR _nameEventForTerminatingWC+512, ax
	jmp	$LN133@ObtainOpti
$LN44@ObtainOpti:

; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {

	mov	ecx, OFFSET $SG4294899189
	mov	eax, esi
	npad	4
$LL366@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN367@ObtainOpti
	test	dl, dl
	je	SHORT $LN368@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN367@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL366@ObtainOpti
$LN368@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN369@ObtainOpti
$LN367@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN369@ObtainOpti:
	test	eax, eax
	je	$LN476@ObtainOpti

; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899188
	mov	eax, esi
$LL370@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN371@ObtainOpti
	test	dl, dl
	je	SHORT $LN372@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN371@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL370@ObtainOpti
$LN372@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN373@ObtainOpti
$LN371@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN373@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN37@ObtainOpti

; 1364 : 			options.searchForHisekiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+52, 1
	jmp	$LN472@ObtainOpti
$LN37@ObtainOpti:

; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899187
	mov	eax, esi
$LL374@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN375@ObtainOpti
	test	dl, dl
	je	SHORT $LN376@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN375@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL374@ObtainOpti
$LN376@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN377@ObtainOpti
$LN375@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN377@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN35@ObtainOpti

; 1367 : 			options.searchForKakuhiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+56, 1
	jmp	$LN472@ObtainOpti
$LN35@ObtainOpti:

; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899186
	mov	eax, esi
$LL378@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN379@ObtainOpti
	test	dl, dl
	je	SHORT $LN380@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN379@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL378@ObtainOpti
$LN380@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN381@ObtainOpti
$LN379@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN381@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN33@ObtainOpti

; 1370 : 			options.searchForKaibunOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+60, 1
	jmp	$LN472@ObtainOpti
$LN33@ObtainOpti:

; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899185
	mov	eax, esi
$LL382@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN383@ObtainOpti
	test	dl, dl
	je	SHORT $LN384@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN383@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL382@ObtainOpti
$LN384@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN385@ObtainOpti
$LN383@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN385@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN31@ObtainOpti

; 1373 : 			options.searchForKagamiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+72, 1
	jmp	$LN472@ObtainOpti
$LN31@ObtainOpti:

; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899184
	mov	eax, esi
$LL386@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN387@ObtainOpti
	test	dl, dl
	je	SHORT $LN388@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN387@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL386@ObtainOpti
$LN388@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN389@ObtainOpti
$LN387@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN389@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN29@ObtainOpti

; 1376 : 			options.searchForYamabikoOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+64, 1
	jmp	$LN472@ObtainOpti
$LN29@ObtainOpti:

; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {

	mov	ecx, OFFSET $SG4294899183
	mov	eax, esi
	npad	1
$LL390@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN391@ObtainOpti
	test	dl, dl
	je	SHORT $LN392@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN391@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL390@ObtainOpti
$LN392@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN393@ObtainOpti
$LN391@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN393@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN27@ObtainOpti

; 1379 : 			options.searchForSourenOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+68, 1
	jmp	$LN472@ObtainOpti
$LN27@ObtainOpti:

; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {

	mov	ecx, OFFSET $SG4294899182
	mov	eax, esi
	npad	1
$LL394@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN395@ObtainOpti
	test	dl, dl
	je	SHORT $LN396@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN395@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL394@ObtainOpti
$LN396@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN397@ObtainOpti
$LN395@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN397@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN25@ObtainOpti

; 1382 : 			options.useOpenCLForCUDADevices = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+76, 1
	jmp	$LN472@ObtainOpti
$LN25@ObtainOpti:

; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {

	mov	ecx, OFFSET $SG4294899181
	mov	eax, esi
	npad	1
$LL398@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN399@ObtainOpti
	test	dl, dl
	je	SHORT $LN400@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN399@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL398@ObtainOpti
$LN400@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN401@ObtainOpti
$LN399@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN401@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN23@ObtainOpti

; 1385 : 			options.isAVXEnabled = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+80, eax
	jmp	$LN472@ObtainOpti
$LN23@ObtainOpti:

; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {

	mov	ecx, OFFSET $SG4294899180
	mov	eax, esi
	npad	6
$LL402@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN403@ObtainOpti
	test	dl, dl
	je	SHORT $LN404@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN403@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL402@ObtainOpti
$LN404@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN405@ObtainOpti
$LN403@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN405@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN21@ObtainOpti

; 1388 : 			options.isAVX2Enabled = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+92, eax
	jmp	SHORT $LN472@ObtainOpti
$LN21@ObtainOpti:

; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {

	mov	ecx, OFFSET $SG4294899179
	mov	eax, esi
$LL406@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN407@ObtainOpti
	test	dl, dl
	je	SHORT $LN408@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN407@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL406@ObtainOpti
$LN408@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN409@ObtainOpti
$LN407@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN409@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN19@ObtainOpti

; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, eax
$LN476@ObtainOpti:

; 1392 : 			options.useOneByteCharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, 1
$LN472@ObtainOpti:
	mov	esi, DWORD PTR _arguments$GSCopy$1$[ebp]
$LN133@ObtainOpti:

; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {

	inc	ebx
	cmp	ebx, edi
	jl	$LL134@ObtainOpti
$LN467@ObtainOpti:

; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {

	cmp	DWORD PTR ?numPatternFiles@@3HA, 0	; numPatternFiles
	jg	SHORT $LN1@ObtainOpti

; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);

	mov	eax, DWORD PTR $SG4294899166+8
	movq	xmm0, QWORD PTR $SG4294899166
	mov	DWORD PTR ?patternFilePathArray@@3PAY0EAB@DA+8, eax
	mov	al, BYTE PTR $SG4294899166+12
	movq	QWORD PTR ?patternFilePathArray@@3PAY0EAB@DA, xmm0
	mov	BYTE PTR ?patternFilePathArray@@3PAY0EAB@DA+12, al

; 1425 : 		numPatternFiles = 1;

	mov	DWORD PTR ?numPatternFiles@@3HA, 1	; numPatternFiles
$LN1@ObtainOpti:

; 1426 : 	}
; 1427 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@ObtainOpti:

; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {

	mov	ecx, OFFSET $SG4294899178
	mov	eax, esi
	npad	3
$LL410@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN411@ObtainOpti
	test	dl, dl
	je	SHORT $LN412@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN411@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL410@ObtainOpti
$LN412@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN413@ObtainOpti
$LN411@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN413@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN17@ObtainOpti

; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, 1

; 1396 : 			options.useOneByteCharactersForKeys = TRUE;

	jmp	$LN476@ObtainOpti
$LN17@ObtainOpti:

; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {

	mov	ecx, OFFSET $SG4294899177
	mov	eax, esi
	npad	1
$LL414@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN415@ObtainOpti
	test	dl, dl
	je	SHORT $LN416@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN415@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL414@ObtainOpti
$LN416@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN417@ObtainOpti
$LN415@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN417@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN15@ObtainOpti

; 1399 : 			options.useOneByteCharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, eax

; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, eax
	jmp	$LN472@ObtainOpti
$LN15@ObtainOpti:

; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {

	mov	ecx, OFFSET $SG4294899176
	mov	eax, esi
	npad	1
$LL418@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN419@ObtainOpti
	test	dl, dl
	je	SHORT $LN420@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN419@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL418@ObtainOpti
$LN420@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN421@ObtainOpti
$LN419@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN421@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN13@ObtainOpti

; 1403 : 			options.useOneByteCharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, eax

; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, eax

; 1405 : 			options.maximizeKeySpace = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+88, 1
	jmp	$LN472@ObtainOpti
$LN13@ObtainOpti:

; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {

	mov	ecx, OFFSET $SG4294899175
	mov	eax, esi
	npad	7
$LL422@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN423@ObtainOpti
	test	dl, dl
	je	SHORT $LN424@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN423@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL422@ObtainOpti
$LN424@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN425@ObtainOpti
$LN423@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN425@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN11@ObtainOpti

; 1408 : 			options.checkTripcodes = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+104, eax
	jmp	$LN472@ObtainOpti
$LN11@ObtainOpti:

; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {

	mov	ecx, OFFSET $SG4294899174
	mov	eax, esi
	npad	6
$LL426@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN427@ObtainOpti
	test	dl, dl
	je	SHORT $LN428@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN427@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL426@ObtainOpti
$LN428@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN429@ObtainOpti
$LN427@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN429@ObtainOpti:
	test	eax, eax
	jne	SHORT $LN9@ObtainOpti

; 1411 : 			options.enableGCNAssembler = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+108, eax

; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0

	jmp	$LN472@ObtainOpti
$LN9@ObtainOpti:

; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {

	mov	ecx, OFFSET $SG4294899173
	mov	eax, esi
	npad	6
$LL430@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN431@ObtainOpti
	test	dl, dl
	je	SHORT $LN432@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN431@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL430@ObtainOpti
$LN432@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN433@ObtainOpti
$LN431@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN433@ObtainOpti:
	test	eax, eax
	je	$LN472@ObtainOpti
	mov	ecx, OFFSET $SG4294899172
	mov	eax, esi
$LL434@ObtainOpti:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN435@ObtainOpti
	test	dl, dl
	je	SHORT $LN436@ObtainOpti
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN435@ObtainOpti
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL434@ObtainOpti
$LN436@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN437@ObtainOpti
$LN435@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN437@ObtainOpti:
	test	eax, eax
	je	$LN472@ObtainOpti
	mov	eax, OFFSET $SG4294899171
$LL438@ObtainOpti:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN439@ObtainOpti
	test	cl, cl
	je	SHORT $LN440@ObtainOpti
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN439@ObtainOpti
	add	esi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL438@ObtainOpti
$LN440@ObtainOpti:
	xor	eax, eax
	jmp	SHORT $LN441@ObtainOpti
$LN439@ObtainOpti:
	sbb	eax, eax
	or	eax, 1
$LN441@ObtainOpti:
	test	eax, eax
	je	$LN472@ObtainOpti

; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");

	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN472@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN3@ObtainOpti
	push	10					; 0000000aH
	push	OFFSET $SG4294899170
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	10					; 0000000aH
	push	OFFSET $SG4294899169
	jmp	$LN480@ObtainOpti
$LN250@ObtainOpti:

; 1236 : 			       arguments[indexArg]);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN129@ObtainOpti
	push	DWORD PTR [esi+ebx*4]
	push	11					; 0000000bH
	push	OFFSET $SG4294899283
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	11					; 0000000bH
	push	OFFSET $SG4294899282
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN210@ObtainOpti
$LN129@ObtainOpti:
	mov	esi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$16[ebp]
	mov	ebx, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN206@ObtainOpti

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$16[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$15[ebp], ax
	movsx	eax, cx
	add	eax, esi
	js	SHORT $LN208@ObtainOpti
	lea	eax, DWORD PTR [esi+ecx]
	jmp	SHORT $LN477@ObtainOpti
$LN208@ObtainOpti:
	xor	eax, eax
$LN477@ObtainOpti:
	mov	WORD PTR _cursorPos$15[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$15[ebp]
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN206@ObtainOpti:

; 1236 : 			       arguments[indexArg]);

	movdqu	xmm0, XMMWORD PTR $SG4294899281
	lea	edi, DWORD PTR _line$23[ebp]
	dec	edi
	movdqu	XMMWORD PTR _line$23[ebp], xmm0
	npad	2
$LL442@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL442@ObtainOpti
	mov	ecx, 12					; 0000000cH
	mov	esi, OFFSET $SG4294899280
	rep movsd
	lea	edi, DWORD PTR _line$23[ebp]
	dec	edi
	npad	5
$LL443@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL443@ObtainOpti
	mov	eax, DWORD PTR _indexArg$1$[ebp]
	mov	ecx, 6
	mov	esi, OFFSET $SG4294899279
	rep movsd
	mov	ecx, DWORD PTR _arguments$GSCopy$1$[ebp]
	movsw
	push	DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR _line$23[ebp]
	push	eax
	call	_printf
	add	esp, 8
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$7[ebp]
	mov	DWORD PTR _info$7[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$7[ebp], 100		; 00000064H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN210@ObtainOpti:

; 1236 : 			       arguments[indexArg]);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN482@ObtainOpti:
$LN251@ObtainOpti:

; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN124@ObtainOpti
	push	DWORD PTR [esi+ebx*4]
	push	6
	push	OFFSET $SG4294899277
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	6
	push	OFFSET $SG4294899276
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	$LN217@ObtainOpti
$LN124@ObtainOpti:
	mov	esi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$17[ebp]
	mov	ebx, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN213@ObtainOpti

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$17[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$14[ebp], ax
	movsx	eax, cx
	add	eax, esi
	js	SHORT $LN215@ObtainOpti
	lea	eax, DWORD PTR [esi+ecx]
	jmp	SHORT $LN478@ObtainOpti
$LN215@ObtainOpti:
	xor	eax, eax
$LN478@ObtainOpti:
	mov	WORD PTR _cursorPos$14[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$14[ebp]
	push	-11					; fffffff5H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN213@ObtainOpti:

; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);

	movdqu	xmm0, XMMWORD PTR $SG4294899275
	lea	edi, DWORD PTR _line$21[ebp]
	dec	edi
	movdqu	XMMWORD PTR _line$21[ebp], xmm0
	npad	2
$LL444@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL444@ObtainOpti
	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET $SG4294899274
	rep movsd
	movsw
	movsb
	lea	edi, DWORD PTR _line$21[ebp]
	dec	edi
	npad	2
$LL445@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL445@ObtainOpti
	mov	eax, DWORD PTR _indexArg$1$[ebp]
	mov	ecx, 6
	mov	esi, OFFSET $SG4294899273
	rep movsd
	mov	ecx, DWORD PTR _arguments$GSCopy$1$[ebp]
	movsw
	push	DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR _line$21[ebp]
	push	eax
	call	_printf
	add	esp, 8
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$5[ebp]
	mov	DWORD PTR _info$5[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$5[ebp], 100		; 00000064H
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN217@ObtainOpti:

; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN483@ObtainOpti:
$LN252@ObtainOpti:

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN121@ObtainOpti
	push	6
	push	OFFSET $SG4294899272
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	6
	push	OFFSET $SG4294899271
$LN480@ObtainOpti:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN219@ObtainOpti
$LN121@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899270
	push	OFFSET $SG4294899269
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$13[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$13[ebp]
	mov	DWORD PTR _info$13[ebp], 100		; 00000064H
$LN479@ObtainOpti:
	push	eax
	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN219@ObtainOpti:

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN484@ObtainOpti:
$LN253@ObtainOpti:

; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN114@ObtainOpti
	push	1
	push	10					; 0000000aH
	push	OFFSET $SG4294899266
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899265
	jmp	$LN480@ObtainOpti
$LN114@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899264
	lea	edi, DWORD PTR _line$29[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$29[ebp], xmm0
	npad	5
$LL446@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL446@ObtainOpti
	mov	ecx, 12					; 0000000cH
	mov	esi, OFFSET $SG4294899263
	rep movsd
	movsb
	lea	edi, DWORD PTR _line$29[ebp]
	dec	edi
	npad	4
$LL447@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL447@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$29[ebp]
	mov	esi, OFFSET $SG4294899262
	rep movsd
	push	1
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$3[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$3[ebp]
	mov	DWORD PTR _info$3[ebp], 100		; 00000064H

; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	jmp	$LN479@ObtainOpti
$LN111@ObtainOpti:

; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899259
	lea	edi, DWORD PTR _line$27[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$27[ebp], xmm0
$LL448@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL448@ObtainOpti
	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET $SG4294899258
	rep movsd
	movsw
	lea	edi, DWORD PTR _line$27[ebp]
	dec	edi
	npad	3
$LL449@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL449@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$27[ebp]
	mov	esi, OFFSET $SG4294899257
	rep movsd
	push	256					; 00000100H
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$1[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$1[ebp]
	mov	DWORD PTR _info$1[ebp], 100		; 00000064H

; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	jmp	$LN479@ObtainOpti
$LN255@ObtainOpti:

; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN106@ObtainOpti
	push	1
	push	10					; 0000000aH
	push	OFFSET $SG4294899255
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899254
	jmp	$LN480@ObtainOpti
$LN106@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899253
	lea	edi, DWORD PTR _line$24[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$24[ebp], xmm0
$LL450@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL450@ObtainOpti
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET $SG4294899252
	rep movsd
	movsb
	lea	edi, DWORD PTR _line$24[ebp]
	dec	edi
$LL451@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL451@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$24[ebp]
	mov	esi, OFFSET $SG4294899251
	rep movsd
	push	1
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$10[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$10[ebp]
	mov	DWORD PTR _info$10[ebp], 100		; 00000064H

; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	jmp	$LN479@ObtainOpti
$LN103@ObtainOpti:

; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899248
	lea	edi, DWORD PTR _line$22[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$22[ebp], xmm0
$LL452@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL452@ObtainOpti
	mov	ecx, 12					; 0000000cH
	mov	esi, OFFSET $SG4294899247
	rep movsd
	movsw
	lea	edi, DWORD PTR _line$22[ebp]
	dec	edi
	npad	2
$LL453@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL453@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$22[ebp]
	mov	esi, OFFSET $SG4294899246
	rep movsd
	push	16384					; 00004000H
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$2[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H

; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	jmp	$LN479@ObtainOpti
$LN257@ObtainOpti:

; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN98@ObtainOpti
	push	1
	push	10					; 0000000aH
	push	OFFSET $SG4294899244
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899243
	jmp	$LN480@ObtainOpti
$LN98@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899242
	lea	edi, DWORD PTR _line$20[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$20[ebp], xmm0
$LL454@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL454@ObtainOpti
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET $SG4294899241
	rep movsd
	movsb
	lea	edi, DWORD PTR _line$20[ebp]
	dec	edi
$LL455@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL455@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$20[ebp]
	mov	esi, OFFSET $SG4294899240
	rep movsd
	push	1
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$8[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$8[ebp]
	mov	DWORD PTR _info$8[ebp], 100		; 00000064H

; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	jmp	$LN479@ObtainOpti
$LN258@ObtainOpti:

; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN95@ObtainOpti
	push	256					; 00000100H
	push	10					; 0000000aH
	push	OFFSET $SG4294899239
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899238
	jmp	$LN480@ObtainOpti
$LN95@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899237
	lea	edi, DWORD PTR _line$18[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$18[ebp], xmm0
$LL456@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL456@ObtainOpti
	mov	ecx, 12					; 0000000cH
	mov	esi, OFFSET $SG4294899236
	rep movsd
	movsw
	lea	edi, DWORD PTR _line$18[ebp]
	dec	edi
$LL457@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL457@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$18[ebp]
	mov	esi, OFFSET $SG4294899235
	rep movsd
	push	256					; 00000100H
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$4[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$4[ebp]
	mov	DWORD PTR _info$4[ebp], 100		; 00000064H

; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	jmp	$LN479@ObtainOpti
$LN92@ObtainOpti:

; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899232
	push	OFFSET $SG4294899231
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$6[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$6[ebp]
	mov	DWORD PTR _info$6[ebp], 100		; 00000064H

; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	jmp	$LN479@ObtainOpti
$LN260@ObtainOpti:

; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN87@ObtainOpti
	push	1
	push	10					; 0000000aH
	push	OFFSET $SG4294899229
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899228
	jmp	$LN480@ObtainOpti
$LN87@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899227
	lea	edi, DWORD PTR _line$19[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$19[ebp], xmm0
	npad	4
$LL458@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL458@ObtainOpti
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET $SG4294899226
	rep movsd
	movsw
	movsb
	lea	edi, DWORD PTR _line$19[ebp]
	dec	edi
	npad	2
$LL459@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL459@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$19[ebp]
	mov	esi, OFFSET $SG4294899225
	rep movsd
	push	1
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$11[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$11[ebp]
	mov	DWORD PTR _info$11[ebp], 100		; 00000064H

; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	jmp	$LN479@ObtainOpti
$LN84@ObtainOpti:

; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899222
	lea	edi, DWORD PTR _line$25[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$25[ebp], xmm0
$LL460@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL460@ObtainOpti
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET $SG4294899221
	rep movsd
	lea	edi, DWORD PTR _line$25[ebp]
	dec	edi
	npad	5
$LL461@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL461@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$25[ebp]
	mov	esi, OFFSET $SG4294899220
	rep movsd
	push	32					; 00000020H
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$9[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$9[ebp]
	mov	DWORD PTR _info$9[ebp], 100		; 00000064H

; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);

	jmp	$LN479@ObtainOpti
$LN262@ObtainOpti:

; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN79@ObtainOpti
	push	1
	push	10					; 0000000aH
	push	OFFSET $SG4294899218
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 20					; 00000014H
	push	10					; 0000000aH
	push	OFFSET $SG4294899217
	jmp	$LN480@ObtainOpti
$LN79@ObtainOpti:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899216
	lea	edi, DWORD PTR _line$26[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$26[ebp], xmm0
$LL462@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL462@ObtainOpti
	mov	ecx, 14					; 0000000eH
	mov	esi, OFFSET $SG4294899215
	rep movsd
	movsb
	lea	edi, DWORD PTR _line$26[ebp]
	dec	edi
	npad	2
$LL463@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL463@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$26[ebp]
	mov	esi, OFFSET $SG4294899214
	rep movsd
	push	1
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$12[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$12[ebp]
	mov	DWORD PTR _info$12[ebp], 100		; 00000064H

; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);

	jmp	$LN479@ObtainOpti
$LN76@ObtainOpti:

; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	movdqu	xmm0, XMMWORD PTR $SG4294899211
	lea	edi, DWORD PTR _line$28[ebp]
	add	esp, 4
	dec	edi
	movdqu	XMMWORD PTR _line$28[ebp], xmm0
$LL464@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL464@ObtainOpti
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET $SG4294899210
	rep movsd
	movsw
	lea	edi, DWORD PTR _line$28[ebp]
	dec	edi
	npad	3
$LL465@ObtainOpti:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL465@ObtainOpti
	mov	ecx, 6
	lea	eax, DWORD PTR _line$28[ebp]
	mov	esi, OFFSET $SG4294899209
	rep movsd
	push	32					; 00000020H
	push	eax
	movsw
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN219@ObtainOpti
$LN71@ObtainOpti:

; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899205
	push	OFFSET $SG4294899204
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN219@ObtainOpti
$LN54@ObtainOpti:

; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899194
	push	OFFSET $SG4294899193
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN219@ObtainOpti
$LN3@ObtainOpti:

; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");

	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899168
	push	OFFSET $SG4294899167
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN219@ObtainOpti
$LN481@ObtainOpti:

; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;

	call	___report_rangecheckfailure
$LN485@ObtainOpti:
$LN474@ObtainOpti:
	int	3
?ObtainOptions@@YAXHPAPAD@Z ENDP			; ObtainOptions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?OpenTripcodeFile@@YAXXZ
_TEXT	SEGMENT
?OpenTripcodeFile@@YAXXZ PROC				; OpenTripcodeFile, COMDAT

; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");

	push	OFFSET $SG4294899112
	push	OFFSET ?tripcodeFilePath@@3PADA		; tripcodeFilePath
	call	_fopen
	add	esp, 8
	mov	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A, eax ; tripcodeFile

; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }

	ret	0
?OpenTripcodeFile@@YAXXZ ENDP				; OpenTripcodeFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?AddToNumGeneratedTripcodesByGPU@@YAXI@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
?AddToNumGeneratedTripcodesByGPU@@YAXI@Z PROC		; AddToNumGeneratedTripcodesByGPU, COMDAT

; 1584 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, OFFSET ?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
	npad	7
$LL5@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN4@AddToNumGe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN19@AddToNumGe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@AddToNumGe
$LN19@AddToNumGe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@AddToNumGe
$LN4@AddToNumGe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1586 : 	numGeneratedTripcodes_GPU += num;

	mov	ecx, DWORD PTR ?numGeneratedTripcodes_GPU@@3IA ; numGeneratedTripcodes_GPU
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, ecx ; numGeneratedTripcodes_GPU
	pop	esi

; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {

	cmp	ecx, 1000000				; 000f4240H
	jb	SHORT $LN49@AddToNumGe

; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;

	mov	eax, 1125899907				; 431bde83H
	mul	ecx
	shr	edx, 18					; 00000012H
	add	DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA, edx ; numGeneratedTripcodesByGPUInMillions

; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;

	imul	eax, edx, -1000000
	add	ecx, eax
	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, ecx ; numGeneratedTripcodes_GPU
$LN49@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1592 : }

	pop	ebp
	ret	0
?AddToNumGeneratedTripcodesByGPU@@YAXI@Z ENDP		; AddToNumGeneratedTripcodesByGPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetNumGeneratedTripcodesByCPU@@YANXZ
_TEXT	SEGMENT
?GetNumGeneratedTripcodesByCPU@@YANXZ PROC		; GetNumGeneratedTripcodesByCPU, COMDAT

; 1595 : {

	push	esi
	mov	esi, OFFSET ?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
$LL4@GetNumGene:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@GetNumGene
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@GetNumGene

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetNumGene
$LN18@GetNumGene:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetNumGene
$LN3@GetNumGene:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1599 : 	             +         numGeneratedTripcodes_CPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA ; numGeneratedTripcodesByCPUInMillions

; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;

	mov	DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA, 0 ; numGeneratedTripcodesByCPUInMillions
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR ?numGeneratedTripcodes_CPU@@3IA ; numGeneratedTripcodes_CPU

; 1601 : 	numGeneratedTripcodes_CPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, 0 ; numGeneratedTripcodes_CPU
	mulsd	xmm0, QWORD PTR __real@412e848000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1606 : }

	pop	esi
	ret	0
?GetNumGeneratedTripcodesByCPU@@YANXZ ENDP		; GetNumGeneratedTripcodesByCPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetNumGeneratedTripcodesByGPU@@YANXZ
_TEXT	SEGMENT
?GetNumGeneratedTripcodesByGPU@@YANXZ PROC		; GetNumGeneratedTripcodesByGPU, COMDAT

; 1609 : {

	push	esi
	mov	esi, OFFSET ?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
$LL4@GetNumGene:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@GetNumGene
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@GetNumGene

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetNumGene
$LN18@GetNumGene:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetNumGene
$LN3@GetNumGene:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1613 : 	             +         numGeneratedTripcodes_GPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA ; numGeneratedTripcodesByGPUInMillions

; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;

	mov	DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA, 0 ; numGeneratedTripcodesByGPUInMillions
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR ?numGeneratedTripcodes_GPU@@3IA ; numGeneratedTripcodes_GPU

; 1615 : 	numGeneratedTripcodes_GPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, 0 ; numGeneratedTripcodes_GPU
	mulsd	xmm0, QWORD PTR __real@412e848000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1620 : }

	pop	esi
	ret	0
?GetNumGeneratedTripcodesByGPU@@YANXZ ENDP		; GetNumGeneratedTripcodesByGPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetPauseState@@YAXH@Z
_TEXT	SEGMENT
?SetPauseState@@YAXH@Z PROC				; SetPauseState, COMDAT
; _newPauseState$ = ecx

; 1623 : {

	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	npad	7
$LL4@SetPauseSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@SetPauseSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@SetPauseSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetPauseSt
$LN18@SetPauseSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetPauseSt
$LN3@SetPauseSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, esi	; isSearchPaused
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1627 : }

	ret	0
?SetPauseState@@YAXH@Z ENDP				; SetPauseState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetTerminationState@@YAXXZ
_TEXT	SEGMENT
?SetTerminationState@@YAXXZ PROC			; SetTerminationState, COMDAT

; 1655 : {

	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL4@SetTermina:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN3@SetTermina
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN18@SetTermina

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetTermina
$LN18@SetTermina:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetTermina
$LN3@SetTermina:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1657 : 	wasSearchTerminated = TRUE;

	mov	DWORD PTR ?wasSearchTerminated@@3HA, 1	; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	pop	esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1659 : }

	ret	0
?SetTerminationState@@YAXXZ ENDP			; SetTerminationState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateCurrentStatus@@YAN_K@Z
_TEXT	SEGMENT
_numGeneratedTripcodes_GPU$1$ = -24			; size = 8
_numGeneratedTripcodes_CPU$1$ = -16			; size = 8
$T1 = -8						; size = 8
_startingTime$ = 8					; size = 8
?UpdateCurrentStatus@@YAN_K@Z PROC			; UpdateCurrentStatus, COMDAT

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
	npad	4
$LL5@UpdateCurr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [esi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN4@UpdateCurr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN19@UpdateCurr

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@UpdateCurr
$LN19@UpdateCurr:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@UpdateCurr
$LN4@UpdateCurr:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();

	call	?GetNumGeneratedTripcodesByGPU@@YANXZ	; GetNumGeneratedTripcodesByGPU
	movsd	QWORD PTR _numGeneratedTripcodes_GPU$1$[ebp], xmm0

; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();

	call	?GetNumGeneratedTripcodesByCPU@@YANXZ	; GetNumGeneratedTripcodesByCPU
	movsd	QWORD PTR _numGeneratedTripcodes_CPU$1$[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;

	sub	eax, DWORD PTR _startingTime$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T1[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;

	mov	ecx, eax
	sbb	edx, DWORD PTR _startingTime$[ebp+4]
	call	__ultod3

; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;

	movsd	xmm2, QWORD PTR _numGeneratedTripcodes_CPU$1$[ebp]
	movapd	xmm4, xmm0
	movsd	xmm1, QWORD PTR _numGeneratedTripcodes_GPU$1$[ebp]
	movapd	xmm3, xmm2
	mulsd	xmm4, QWORD PTR __real@3f50624dd2f1a9fc
	addsd	xmm3, xmm1

; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;

	movsd	xmm6, QWORD PTR ?totalNumGeneratedTripcodes_GPU@@3NA

; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;

	movsd	xmm7, QWORD PTR ?totalNumGeneratedTripcodes_CPU@@3NA
	addsd	xmm6, xmm1
	addsd	xmm7, xmm2

; 1696 : 	totalTime += deltaTime;

	movsd	xmm0, QWORD PTR ?totalTime@@3NA
	movapd	xmm5, xmm3
	addsd	xmm0, xmm4

; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);

	divsd	xmm3, xmm4

; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);

	divsd	xmm1, xmm4

; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)

	comisd	xmm3, QWORD PTR ?maximumSpeed@@3NA
	divsd	xmm2, xmm4
	addsd	xmm5, QWORD PTR ?totalNumGeneratedTripcodes@@3NA
	movsd	QWORD PTR ?totalNumGeneratedTripcodes_GPU@@3NA, xmm6
	movsd	QWORD PTR ?totalNumGeneratedTripcodes_CPU@@3NA, xmm7
	movsd	QWORD PTR ?totalTime@@3NA, xmm0
	movsd	QWORD PTR ?currentSpeed_thisProcess@@3NA, xmm3
	movsd	QWORD PTR ?totalNumGeneratedTripcodes@@3NA, xmm5
	movsd	QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA, xmm1
	movsd	QWORD PTR ?currentSpeed_CPU@@3NA, xmm2
	jbe	SHORT $LN1@UpdateCurr

; 1701 : 		maximumSpeed = currentSpeed_thisProcess;

	movsd	QWORD PTR ?maximumSpeed@@3NA, xmm3
$LN1@UpdateCurr:

; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;

	mov	eax, DWORD PTR ?numValidTripcodes@@3IA	; numValidTripcodes
	mov	DWORD PTR ?prevNumValidTripcodes@@3IA, eax ; prevNumValidTripcodes

; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;

	mov	eax, DWORD PTR ?numDiscardedTripcodes@@3IA ; numDiscardedTripcodes
	movsd	QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA, xmm5
	movsd	QWORD PTR ?prevTotalNumGeneratedTripcodes_GPU@@3NA, xmm6
	movsd	QWORD PTR ?prevTotalNumGeneratedTripcodes_CPU@@3NA, xmm7
	mov	DWORD PTR ?prevNumDiscardedTripcodes@@3IA, eax ; prevNumDiscardedTripcodes
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1710 : 	return deltaTime;

	movapd	xmm0, xmm4

; 1711 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCurrentStatus@@YAN_K@Z ENDP			; UpdateCurrentStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartCUDADeviceSearchThreads@@YAXXZ
_TEXT	SEGMENT
__Launcher$2 = -264					; size = 24
$T3 = -240						; size = 8
__Launcher$4 = -232					; size = 24
__Launcher$5 = -208					; size = 24
_info$6 = -184						; size = 8
_info$7 = -176						; size = 8
_info$8 = -168						; size = 8
_info$9 = -160						; size = 8
_info$10 = -152						; size = 8
_info$11 = -144						; size = 8
_info$12 = -136						; size = 8
_info$13 = -128						; size = 8
__errorCode$1$ = -120					; size = 4
_i$1$ = -120						; size = 4
tv1504 = -120						; size = 4
$T14 = -120						; size = 4
$T15 = -120						; size = 4
_CUDADeviceIndex$1$ = -116				; size = 4
tv1503 = -116						; size = 4
_cursorPos$16 = -116					; size = 4
_cursorPos$17 = -116					; size = 4
_cursorPos$18 = -116					; size = 4
_cursorPos$19 = -116					; size = 4
$T20 = -116						; size = 4
_scrnBufInfo$21 = -112					; size = 22
_scrnBufInfo$22 = -88					; size = 22
_scrnBufInfo$23 = -64					; size = 22
_scrnBufInfo$24 = -40					; size = 22
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?StartCUDADeviceSearchThreads@@YAXXZ PROC		; StartCUDADeviceSearchThreads, COMDAT

; 1793 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StartCUDADeviceSearchThreads@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1794 : 	int32_t    i;
; 1795 : 	uint32_t winThreadID;
; 1796 : 	
; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	test	eax, eax
	jg	$LN62@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN519@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN61@StartCUDAD
	push	14					; 0000000eH
	push	OFFSET $SG4294899103
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899102
$LN542@StartCUDAD:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN74@StartCUDAD
$LN61@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1797					; 00000705H
	push	OFFSET $SG4294899101
	push	OFFSET $SG4294899100
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$6[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$6[ebp]
	mov	DWORD PTR _info$6[ebp], 100		; 00000064H
$LN540@StartCUDAD:
	push	eax
	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
$LN541@StartCUDAD:
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN74@StartCUDAD:

; 1794 : 	int32_t    i;
; 1795 : 	uint32_t winThreadID;
; 1796 : 	
; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN543@StartCUDAD:
$LN519@StartCUDAD:
	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
$LN62@StartCUDAD:

; 1798 : 
; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXIABUnothrow_t@std@@@Z		; operator new[]
	add	esp, 8
	mov	DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A, eax ; cuda_device_search_threads
	test	eax, eax
	jne	$LN59@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN59@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN58@StartCUDAD
	push	5
	push	OFFSET $SG4294899099
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899098
	jmp	$LN542@StartCUDAD
$LN58@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899097
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$7[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$7[ebp]
	mov	DWORD PTR _info$7[ebp], 100		; 00000064H

; 1798 : 
; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	jmp	$LN540@StartCUDAD
$LN59@StartCUDAD:

; 1800 : 	ERROR0((CUDADeviceSearchThreadInfoArray = (struct CUDADeviceSearchThreadInfo *)malloc(sizeof(struct CUDADeviceSearchThreadInfo) * numCUDADeviceSearchThreads)) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	imul	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 1640 ; numCUDADeviceSearchThreads
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A, eax ; CUDADeviceSearchThreadInfoArray
	test	eax, eax
	jne	SHORT $LN520@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN520@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN55@StartCUDAD
	push	5
	push	OFFSET $SG4294899096
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899095
	jmp	$LN542@StartCUDAD
$LN55@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899094
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN74@StartCUDAD
$LN520@StartCUDAD:

; 1801 : 	if (options.GPUIndex == GPU_INDEX_ALL) {

	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	cmp	ecx, -1
	jne	$LN53@StartCUDAD

; 1802 : 		int32_t CUDADeviceIndex;
; 1803 : 		for (CUDADeviceIndex = 0, i = 0; CUDADeviceIndex < CUDADeviceCount; ++CUDADeviceIndex) {

	xor	ecx, ecx
	xor	edi, edi
	mov	DWORD PTR _CUDADeviceIndex$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR ?CUDADeviceCount@@3HA, ecx	; CUDADeviceCount
	jle	$LN523@StartCUDAD
	npad	6
$LL52@StartCUDAD:

; 1804 : 			for (int32_t j = 0; j < CUDA_NUM_THREADS_PER_DEVICE; ++j, ++i) {

	xor	esi, esi
	imul	ebx, edi, 1640
$LL49@StartCUDAD:

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	cmp	edi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LN46@StartCUDAD
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL139@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN138@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN153@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL139@StartCUDAD
$LN153@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL139@StartCUDAD
$LN138@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	mov	edi, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	test	eax, eax
	je	$LN486@StartCUDAD
	mov	ecx, DWORD PTR _CUDADeviceIndex$1$[ebp]
$LN46@StartCUDAD:

; 1806 : 				CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = CUDADeviceIndex;

	mov	eax, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	mov	DWORD PTR [ebx+eax], ecx

; 1807 : 				CUDADeviceSearchThreadInfoArray[i].subindex = j;

	mov	DWORD PTR [ebx+eax+4], esi

; 1808 : 				CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';

	mov	BYTE PTR [ebx+eax+604], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1809 : 				CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	push	DWORD PTR _CUDADeviceIndex$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1809 : 				CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR [ebx+ecx+1632], eax

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	lea	eax, DWORD PTR [ecx+8]
	add	eax, ebx
	mov	DWORD PTR [ebx+ecx+1636], edx
	push	eax
	call	DWORD PTR __imp__cudaGetDeviceProperties@8
	mov	DWORD PTR __errorCode$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN48@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN487@StartCUDAD
$LN48@StartCUDAD:

; 1804 : 			for (int32_t j = 0; j < CUDA_NUM_THREADS_PER_DEVICE; ++j, ++i) {

	mov	ecx, DWORD PTR _CUDADeviceIndex$1$[ebp]
	inc	esi
	inc	edi
	add	ebx, 1640				; 00000668H
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	esi, 2
	jl	$LL49@StartCUDAD

; 1802 : 		int32_t CUDADeviceIndex;
; 1803 : 		for (CUDADeviceIndex = 0, i = 0; CUDADeviceIndex < CUDADeviceCount; ++CUDADeviceIndex) {

	inc	ecx
	mov	DWORD PTR _CUDADeviceIndex$1$[ebp], ecx
	cmp	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jl	$LL52@StartCUDAD
$LN523@StartCUDAD:

; 1821 : 		}
; 1822 : 	}
; 1823 : 
; 1824 : 	if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12					; 0000000cH
	jne	$LN19@StartCUDAD

; 1825 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	xor	ebx, ebx
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, ebx ; numCUDADeviceSearchThreads
	jle	$LN518@StartCUDAD
	xor	esi, esi
	mov	DWORD PTR tv1504[ebp], esi
	npad	5
$LL18@StartCUDAD:

; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	8
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR $T20[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	$LN65@StartCUDAD
	add	esi, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$5[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$5[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$5[ebp+16], OFFSET ?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnCUDADevice
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$5[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$5[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	mov	esi, DWORD PTR tv1504[ebp]
	jmp	$LN66@StartCUDAD
$LN486@StartCUDAD:

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN45@StartCUDAD
	push	14					; 0000000eH
	push	OFFSET $SG4294899093
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899092
	jmp	$LN542@StartCUDAD
$LN45@StartCUDAD:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$23[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN181@StartCUDAD

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$23[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$19[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN183@StartCUDAD
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN536@StartCUDAD
$LN183@StartCUDAD:
	xor	eax, eax
$LN536@StartCUDAD:
	mov	WORD PTR _cursorPos$19[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$19[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN181@StartCUDAD:

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	push	1805					; 0000070dH
	push	OFFSET $SG4294899091
	push	OFFSET $SG4294899090
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$12[ebp]
	mov	DWORD PTR _info$12[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$12[ebp], 100		; 00000064H
	call	esi

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	jmp	$LN541@StartCUDAD
$LN487@StartCUDAD:

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN42@StartCUDAD
	push	4
	push	OFFSET $SG4294899089
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	4
	push	OFFSET $SG4294899088
	jmp	$LN542@StartCUDAD
$LN42@StartCUDAD:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$21[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN222@StartCUDAD

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$21[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$18[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN224@StartCUDAD
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN537@StartCUDAD
$LN224@StartCUDAD:
	xor	eax, eax
$LN537@StartCUDAD:
	mov	WORD PTR _cursorPos$18[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$18[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN222@StartCUDAD:

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	mov	ecx, OFFSET $SG4294899087
	mov	al, 46					; 0000002eH
	mov	edx, ecx
$LL40@StartCUDAD:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN36@StartCUDAD
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN39@StartCUDAD
$LN36@StartCUDAD:
	lea	edx, DWORD PTR [ecx+1]
$LN39@StartCUDAD:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL40@StartCUDAD
	mov	eax, DWORD PTR __errorCode$1$[ebp]
	push	1810					; 00000712H
	push	edx
	push	eax
	push	eax
	call	DWORD PTR __imp__cudaGetErrorString@4
	push	eax
	push	OFFSET $SG4294899086
	call	_printf
	add	esp, 20					; 00000014H
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$10[ebp]
	mov	DWORD PTR _info$10[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$10[ebp], 100		; 00000064H
	call	esi

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	jmp	$LN541@StartCUDAD
$LN53@StartCUDAD:

; 1811 : 			}
; 1812 : 		}
; 1813 : 	} else if (options.GPUIndex < CUDADeviceCount) {

	cmp	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jge	$LN523@StartCUDAD

; 1814 : 		ASSERT(numCUDADeviceSearchThreads == CUDA_NUM_THREADS_PER_DEVICE);

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 2 ; numCUDADeviceSearchThreads
	je	$LN33@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN522@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN32@StartCUDAD
	push	14					; 0000000eH
	push	OFFSET $SG4294899085
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899084
	jmp	$LN542@StartCUDAD
$LN32@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1814					; 00000716H
	push	OFFSET $SG4294899083
	push	OFFSET $SG4294899082
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN74@StartCUDAD
$LN522@StartCUDAD:
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
$LN33@StartCUDAD:

; 1815 : 		for (i = 0; i < CUDA_NUM_THREADS_PER_DEVICE; ++i) {

	xor	edi, edi
	xor	esi, esi
	npad	2
$LL30@StartCUDAD:

; 1816 : 			CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = options.GPUIndex;

	mov	eax, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	mov	DWORD PTR [esi+eax], ecx

; 1817 : 			CUDADeviceSearchThreadInfoArray[i].subindex = i;

	mov	DWORD PTR [esi+eax+4], edi

; 1818 : 			CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';

	mov	BYTE PTR [esi+eax+604], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1819 : 			CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
	mov	DWORD PTR [esi+ecx+1632], eax

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+ecx+1636], edx
	add	eax, esi
	push	DWORD PTR ?options@@3UOptions@@A
	push	eax
	call	DWORD PTR __imp__cudaGetDeviceProperties@8
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN29@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN488@StartCUDAD
$LN29@StartCUDAD:

; 1815 : 		for (i = 0; i < CUDA_NUM_THREADS_PER_DEVICE; ++i) {

	add	esi, 1640				; 00000668H
	inc	edi
	cmp	esi, 3280				; 00000cd0H
	jge	$LN523@StartCUDAD
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	jmp	SHORT $LL30@StartCUDAD
$LN488@StartCUDAD:

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN26@StartCUDAD
	push	4
	push	OFFSET $SG4294899081
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	4
	push	OFFSET $SG4294899080
	jmp	$LN542@StartCUDAD
$LN26@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899079
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL24@StartCUDAD:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN20@StartCUDAD
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN23@StartCUDAD
$LN20@StartCUDAD:
	lea	edx, DWORD PTR [ecx+1]
$LN23@StartCUDAD:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL24@StartCUDAD
	push	1820					; 0000071cH
	push	edx
	push	ebx
	push	ebx
	call	DWORD PTR __imp__cudaGetErrorString@4
	push	eax
	push	OFFSET $SG4294899078
	call	_printf
	add	esp, 20					; 00000014H
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$8[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$8[ebp]
	mov	DWORD PTR _info$8[ebp], 100		; 00000064H

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	jmp	$LN540@StartCUDAD
$LN65@StartCUDAD:

; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	xor	edi, edi
$LN66@StartCUDAD:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
	mov	DWORD PTR [eax+ebx*4], edi

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	edi, edi
	jne	SHORT $LN17@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN489@StartCUDAD
$LN17@StartCUDAD:

; 1825 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	ebx
	add	esi, 1640				; 00000668H
	mov	DWORD PTR tv1504[ebp], esi
	cmp	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	$LL18@StartCUDAD
$LN518@StartCUDAD:

; 1838 : 		}
; 1839 : 	}
; 1840 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN489@StartCUDAD:

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN14@StartCUDAD
	push	12					; 0000000cH
	push	OFFSET $SG4294899077
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	12					; 0000000cH
	push	OFFSET $SG4294899076
	jmp	$LN542@StartCUDAD
$LN14@StartCUDAD:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$22[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN331@StartCUDAD

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$22[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$17[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN333@StartCUDAD
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN538@StartCUDAD
$LN333@StartCUDAD:
	xor	eax, eax
$LN538@StartCUDAD:
	mov	WORD PTR _cursorPos$17[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$17[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN331@StartCUDAD:

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	push	OFFSET $SG4294899075
	push	OFFSET $SG4294899074
	call	_printf
	add	esp, 8
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$11[ebp]
	mov	DWORD PTR _info$11[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$11[ebp], 100		; 00000064H
	call	esi

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	jmp	$LN541@StartCUDAD
$LN19@StartCUDAD:

; 1828 : 		}
; 1829 : 	} else {
; 1830 : 		ASSERT(lenTripcode == 10);

	cmp	eax, 10					; 0000000aH
	je	$LN524@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN524@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN10@StartCUDAD
	push	14					; 0000000eH
	push	OFFSET $SG4294899073
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899072
	jmp	$LN542@StartCUDAD
$LN10@StartCUDAD:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1830					; 00000726H
	push	OFFSET $SG4294899071
	push	OFFSET $SG4294899070
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;

	mov	DWORD PTR _info$13[ebp+4], 1

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$13[ebp]
	mov	DWORD PTR _info$13[ebp], 100		; 00000064H

; 1828 : 		}
; 1829 : 	} else {
; 1830 : 		ASSERT(lenTripcode == 10);

	jmp	$LN540@StartCUDAD
$LN524@StartCUDAD:

; 1831 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	xor	ebx, ebx
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, ebx ; numCUDADeviceSearchThreads
	jle	$LN518@StartCUDAD
	xor	esi, esi
	mov	DWORD PTR tv1503[ebp], esi
	npad	10
$LL8@StartCUDAD:

; 1832 : 			if (CUDADeviceSearchThreadInfoArray[i].properties.major >= 5) {

	mov	eax, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray

; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	8
	cmp	DWORD PTR [esi+eax+320], 5
	jl	SHORT $LN5@StartCUDAD
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR $T15[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edi, edi
	je	$LN69@StartCUDAD
	add	esi, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$4[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$4[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$4[ebp+16], OFFSET ?Thread_SearchForDESTripcodesOnCUDADevice_Registers@@YAXPAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice_Registers
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$4[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));

	mov	esi, DWORD PTR tv1503[ebp]
	jmp	SHORT $LN70@StartCUDAD
$LN5@StartCUDAD:

; 1835 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR $T14[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	edi, edi
	je	SHORT $LN69@StartCUDAD
	add	esi, DWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PAUCUDADeviceSearchThreadInfo@@A ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], OFFSET ?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$2[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1835 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	mov	esi, DWORD PTR tv1503[ebp]
	jmp	SHORT $LN70@StartCUDAD
$LN69@StartCUDAD:
	xor	edi, edi
$LN70@StartCUDAD:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
	mov	DWORD PTR [eax+ebx*4], edi
	lea	eax, DWORD PTR [eax+ebx*4]

; 1836 : 			}
; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	edi, edi
	jne	SHORT $LN7@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN490@StartCUDAD
$LN7@StartCUDAD:

; 1831 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	ebx
	add	esi, 1640				; 00000668H
	mov	DWORD PTR tv1503[ebp], esi
	cmp	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	$LL8@StartCUDAD
	jmp	$LN518@StartCUDAD
$LN490@StartCUDAD:

; 1836 : 			}
; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartCUDAD
	push	12					; 0000000cH
	push	OFFSET $SG4294899069
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	12					; 0000000cH
	push	OFFSET $SG4294899068
	jmp	$LN542@StartCUDAD
$LN2@StartCUDAD:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$24[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN472@StartCUDAD

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$24[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$16[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN474@StartCUDAD
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN539@StartCUDAD
$LN474@StartCUDAD:
	xor	eax, eax
$LN539@StartCUDAD:
	mov	WORD PTR _cursorPos$16[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$16[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN472@StartCUDAD:

; 1836 : 			}
; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	push	OFFSET $SG4294899067
	push	OFFSET $SG4294899066
	call	_printf
	add	esp, 8
	call	__getch

; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$9[ebp]
	mov	DWORD PTR _info$9[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$9[ebp], 100		; 00000064H
	call	esi

; 1836 : 			}
; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	jmp	$LN541@StartCUDAD
$LN535@StartCUDAD:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$0:
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAXABUnothrow_t@std@@@Z		; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$3:
	lea	ecx, DWORD PTR __Launcher$5[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$1:
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAXABUnothrow_t@std@@@Z		; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$5:
	lea	ecx, DWORD PTR __Launcher$4[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$2:
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAXABUnothrow_t@std@@@Z		; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?StartCUDADeviceSearchThreads@@YAXXZ$7:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$?StartCUDADeviceSearchThreads@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?StartCUDADeviceSearchThreads@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartCUDADeviceSearchThreads@@YAXXZ ENDP		; StartCUDADeviceSearchThreads
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartOpenCLDeviceSearchThreads@@YAXXZ
_TEXT	SEGMENT
_i$3$ = -1080						; size = 4
tv2023 = -1080						; size = 4
_info$2 = -1076						; size = 8
_info$3 = -1076						; size = 8
$T4 = -1072						; size = 4
$T5 = -1072						; size = 4
_j$2$ = -1068						; size = 4
_j$1$ = -1068						; size = 4
_i$2$ = -1068						; size = 4
tv2021 = -1068						; size = 4
_cursorPos$6 = -1068					; size = 4
__Launcher$7 = -1064					; size = 24
__Launcher$8 = -1064					; size = 24
_scrnBufInfo$9 = -1064					; size = 22
_deviceVendor$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?StartOpenCLDeviceSearchThreads@@YAXXZ PROC		; StartOpenCLDeviceSearchThreads, COMDAT

; 1843 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StartOpenCLDeviceSearchThreads@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1068				; 0000042cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1844 : 	int32_t          i, j;
; 1845 : 	uint32_t winThreadID;
; 1846 : 	char         deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 1847 : 	
; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	test	eax, eax
	jg	$LN82@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN559@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN81@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899065
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899064
$LN570@StartOpenC:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN91@StartOpenC
$LN81@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1848					; 00000738H
	push	OFFSET $SG4294899063
	push	OFFSET $SG4294899062
$LN568@StartOpenC:
	call	_printf
	add	esp, 12					; 0000000cH
$LN567@StartOpenC:
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$3[ebp]
	mov	DWORD PTR _info$3[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$3[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
$LN569@StartOpenC:
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN91@StartOpenC:

; 1844 : 	int32_t          i, j;
; 1845 : 	uint32_t winThreadID;
; 1846 : 	char         deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 1847 : 	
; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN571@StartOpenC:
$LN559@StartOpenC:
	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
$LN82@StartOpenC:

; 1849 : 
; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXIABUnothrow_t@std@@@Z		; operator new[]
	add	esp, 8
	mov	DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A, eax ; opencl_device_search_threads
	test	eax, eax
	jne	SHORT $LN79@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN79@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN78@StartOpenC
	push	5
	push	OFFSET $SG4294899061
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899060
	jmp	$LN570@StartOpenC
$LN78@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899059
	call	_printf
	add	esp, 8
	jmp	$LN567@StartOpenC
$LN79@StartOpenC:

; 1851 : 	ERROR0((openCLDeviceSearchThreadInfoArray = new (std::nothrow) struct OpenCLDeviceSearchThreadInfo [numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	xor	ecx, ecx
	mov	edx, 1088				; 00000440H
	mul	edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXIABUnothrow_t@std@@@Z		; operator new[]
	add	esp, 8
	mov	DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A, eax ; openCLDeviceSearchThreadInfoArray
	test	eax, eax
	jne	SHORT $LN76@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN76@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN75@StartOpenC
	push	5
	push	OFFSET $SG4294899058
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899057
	jmp	$LN570@StartOpenC
$LN75@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899056
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN91@StartOpenC
$LN76@StartOpenC:

; 1852 : 	if (options.GPUIndex == GPU_INDEX_ALL) {

	mov	edi, DWORD PTR ?options@@3UOptions@@A
	cmp	edi, -1
	jne	$LN73@StartOpenC

; 1853 : 		int32_t openCLDeviceIDArrayIndex = 0;

	xor	ebx, ebx

; 1854 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	xor	edi, edi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, ebx ; numOpenCLDeviceSearchThreads
	jle	$LN561@StartOpenC
	npad	3
$LL72@StartOpenC:

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	push	0
	lea	eax, DWORD PTR _deviceVendor$[ebp]
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4140					; 0000102cH
	push	DWORD PTR [eax+ebx*4]
	call	DWORD PTR __imp__clGetDeviceInfo@20
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN69@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN523@StartOpenC
$LN69@StartOpenC:

; 1856 : 			openCLDeviceSearchThreadInfoArray[i].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	imul	esi, edi, 1088
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [esi+ecx], eax

; 1857 : 			openCLDeviceSearchThreadInfoArray[i].index           = openCLDeviceIDArrayIndex;
; 1858 : 			openCLDeviceSearchThreadInfoArray[i].subindex        = -1;
; 1859 : 			openCLDeviceSearchThreadInfoArray[i].status[0]       = '\0';
; 1860 : 			openCLDeviceSearchThreadInfoArray[i].runChildProcess = openCLRunChildProcesses;

	mov	eax, DWORD PTR ?openCLRunChildProcesses@@3HA ; openCLRunChildProcesses
	mov	DWORD PTR [esi+ecx+4], ebx
	mov	DWORD PTR [esi+ecx+8], -1
	mov	BYTE PTR [esi+ecx+12], 0
	mov	DWORD PTR [esi+ecx+1072], eax

; 1861 : 			openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	DWORD PTR [esi+ecx+1076], 0

; 1862 : 			//
; 1863 : 			openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	eax, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	eax, ebx

; 1864 : 			openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;
; 1865 : 			openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;
; 1866 : 			openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;

	movsd	QWORD PTR [esi+ecx+1056], xmm0
	mov	DWORD PTR [esi+ecx+1036], eax
	movups	XMMWORD PTR [esi+ecx+1040], xmm0

; 1867 : 			openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;

	mov	DWORD PTR [esi+ecx+1064], 0

; 1868 : 			openCLDeviceSearchThreadInfoArray[i].numRestarts                = 0;

	mov	DWORD PTR [esi+ecx+1068], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1871 : 			if (!openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, 0 ; openCLRunChildProcesses
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray

; 1872 : 				for (j = 1; j < options.openCLNumThreads; ++j) {

	mov	DWORD PTR _j$1$[ebp], 1
	mov	DWORD PTR [esi+ecx+1080], eax
	mov	DWORD PTR [esi+ecx+1084], edx
	mov	DWORD PTR [esi+ecx+8], 0
	jne	$LN61@StartOpenC
	cmp	DWORD PTR ?options@@3UOptions@@A+44, 1
	jle	$LN48@StartOpenC
	npad	2
$LL60@StartOpenC:

; 1873 : 					++i;

	inc	edi
	lea	esi, DWORD PTR [esi+1088]

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LN57@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN519@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN57@StartOpenC:

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	ebx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN54@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN520@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN54@StartOpenC:

; 1876 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+esi], eax

; 1877 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;
; 1878 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;

	mov	eax, DWORD PTR _j$1$[ebp]
	mov	DWORD PTR [ecx+esi+4], ebx
	mov	DWORD PTR [ecx+esi+8], eax

; 1879 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';

	mov	BYTE PTR [ecx+esi+12], 0

; 1880 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = FALSE;

	mov	DWORD PTR [ecx+esi+1072], 0

; 1881 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	DWORD PTR [ecx+esi+1076], 0

; 1882 : 					openCLDeviceSearchThreadInfoArray[i].numRestarts = 0;

	mov	DWORD PTR [ecx+esi+1068], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1883 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	mov	DWORD PTR [ecx+esi+1080], eax
	mov	eax, DWORD PTR _j$1$[ebp]
	inc	eax
	mov	DWORD PTR [ecx+esi+1084], edx
	mov	DWORD PTR _j$1$[ebp], eax
	cmp	eax, DWORD PTR ?options@@3UOptions@@A+44
	jl	$LL60@StartOpenC

; 1884 : 				}

	jmp	$LN48@StartOpenC
$LN61@StartOpenC:

; 1885 : 			} else {
; 1886 : 				openCLDeviceSearchThreadInfoArray[i].subindex       = 0;

	mov	DWORD PTR [esi+ecx+8], 0

; 1887 : 				for (j = 1; j < options.openCLNumProcesses; ++j) {

	cmp	DWORD PTR ?options@@3UOptions@@A+100, 1
	jle	$LN48@StartOpenC
	npad	10
$LL50@StartOpenC:

; 1888 : 					++i;

	inc	edi
	lea	esi, DWORD PTR [esi+1088]

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LN47@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN521@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN47@StartOpenC:

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	ebx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN44@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN522@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN44@StartOpenC:

; 1891 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [esi+ecx], eax

; 1892 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;
; 1893 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;

	mov	eax, DWORD PTR _j$2$[ebp]
	mov	DWORD PTR [esi+ecx+8], eax
	mov	DWORD PTR [esi+ecx+4], ebx

; 1894 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';

	mov	BYTE PTR [esi+ecx+12], 0

; 1895 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = TRUE;

	mov	DWORD PTR [esi+ecx+1072], 1

; 1896 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	DWORD PTR [esi+ecx+1076], 0

; 1897 : 					//
; 1898 : 					openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	eax, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	eax, ebx

; 1899 : 					openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;
; 1900 : 					openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;
; 1901 : 					openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;

	movsd	QWORD PTR [esi+ecx+1056], xmm0
	mov	DWORD PTR [esi+ecx+1036], eax
	movups	XMMWORD PTR [esi+ecx+1040], xmm0

; 1902 : 					openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;

	mov	DWORD PTR [esi+ecx+1064], 0

; 1903 : 					openCLDeviceSearchThreadInfoArray[i].numRestarts = 0;

	mov	DWORD PTR [esi+ecx+1068], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1904 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	mov	DWORD PTR [esi+ecx+1080], eax
	mov	eax, DWORD PTR _j$2$[ebp]
	inc	eax
	mov	DWORD PTR [esi+ecx+1084], edx
	mov	DWORD PTR _j$2$[ebp], eax
	cmp	eax, DWORD PTR ?options@@3UOptions@@A+100
	jl	$LL50@StartOpenC
$LN48@StartOpenC:

; 1854 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	edi

; 1905 : 				}
; 1906 : 			}
; 1907 : 			++openCLDeviceIDArrayIndex;

	inc	ebx
	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	$LL72@StartOpenC
$LN561@StartOpenC:

; 1957 : 			}	
; 1958 : 		}
; 1959 : 	}
; 1960 : 
; 1961 : 	if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12					; 0000000cH
	jne	$LN17@StartOpenC

; 1962 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	xor	esi, esi
	mov	DWORD PTR _i$2$[ebp], esi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, esi ; numOpenCLDeviceSearchThreads
	jle	$LN558@StartOpenC
	xor	edi, edi
	mov	DWORD PTR tv2023[ebp], edi
$LL16@StartOpenC:

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	$LN85@StartOpenC
	add	edi, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$8[ebp]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	eax, OFFSET ?Thread_RunChildProcessForOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_RunChildProcessForOpenCLDevice
	mov	esi, OFFSET ?Thread_SearchForSHA1TripcodesOnOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnOpenCLDevice
	cmp	DWORD PTR [edi+1072], 0
	cmovne	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$8[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$8[ebp+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$8[ebp+20], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	ebx
	lea	ecx, DWORD PTR __Launcher$8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$8[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	esi, DWORD PTR _i$2$[ebp]
	mov	edi, DWORD PTR tv2023[ebp]
	jmp	$LN86@StartOpenC
$LN523@StartOpenC:

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN68@StartOpenC
	push	15					; 0000000fH
	push	OFFSET $SG4294899055
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899054
	jmp	$LN570@StartOpenC
$LN68@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899053
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
$LL66@StartOpenC:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN62@StartOpenC
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN65@StartOpenC
$LN62@StartOpenC:
	lea	edx, DWORD PTR [ecx+1]
$LN65@StartOpenC:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL66@StartOpenC
	push	1855					; 0000073fH
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899052
	call	_printf
	add	esp, 16					; 00000010H
	jmp	$LN567@StartOpenC
$LN519@StartOpenC:

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN56@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899051
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899050
	jmp	$LN570@StartOpenC
$LN56@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1874					; 00000752H
	push	OFFSET $SG4294899049
	push	OFFSET $SG4294899048
	jmp	$LN568@StartOpenC
$LN520@StartOpenC:

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN53@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899047
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899046
	jmp	$LN570@StartOpenC
$LN53@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1875					; 00000753H
	push	OFFSET $SG4294899045
	push	OFFSET $SG4294899044
	jmp	$LN568@StartOpenC
$LN521@StartOpenC:

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN46@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899043
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899042
	jmp	$LN570@StartOpenC
$LN46@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1889					; 00000761H
	push	OFFSET $SG4294899041
	push	OFFSET $SG4294899040
	jmp	$LN568@StartOpenC
$LN522@StartOpenC:

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN43@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899039
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899038
	jmp	$LN570@StartOpenC
$LN43@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1890					; 00000762H
	push	OFFSET $SG4294899037
	push	OFFSET $SG4294899036
	jmp	$LN568@StartOpenC
$LN73@StartOpenC:

; 1908 : 		}
; 1909 : 
; 1910 : 	} else if (CUDADeviceCount <= options.GPUIndex && options.GPUIndex < CUDADeviceCount + openCLDeviceCount) {

	mov	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	cmp	ecx, edi
	jg	$LN561@StartOpenC
	mov	eax, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	add	eax, ecx
	cmp	edi, eax
	jge	$LN561@StartOpenC

; 1911 : 		int32_t openCLDeviceIDArrayIndex = options.GPUIndex - CUDADeviceCount;
; 1912 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	push	0
	lea	eax, DWORD PTR _deviceVendor$[ebp]
	sub	edi, ecx
	push	eax
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	push	1024					; 00000400H
	push	4140					; 0000102cH
	push	DWORD PTR [eax+edi*4]
	call	DWORD PTR __imp__clGetDeviceInfo@20
	mov	esi, eax
	test	esi, esi
	je	$LN39@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN39@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN38@StartOpenC
	push	15					; 0000000fH
	push	OFFSET $SG4294899035
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	15					; 0000000fH
	push	OFFSET $SG4294899034
	jmp	$LN570@StartOpenC
$LN38@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	ecx, OFFSET $SG4294899033
	add	esp, 4
	mov	edx, ecx
	mov	al, 46					; 0000002eH
	npad	5
$LL36@StartOpenC:
	cmp	al, 92					; 0000005cH
	je	SHORT $LN32@StartOpenC
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN35@StartOpenC
$LN32@StartOpenC:
	lea	edx, DWORD PTR [ecx+1]
$LN35@StartOpenC:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL36@StartOpenC
	push	1912					; 00000778H
	push	edx
	mov	ecx, esi
	call	?ConvertOpenCLErrorCodeToString@@YAPADH@Z ; ConvertOpenCLErrorCodeToString
	push	eax
	push	OFFSET $SG4294899032
	call	_printf
	add	esp, 16					; 00000010H
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN91@StartOpenC
$LN39@StartOpenC:

; 1913 : 		openCLDeviceSearchThreadInfoArray[0].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx], eax

; 1914 : 		openCLDeviceSearchThreadInfoArray[0].index           = 0;
; 1915 : 		openCLDeviceSearchThreadInfoArray[0].subindex        = -1;
; 1916 : 		openCLDeviceSearchThreadInfoArray[0].status[0]       = '\0';
; 1917 : 		openCLDeviceSearchThreadInfoArray[0].runChildProcess = openCLRunChildProcesses;

	mov	eax, DWORD PTR ?openCLRunChildProcesses@@3HA ; openCLRunChildProcesses
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], -1
	mov	BYTE PTR [ecx+12], 0
	mov	DWORD PTR [ecx+1072], eax

; 1918 : 		openCLDeviceSearchThreadInfoArray[0].child_process = NULL;

	mov	DWORD PTR [ecx+1076], 0

; 1919 : 		//
; 1920 : 		openCLDeviceSearchThreadInfoArray[0].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	eax, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	eax, edi

; 1921 : 		openCLDeviceSearchThreadInfoArray[0].currentSpeed               = 0;
; 1922 : 		openCLDeviceSearchThreadInfoArray[0].averageSpeed               = 0;
; 1923 : 		openCLDeviceSearchThreadInfoArray[0].totalNumGeneratedTripcodes = 0;

	movsd	QWORD PTR [ecx+1056], xmm0
	mov	DWORD PTR [ecx+1036], eax
	movups	XMMWORD PTR [ecx+1040], xmm0

; 1924 : 		openCLDeviceSearchThreadInfoArray[0].numDiscardedTripcodes = 0;

	mov	DWORD PTR [ecx+1064], 0

; 1925 : 		openCLDeviceSearchThreadInfoArray[0].numRestarts = 0;

	mov	DWORD PTR [ecx+1068], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1927 : 		if (!openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, 0 ; openCLRunChildProcesses
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	mov	DWORD PTR [ecx+1080], eax
	mov	DWORD PTR [ecx+1084], edx
	jne	$LN31@StartOpenC

; 1928 : 			ASSERT(numOpenCLDeviceSearchThreads == options.openCLNumThreads);

	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	cmp	eax, DWORD PTR ?options@@3UOptions@@A+44
	je	$LN30@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN560@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN29@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899031
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899030
	jmp	$LN570@StartOpenC
$LN29@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1928					; 00000788H
	push	OFFSET $SG4294899029
	push	OFFSET $SG4294899028
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN91@StartOpenC
$LN560@StartOpenC:
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN30@StartOpenC:

; 1930 : 			for (j = 1; j < options.openCLNumThreads; ++j) {

	mov	ebx, 1
	mov	DWORD PTR [ecx+8], 0
	cmp	DWORD PTR ?options@@3UOptions@@A+44, ebx
	jle	$LN561@StartOpenC

; 1929 : 			openCLDeviceSearchThreadInfoArray[0].subindex       = 0;

	mov	esi, 1088				; 00000440H
	npad	3
$LL27@StartOpenC:

; 1931 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+ecx], eax

; 1932 : 				openCLDeviceSearchThreadInfoArray[j].index           = 0;

	mov	DWORD PTR [esi+ecx+4], 0

; 1933 : 				openCLDeviceSearchThreadInfoArray[j].subindex        = j;

	mov	DWORD PTR [esi+ecx+8], ebx

; 1934 : 				openCLDeviceSearchThreadInfoArray[j].status[0]       = '\0';

	mov	BYTE PTR [esi+ecx+12], 0

; 1935 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = FALSE;

	mov	DWORD PTR [esi+ecx+1072], 0

; 1936 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;

	mov	DWORD PTR [esi+ecx+1076], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1937 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	lea	esi, DWORD PTR [esi+1088]
	inc	ebx
	mov	DWORD PTR [esi+ecx-8], eax
	mov	DWORD PTR [esi+ecx-4], edx
	cmp	ebx, DWORD PTR ?options@@3UOptions@@A+44
	jl	SHORT $LL27@StartOpenC

; 1938 : 			}

	jmp	$LN561@StartOpenC
$LN31@StartOpenC:

; 1941 : 			for (j = 1; j < options.openCLNumProcesses; ++j) {

	mov	ebx, 1
	mov	DWORD PTR [ecx+8], 0
	cmp	DWORD PTR ?options@@3UOptions@@A+100, ebx
	jle	$LN561@StartOpenC

; 1939 : 		} else {
; 1940 : 			openCLDeviceSearchThreadInfoArray[0].subindex = 0;

	mov	esi, 1088				; 00000440H
$LL23@StartOpenC:

; 1942 : 				ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	edi, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN20@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN524@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
$LN20@StartOpenC:

; 1943 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	eax, DWORD PTR ?openCLDeviceIDArray@@3PAPAU_cl_device_id@@A ; openCLDeviceIDArray
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+ecx], eax

; 1944 : 				openCLDeviceSearchThreadInfoArray[j].index          = 0;

	mov	DWORD PTR [esi+ecx+4], 0

; 1945 : 				openCLDeviceSearchThreadInfoArray[j].subindex       = j;

	mov	DWORD PTR [esi+ecx+8], ebx

; 1946 : 				openCLDeviceSearchThreadInfoArray[j].status[0]      = '\0';

	mov	BYTE PTR [esi+ecx+12], 0

; 1947 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = TRUE;

	mov	DWORD PTR [esi+ecx+1072], 1

; 1948 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;

	mov	DWORD PTR [esi+ecx+1076], 0

; 1949 : 				//
; 1950 : 				openCLDeviceSearchThreadInfoArray[j].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	eax, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	eax, edi

; 1951 : 				openCLDeviceSearchThreadInfoArray[j].currentSpeed               = 0;
; 1952 : 				openCLDeviceSearchThreadInfoArray[j].averageSpeed               = 0;
; 1953 : 				openCLDeviceSearchThreadInfoArray[j].totalNumGeneratedTripcodes = 0;

	movsd	QWORD PTR [esi+ecx+1056], xmm0
	mov	DWORD PTR [esi+ecx+1036], eax
	movups	XMMWORD PTR [esi+ecx+1040], xmm0

; 1954 : 				openCLDeviceSearchThreadInfoArray[j].numDiscardedTripcodes = 0;

	mov	DWORD PTR [esi+ecx+1064], 0

; 1955 : 				openCLDeviceSearchThreadInfoArray[j].numRestarts = 0;

	mov	DWORD PTR [esi+ecx+1068], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1956 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	ecx, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
	inc	ebx
	mov	DWORD PTR [esi+ecx+1080], eax
	mov	DWORD PTR [esi+ecx+1084], edx
	add	esi, 1088				; 00000440H
	cmp	ebx, DWORD PTR ?options@@3UOptions@@A+100
	jl	$LL23@StartOpenC

; 1941 : 			for (j = 1; j < options.openCLNumProcesses; ++j) {

	jmp	$LN561@StartOpenC
$LN524@StartOpenC:

; 1942 : 				ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN19@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899027
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899026
	jmp	$LN570@StartOpenC
$LN19@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1942					; 00000796H
	push	OFFSET $SG4294899025
	push	OFFSET $SG4294899024
	call	_printf
	add	esp, 12					; 0000000cH
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
	jmp	$LN91@StartOpenC
$LN85@StartOpenC:

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	xor	ebx, ebx
$LN86@StartOpenC:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
	mov	DWORD PTR [eax+esi*4], ebx

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	ebx, ebx
	jne	SHORT $LN15@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN525@StartOpenC
$LN15@StartOpenC:

; 1962 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	esi
	add	edi, 1088				; 00000440H
	mov	DWORD PTR _i$2$[ebp], esi
	mov	DWORD PTR tv2023[ebp], edi
	cmp	esi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	$LL16@StartOpenC
$LN558@StartOpenC:

; 1975 : 		}
; 1976 : 	}
; 1977 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN525@StartOpenC:

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN12@StartOpenC
	push	12					; 0000000cH
	push	OFFSET $SG4294899023
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	12					; 0000000cH
	push	OFFSET $SG4294899022
	jmp	$LN570@StartOpenC
$LN12@StartOpenC:
	mov	edi, DWORD PTR ?prevLineCount@@3HA	; prevLineCount

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	lea	eax, DWORD PTR _scrnBufInfo$9[ebp]
	mov	esi, DWORD PTR __imp__GetStdHandle@4
	push	eax
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__GetConsoleScreenBufferInfo@8
	test	eax, eax
	je	SHORT $LN434@StartOpenC

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	mov	ecx, DWORD PTR _scrnBufInfo$9[ebp+6]
	xor	eax, eax
	mov	WORD PTR _cursorPos$6[ebp], ax
	movsx	eax, cx
	add	eax, edi
	js	SHORT $LN436@StartOpenC
	lea	eax, DWORD PTR [edi+ecx]
	jmp	SHORT $LN566@StartOpenC
$LN436@StartOpenC:
	xor	eax, eax
$LN566@StartOpenC:
	mov	WORD PTR _cursorPos$6[ebp+2], ax

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	push	DWORD PTR _cursorPos$6[ebp]
	push	-11					; fffffff5H
	call	esi
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorPosition@8
$LN434@StartOpenC:

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	push	OFFSET $SG4294899021
	push	OFFSET $SG4294899020
	call	_printf
	add	esp, 8
	call	__getch

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$2[ebp]
	mov	DWORD PTR _info$2[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$2[ebp], 100		; 00000064H
	call	esi

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	jmp	$LN569@StartOpenC
$LN17@StartOpenC:

; 1967 : 		}
; 1968 : 	} else {
; 1969 : 		ASSERT(lenTripcode == 10);

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN562@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN562@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN8@StartOpenC
	push	14					; 0000000eH
	push	OFFSET $SG4294899019
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899018
	jmp	$LN570@StartOpenC
$LN8@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1969					; 000007b1H
	push	OFFSET $SG4294899017
	push	OFFSET $SG4294899016
	jmp	$LN568@StartOpenC
$LN562@StartOpenC:

; 1970 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	xor	esi, esi
	mov	DWORD PTR _i$3$[ebp], esi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, esi ; numOpenCLDeviceSearchThreads
	jle	$LN558@StartOpenC
	xor	edi, edi
	mov	DWORD PTR tv2021[ebp], edi
	npad	4
$LL6@StartOpenC:

; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	ebx, ebx
	je	SHORT $LN87@StartOpenC
	add	edi, DWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PAUOpenCLDeviceSearchThreadInfo@@A ; openCLDeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$7[ebp]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	eax, OFFSET ?Thread_RunChildProcessForOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_RunChildProcessForOpenCLDevice
	mov	esi, OFFSET ?Thread_SearchForDESTripcodesOnOpenCLDevice@@YAXPAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnOpenCLDevice
	cmp	DWORD PTR [edi+1072], 0
	cmovne	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$7[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$7[ebp+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$7[ebp+20], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	ebx
	lea	ecx, DWORD PTR __Launcher$7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$7[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	esi, DWORD PTR _i$3$[ebp]
	mov	edi, DWORD PTR tv2021[ebp]
	jmp	SHORT $LN88@StartOpenC
$LN87@StartOpenC:
	xor	ebx, ebx
$LN88@StartOpenC:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
	mov	DWORD PTR [eax+esi*4], ebx

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	ebx, ebx
	jne	SHORT $LN5@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	SHORT $LN526@StartOpenC
$LN5@StartOpenC:

; 1970 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	esi
	add	edi, 1088				; 00000440H
	mov	DWORD PTR _i$3$[ebp], esi
	mov	DWORD PTR tv2021[ebp], edi
	cmp	esi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	$LL6@StartOpenC
	jmp	$LN558@StartOpenC
$LN526@StartOpenC:

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartOpenC
	push	12					; 0000000cH
	push	OFFSET $SG4294899015
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	12					; 0000000cH
	push	OFFSET $SG4294899014
	jmp	$LN570@StartOpenC
$LN2@StartOpenC:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899013
	push	OFFSET $SG4294899012
	call	_printf
	add	esp, 8
	jmp	$LN567@StartOpenC
$LN565@StartOpenC:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$2:
	lea	ecx, DWORD PTR __Launcher$8[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartOpenCLDeviceSearchThreads@@YAXXZ$4:
	lea	ecx, DWORD PTR __Launcher$7[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$?StartOpenCLDeviceSearchThreads@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1084]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?StartOpenCLDeviceSearchThreads@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartOpenCLDeviceSearchThreads@@YAXXZ ENDP		; StartOpenCLDeviceSearchThreads
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartGPUSearchThreads@@YAXXZ
_TEXT	SEGMENT
?StartGPUSearchThreads@@YAXXZ PROC			; StartGPUSearchThreads, COMDAT

; 1980 : {

	push	ecx

; 1981 : 	if (numCUDADeviceSearchThreads > 0)

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads
	jle	SHORT $LN2@StartGPUSe

; 1982 : 		StartCUDADeviceSearchThreads();

	call	?StartCUDADeviceSearchThreads@@YAXXZ	; StartCUDADeviceSearchThreads
$LN2@StartGPUSe:

; 1983 : 	if (numOpenCLDeviceSearchThreads > 0)

	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN1@StartGPUSe

; 1984 : 		StartOpenCLDeviceSearchThreads();

	call	?StartOpenCLDeviceSearchThreads@@YAXXZ	; StartOpenCLDeviceSearchThreads
$LN1@StartGPUSe:
	pop	ecx

; 1985 : }

	ret	0
?StartGPUSearchThreads@@YAXXZ ENDP			; StartGPUSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartCPUSearchThreads@@YAXXZ
_TEXT	SEGMENT
__Launcher$2 = -68					; size = 24
__Launcher$3 = -44					; size = 24
_info$4 = -20						; size = 8
$T5 = -16						; size = 4
$T6 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?StartCPUSearchThreads@@YAXXZ PROC			; StartCPUSearchThreads, COMDAT

; 1988 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StartCPUSearchThreads@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, 0	; numCPUSearchThreads
	jg	$LN143@StartCPUSe
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN143@StartCPUSe
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN17@StartCPUSe
	push	14					; 0000000eH
	push	OFFSET $SG4294899011
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899010
$LN148@StartCPUSe:
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN27@StartCPUSe
$LN17@StartCPUSe:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	1989					; 000007c5H
	push	OFFSET $SG4294899009
	push	OFFSET $SG4294899008
$LN147@StartCPUSe:
	call	_printf
	add	esp, 12					; 0000000cH
$LN146@StartCPUSe:
	call	__getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	lea	eax, DWORD PTR _info$4[ebp]
	mov	DWORD PTR _info$4[ebp+4], 1
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$4[ebp], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8
$LN27@StartCPUSe:

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN149@StartCPUSe:
$LN143@StartCPUSe:

; 1990 : 
; 1991 : 	uint32_t winThreadID;
; 1992 : 	
; 1993 : 	if (cpu_search_threads)

	mov	eax, DWORD PTR ?cpu_search_threads@@3PAPAVthread@std@@A ; cpu_search_threads
	test	eax, eax
	je	SHORT $LN15@StartCPUSe

; 1994 : 		delete [] cpu_search_threads;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN15@StartCPUSe:

; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	eax, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXIABUnothrow_t@std@@@Z		; operator new[]
	add	esp, 8
	mov	DWORD PTR ?cpu_search_threads@@3PAPAVthread@std@@A, eax ; cpu_search_threads
	test	eax, eax
	jne	SHORT $LN14@StartCPUSe
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	SHORT $LN14@StartCPUSe
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN13@StartCPUSe
	push	5
	push	OFFSET $SG4294899007
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	5
	push	OFFSET $SG4294899006
	jmp	$LN148@StartCPUSe
$LN13@StartCPUSe:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294899524
	push	OFFSET $SG4294899005
	call	_printf
	add	esp, 8
	jmp	$LN146@StartCPUSe
$LN14@StartCPUSe:

; 1996 : 	
; 1997 : 	for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	xor	edi, edi
	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, edi ; numCPUSearchThreads
	jle	$LN142@StartCPUSe
	npad	9
$LL11@StartCPUSe:

; 1998 : 		if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN8@StartCPUSe

; 1999 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCPU);

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	8
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR $T6[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	$LN23@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$3[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$3[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$3[ebp+16], OFFSET ?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ ; Thread_SearchForSHA1TripcodesOnCPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	esi
	lea	ecx, DWORD PTR __Launcher$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$3[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1999 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCPU);

	jmp	SHORT $LN24@StartCPUSe
$LN8@StartCPUSe:

; 2000 : 		} else {
; 2001 : 			ASSERT(lenTripcode == 10);

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN6@StartCPUSe
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN137@StartCPUSe
$LN6@StartCPUSe:

; 2002 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCPU);

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	8
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR $T5[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	esi, esi
	je	SHORT $LN23@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], OFFSET ?Thread_SearchForDESTripcodesOnCPU@@YAXXZ ; Thread_SearchForDESTripcodesOnCPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	esi
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2002 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCPU);

	jmp	SHORT $LN24@StartCPUSe
$LN23@StartCPUSe:
	xor	esi, esi
$LN24@StartCPUSe:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ?cpu_search_threads@@3PAPAVthread@std@@A ; cpu_search_threads
	mov	DWORD PTR [eax+edi*4], esi
	lea	eax, DWORD PTR [eax+edi*4]

; 2003 : 		}
; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	test	esi, esi
	jne	SHORT $LN10@StartCPUSe
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN138@StartCPUSe
$LN10@StartCPUSe:

; 1996 : 	
; 1997 : 	for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	inc	edi
	cmp	edi, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	jl	$LL11@StartCPUSe
$LN142@StartCPUSe:

; 2005 : 	}
; 2006 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN137@StartCPUSe:

; 2000 : 		} else {
; 2001 : 			ASSERT(lenTripcode == 10);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN5@StartCPUSe
	push	14					; 0000000eH
	push	OFFSET $SG4294899004
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	14					; 0000000eH
	push	OFFSET $SG4294899003
	jmp	$LN148@StartCPUSe
$LN5@StartCPUSe:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	2001					; 000007d1H
	push	OFFSET $SG4294899002
	push	OFFSET $SG4294899001
	jmp	$LN147@StartCPUSe
$LN138@StartCPUSe:

; 2003 : 		}
; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartCPUSe
	push	12					; 0000000cH
	push	OFFSET $SG4294899000
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	12					; 0000000cH
	push	OFFSET $SG4294898999
	jmp	$LN148@StartCPUSe
$LN2@StartCPUSe:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294898998
	push	OFFSET $SG4294898997
	call	_printf
	add	esp, 8
	jmp	$LN146@StartCPUSe
$LN145@StartCPUSe:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$0:
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXABUnothrow_t@std@@@Z		; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$2:
	lea	ecx, DWORD PTR __Launcher$3[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ
__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$1:
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXABUnothrow_t@std@@@Z		; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?StartCPUSearchThreads@@YAXXZ$4:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ
__ehhandler$?StartCPUSearchThreads@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?StartCPUSearchThreads@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartCPUSearchThreads@@YAXXZ ENDP			; StartCPUSearchThreads
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetParentProcessID@@YAHXZ
_TEXT	SEGMENT
_parentProcessID$1$ = -564				; size = 4
_processEntry$ = -560					; size = 556
__$ArrayPad$ = -4					; size = 4
?GetParentProcessID@@YAHXZ PROC				; GetParentProcessID, COMDAT

; 2009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 564				; 00000234H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2010 : 	int32_t processID = GetCurrentProcessId();

	call	DWORD PTR __imp__GetCurrentProcessId@0

; 2011 : 	int32_t parentProcessID = -1;
; 2012 : 	HANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	push	0
	push	2
	mov	edi, eax
	mov	DWORD PTR _parentProcessID$1$[ebp], -1
	call	DWORD PTR __imp__CreateToolhelp32Snapshot@8

; 2013 : 	PROCESSENTRY32 processEntry = {0};

	push	552					; 00000228H
	mov	esi, eax
	lea	eax, DWORD PTR _processEntry$[ebp+4]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2014 : 	processEntry.dwSize = sizeof(PROCESSENTRY32);

	mov	DWORD PTR _processEntry$[ebp], 556	; 0000022cH

; 2015 : 
; 2016 : 	if(Process32First(hSnapProcess, &processEntry)) {

	lea	eax, DWORD PTR _processEntry$[ebp]
	push	eax
	push	esi
	call	DWORD PTR __imp__Process32FirstW@8
	test	eax, eax
	je	SHORT $LN2@GetParentP
	push	ebx
	mov	ebx, DWORD PTR __imp__Process32NextW@8
	npad	4
$LL4@GetParentP:

; 2017 : 		do {
; 2018 :     		if (processEntry.th32ProcessID == processID) {

	cmp	DWORD PTR _processEntry$[ebp+8], edi
	je	SHORT $LN9@GetParentP

; 2020 :     			break;
; 2021 : 			}
; 2022 : 		} while( Process32Next(hSnapProcess, &processEntry));

	lea	eax, DWORD PTR _processEntry$[ebp]
	push	eax
	push	esi
	call	ebx
	test	eax, eax
	jne	SHORT $LL4@GetParentP
	jmp	SHORT $LN12@GetParentP
$LN9@GetParentP:

; 2019 :     			parentProcessID = processEntry.th32ParentProcessID;

	mov	eax, DWORD PTR _processEntry$[ebp+24]
	mov	DWORD PTR _parentProcessID$1$[ebp], eax
$LN12@GetParentP:
	pop	ebx
$LN2@GetParentP:

; 2023 : 	}
; 2024 : 
; 2025 : 	CloseHandle(hSnapProcess);

	push	esi
	call	DWORD PTR __imp__CloseHandle@4

; 2026 : 	return parentProcessID;
; 2027 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _parentProcessID$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetParentProcessID@@YAHXZ ENDP				; GetParentProcessID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListExpandedPatterns@@YAXXZ
_TEXT	SEGMENT
?ListExpandedPatterns@@YAXXZ PROC			; ListExpandedPatterns, COMDAT

; 2030 : {

	push	esi

; 2031 : 	for (int32_t i = 0; i < numExpandedPatterns; ++i)

	xor	esi, esi
	cmp	DWORD PTR ?numExpandedPatterns@@3IA, esi ; numExpandedPatterns
	jbe	SHORT $LN1@ListExpand
	push	edi
	xor	edi, edi
	npad	2
$LL3@ListExpand:

; 2032 : 		printf("%d: `%s' @ %d\n", i, expandedPatternArray[i].c, expandedPatternArray[i].pos);

	mov	ecx, DWORD PTR ?expandedPatternArray@@3PAUExpandedPattern@@A ; expandedPatternArray
	movzx	eax, BYTE PTR [ecx+edi]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	add	eax, edi
	push	eax
	push	esi
	push	OFFSET $SG4294898996
	call	_printf
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 14					; 0000000eH
	cmp	esi, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	jb	SHORT $LL3@ListExpand
	pop	edi
$LN1@ListExpand:
	pop	esi

; 2033 : }

	ret	0
?ListExpandedPatterns@@YAXXZ ENDP			; ListExpandedPatterns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_parentProcess$1$ = -44					; size = 4
_listExpandedPatternsAndExit$1$ = -44			; size = 4
_startingTime$4$ = -40					; size = 4
_startingTime$1$ = -40					; size = 4
_startingTime$3$ = -36					; size = 4
_startingTime$2$ = -36					; size = 4
_displayDeviceInformationAndExit$1$ = -36		; size = 4
_info$1 = -32						; size = 8
$T2 = -24						; size = 8
$T3 = -16						; size = 8
__real@3fe0000000000000$1$ = -8				; size = 8
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 2036 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi

; 2037 : 	BOOL   displayDeviceInformationAndExit = false;
; 2038 : 	BOOL   listExpandedPatternsAndExit     = false;
; 2039 : 
; 2040 : 	if (argc > 1) {

	mov	edi, DWORD PTR _argc$[ebp]
	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR _listExpandedPatternsAndExit$1$[esp+56], ebx
	cmp	edi, 1
	jle	SHORT $LN56@main

; 2041 : 		displayDeviceInformationAndExit = (strcmp(argv[1], "--display-device-information") == 0);

	mov	eax, DWORD PTR _argv$[ebp]
	mov	edx, OFFSET $SG4294898995
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, eax
	npad	7
$LL393@main:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN394@main
	test	bl, bl
	je	SHORT $LN395@main
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN394@main
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL393@main
$LN395@main:
	xor	ecx, ecx
	jmp	SHORT $LN396@main
$LN394@main:
	sbb	ecx, ecx
	or	ecx, 1
$LN396@main:
	xor	edx, edx
	test	ecx, ecx

; 2042 : 		listExpandedPatternsAndExit     = (strcmp(argv[1], "--list-expanded-patterns"    ) == 0);

	mov	ecx, OFFSET $SG4294898994
	sete	dl
	mov	DWORD PTR _displayDeviceInformationAndExit$1$[esp+56], edx
$LL397@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN398@main
	test	dl, dl
	je	SHORT $LN399@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN398@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL397@main
$LN399@main:
	xor	eax, eax
	jmp	SHORT $LN400@main
$LN398@main:
	sbb	eax, eax
	or	eax, 1
$LN400@main:
	mov	esi, DWORD PTR _displayDeviceInformationAndExit$1$[esp+56]
	xor	ebx, ebx
	test	eax, eax
	sete	bl
	mov	DWORD PTR _listExpandedPatternsAndExit$1$[esp+56], ebx
$LN56@main:

; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	lea	eax, DWORD PTR _info$1[esp+56]
	mov	DWORD PTR _info$1[esp+60], 0
	push	eax
	push	-11					; fffffff5H
	mov	DWORD PTR _info$1[esp+64], 100		; 00000064H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleCursorInfo@8

; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);

	push	1
	push	OFFSET ?ControlHandler@@YGHK@Z		; ControlHandler
	call	DWORD PTR __imp__SetConsoleCtrlHandler@8

; 2043 : 	}
; 2044 : 
; 2045 : 	InitProcess();
; 2046 : 	if (    argc <= 1
; 2047 : 		|| (   strcmp(argv[1], "--gpu-list"              ) != 0
; 2048 : 		    && !displayDeviceInformationAndExit
; 2049 : 			&& !listExpandedPatternsAndExit
; 2050 : 		    && strcmp(argv[1], "--output-for-redirection") != 0))

	cmp	edi, 1
	jle	SHORT $LN54@main
	mov	eax, DWORD PTR _argv$[ebp]
	mov	edx, OFFSET $SG4294898993
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	npad	4
$LL401@main:
	mov	bl, BYTE PTR [eax]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN402@main
	test	bl, bl
	je	SHORT $LN403@main
	mov	bl, BYTE PTR [eax+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN402@main
	add	eax, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL401@main
$LN403@main:
	xor	eax, eax
	jmp	SHORT $LN404@main
$LN402@main:
	sbb	eax, eax
	or	eax, 1
$LN404@main:
	mov	ebx, DWORD PTR _listExpandedPatternsAndExit$1$[esp+56]
	test	eax, eax
	je	SHORT $LN55@main
	test	esi, esi
	jne	SHORT $LN55@main
	test	ebx, ebx
	jne	SHORT $LN55@main
	mov	eax, OFFSET $SG4294898992
	npad	6
$LL405@main:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN406@main
	test	dl, dl
	je	SHORT $LN407@main
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN406@main
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL405@main
$LN407@main:
	xor	eax, eax
	jmp	SHORT $LN408@main
$LN406@main:
	sbb	eax, eax
	or	eax, 1
$LN408@main:
	test	eax, eax
	je	SHORT $LN55@main
$LN54@main:

; 2051 : 		DisplayCopyrights();

	call	?DisplayCopyrights@@YAXXZ		; DisplayCopyrights
$LN55@main:

; 2052 : 	ObtainOptions(argc, argv);

	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, edi
	call	?ObtainOptions@@YAXHPAPAD@Z		; ObtainOptions

; 2053 : 	if (argc > 1 && strcmp(argv[1], "--gpu-list") == 0)

	cmp	edi, 1
	jle	SHORT $LN53@main
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, OFFSET $SG4294898991
	mov	eax, DWORD PTR [eax+4]
$LL409@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN410@main
	test	dl, dl
	je	SHORT $LN411@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN410@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL409@main
$LN411@main:
	xor	eax, eax
	jmp	SHORT $LN412@main
$LN410@main:
	sbb	eax, eax
	or	eax, 1
$LN412@main:
	test	eax, eax
	jne	SHORT $LN53@main

; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)

	cmp	DWORD PTR ?options@@3UOptions@@A+76, eax
	jne	$LN68@main
	jmp	$LN435@main
$LN53@main:

; 2054 : 		ListGPUsAndExit();
; 2055 : 	InitSearchDevices((!options.redirection && !listExpandedPatternsAndExit) || displayDeviceInformationAndExit);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	SHORT $LN59@main
	test	ebx, ebx
	je	SHORT $LN60@main
$LN59@main:
	test	esi, esi
	jne	SHORT $LN60@main
	xor	ecx, ecx
	jmp	SHORT $LN61@main
$LN60@main:
	mov	ecx, 1
$LN61@main:
	call	?InitSearchDevices@@YAXH@Z		; InitSearchDevices

; 2056 : 
; 2057 : 	if (displayDeviceInformationAndExit)

	test	esi, esi
	jne	$LN437@main

; 2059 : 
; 2060 : 	CreateCharacterTables();

	call	?CreateCharacterTables@@YAXXZ		; CreateCharacterTables

; 2061 : 	LoadTargetPatterns(!options.redirection && !listExpandedPatternsAndExit);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	jne	SHORT $LN62@main
	test	ebx, ebx
	jne	SHORT $LN62@main
	lea	ecx, DWORD PTR [esi+1]
	jmp	SHORT $LN63@main
$LN62@main:
	xor	ecx, ecx
$LN63@main:
	call	?LoadTargetPatterns@@YAXH@Z		; LoadTargetPatterns

; 2062 : 
; 2063 : 	if (listExpandedPatternsAndExit) {

	test	ebx, ebx
	jne	$LN438@main

; 2066 : 	}
; 2067 : 
; 2068 : 	if (!options.redirection)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	jne	SHORT $LN74@main

; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");

	push	OFFSET $SG4294899112
	push	OFFSET ?tripcodeFilePath@@3PADA		; tripcodeFilePath
	call	_fopen
	add	esp, 8
	mov	DWORD PTR ?tripcodeFile@@3PAU_iobuf@@A, eax ; tripcodeFile
$LN74@main:

; 2069 : 		OpenTripcodeFile();
; 2070 : 
; 2071 : #ifdef DEBUG_TEST_NEW_CODE
; 2072 : 	if (options.testNewCode)

	cmp	DWORD PTR ?options@@3UOptions@@A+24, 0
	je	SHORT $LN49@main

; 2073 : 		TestNewCode();

	call	?TestNewCode@@YAXXZ			; TestNewCode
$LN49@main:

; 2074 : #endif
; 2075 : 	
; 2076 : #ifdef REDIRECTION_ONLY
; 2077 : 	if (!options.redirection)
; 2078 : 		exit(0);
; 2079 : #endif
; 2080 : 
; 2081 : 	// Prepare for pausing.
; 2082 : 	HANDLE mutexForPausing = NULL;

	xor	ebx, ebx

; 2083 : 	if (options.redirection && nameMutexForPausingWC[0] != 0x0) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	$LN420@main
	cmp	WORD PTR _nameMutexForPausingWC, bx
	je	$LN420@main

; 2084 : 		mutexForPausing = OpenMutex(MUTEX_ALL_ACCESS, false, nameMutexForPausingWC);

	push	OFFSET _nameMutexForPausingWC
	push	ebx
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexW@12
	mov	ebx, eax

; 2085 : 		ERROR0(!mutexForPausing, ERROR_EVENT, "Failed to open an event.") 

	test	ebx, ebx
	jne	$LN420@main
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN420@main
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	SHORT $LN46@main
	push	21					; 00000015H
	push	OFFSET $SG4294898990
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fflush
	add	esp, 4
	push	21					; 00000015H
	push	OFFSET $SG4294898989
	call	_printf
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN45@main
$LN46@main:
	push	DWORD PTR ?prevLineCount@@3HA		; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	add	esp, 4
	push	OFFSET $SG4294898988
	push	OFFSET $SG4294898987
	call	_printf
	add	esp, 8
	call	__getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN45@main:
	push	1
	call	DWORD PTR __imp__ExitProcess@4
$LN439@main:
$LN420@main:

; 2086 : 	}
; 2087 : 	isSearchPaused = FALSE;
; 2088 : 	
; 2089 : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	mov	DWORD PTR ?isSearchPaused@@3HA, 0	; isSearchPaused
	jne	SHORT $LN44@main

; 2090 : 		printf("TRIPCODES\n");

	push	OFFSET $SG4294898986
	call	_printf
	add	esp, 4

; 2091 : 		printf("=========\n");

	push	OFFSET $SG4294898985

; 2092 : 	} else {

	jmp	SHORT $LN434@main
$LN44@main:

; 2093 : 		printf("[started]\n");

	push	OFFSET $SG4294898984
$LN434@main:
	call	_printf
	add	esp, 4

; 2094 : 	}
; 2095 : 	PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2100 : 	if (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)

	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	DWORD PTR _startingTime$1$[esp+56], eax
	mov	DWORD PTR $T2[esp+56], eax
	mov	eax, edx
	mov	DWORD PTR _startingTime$3$[esp+56], eax
	mov	DWORD PTR $T2[esp+60], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2100 : 	if (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)

	cmp	ecx, 2
	je	SHORT $LN41@main
	cmp	ecx, 1
	jne	SHORT $LN113@main
$LN41@main:

; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {
; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);
; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);
; 1719 : 	}
; 1720 : }
; 1721 : 
; 1722 : void SetCharactersInTripcodeKey(unsigned char *key, int32_t n)
; 1723 : {
; 1724 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1725 : 		for (int32_t i = 0; i < n; i++){
; 1726 : 			key[i] = RandomByte();
; 1727 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))
; 1728 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1729 : 		}
; 1730 : 	} else if (options.useOneByteCharactersForKeys) {
; 1731 : 		for (int32_t i = 0; i < n; i++){
; 1732 : 			key[i] = RandomByte();
; 1733 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))
; 1734 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1735 : 		}
; 1736 : 	} else {
; 1737 : 		BOOL isSecondByteSJIS = FALSE;
; 1738 : 		for (int32_t i = 0; i < n; i++){
; 1739 : 			if (!isSecondByteSJIS) {
; 1740 : 				key[i] = RandomByte();
; 1741 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))
; 1742 : 					key[i] = (unsigned char)(RandomByte() & 0xff);
; 1743 : 				if (IsFirstByteSJIS(key[i]))
; 1744 : 					isSecondByteSJIS = TRUE;
; 1745 : 			} else {
; 1746 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1747 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))
; 1748 : 					key[i] = (unsigned char)(RandomByte() & 0xff);
; 1749 : 				isSecondByteSJIS = FALSE;
; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }
; 1754 : 
; 1755 : void SetCharactersInTripcodeKeyForSHA1Tripcode(unsigned char *key)
; 1756 : {
; 1757 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1758 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){
; 1759 : 			key[i] = RandomByte();
; 1760 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))
; 1761 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1762 : 		}
; 1763 : 	} else if (options.useOneByteCharactersForKeys) {
; 1764 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){
; 1765 : 			key[i] = RandomByte();
; 1766 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))
; 1767 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1768 : 		}
; 1769 : 	} else {
; 1770 : 		BOOL isSecondByteSJIS = FALSE;
; 1771 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){
; 1772 : 			if (!isSecondByteSJIS) {
; 1773 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1774 : 				if (i == 3 || i == lenTripcodeKey - 1) {
; 1775 : 					while (!IS_ONE_BYTE_KEY_CHAR(key[i]))
; 1776 : 						key[i] = (unsigned char)(RandomByte() & 0xff);
; 1777 : 				} else {
; 1778 : 					while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))
; 1779 : 						key[i] = (unsigned char)(RandomByte() & 0xff);
; 1780 : 				}
; 1781 : 				isSecondByteSJIS = IsFirstByteSJIS(key[i]);
; 1782 : 			} else {
; 1783 : 				key[i] = (unsigned char)(RandomByte() & 0xff);
; 1784 : 				while (!IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))
; 1785 : 					key[i] = (unsigned char)(RandomByte() & 0xff);
; 1786 : 				isSecondByteSJIS = FALSE;
; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }
; 1791 : 
; 1792 : void StartCUDADeviceSearchThreads()
; 1793 : {
; 1794 : 	int32_t    i;
; 1795 : 	uint32_t winThreadID;
; 1796 : 	
; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);
; 1798 : 
; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 1800 : 	ERROR0((CUDADeviceSearchThreadInfoArray = (struct CUDADeviceSearchThreadInfo *)malloc(sizeof(struct CUDADeviceSearchThreadInfo) * numCUDADeviceSearchThreads)) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 1801 : 	if (options.GPUIndex == GPU_INDEX_ALL) {
; 1802 : 		int32_t CUDADeviceIndex;
; 1803 : 		for (CUDADeviceIndex = 0, i = 0; CUDADeviceIndex < CUDADeviceCount; ++CUDADeviceIndex) {
; 1804 : 			for (int32_t j = 0; j < CUDA_NUM_THREADS_PER_DEVICE; ++j, ++i) {
; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);
; 1806 : 				CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = CUDADeviceIndex;
; 1807 : 				CUDADeviceSearchThreadInfoArray[i].subindex = j;
; 1808 : 				CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';
; 1809 : 				CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));
; 1811 : 			}
; 1812 : 		}
; 1813 : 	} else if (options.GPUIndex < CUDADeviceCount) {
; 1814 : 		ASSERT(numCUDADeviceSearchThreads == CUDA_NUM_THREADS_PER_DEVICE);
; 1815 : 		for (i = 0; i < CUDA_NUM_THREADS_PER_DEVICE; ++i) {
; 1816 : 			CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = options.GPUIndex;
; 1817 : 			CUDADeviceSearchThreadInfoArray[i].subindex = i;
; 1818 : 			CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';
; 1819 : 			CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));
; 1821 : 		}
; 1822 : 	}
; 1823 : 
; 1824 : 	if (lenTripcode == 12) {
; 1825 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {
; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));
; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");
; 1828 : 		}
; 1829 : 	} else {
; 1830 : 		ASSERT(lenTripcode == 10);
; 1831 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {
; 1832 : 			if (CUDADeviceSearchThreadInfoArray[i].properties.major >= 5) {
; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));
; 1834 : 			} else {
; 1835 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));
; 1836 : 			}
; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");
; 1838 : 		}
; 1839 : 	}
; 1840 : }
; 1841 : 
; 1842 : void StartOpenCLDeviceSearchThreads()
; 1843 : {
; 1844 : 	int32_t          i, j;
; 1845 : 	uint32_t winThreadID;
; 1846 : 	char         deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 1847 : 	
; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);
; 1849 : 
; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 1851 : 	ERROR0((openCLDeviceSearchThreadInfoArray = new (std::nothrow) struct OpenCLDeviceSearchThreadInfo [numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 1852 : 	if (options.GPUIndex == GPU_INDEX_ALL) {
; 1853 : 		int32_t openCLDeviceIDArrayIndex = 0;
; 1854 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));
; 1856 : 			openCLDeviceSearchThreadInfoArray[i].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1857 : 			openCLDeviceSearchThreadInfoArray[i].index           = openCLDeviceIDArrayIndex;
; 1858 : 			openCLDeviceSearchThreadInfoArray[i].subindex        = -1;
; 1859 : 			openCLDeviceSearchThreadInfoArray[i].status[0]       = '\0';
; 1860 : 			openCLDeviceSearchThreadInfoArray[i].runChildProcess = openCLRunChildProcesses;
; 1861 : 			openCLDeviceSearchThreadInfoArray[i].child_process = NULL;
; 1862 : 			//
; 1863 : 			openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;
; 1864 : 			openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;
; 1865 : 			openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;
; 1866 : 			openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;
; 1867 : 			openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;
; 1868 : 			openCLDeviceSearchThreadInfoArray[i].numRestarts                = 0;
; 1869 : 			openCLDeviceSearchThreadInfoArray[i].timeLastUpdated            = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1870 : 			openCLDeviceSearchThreadInfoArray[i].subindex                   = 0;
; 1871 : 			if (!openCLRunChildProcesses) {
; 1872 : 				for (j = 1; j < options.openCLNumThreads; ++j) {
; 1873 : 					++i;
; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);
; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);
; 1876 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1877 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;
; 1878 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;
; 1879 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';
; 1880 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = FALSE;
; 1881 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;
; 1882 : 					openCLDeviceSearchThreadInfoArray[i].numRestarts = 0;
; 1883 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1884 : 				}
; 1885 : 			} else {
; 1886 : 				openCLDeviceSearchThreadInfoArray[i].subindex       = 0;
; 1887 : 				for (j = 1; j < options.openCLNumProcesses; ++j) {
; 1888 : 					++i;
; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);
; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);
; 1891 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1892 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;
; 1893 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;
; 1894 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';
; 1895 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = TRUE;
; 1896 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;
; 1897 : 					//
; 1898 : 					openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;
; 1899 : 					openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;
; 1900 : 					openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;
; 1901 : 					openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;
; 1902 : 					openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;
; 1903 : 					openCLDeviceSearchThreadInfoArray[i].numRestarts = 0;
; 1904 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1905 : 				}
; 1906 : 			}
; 1907 : 			++openCLDeviceIDArrayIndex;
; 1908 : 		}
; 1909 : 
; 1910 : 	} else if (CUDADeviceCount <= options.GPUIndex && options.GPUIndex < CUDADeviceCount + openCLDeviceCount) {
; 1911 : 		int32_t openCLDeviceIDArrayIndex = options.GPUIndex - CUDADeviceCount;
; 1912 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));
; 1913 : 		openCLDeviceSearchThreadInfoArray[0].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1914 : 		openCLDeviceSearchThreadInfoArray[0].index           = 0;
; 1915 : 		openCLDeviceSearchThreadInfoArray[0].subindex        = -1;
; 1916 : 		openCLDeviceSearchThreadInfoArray[0].status[0]       = '\0';
; 1917 : 		openCLDeviceSearchThreadInfoArray[0].runChildProcess = openCLRunChildProcesses;
; 1918 : 		openCLDeviceSearchThreadInfoArray[0].child_process = NULL;
; 1919 : 		//
; 1920 : 		openCLDeviceSearchThreadInfoArray[0].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;
; 1921 : 		openCLDeviceSearchThreadInfoArray[0].currentSpeed               = 0;
; 1922 : 		openCLDeviceSearchThreadInfoArray[0].averageSpeed               = 0;
; 1923 : 		openCLDeviceSearchThreadInfoArray[0].totalNumGeneratedTripcodes = 0;
; 1924 : 		openCLDeviceSearchThreadInfoArray[0].numDiscardedTripcodes = 0;
; 1925 : 		openCLDeviceSearchThreadInfoArray[0].numRestarts = 0;
; 1926 : 		openCLDeviceSearchThreadInfoArray[0].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1927 : 		if (!openCLRunChildProcesses) {
; 1928 : 			ASSERT(numOpenCLDeviceSearchThreads == options.openCLNumThreads);
; 1929 : 			openCLDeviceSearchThreadInfoArray[0].subindex       = 0;
; 1930 : 			for (j = 1; j < options.openCLNumThreads; ++j) {
; 1931 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1932 : 				openCLDeviceSearchThreadInfoArray[j].index           = 0;
; 1933 : 				openCLDeviceSearchThreadInfoArray[j].subindex        = j;
; 1934 : 				openCLDeviceSearchThreadInfoArray[j].status[0]       = '\0';
; 1935 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = FALSE;
; 1936 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;
; 1937 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1938 : 			}
; 1939 : 		} else {
; 1940 : 			openCLDeviceSearchThreadInfoArray[0].subindex = 0;
; 1941 : 			for (j = 1; j < options.openCLNumProcesses; ++j) {
; 1942 : 				ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);
; 1943 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];
; 1944 : 				openCLDeviceSearchThreadInfoArray[j].index          = 0;
; 1945 : 				openCLDeviceSearchThreadInfoArray[j].subindex       = j;
; 1946 : 				openCLDeviceSearchThreadInfoArray[j].status[0]      = '\0';
; 1947 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = TRUE;
; 1948 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;
; 1949 : 				//
; 1950 : 				openCLDeviceSearchThreadInfoArray[j].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;
; 1951 : 				openCLDeviceSearchThreadInfoArray[j].currentSpeed               = 0;
; 1952 : 				openCLDeviceSearchThreadInfoArray[j].averageSpeed               = 0;
; 1953 : 				openCLDeviceSearchThreadInfoArray[j].totalNumGeneratedTripcodes = 0;
; 1954 : 				openCLDeviceSearchThreadInfoArray[j].numDiscardedTripcodes = 0;
; 1955 : 				openCLDeviceSearchThreadInfoArray[j].numRestarts = 0;
; 1956 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1957 : 			}	
; 1958 : 		}
; 1959 : 	}
; 1960 : 
; 1961 : 	if (lenTripcode == 12) {
; 1962 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 1963 : 			opencl_device_search_threads[i] = new std::thread(
; 1964 : 				openCLDeviceSearchThreadInfoArray[i].runChildProcess ? Thread_RunChildProcessForOpenCLDevice : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));
; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");
; 1967 : 		}
; 1968 : 	} else {
; 1969 : 		ASSERT(lenTripcode == 10);
; 1970 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 1971 : 			opencl_device_search_threads[i] = new std::thread(
; 1972 : 				openCLDeviceSearchThreadInfoArray[i].runChildProcess ? Thread_RunChildProcessForOpenCLDevice : Thread_SearchForDESTripcodesOnOpenCLDevice,
; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));
; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");
; 1975 : 		}
; 1976 : 	}
; 1977 : }
; 1978 : 
; 1979 : void StartGPUSearchThreads()
; 1980 : {
; 1981 : 	if (numCUDADeviceSearchThreads > 0)

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads
	jle	SHORT $LN114@main

; 1982 : 		StartCUDADeviceSearchThreads();

	call	?StartCUDADeviceSearchThreads@@YAXXZ	; StartCUDADeviceSearchThreads
	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN114@main:

; 1983 : 	if (numOpenCLDeviceSearchThreads > 0)

	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN113@main

; 1984 : 		StartOpenCLDeviceSearchThreads();

	call	?StartOpenCLDeviceSearchThreads@@YAXXZ	; StartOpenCLDeviceSearchThreads
	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN113@main:

; 2101 : 		StartGPUSearchThreads();
; 2102 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)

	cmp	ecx, 3
	je	SHORT $LN39@main
	cmp	ecx, 1
	jne	SHORT $LN40@main
$LN39@main:

; 2103 : 		StartCPUSearchThreads();

	call	?StartCPUSearchThreads@@YAXXZ		; StartCPUSearchThreads
$LN40@main:

; 2104 : 	HANDLE parentProcess = OpenProcess(SYNCHRONIZE, FALSE, GetParentProcessID());

	call	?GetParentProcessID@@YAHXZ		; GetParentProcessID
	push	eax
	push	0
	push	1048576					; 00100000H
	call	DWORD PTR __imp__OpenProcess@12
	mov	esi, eax
	mov	DWORD PTR _parentProcess$1$[esp+56], esi

; 2105 : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	$LN428@main
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR __real@3fe0000000000000$1$[esp+56], xmm0
$LL38@main:

; 2106 : 		// Break the main loop if necessary.
; 2107 : 		if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN36@main
	push	0
	push	esi
	call	edi
	cmp	eax, 258				; 00000102H
	jne	$LN428@main
$LN36@main:

; 2108 : 			break;
; 2109 : 
; 2110 : 		// Wait for the duration of STATUS_UPDATE_INTERVAL.
; 2111 : 		uint32_t mutexForPausingState;
; 2112 : 		for (int32_t i = 0; i < NUM_CHECKS_PER_INTERVAL; ++i) {

	xor	esi, esi
	npad	1
$LL35@main:

; 2113 : 			// Break the loop if the search is paused.
; 2114 : 			if (mutexForPausing) {

	test	ebx, ebx
	je	SHORT $LN29@main

; 2115 : 				mutexForPausingState = WaitForSingleObject(mutexForPausing, 0);

	push	0
	push	ebx
	call	edi

; 2116 : 				if (mutexForPausingState == WAIT_OBJECT_0) {

	test	eax, eax
	jne	SHORT $LN31@main

; 2117 : 					ReleaseMutex(mutexForPausing);

	push	ebx
	call	DWORD PTR __imp__ReleaseMutex@4
	jmp	SHORT $LN29@main
$LN31@main:

; 2118 : 				} else if (mutexForPausingState == WAIT_TIMEOUT) {

	cmp	eax, 258				; 00000102H
	je	SHORT $LN322@main
$LN29@main:

; 2120 : 					break;
; 2121 : 				}
; 2122 : 			}
; 2123 : 
; 2124 : 			// Break the loop if the search was terminated.
; 2125 : 			if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN392@main

; 2126 : 				break;
; 2127 : 
; 2128 : 			// Break the loop if the parent process has already quit.
; 2129 : 			if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, eax
	je	SHORT $LN27@main
	push	eax
	push	DWORD PTR _parentProcess$1$[esp+60]
	call	edi
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN392@main
$LN27@main:

; 2130 : 				break;
; 2131 : 
; 2132 : 			Sleep((uint32_t)(STATUS_UPDATE_INTERVAL * 1000 / NUM_CHECKS_PER_INTERVAL));

	push	1000					; 000003e8H
	call	DWORD PTR __imp__Sleep@4
	inc	esi
	cmp	esi, 10					; 0000000aH
	jl	SHORT $LL35@main

; 2108 : 			break;
; 2109 : 
; 2110 : 		// Wait for the duration of STATUS_UPDATE_INTERVAL.
; 2111 : 		uint32_t mutexForPausingState;
; 2112 : 		for (int32_t i = 0; i < NUM_CHECKS_PER_INTERVAL; ++i) {

	jmp	SHORT $LN392@main
$LN322@main:

; 2119 : 					SetPauseState(TRUE);

	mov	ecx, 1
	call	?SetPauseState@@YAXH@Z			; SetPauseState
$LN392@main:

; 2133 : 		}
; 2134 : 		if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN432@main

; 2135 : 			break;
; 2136 : 		UpdateCurrentStatus(startingTime);

	push	DWORD PTR _startingTime$3$[esp+56]
	push	DWORD PTR _startingTime$1$[esp+60]
	call	?UpdateCurrentStatus@@YAN_K@Z		; UpdateCurrentStatus
	add	esp, 8

; 2137 : 		
; 2138 : 		// Pause searching if necessary.
; 2139 : 		if (mutexForPausing) {

	test	ebx, ebx
	je	$LN20@main

; 2140 : 			while ((mutexForPausingState = WaitForSingleObject(mutexForPausing, 0)) == WAIT_TIMEOUT) {

	push	0
	push	ebx
	call	edi
	mov	esi, eax
	cmp	esi, 258				; 00000102H
	jne	$LN427@main
$LL24@main:

; 2141 : 				// Break the loop if the search was terminated.
; 2142 : 				if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN427@main

; 2143 : 					break;
; 2144 : 
; 2145 : 				// Break the loop if the parent process has already quit.
; 2146 : 				if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, eax
	je	SHORT $LN421@main
	push	eax
	push	DWORD PTR _parentProcess$1$[esp+60]
	call	edi
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN427@main
$LN421@main:
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL120@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN119@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN134@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL120@main
$LN134@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL120@main
$LN119@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, 1	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2150 : 				KeepSearchThreadsAlive();

	call	?KeepSearchThreadsAlive@@YAXXZ		; KeepSearchThreadsAlive

; 2151 : 				Sleep(PAUSE_INTERVAL);

	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
	push	0
	push	ebx
	call	edi
	mov	esi, eax
	cmp	esi, 258				; 00000102H
	je	$LL24@main
$LN427@main:

; 2152 : 			}
; 2153 : 			if (mutexForPausingState == WAIT_OBJECT_0) {

	test	esi, esi
	jne	SHORT $LN20@main

; 2154 : 				ReleaseMutex(mutexForPausing);

	push	ebx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2155 : 				SetPauseState(FALSE);

	xor	ecx, ecx
	call	?SetPauseState@@YAXH@Z			; SetPauseState
$LN20@main:

; 2156 : 			}
; 2157 : 		}
; 2158 : 		if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN432@main

; 2159 : 			break;
; 2160 : 				
; 2161 : 		//
; 2162 : 		CheckSearchThreads();

	call	?CheckSearchThreads@@YAXXZ		; CheckSearchThreads
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv

; 105  : 		{	// construct from representation

	mov	esi, eax
	mov	DWORD PTR _startingTime$1$[esp+56], esi
	mov	DWORD PTR $T3[esp+56], esi
	mov	esi, edx
	mov	DWORD PTR _startingTime$3$[esp+56], esi
	mov	DWORD PTR $T3[esp+60], esi
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2164 : 		PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus

; 2165 : 		
; 2166 : 		// Warn the user if the speed drops suddenly.
; 2167 : 		if (!options.redirection && options.warnSpeedDrop && currentSpeed_thisProcess < maximumSpeed * SPEED_DROP_WARNING_THRESHOLD)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	jne	SHORT $LN18@main
	cmp	DWORD PTR ?options@@3UOptions@@A+16, 0
	je	SHORT $LN18@main
	movsd	xmm0, QWORD PTR ?maximumSpeed@@3NA
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000$1$[esp+56]
	comisd	xmm0, QWORD PTR ?currentSpeed_thisProcess@@3NA
	jbe	SHORT $LN18@main

; 2168 : 			printf("\a");

	push	OFFSET $SG4294898983
	call	_printf
	add	esp, 4
$LN18@main:

; 2105 : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	mov	esi, DWORD PTR _parentProcess$1$[esp+56]
	test	eax, eax
	je	$LL38@main
	jmp	SHORT $LN428@main
$LN432@main:
	mov	esi, DWORD PTR _parentProcess$1$[esp+56]
$LN428@main:

; 2169 : 	}
; 2170 : 
; 2171 : 	// Close handles.
; 2172 : 	CloseHandle(parentProcess);

	push	esi
	mov	esi, DWORD PTR __imp__CloseHandle@4
	call	esi

; 2173 : 	if (mutexForPausing)

	test	ebx, ebx
	je	SHORT $LN422@main

; 2174 : 		CloseHandle(mutexForPausing);

	push	ebx
	call	esi
$LN422@main:
	mov	edi, OFFSET ?current_state_spinlock@@3Vspinlock@@A ; current_state_spinlock
$LL198@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock	 bts	 DWORD PTR [edi], 0
	setb	al
	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	eax, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN197@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1
	je	SHORT $LN212@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL198@main
$LN212@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	__Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL198@main
$LN197@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1657 : 	wasSearchTerminated = TRUE;

	mov	DWORD PTR ?wasSearchTerminated@@3HA, 1	; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2179 : 	startingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	DWORD PTR _startingTime$2$[esp+56], eax
	mov	DWORD PTR _startingTime$4$[esp+56], edx
$LL16@main:

; 2180 : 	uint64_t currentTime, deltaTime;
; 2181 : 	do {
; 2182 : 		Sleep(100);

	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4

; 2183 : 		allThreadsHaveExited = TRUE;
; 2184 : 		for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i) {

	xor	esi, esi
	mov	ebx, 1
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, esi ; numCUDADeviceSearchThreads
	jle	SHORT $LN11@main
	npad	8
$LL13@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR ?cuda_device_search_threads@@3PAPAVthread@std@@A ; cuda_device_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2185 : 			if (WaitForSingleObject(cuda_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR [eax+esi*4]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2185 : 			if (WaitForSingleObject(cuda_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	DWORD PTR [eax]
	call	edi
	test	eax, eax
	jne	SHORT $LN330@main

; 2183 : 		allThreadsHaveExited = TRUE;
; 2184 : 		for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	esi
	cmp	esi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LL13@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN11@main
$LN330@main:

; 2186 : 				allThreadsHaveExited = FALSE;

	xor	ebx, ebx
$LN11@main:

; 2187 : 				break;
; 2188 : 			}
; 2189 : 		}
; 2190 : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	xor	esi, esi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, esi ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN7@main
	npad	7
$LL9@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR ?opencl_device_search_threads@@3PAPAVthread@std@@A ; opencl_device_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2191 : 			if (WaitForSingleObject(opencl_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR [eax+esi*4]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2191 : 			if (WaitForSingleObject(opencl_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	DWORD PTR [eax]
	call	edi
	test	eax, eax
	jne	SHORT $LN331@main

; 2187 : 				break;
; 2188 : 			}
; 2189 : 		}
; 2190 : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	esi
	cmp	esi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LL9@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN7@main
$LN331@main:

; 2192 : 				allThreadsHaveExited = FALSE;

	xor	ebx, ebx
$LN7@main:

; 2193 : 				break;
; 2194 : 			}
; 2195 : 		}
; 2196 : 		for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	xor	esi, esi
	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, esi ; numCPUSearchThreads
	jle	SHORT $LN3@main
	npad	7
$LL5@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR ?cpu_search_threads@@3PAPAVthread@std@@A ; cpu_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	eax, DWORD PTR [eax+esi*4]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	push	DWORD PTR [eax]
	call	edi
	test	eax, eax
	jne	SHORT $LN332@main

; 2193 : 				break;
; 2194 : 			}
; 2195 : 		}
; 2196 : 		for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	inc	esi
	cmp	esi, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	jl	SHORT $LL5@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN3@main
$LN332@main:

; 2198 : 				allThreadsHaveExited = FALSE;

	xor	ebx, ebx
$LN3@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	__Xtime_get_ticks

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	push	0
	push	10000					; 00002710H
	push	edx
	push	eax
	call	__alldiv
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2203 : 		deltaTime = currentTime - startingTime;

	sub	eax, DWORD PTR _startingTime$2$[esp+56]
	sbb	edx, DWORD PTR _startingTime$4$[esp+56]

; 2204 : 	} while (deltaTime < 10 * 1000 && !allThreadsHaveExited);	

	test	edx, edx
	ja	SHORT $LN1@main
	jb	SHORT $LN413@main
	cmp	eax, 10000				; 00002710H
	jae	SHORT $LN1@main
$LN413@main:
	test	ebx, ebx
	je	$LL16@main
$LN1@main:

; 2205 : 
; 2206 : 	ReleaseResources();

	call	?ReleaseResources@@YAXXZ		; ReleaseResources

; 2207 : 
; 2208 : 	return 0;
; 2209 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN435@main:

; 1024 : 		ListCUDADevices();

	call	?ListCUDADevices@@YAXXZ			; ListCUDADevices
$LN68@main:

; 1025 : 	ListOpenCLDevices();

	call	?ListOpenCLDevices@@YAXXZ		; ListOpenCLDevices

; 1026 : 	exit(0);

	push	0
	call	_exit
$LN440@main:
$LN437@main:

; 2058 : 		exit(0);

	push	0
	call	_exit
$LN441@main:
$LN438@main:

; 2064 : 		ListExpandedPatterns();

	call	?ListExpandedPatterns@@YAXXZ		; ListExpandedPatterns

; 2065 : 		exit(0);

	push	0
	call	_exit
$LN442@main:
$LN433@main:
	int	3
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
__Launcher$2 = -36					; size = 24
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 46   : 		{	// construct with _Fx(_Ax...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	eax, DWORD PTR _<_Ax_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR __Fx$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$2[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z$0:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0A6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
__Launcher$2 = -36					; size = 24
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 46   : 		{	// construct with _Fx(_Ax...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	eax, DWORD PTR _<_Ax_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR __Fx$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$2[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z$0:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0A6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@thread@std@@QAE@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z
_TEXT	SEGMENT
__Launcher$2 = -40					; size = 24
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z PROC		; std::thread::thread<void (__cdecl&)(void)>, COMDAT
; _this$ = ecx

; 46   : 		{	// construct with _Fx(_Ax...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR __Fx$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$2[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	esi
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z$0:
	lea	ecx, DWORD PTR __Launcher$2[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ
__ehhandler$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0A6AXXZ$$$V@thread@std@@QAE@A6AXXZ@Z ENDP		; std::thread::thread<void (__cdecl&)(void)>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
??$forward@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
??$_Decay_copy@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, ecx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PAUCUDADeviceSearchThreadInfo@@@std@@YA$$QAPAUCUDADeviceSearchThreadInfo@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUCUDADeviceSearchThreadInfo@@@std@@YA$$QAPAUCUDADeviceSearchThreadInfo@@AAPAU1@@Z PROC ; std::forward<CUDADeviceSearchThreadInfo *>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@PAUCUDADeviceSearchThreadInfo@@@std@@YA$$QAPAUCUDADeviceSearchThreadInfo@@AAPAU1@@Z ENDP ; std::forward<CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@PAUCUDADeviceSearchThreadInfo@@@std@@YAPAUCUDADeviceSearchThreadInfo@@$$QAPAU1@@Z
_TEXT	SEGMENT
??$_Decay_copy@PAUCUDADeviceSearchThreadInfo@@@std@@YAPAUCUDADeviceSearchThreadInfo@@$$QAPAU1@@Z PROC ; std::_Decay_copy<CUDADeviceSearchThreadInfo *>, COMDAT
; __Arg$ = ecx

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, DWORD PTR [ecx]

; 1546 : 	}

	ret	0
??$_Decay_copy@PAUCUDADeviceSearchThreadInfo@@@std@@YAPAUCUDADeviceSearchThreadInfo@@$$QAPAU1@@Z ENDP ; std::_Decay_copy<CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@XPAUCUDADeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$bind@XPAUCUDADeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::bind<void,CUDADeviceSearchThreadInfo *,CUDADeviceSearchThreadInfo *>, COMDAT
; ___$ReturnUdt$ = ecx
; __Pfx$ = edx

; 1269 : 	{	// bind a function pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	eax, ecx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	pop	ebp
	ret	0
??$bind@XPAUCUDADeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::bind<void,CUDADeviceSearchThreadInfo *,CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z
_TEXT	SEGMENT
__Launcher$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >, COMDAT
; __Thr$ = ecx
; __Tg$ = edx

; 204  : 	{	// launch a new thread

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, edx
	mov	edi, ecx

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Launcher$[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$[ebp+20], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z$0:
	lea	ecx, DWORD PTR __Launcher$[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Launch@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
??$forward@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
??$_Decay_copy@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, ecx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QAPAUOpenCLDeviceSearchThreadInfo@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QAPAUOpenCLDeviceSearchThreadInfo@@AAPAU1@@Z PROC ; std::forward<OpenCLDeviceSearchThreadInfo *>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@PAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QAPAUOpenCLDeviceSearchThreadInfo@@AAPAU1@@Z ENDP ; std::forward<OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAPAUOpenCLDeviceSearchThreadInfo@@$$QAPAU1@@Z
_TEXT	SEGMENT
??$_Decay_copy@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAPAUOpenCLDeviceSearchThreadInfo@@$$QAPAU1@@Z PROC ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo *>, COMDAT
; __Arg$ = ecx

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, DWORD PTR [ecx]

; 1546 : 	}

	ret	0
??$_Decay_copy@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAPAUOpenCLDeviceSearchThreadInfo@@$$QAPAU1@@Z ENDP ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@XPAUOpenCLDeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$bind@XPAUOpenCLDeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::bind<void,OpenCLDeviceSearchThreadInfo *,OpenCLDeviceSearchThreadInfo *>, COMDAT
; ___$ReturnUdt$ = ecx
; __Pfx$ = edx

; 1269 : 	{	// bind a function pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	eax, ecx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	pop	ebp
	ret	0
??$bind@XPAUOpenCLDeviceSearchThreadInfo@@PAU1@@std@@YA?AV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::bind<void,OpenCLDeviceSearchThreadInfo *,OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z
_TEXT	SEGMENT
__Launcher$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >, COMDAT
; __Thr$ = ecx
; __Tg$ = edx

; 204  : 	{	// launch a new thread

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, edx
	mov	edi, ecx

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Launcher$[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	DWORD PTR __Launcher$[ebp+20], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z$0:
	lea	ecx, DWORD PTR __Launcher$[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Launch@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z
_TEXT	SEGMENT
??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z PROC		; std::forward<void (__cdecl&)(void)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z ENDP		; std::forward<void (__cdecl&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z
_TEXT	SEGMENT
??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z PROC	; std::_Decay_copy<void (__cdecl&)(void)>, COMDAT
; __Arg$ = ecx

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, ecx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z ENDP	; std::_Decay_copy<void (__cdecl&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z
_TEXT	SEGMENT
??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z PROC ; std::bind<void>, COMDAT
; ___$ReturnUdt$ = ecx
; __Pfx$ = edx

; 1109 : 		{	// construct from functor and arguments

	mov	DWORD PTR [ecx], edx

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	eax, ecx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	ret	0
??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z ENDP ; std::bind<void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
_TEXT	SEGMENT
__Launcher$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT
; __Thr$ = ecx
; __Tg$ = edx

; 204  : 	{	// launch a new thread

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, edx
	mov	edi, ecx

; 182  : 		{	// construct from target

	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR __Launcher$[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	DWORD PTR __Launcher$[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	push	edi
	lea	ecx, DWORD PTR __Launcher$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z$0:
	lea	ecx, DWORD PTR __Launcher$[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ
__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >, COMDAT
; _this$ = ecx
	jmp	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >, COMDAT
; _this$ = ecx
	jmp	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT
; _this$ = ecx
	jmp	??1_Pad@std@@QAE@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ
_TEXT	SEGMENT
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Go, COMDAT
; _this$ = ecx

; 186  : 		{	// run the thread function object

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	esi, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 186  : 		{	// run the thread function object

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	esi
	call	edi
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 187  : 		return (_Run(this));

	xor	eax, eax

; 188  : 		}

	pop	edi
	pop	esi
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ
_TEXT	SEGMENT
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Go, COMDAT
; _this$ = ecx

; 186  : 		{	// run the thread function object

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	esi, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 186  : 		{	// run the thread function object

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	esi
	call	edi
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 187  : 		return (_Run(this));

	xor	eax, eax

; 188  : 		}

	pop	edi
	pop	esi
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@UAEIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UAEIXZ
_TEXT	SEGMENT
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UAEIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go, COMDAT
; _this$ = ecx

; 186  : 		{	// run the thread function object

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	esi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	call	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 187  : 		return (_Run(this));

	xor	eax, eax

; 188  : 		}

	pop	esi
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UAEIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z
_TEXT	SEGMENT
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Run, COMDAT
; __Ln$ = ecx

; 192  : 		{	// make local copy of function object and call it

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	esi, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 192  : 		{	// make local copy of function object and call it

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	esi
	call	edi
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 196  : 		return (0);

	xor	eax, eax

; 197  : 		}

	pop	edi
	pop	esi
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z
_TEXT	SEGMENT
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Run, COMDAT
; __Ln$ = ecx

; 192  : 		{	// make local copy of function object and call it

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	esi, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 192  : 		{	// make local copy of function object and call it

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	esi
	call	edi
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 196  : 		return (0);

	xor	eax, eax

; 197  : 		}

	pop	edi
	pop	esi
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@CAIPAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPAV12@@Z
_TEXT	SEGMENT
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run, COMDAT
; __Ln$ = ecx

; 192  : 		{	// make local copy of function object and call it

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	esi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QAEXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	call	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 196  : 		return (0);

	xor	eax, eax

; 197  : 		}

	pop	esi
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 1127 : 		{	// construct by moving

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1128 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 1127 : 		{	// construct by moving

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1128 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@$$QAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@$$QAV01@@Z PROC	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>, COMDAT
; _this$ = ecx

; 1127 : 		{	// construct by moving

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1128 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@$$QAV01@@Z ENDP	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$?0AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *><void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 1109 : 		{	// construct from functor and arguments

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Fx$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1110 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *><void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@1@@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
??$?0V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from target

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edx, DWORD PTR __Tgt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR [esi], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+20], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??$?0V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$?0AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *><void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 1109 : 		{	// construct from functor and arguments

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Fx$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1110 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU0@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAE@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z$$QAPAU2@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *><void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@0@AAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@1@@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
??$?0V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from target

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	edx, DWORD PTR __Tgt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR [esi], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+20], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??$?0V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@AAP6AXXZ@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
??$?0AAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@AAP6AXXZ@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*&)(void)>, COMDAT
; _this$ = ecx

; 1109 : 		{	// construct from functor and arguments

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Fx$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1110 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0AAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAE@AAP6AXXZ@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@AAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXXZ$$$V@0@AAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from target

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??0_Pad@std@@QAE@XZ			; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR __Tgt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	mov	DWORD PTR [esi], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ
_TEXT	SEGMENT
??$?R$$$V@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::operator()<>, COMDAT
; _this$ = ecx

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	call	eax
	pop	ecx

; 1132 : 			tuple<_Ftypes&...>,
; 1133 : 			typename _Make_arg_idx<_Types...>::type>::type
; 1134 : 		operator()(_Ftypes&&... _Fargs)
; 1135 : 		{	// evaluate the called function
; 1136 : 		return (_Do_call(_STD tie(_Fargs...),
; 1137 : 			typename _Make_arg_idx<_Types...>::type()));
; 1138 : 		}

	ret	0
??$?R$$$V@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ
_TEXT	SEGMENT
??$?R$$$V@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::operator()<>, COMDAT
; _this$ = ecx

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	call	eax
	pop	ecx

; 1132 : 			tuple<_Ftypes&...>,
; 1133 : 			typename _Make_arg_idx<_Types...>::type>::type
; 1134 : 		operator()(_Ftypes&&... _Fargs)
; 1135 : 		{	// evaluate the called function
; 1136 : 		return (_Do_call(_STD tie(_Fargs...),
; 1137 : 			typename _Make_arg_idx<_Types...>::type()));
; 1138 : 		}

	ret	0
??$?R$$$V@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXXZ
_TEXT	SEGMENT
??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXXZ PROC	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>, COMDAT
; _this$ = ecx

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	eax, DWORD PTR [ecx]
	jmp	eax
??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXXZ ENDP	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@P6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@P6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV10@@Z PROC ; std::forward<std::tuple<CUDADeviceSearchThreadInfo *> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<CUDADeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUCUDADeviceSearchThreadInfo@@PAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PAUCUDADeviceSearchThreadInfo@@PAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z PROC ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>, COMDAT
; _this$ = ecx

; 258  : 		{	// construct by moving same size tuple

	push	ebp
	mov	ebp, esp

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 259  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUCUDADeviceSearchThreadInfo@@PAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z ENDP ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@P6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV10@@Z PROC ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo *> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUOpenCLDeviceSearchThreadInfo@@PAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PAUOpenCLDeviceSearchThreadInfo@@PAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z PROC ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>, COMDAT
; _this$ = ecx

; 258  : 		{	// construct by moving same size tuple

	push	ebp
	mov	ebp, esp

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 259  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUOpenCLDeviceSearchThreadInfo@@PAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAV01@@Z ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXXZ@std@@YA$$QAP6AXXZAAP6AXXZ@Z
_TEXT	SEGMENT
??$forward@P6AXXZ@std@@YA$$QAP6AXXZAAP6AXXZ@Z PROC	; std::forward<void (__cdecl*)(void)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@P6AXXZ@std@@YA$$QAP6AXXZAAP6AXXZ@Z ENDP	; std::forward<void (__cdecl*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
?_Get_rest@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ PROC ; std::tuple<CUDADeviceSearchThreadInfo *>::_Get_rest, COMDAT
; _this$ = ecx

; 439  : 		return (*this);

	mov	eax, ecx

; 440  : 		}

	ret	0
?_Get_rest@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<CUDADeviceSearchThreadInfo *>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
?_Get_rest@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ PROC ; std::tuple<OpenCLDeviceSearchThreadInfo *>::_Get_rest, COMDAT
; _this$ = ecx

; 439  : 		return (*this);

	mov	eax, ecx

; 440  : 		}

	ret	0
?_Get_rest@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAEAAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo *>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*&)(CUDADeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@AAP6AXPAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUCUDADeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*&)(CUDADeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUCUDADeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0PAUCUDADeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z PROC ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from one or more moved elements

	push	ebp
	mov	ebp, esp

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR __This_arg$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 234  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUCUDADeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z ENDP ; std::tuple<CUDADeviceSearchThreadInfo *>::tuple<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUOpenCLDeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0PAUOpenCLDeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z PROC ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from one or more moved elements

	push	ebp
	mov	ebp, esp

; 80   : 		{	// construct with argument

	mov	eax, DWORD PTR __This_arg$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 234  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUOpenCLDeviceSearchThreadInfo@@$$$VPAPAX@?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo *>::tuple<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6AXXZ@std@@YAAAP6AXXZAAP6AXXZ@Z
_TEXT	SEGMENT
??$forward@AAP6AXXZ@std@@YAAAP6AXXZAAP6AXXZ@Z PROC	; std::forward<void (__cdecl*&)(void)>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1506 : 	}

	ret	0
??$forward@AAP6AXXZ@std@@YAAAP6AXXZAAP6AXXZ@Z ENDP	; std::forward<void (__cdecl*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ
_TEXT	SEGMENT
??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ PROC		; std::tie<>, COMDAT
; ___$ReturnUdt$ = ecx

; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));

	mov	eax, ecx

; 620  : 	}

	ret	0
??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ ENDP		; std::tie<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
_TEXT	SEGMENT
__Myfargs$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Do_call<,0>, COMDAT
; _this$ = ecx

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	call	eax
	pop	ecx

; 1150 : 		}

	ret	8
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *>::_Do_call<,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
_TEXT	SEGMENT
__Myfargs$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Do_call<,0>, COMDAT
; _this$ = ecx

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	push	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	call	eax
	pop	ecx

; 1150 : 		}

	ret	8
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *>::_Do_call<,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z
_TEXT	SEGMENT
__Myfargs$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>, COMDAT
; _this$ = ecx

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	eax, DWORD PTR [ecx]
	call	eax

; 1150 : 		}

	ret	8
??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QAEXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0PAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z PROC ; std::_Tuple_val<CUDADeviceSearchThreadInfo *>::_Tuple_val<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Arg$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 81   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PAUCUDADeviceSearchThreadInfo@@@std@@QAE@$$QAPAUCUDADeviceSearchThreadInfo@@@Z ENDP ; std::_Tuple_val<CUDADeviceSearchThreadInfo *>::_Tuple_val<CUDADeviceSearchThreadInfo *><CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0PAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z PROC ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo *>::_Tuple_val<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *>, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Arg$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 81   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PAUOpenCLDeviceSearchThreadInfo@@@std@@QAE@$$QAPAUOpenCLDeviceSearchThreadInfo@@@Z ENDP ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo *>::_Tuple_val<OpenCLDeviceSearchThreadInfo *><OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@PAUCUDADeviceSearchThreadInfo@@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@@Z
_TEXT	SEGMENT
??$get@$0A@PAUCUDADeviceSearchThreadInfo@@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@@Z PROC ; std::get<0,CUDADeviceSearchThreadInfo *>, COMDAT
; __Tuple$ = ecx

; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);

	mov	eax, ecx

; 580  : 	}

	ret	0
??$get@$0A@PAUCUDADeviceSearchThreadInfo@@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@@Z ENDP ; std::get<0,CUDADeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Fixarg@AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z
_TEXT	SEGMENT
__Myfargs$dead$ = 8					; size = 4
__Arg$ = 12						; size = 4
??$_Fixarg@AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z PROC ; std::_Fixarg<void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *,std::tuple<CUDADeviceSearchThreadInfo *>,std::tuple<> >, COMDAT
; ___formal$dead$ = ecx
; __Mybargs$dead$ = edx

; 1084 : 	{	// convert a plain argument

	push	ebp
	mov	ebp, esp

; 1085 : 	return (_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1086 : 	}

	pop	ebp
	ret	0
??$_Fixarg@AAP6AXPAUCUDADeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUCUDADeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUCUDADeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z ENDP ; std::_Fixarg<void (__cdecl*&)(CUDADeviceSearchThreadInfo *),CUDADeviceSearchThreadInfo *,std::tuple<CUDADeviceSearchThreadInfo *>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@@Z
_TEXT	SEGMENT
??$get@$0A@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@@Z PROC ; std::get<0,OpenCLDeviceSearchThreadInfo *>, COMDAT
; __Tuple$ = ecx

; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);

	mov	eax, ecx

; 580  : 	}

	ret	0
??$get@$0A@PAUOpenCLDeviceSearchThreadInfo@@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@@Z ENDP ; std::get<0,OpenCLDeviceSearchThreadInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Fixarg@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z
_TEXT	SEGMENT
__Myfargs$dead$ = 8					; size = 4
__Arg$ = 12						; size = 4
??$_Fixarg@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z PROC ; std::_Fixarg<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *,std::tuple<OpenCLDeviceSearchThreadInfo *>,std::tuple<> >, COMDAT
; ___formal$dead$ = ecx
; __Mybargs$dead$ = edx

; 1084 : 	{	// convert a plain argument

	push	ebp
	mov	ebp, esp

; 1085 : 	return (_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1086 : 	}

	pop	ebp
	ret	0
??$_Fixarg@AAP6AXPAUOpenCLDeviceSearchThreadInfo@@@ZPAU1@V?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAAPAUOpenCLDeviceSearchThreadInfo@@AAP6AXPAU1@@ZAAV?$tuple@PAUOpenCLDeviceSearchThreadInfo@@@0@AAV?$tuple@$$$V@0@AAPAU1@@Z ENDP ; std::_Fixarg<void (__cdecl*&)(OpenCLDeviceSearchThreadInfo *),OpenCLDeviceSearchThreadInfo *,std::tuple<OpenCLDeviceSearchThreadInfo *>,std::tuple<> >
_TEXT	ENDS
END
