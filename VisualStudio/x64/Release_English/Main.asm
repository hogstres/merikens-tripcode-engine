; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?patternFilePathArray@@3PAY0EAB@DA		; patternFilePathArray
PUBLIC	?applicationPath@@3PADA				; applicationPath
PUBLIC	?numPatternFiles@@3HA				; numPatternFiles
PUBLIC	?nameEventForTerminating@@3PADA			; nameEventForTerminating
PUBLIC	?nameMutexForPausing@@3PADA			; nameMutexForPausing
PUBLIC	?prevLineCount@@3HA				; prevLineCount
PUBLIC	?base64CharTable@@3PADA				; base64CharTable
PUBLIC	?lenTripcodeKey@@3HA				; lenTripcodeKey
PUBLIC	?applicationDirectory@@3PADA			; applicationDirectory
PUBLIC	?keyCharTable_SecondByteAndOneByte@@3PAEA	; keyCharTable_SecondByteAndOneByte
PUBLIC	?tripcodeFilePath@@3PADA			; tripcodeFilePath
PUBLIC	?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?wasSearchAbortedWithError@@3HA			; wasSearchAbortedWithError
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`vftable'
PUBLIC	?prevTotalNumGeneratedTripcodes_GPU@@3NA	; prevTotalNumGeneratedTripcodes_GPU
PUBLIC	?CUDADeviceCount@@3HA				; CUDADeviceCount
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?openCLDeviceCount@@3HA				; openCLDeviceCount
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV_Pad@std@@@8				; std::_Pad `RTTI Type Descriptor'
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Complete Object Locator'
PUBLIC	?openCLRunChildProcesses@@3HA			; openCLRunChildProcesses
PUBLIC	??_R3_Pad@std@@8				; std::_Pad::`RTTI Class Hierarchy Descriptor'
PUBLIC	?totalNumGeneratedTripcodes_CPU@@3NA		; totalNumGeneratedTripcodes_CPU
PUBLIC	?numOneByte@@3HA				; numOneByte
PUBLIC	?prevNumValidTripcodes@@3IA			; prevNumValidTripcodes
PUBLIC	?eventForTerminating@@3PEAXEA			; eventForTerminating
PUBLIC	?numOpenCLDeviceSearchThreads@@3HA		; numOpenCLDeviceSearchThreads
PUBLIC	??_R1A@?0A@EA@_Pad@std@@8			; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?numGeneratedTripcodes_GPU@@3IA			; numGeneratedTripcodes_GPU
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?numGeneratedTripcodesByGPUInMillions@@3IA	; numGeneratedTripcodesByGPUInMillions
PUBLIC	?currentSpeed_CPU@@3NA				; currentSpeed_CPU
PUBLIC	??_R2_Pad@std@@8				; std::_Pad::`RTTI Base Class Array'
PUBLIC	?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Array'
PUBLIC	?numFirstByte@@3HA				; numFirstByte
PUBLIC	?cpu_search_threads@@3PEAPEAVthread@std@@EA	; cpu_search_threads
PUBLIC	?numGeneratedTripcodes_CPU@@3IA			; numGeneratedTripcodes_CPU
PUBLIC	?totalTime@@3NA					; totalTime
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`vftable'
PUBLIC	?currentSpeed_thisProcess@@3NA			; currentSpeed_thisProcess
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Array'
PUBLIC	?prevTotalNumGeneratedTripcodes@@3NA		; prevTotalNumGeneratedTripcodes
PUBLIC	?prevNumDiscardedTripcodes@@3IA			; prevNumDiscardedTripcodes
PUBLIC	?numValidTripcodes@@3IA				; numValidTripcodes
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Array'
PUBLIC	?isSearchPaused@@3HA				; isSearchPaused
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`vftable'
PUBLIC	?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
PUBLIC	?tripcodeFile@@3PEAU_iobuf@@EA			; tripcodeFile
PUBLIC	?numCUDADeviceSearchThreads@@3HA		; numCUDADeviceSearchThreads
PUBLIC	?wasSearchTerminated@@3HA			; wasSearchTerminated
PUBLIC	?numSecondByte@@3HA				; numSecondByte
PUBLIC	?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
PUBLIC	?numGeneratedTripcodesByCPUInMillions@@3IA	; numGeneratedTripcodesByCPUInMillions
PUBLIC	?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA	; openCLDeviceIDArray
PUBLIC	?currentSpeed_thisProcess_GPU@@3NA		; currentSpeed_thisProcess_GPU
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?totalNumGeneratedTripcodes_GPU@@3NA		; totalNumGeneratedTripcodes_GPU
PUBLIC	?totalNumGeneratedTripcodes@@3NA		; totalNumGeneratedTripcodes
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?maximumSpeed@@3NA				; maximumSpeed
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?numCPUSearchThreads@@3HA			; numCPUSearchThreads
PUBLIC	?numDiscardedTripcodes@@3IA			; numDiscardedTripcodes
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> > `RTTI Type Descriptor'
PUBLIC	?prevTotalNumGeneratedTripcodes_CPU@@3NA	; prevTotalNumGeneratedTripcodes_CPU
PUBLIC	?keyCharTable_OneByte@@3PAEA			; keyCharTable_OneByte
PUBLIC	?options@@3UOptions@@A				; options
PUBLIC	?keyCharTable_SecondByte@@3PAEA			; keyCharTable_SecondByte
PUBLIC	?lenTripcode@@3HA				; lenTripcode
PUBLIC	?keyCharTable_FirstByte@@3PAEA			; keyCharTable_FirstByte
PUBLIC	?searchMode@@3HA				; searchMode
PUBLIC	?matchingProb@@3NA				; matchingProb
PUBLIC	?searchDevice@@3HA				; searchDevice
PUBLIC	?numAverageTrialsForOneMatch@@3NA		; numAverageTrialsForOneMatch
EXTRN	getchar:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	exit:PROC
EXTRN	__imp_GetCurrentProcessId:PROC
EXTRN	__imp_ReleaseMutex:PROC
EXTRN	__imp_OpenEventW:PROC
EXTRN	__imp_CreateToolhelp32Snapshot:PROC
EXTRN	__imp_cudaGetErrorString:PROC
EXTRN	__imp_SetConsoleCursorInfo:PROC
EXTRN	__imp_Process32NextW:PROC
EXTRN	?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForDESTripcodesOnCUDADevice
EXTRN	?terminate@@YAXXZ:PROC				; terminate
EXTRN	__imp_GetSystemInfo:PROC
EXTRN	__imp_SetConsoleCtrlHandler:PROC
EXTRN	__imp_GetConsoleScreenBufferInfo:PROC
EXTRN	_fullpath:PROC
EXTRN	__imp_Process32FirstW:PROC
EXTRN	rand_s:PROC
EXTRN	?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForSHA1TripcodesOnCUDADevice
EXTRN	?Thread_SearchForDESTripcodesOnCUDADevice_Registers@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z:PROC ; Thread_SearchForDESTripcodesOnCUDADevice_Registers
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	__imp_OpenMutexW:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	__imp_clGetDeviceIDs:PROC
EXTRN	__imp_cudaGetDeviceProperties:PROC
EXTRN	__imp_SetConsoleCursorPosition:PROC
EXTRN	__imp_clGetPlatformInfo:PROC
EXTRN	__imp_TerminateThread:PROC
EXTRN	__imp_OpenProcess:PROC
EXTRN	?TestNewCode@@YAXXZ:PROC			; TestNewCode
EXTRN	__imp_clGetPlatformIDs:PROC
EXTRN	atoi:PROC
EXTRN	__imp_cudaGetDeviceCount:PROC
EXTRN	_Thrd_detach:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??1_Pad@std@@QEAA@XZ:PROC			; std::_Pad::~_Pad
EXTRN	??0_Pad@std@@QEAA@XZ:PROC			; std::_Pad::_Pad
EXTRN	?_Release@_Pad@std@@QEAAXXZ:PROC		; std::_Pad::_Release
EXTRN	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z:PROC ; std::_Pad::_Launch
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
?patternFilePathArray@@3PAY0EAB@DA DB 040100H DUP (?)	; patternFilePathArray
?applicationPath@@3PADA DB 0401H DUP (?)		; applicationPath
	ALIGN	4

?numPatternFiles@@3HA DD 01H DUP (?)			; numPatternFiles
?nameEventForTerminating@@3PADA DB 0101H DUP (?)	; nameEventForTerminating
	ALIGN	4

?nameMutexForPausing@@3PADA DB 0101H DUP (?)		; nameMutexForPausing
	ALIGN	4

?prevLineCount@@3HA DD 01H DUP (?)			; prevLineCount
?applicationDirectory@@3PADA DB 0401H DUP (?)		; applicationDirectory
	ALIGN	4

?keyCharTable_SecondByteAndOneByte@@3PAEA DB 0200H DUP (?) ; keyCharTable_SecondByteAndOneByte
?tripcodeFilePath@@3PADA DB 0401H DUP (?)		; tripcodeFilePath
	ALIGN	8

?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA DQ 01H DUP (?) ; openCLDeviceSearchThreadInfoArray
?wasSearchAbortedWithError@@3HA DD 01H DUP (?)		; wasSearchAbortedWithError
	ALIGN	8

?prevTotalNumGeneratedTripcodes_GPU@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes_GPU
?CUDADeviceCount@@3HA DD 01H DUP (?)			; CUDADeviceCount
?openCLDeviceCount@@3HA DD 01H DUP (?)			; openCLDeviceCount
?openCLRunChildProcesses@@3HA DD 01H DUP (?)		; openCLRunChildProcesses
	ALIGN	8

?totalNumGeneratedTripcodes_CPU@@3NA DQ 01H DUP (?)	; totalNumGeneratedTripcodes_CPU
?numOneByte@@3HA DD 01H DUP (?)				; numOneByte
?prevNumValidTripcodes@@3IA DD 01H DUP (?)		; prevNumValidTripcodes
?eventForTerminating@@3PEAXEA DQ 01H DUP (?)		; eventForTerminating
?numOpenCLDeviceSearchThreads@@3HA DD 01H DUP (?)	; numOpenCLDeviceSearchThreads
?numGeneratedTripcodes_GPU@@3IA DD 01H DUP (?)		; numGeneratedTripcodes_GPU
?numGeneratedTripcodesByGPUInMillions@@3IA DD 01H DUP (?) ; numGeneratedTripcodesByGPUInMillions
	ALIGN	8

?currentSpeed_CPU@@3NA DQ 01H DUP (?)			; currentSpeed_CPU
?opencl_device_search_threads@@3PEAPEAVthread@std@@EA DQ 01H DUP (?) ; opencl_device_search_threads
?numFirstByte@@3HA DD 01H DUP (?)			; numFirstByte
	ALIGN	8

?cpu_search_threads@@3PEAPEAVthread@std@@EA DQ 01H DUP (?) ; cpu_search_threads
?numGeneratedTripcodes_CPU@@3IA DD 01H DUP (?)		; numGeneratedTripcodes_CPU
	ALIGN	8

?totalTime@@3NA DQ 01H DUP (?)				; totalTime
?currentSpeed_thisProcess@@3NA DQ 01H DUP (?)		; currentSpeed_thisProcess
?prevTotalNumGeneratedTripcodes@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes
?prevNumDiscardedTripcodes@@3IA DD 01H DUP (?)		; prevNumDiscardedTripcodes
?numValidTripcodes@@3IA DD 01H DUP (?)			; numValidTripcodes
?isSearchPaused@@3HA DD 01H DUP (?)			; isSearchPaused
	ALIGN	8

?cuda_device_search_threads@@3PEAPEAVthread@std@@EA DQ 01H DUP (?) ; cuda_device_search_threads
?tripcodeFile@@3PEAU_iobuf@@EA DQ 01H DUP (?)		; tripcodeFile
?numCUDADeviceSearchThreads@@3HA DD 01H DUP (?)		; numCUDADeviceSearchThreads
?wasSearchTerminated@@3HA DD 01H DUP (?)		; wasSearchTerminated
?numSecondByte@@3HA DD 01H DUP (?)			; numSecondByte
	ALIGN	8

?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA DQ 01H DUP (?) ; CUDADeviceSearchThreadInfoArray
?numGeneratedTripcodesByCPUInMillions@@3IA DD 01H DUP (?) ; numGeneratedTripcodesByCPUInMillions
nameEventForTerminatingWC DW 0101H DUP (?)
	ALIGN	8

?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA DQ 01H DUP (?) ; openCLDeviceIDArray
?currentSpeed_thisProcess_GPU@@3NA DQ 01H DUP (?)	; currentSpeed_thisProcess_GPU
?totalNumGeneratedTripcodes_GPU@@3NA DQ 01H DUP (?)	; totalNumGeneratedTripcodes_GPU
?totalNumGeneratedTripcodes@@3NA DQ 01H DUP (?)		; totalNumGeneratedTripcodes
?maximumSpeed@@3NA DQ 01H DUP (?)			; maximumSpeed
nameMutexForPausingWC DW 0101H DUP (?)
	ALIGN	4

?numCPUSearchThreads@@3HA DD 01H DUP (?)		; numCPUSearchThreads
?numDiscardedTripcodes@@3IA DD 01H DUP (?)		; numDiscardedTripcodes
	ALIGN	8

?prevTotalNumGeneratedTripcodes_CPU@@3NA DQ 01H DUP (?)	; prevTotalNumGeneratedTripcodes_CPU
?keyCharTable_OneByte@@3PAEA DB 0200H DUP (?)		; keyCharTable_OneByte
?keyCharTable_SecondByte@@3PAEA DB 0200H DUP (?)	; keyCharTable_SecondByte
?keyCharTable_FirstByte@@3PAEA DB 0200H DUP (?)		; keyCharTable_FirstByte
?matchingProb@@3NA DQ 01H DUP (?)			; matchingProb
?searchDevice@@3HA DD 01H DUP (?)			; searchDevice
	ALIGN	8

?numAverageTrialsForOneMatch@@3NA DQ 01H DUP (?)	; numAverageTrialsForOneMatch
_BSS	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ DD 01H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
	DD	imagerel ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ DQ FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`vftable'
	DQ	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ
CONST	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Pad@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Pad@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ DD 01H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
	DD	imagerel ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ DQ FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`vftable'
	DQ	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
CONST	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Pad@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2_Pad@std@@8
rdata$r	SEGMENT
??_R2_Pad@std@@8 DD imagerel ??_R1A@?0A@EA@_Pad@std@@8	; std::_Pad::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Pad@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Pad@std@@8 DD imagerel ??_R0?AV_Pad@std@@@8 ; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Pad@std@@8
rdata$r	SEGMENT
??_R3_Pad@std@@8 DD 00H					; std::_Pad::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@ DD 01H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
	DD	imagerel ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV_Pad@std@@@8
data$r	SEGMENT
??_R0?AV_Pad@std@@@8 DQ FLAT:??_7type_info@@6B@		; std::_Pad `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Pad@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearch'
	DB	'ThreadInfo@@@ZPEAU1@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8 DD imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ DQ FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::`vftable'
	DQ	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8 DD imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchTh'
	DB	'readInfo@@@ZPEAU1@@std@@@std@@', 00H
	ORG $+5
?base64CharTable@@3PADA DB 041H				; base64CharTable
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02eH
	DB	02fH
?lenTripcodeKey@@3HA DD 0aH				; lenTripcodeKey
?lenTripcode@@3HA DD 0aH				; lenTripcode
?searchMode@@3HA DD 0ffffffffH				; searchMode
	ORG $+4
?options@@3UOptions@@A DD 0ffffffffH			; options
	DD	080H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
$SG4294856977 DB 00H
$SG4294856961 DB 00H
$SG4294856959 DB 00H
$SG4294856954 DB 00H
$SG4294856952 DB 00H
$SG4294856944 DB 00H
$SG4294856929 DB 00H
$SG4294856927 DB 00H
$SG4294856918 DB 00H
$SG4294857012 DB '%d', 0aH, 00H
	ORG $+1
$SG4294857008 DB '%d', 0aH, 00H
	ORG $+1
$SG4294857004 DB '%d', 0aH, 00H
$SG4294856992 DB 0aH, 00H
$SG4294856991 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856987 DB '%d', 0aH, 00H
$SG4294856982 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856971 DB 'CPU', 00H
$SG4294856962 DB ':', 00H
	ORG $+1
$SG4294856963 DB '.', 00H
$SG4294856960 DB 's', 00H
	ORG $+1
$SG4294856958 DB 's', 00H
$SG4294856956 DB '.', 00H
	ORG $+1
$SG4294856955 DB ':', 00H
	ORG $+1
$SG4294856953 DB 's', 00H
$SG4294856951 DB 's', 00H
$SG4294856926 DB 'es', 00H
	ORG $+1
$SG4294856919 DB '+', 00H
	ORG $+1
$SG4294856914 DB '%d', 0aH, 00H
$SG4294856911 DB '%d', 0aH, 00H
$SG4294856905 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856902 DB '%d', 0aH, 00H
$SG4294856898 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856895 DB '%d', 0aH, 00H
$SG4294856891 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856887 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856878 DB '%s ', 00H
$SG4294856876 DB '%s', 00H
	ORG $+1
$SG4294856877 DB '%s', 00H
	ORG $+1
$SG4294856874 DB '%d', 0aH, 00H
$SG4294856870 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856850 DB 0aH, 00H
	ORG $+1
$SG4294856844 DB '%d', 0aH, 00H
$SG4294856840 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856836 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856832 DB '%d', 0aH, 00H
$SG4294856828 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856824 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856820 DB '%d', 0aH, 00H
$SG4294856816 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856803 DB 0aH, 00H
	ORG $+1
$SG4294856796 DB 0aH, 00H
$SG4294856794 DB '-o', 00H
	ORG $+1
$SG4294856788 DB '-f', 00H
	ORG $+1
$SG4294856782 DB '%d', 0aH, 00H
$SG4294856778 DB '-d', 00H
	ORG $+1
$SG4294856777 DB '-x', 00H
	ORG $+1
$SG4294856766 DB '-y', 00H
$SG4294856755 DB '-z', 00H
	ORG $+1
$SG4294856744 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856740 DB '-a', 00H
$SG4294856729 DB '-b', 00H
	ORG $+1
$SG4294856718 DB '-l', 00H
	ORG $+1
$SG4294856717 DB '%d', 0aH, 00H
$SG4294856712 DB '-i', 00H
	ORG $+1
$SG4294856713 DB '-b', 00H
	ORG $+1
$SG4294856710 DB '-n', 00H
$SG4294856711 DB '-w', 00H
	ORG $+1
$SG4294856708 DB '-g', 00H
	ORG $+1
$SG4294856709 DB '-c', 00H
$SG4294856706 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856707 DB '-t', 00H
	ORG $+1
$SG4294856700 DB '-E', 00H
$SG4294856701 DB '-e', 00H
	ORG $+1
$SG4294856680 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856675 DB '%d', 0aH, 00H
$SG4294856671 DB '%d', 0aH, 00H
	ORG $+1
$SG4294856666 DB '%c', 00H
	ORG $+1
$SG4294856667 DB '!', 00H
$SG4294856664 DB '%c', 00H
	ORG $+1
$SG4294856665 DB ' #', 00H
	ORG $+1
$SG4294856663 DB ' (', 00H
$SG4294856660 DB ')', 0aH, 00H
	ORG $+1
$SG4294856661 DB ' ', 00H
	ORG $+1
$SG4294856658 DB '%c', 00H
$SG4294856659 DB '  !', 00H
	ORG $+1
$SG4294856656 DB '%c', 00H
	ORG $+2
$SG4294856975 DB 'STATUS', 00H
	ORG $+1
$SG4294856657 DB ' #', 00H
$SG4294856655 DB ' (', 00H
	ORG $+2
$SG4294856973 DB '======', 00H
	ORG $+1
$SG4294856652 DB ')', 00H
	ORG $+2
$SG4294856970 DB 'GPU(s)', 00H
	ORG $+1
$SG4294856653 DB ' ', 00H
$SG4294856650 DB 0aH, 00H
	ORG $+2
$SG4294856920 DB '%-79s', 0aH, 00H
	ORG $+1
$SG4294856651 DB ' ', 00H
	ORG $+3
$SG4294856976 DB '%-79s', 00H
	ORG $+2
$SG4294856793 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856648 DB '%c', 00H
$SG4294856646 DB '%c', 00H
	ORG $+3
$SG4294856974 DB '%-79s', 00H
	ORG $+2
$SG4294856787 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856647 DB ',#', 00H
	ORG $+2
$SG4294856776 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856645 DB ',(', 00H
$SG4294856642 DB ')', 0aH, 00H
	ORG $+2
$SG4294856771 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856643 DB ' ', 00H
	ORG $+3
$SG4294856972 DB '%-79s', 00H
	ORG $+2
$SG4294856765 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856640 DB '!', 00H
$SG4294856641 DB 07H, 00H
	ORG $+3
$SG4294856760 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856638 DB '  ', 00H
	ORG $+2
$SG4294856754 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856639 DB '%c', 00H
$SG4294856636 DB ' (', 00H
	ORG $+2
$SG4294856749 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856637 DB ' ', 00H
	ORG $+3
$SG4294856739 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856634 DB ' ', 00H
	ORG $+2
$SG4294856734 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856632 DB '  !', 00H
	ORG $+2
$SG4294856728 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856633 DB ')', 0aH, 00H
	ORG $+3
$SG4294856723 DB '%d,%s', 0aH, 00H
	ORG $+1
$SG4294856630 DB '  ', 00H
	ORG $+3
$SG4294856631 DB '%c', 00H
	ORG $+2
$SG4294856628 DB ' (', 00H
	ORG $+2
$SG4294856629 DB ' ', 00H
	ORG $+2
$SG4294856626 DB ' ', 00H
	ORG $+2
$SG4294856624 DB ' ', 00H
$SG4294856625 DB ')', 00H
	ORG $+3
$SG4294856622 DB 'a', 00H
	ORG $+2
$SG4294856623 DB 0aH, 00H
$SG4294856621 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856617 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856613 DB '%d', 0aH, 00H
$SG4294856609 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856606 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856603 DB '%d', 0aH, 00H
$SG4294856599 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856595 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856591 DB '%d', 0aH, 00H
$SG4294856587 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856583 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856579 DB '%d', 0aH, 00H
$SG4294856575 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856571 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856568 DB '%d', 0aH, 00H
$SG4294856565 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856561 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856557 DB '%d', 0aH, 00H
$SG4294856553 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856549 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856545 DB '%d', 0aH, 00H
$SG4294856541 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856537 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856533 DB '%d', 0aH, 00H
$SG4294856529 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856525 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856521 DB '%d', 0aH, 00H
$SG4294856517 DB '%d', 0aH, 00H
	ORG $+3
$SG4294856514 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856510 DB '%d', 0aH, 00H
$SG4294856500 DB '%d', 0aH, 00H
	ORG $+2
$SG4294856493 DB 07H, 00H
$SG4294857038 DB 'ERROR_INVALID_REGEX', 00H
	ORG $+4
$SG4294857039 DB 'ERROR_INVALID_TARGET_PATTERN', 00H
	ORG $+3
$SG4294857036 DB 'ERROR_PATTERN_TOO_SHORT', 00H
$SG4294857037 DB 'ERROR_PATTERN_TOO_LONG', 00H
	ORG $+1
$SG4294857034 DB 'ERROR_NO_MEMORY', 00H
$SG4294857035 DB 'CUDA fucnction call failed.', 00H
	ORG $+4
$SG4294857032 DB 'ERROR_IGNORE_DIRECTIVE', 00H
	ORG $+1
$SG4294857033 DB 'ERROR_PATTERN_FILE', 00H
	ORG $+5
$SG4294857030 DB 'ERROR_CRYPTOGRAPHIC_SERVICE', 00H
	ORG $+4
$SG4294857031 DB 'ERROR_NO_TARGET_PATTERNS', 00H
	ORG $+7
$SG4294857028 DB 'ERROR_TRIPCODE_FILE', 00H
	ORG $+4
$SG4294857029 DB 'ERROR_INVALID_OPTION', 00H
	ORG $+3
$SG4294857026 DB 'ERROR_MUTEX', 00H
	ORG $+4
$SG4294857027 DB 'ERROR_SEARCH_THREAD', 00H
	ORG $+4
$SG4294857024 DB 'OpenCL fucnction call failed.', 00H
	ORG $+2
$SG4294857025 DB 'Assertion failed.', 00H
	ORG $+6
$SG4294857022 DB 'ERROR_SHA1', 00H
	ORG $+5
$SG4294857023 DB 'ERROR_DES', 00H
	ORG $+6
$SG4294857020 DB 'ERROR_CHILD_PROCESS', 00H
	ORG $+4
$SG4294857021 DB 'ERROR_INTEL_HD_GRAPHICS', 00H
$SG4294857018 DB 'ERROR_EVENT', 00H
	ORG $+4
$SG4294857019 DB 'A corrupt tripcode was generated.', 0aH, '  The hardwar'
	DB	'e or device driver may be malfunctioning.', 0aH, '  Please ch'
	DB	'eck the temperatures of CPU(s) and GPU(s).', 00H
	ORG $+1
$SG4294857016 DB 'GCN assembler failed.', 00H
	ORG $+2
$SG4294857017 DB 'ERROR_SEARCH_THREAD_UNRESPONSIVE', 00H
	ORG $+7
$SG4294857014 DB 'MerikensTripcodeEngine', 00H
	ORG $+1
$SG4294857015 DB 'ERROR_UNKNOWN', 00H
	ORG $+2
$SG4294857010 DB '..\SourceFiles\Main.cpp', 00H
$SG4294857013 DB 'Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] ['
	DB	'-y global_work_size] [-z local_work_size] [-o tripcode_file] '
	DB	'[-f pattern_file] [-i] [-w]', 0aH, 00H
	ORG $+7
$SG4294857011 DB '[error],%d', 0aH, 00H
$SG4294856882 DB 'AMD ', 00H
	ORG $+7
$SG4294857009 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294857006 DB '..\SourceFiles\Main.cpp', 00H
$SG4294857007 DB '[error],%d', 0aH, 00H
$SG4294856802 DB 'CPU', 0aH, 00H
	ORG $+7
$SG4294857005 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294857002 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294857003 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294857000 DB '%s English', 0aH, 00H
	ORG $+4
$SG4294857001 DB 'Meriken''s Tripcode Engine 2.1.2', 00H
$SG4294856998 DB '07:27:27', 00H
	ORG $+7
$SG4294856999 DB 'May  4 2016', 00H
	ORG $+4
$SG4294856996 DB 'Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@g'
	DB	'mail.com>', 0aH, 00H
	ORG $+6
$SG4294856997 DB '[compiled at %s on %s (PST)]', 0aH, 00H
	ORG $+2
$SG4294856994 DB 'This is free software, and you are welcome to redistrib'
	DB	'ute it', 0aH, 00H
	ORG $+1
$SG4294856995 DB 'This program comes with ABSOLUTELY NO WARRANTY.', 0aH, 00H
	ORG $+7
$SG4294856993 DB 'under certain conditions.', 0aH, 00H
	ORG $+5
$SG4294856990 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856988 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856989 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856986 DB '[error],%d', 0aH, 00H
$SG4294856801 DB '===', 0aH, 00H
	ORG $+7
$SG4294856984 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856985 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856983 DB 'Restarting search thread...', 00H
	ORG $+4
$SG4294856980 DB 'Search thread became unresponsive.', 00H
	ORG $+5
$SG4294856981 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856978 DB '[process] Restarting search thread...', 00H
	ORG $+2
$SG4294856979 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856968 DB 'forward-matching', 00H
	ORG $+7
$SG4294856969 DB 'CPU and GPU(s)', 00H
	ORG $+1
$SG4294856966 DB 'forward- and backward-matching', 00H
	ORG $+1
$SG4294856967 DB 'backward-matching', 00H
	ORG $+6
$SG4294856964 DB '  Performing a %s search on %s', 00H
	ORG $+1
$SG4294856965 DB 'flexible', 00H
	ORG $+7
$SG4294856957 DB '  for %d pattern%s (%d chunk%s) with %d to %d character'
	DB	's%s', 00H
	ORG $+5
$SG4294856950 DB '  for %d pattern%s (%d chunk%s) with %d characters%s', 00H
	ORG $+3
$SG4294856948 DB '      CUDA%d-%d:     %s', 00H
$SG4294856949 DB '      CUDA0:     %s', 00H
	ORG $+4
$SG4294856946 DB '      OpenCL%d:   %s', 00H
	ORG $+3
$SG4294856947 DB '      OpenCL0:   %s', 00H
	ORG $+4
$SG4294856945 DB '      OpenCL%d-%d: %s', 00H
	ORG $+2
$SG4294856942 DB '      %3.2lfM tripcode/s (current)', 00H
	ORG $+5
$SG4294856943 DB '  %.3lfT tripcodes were generated in %dd %dh %dm %02ds '
	DB	'at:', 00H
	ORG $+5
$SG4294856940 DB '          CPU: %7.2lfM tripcode/s', 00H
	ORG $+6
$SG4294856941 DB '          GPU: %7.2lfM tripcode/s', 00H
	ORG $+6
$SG4294856938 DB '          GPU: %7.2lfM tripcode/s', 00H
	ORG $+6
$SG4294856939 DB '      %3.2lfM tripcode/s (average)', 00H
	ORG $+5
$SG4294856936 DB '  On average, it takes %.1lf centuries to find one matc'
	DB	'h at this speed.', 00H
$SG4294856937 DB '          CPU: %7.2lfM tripcode/s', 00H
	ORG $+6
$SG4294856934 DB '  On average, it takes %.1lf months to find one match a'
	DB	't this speed.', 00H
	ORG $+3
$SG4294856915 DB 'NVIDIA %s (CUDA)', 0aH, 00H
	ORG $+6
$SG4294856935 DB '  On average, it takes %.1lf years to find one match at'
	DB	' this speed.', 00H
$SG4294856662 DB '%02X', 00H
	ORG $+7
$SG4294856932 DB '  On average, it takes %.1lf hours to find one match at'
	DB	' this speed.', 00H
$SG4294856654 DB '%02X', 00H
	ORG $+7
$SG4294856933 DB '  On average, it takes %.1lf days to find one match at '
	DB	'this speed.', 00H
	ORG $+5
$SG4294856928 DB '  No matches were found yet.', 00H
	ORG $+3
$SG4294856906 DB 'Intel(R) Corporation', 00H
	ORG $+3
$SG4294856930 DB '  On average, it takes %.1lf seconds to find one match '
	DB	'at this speed.', 00H
	ORG $+2
$SG4294856907 DB 'NVIDIA Corporation', 00H
	ORG $+5
$SG4294856931 DB '  On average, it takes %.1lf minutes to find one match '
	DB	'at this speed.', 00H
	ORG $+2
$SG4294856880 DB 'NVIDIA Corporation', 00H
	ORG $+5
$SG4294856924 DB '  The actual matching probability is %.0f%% higher than'
	DB	' expected.', 00H
	ORG $+6
$SG4294856921 DB '  %.0f%% of matching tripcodes were invalid.', 00H
	ORG $+3
$SG4294856881 DB 'Intel(R) Corporation', 00H
	ORG $+3
$SG4294856925 DB '  %ld match%s found at %.2lf matches/h and %.2lfG tripc'
	DB	'odes/match.', 00H
	ORG $+5
$SG4294856913 DB '[error],%d', 0aH, 00H
$SG4294856644 DB '%02X', 00H
	ORG $+7
$SG4294856922 DB '  The actual matching probability is about the same as '
	DB	'expected.', 00H
	ORG $+7
$SG4294856912 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856910 DB '[error],%d', 0aH, 00H
$SG4294856635 DB '%02X', 00H
	ORG $+7
$SG4294856923 DB '  The actual matching probability is %.0f%% lower than '
	DB	'expected.', 00H
	ORG $+7
$SG4294856904 DB '[error],%d', 0aH, 00H
$SG4294856627 DB '%02X', 00H
	ORG $+7
$SG4294856916 DB '[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d'
	DB	',%.0lf,%.0lf,%u,%.0f%%', 0aH, 00H
	ORG $+1
$SG4294856917 DB '[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0'
	DB	'lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%', 0aH, 00H
$SG4294856879 DB 'NVIDIA ', 00H
$SG4294856908 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856909 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856903 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856901 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856900 DB '..\SourceFiles\Main.cpp', 00H
	ORG $+8
$SG4294856899 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856896 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856897 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856894 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856892 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856893 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856890 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856888 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856889 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856886 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856884 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856885 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856883 DB 'Advanced Micro Devices, Inc.', 00H
	ORG $+3
$SG4294856875 DB ' (OpenCL)', 0aH, 00H
	ORG $+5
$SG4294856872 DB 'An invalid device was specified.', 00H
	ORG $+7
$SG4294856873 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856871 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856868 DB 'There is no GPU.', 00H
	ORG $+7
$SG4294856869 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856866 DB 'CUDA DEVICES', 0aH, 00H
	ORG $+2
$SG4294856867 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856864 DB '  CUDA Device Count:        %d', 0aH, 0aH, 00H
	ORG $+7
$SG4294856865 DB '============', 0aH, 00H
	ORG $+2
$SG4294856862 DB '===========', 0aH, 00H
	ORG $+3
$SG4294856863 DB 'CUDA DEVICE', 0aH, 00H
	ORG $+3
$SG4294856860 DB '  Device Name:              %s', 0aH, 00H
$SG4294856861 DB '  Device No.:               %d', 0aH, 00H
$SG4294856858 DB '  Clock Rate:               %.0fMHz', 0aH, 00H
	ORG $+3
$SG4294856859 DB '  Multiprocessor Count:     %d', 0aH, 00H
$SG4294856856 DB 'cudaComputeModeDefault', 00H
	ORG $+1
$SG4294856857 DB '  Compute Capability:       %d.%d', 0aH, 00H
	ORG $+5
$SG4294856854 DB 'cudaComputeModeProhibited', 00H
	ORG $+6
$SG4294856855 DB 'cudaComputeModeExclusive', 00H
	ORG $+7
$SG4294856852 DB '(unknown)', 00H
	ORG $+6
$SG4294856853 DB 'cudaComputeModeExclusiveProcess', 00H
$SG4294856851 DB '  Compute Mode:             %s', 0aH, 00H
$SG4294856848 DB '==============', 0aH, 00H
$SG4294856849 DB 'OPENCL DEVICES', 0aH, 00H
$SG4294856846 DB 'OPENCL DEVICE', 0aH, 00H
	ORG $+1
$SG4294856847 DB '  OpenCL Device Count:      %d', 0aH, 0aH, 00H
	ORG $+7
$SG4294856845 DB '=============', 0aH, 00H
	ORG $+1
$SG4294856842 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856843 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856841 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856838 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856839 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856837 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856834 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856835 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856833 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856830 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856831 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856829 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856826 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856827 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856825 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856822 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856823 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856821 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856818 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856819 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856817 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856814 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856815 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856812 DB '  Vendor:                   %s', 0aH, 00H
	ORG $+8
$SG4294856813 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856810 DB '  Name:                     %s', 0aH, 00H
$SG4294856811 DB '  Name:                     %s (%s)', 0aH, 00H
	ORG $+3
$SG4294856808 DB '  Clock Frequency:          %dMHz', 0aH, 00H
	ORG $+5
$SG4294856809 DB '  Number of Compute Units:  %d', 0aH, 00H
$SG4294856806 DB '  Max. Work Group Size:     %d', 0aH, 00H
$SG4294856807 DB '  Global Memory Size:       %dM bytes', 0aH, 00H
	ORG $+1
$SG4294856804 DB '  Driver Version:           %s', 0aH, 00H
$SG4294856805 DB '  Version:                  %s', 0aH, 00H
$SG4294856800 DB '  Processor Info:           0x%06x (Nehalem)', 0aH, 00H
	ORG $+2
$SG4294856798 DB '  Number of Logical Cores:  %d', 0aH, 00H
$SG4294856799 DB '  Processor Info:           0x%06x', 0aH, 00H
	ORG $+4
$SG4294856797 DB '  Number of Search Threads: %d', 0aH, 00H
$SG4294856795 DB 'tripcodes.txt', 00H
	ORG $+2
$SG4294856792 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856790 DB 'The path of the tripcode file `%s'' is too long.', 00H
$SG4294856791 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856789 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856786 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856784 DB 'The path of the pattern file `%s'' is too long.', 00H
	ORG $+1
$SG4294856785 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856783 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856780 DB 'Too many pattern files were specified.', 00H
	ORG $+1
$SG4294856781 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856779 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856774 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856775 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856772 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856773 DB 'The number of blocks per SM must be at least %d.', 00H
	ORG $+7
$SG4294856770 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856768 DB 'The number of blocks per SM cannot exceed %d.', 00H
	ORG $+2
$SG4294856769 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856767 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856764 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856762 DB 'The number of work items per CU must be at least %d.', 00H
	ORG $+3
$SG4294856763 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856761 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856758 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856759 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856756 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856757 DB 'The number of work items per CU cannot exceed %d.', 00H
	ORG $+6
$SG4294856752 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856753 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856750 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856751 DB 'The number of work items per WG must be at least %d.', 00H
	ORG $+3
$SG4294856748 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856746 DB 'The number of work items per WG cannot exceed %d.', 00H
	ORG $+6
$SG4294856747 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856745 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856742 DB 'The number of work items per WG must be a multiple of 8'
	DB	'.', 00H
	ORG $+7
$SG4294856743 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856741 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856738 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856736 DB 'The number of threads per AMD GPU must be at least %d.', 00H
	ORG $+1
$SG4294856737 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856735 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856732 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856733 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856730 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856731 DB 'The number of threads per AMD GPU cannot exceed %d.', 00H
	ORG $+4
$SG4294856726 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856727 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856724 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856725 DB 'The number of processes per AMD GPU must be at least %d'
	DB	'.', 00H
	ORG $+7
$SG4294856722 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856720 DB 'The number of processes per AMD GPU cannot exceed %d.', 00H
	ORG $+2
$SG4294856721 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  ', 00H
$SG4294856719 DB 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+6
$SG4294856716 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856714 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856715 DB 'The length of tripcodes must be either 10 or 12.', 00H
	ORG $+7
$SG4294856704 DB 'The number of CPU search threads must be at least 1.', 00H
	ORG $+3
$SG4294856705 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856702 DB '--output-for-redirection', 00H
	ORG $+7
$SG4294856703 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856698 DB '--search-for-hiseki-on-cpu', 00H
	ORG $+5
$SG4294856699 DB '--use-one-byte-characters-for-keys', 00H
	ORG $+5
$SG4294856696 DB '--search-for-kaibun-on-cpu', 00H
	ORG $+5
$SG4294856697 DB '--search-for-kakuhi-on-cpu', 00H
	ORG $+5
$SG4294856694 DB '--search-for-yamabiko-on-cpu', 00H
	ORG $+3
$SG4294856695 DB '--search-for-kagami-on-cpu', 00H
	ORG $+5
$SG4294856692 DB '--use-opencl-for-cuda-devices', 00H
	ORG $+2
$SG4294856693 DB '--search-for-souren-on-cpu', 00H
	ORG $+5
$SG4294856690 DB '--disable-avx2', 00H
	ORG $+1
$SG4294856691 DB '--disable-avx', 00H
	ORG $+2
$SG4294856688 DB '--use-ascii-characters-for-keys', 00H
$SG4294856689 DB '--use-one-byte-characters-for-keys', 00H
	ORG $+5
$SG4294856686 DB '--maximize-key-space', 00H
	ORG $+3
$SG4294856687 DB '--use-one-and-two-byte-characters-for-keys', 00H
	ORG $+5
$SG4294856684 DB '--disable-gcn-assembler', 00H
$SG4294856685 DB '--disable-tripcode-checks', 00H
	ORG $+6
$SG4294856682 DB '--list-expanded-patterns', 00H
	ORG $+7
$SG4294856683 DB '--display-device-information', 00H
	ORG $+3
$SG4294856681 DB '--gpu-list', 00H
	ORG $+5
$SG4294856678 DB 'An invalid option was specified.', 00H
	ORG $+7
$SG4294856679 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856676 DB 'patterns.txt', 00H
	ORG $+3
$SG4294856677 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856674 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856672 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856673 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856670 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856668 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856669 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856649 DB '[tripcode],%c%c', 00H
$SG4294856620 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856618 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856619 DB 'The output file cannot be opened.', 00H
	ORG $+6
$SG4294856616 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856614 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856615 DB 'Failed to open an event.', 00H
	ORG $+7
$SG4294856612 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856610 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856611 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856608 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856607 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856604 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856605 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856602 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856600 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856601 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856598 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856596 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  CUDA Function Call F'
	DB	'ailed: %s [%d] (file ''%s'', line %d)', 0aH, '  The video car'
	DB	'd may be low on resources.', 0aH, 07H, 0aH, '  Hit any key to'
	DB	' exit.', 00H
	ORG $+6
$SG4294856597 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856594 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856592 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856593 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856590 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856588 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  CUDA Function Call F'
	DB	'ailed: %s [%d] (file ''%s'', line %d)', 0aH, '  The video car'
	DB	'd may be low on resources.', 0aH, 07H, 0aH, '  Hit any key to'
	DB	' exit.', 00H
	ORG $+6
$SG4294856589 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856586 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856584 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856585 DB 'Failed to start a CUDA device search thread.', 00H
	ORG $+3
$SG4294856582 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856580 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856581 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856578 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856576 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856577 DB 'Failed to start a CUDA device search thread.', 00H
	ORG $+3
$SG4294856574 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856572 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856573 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856570 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856569 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856566 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856567 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856564 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856562 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856563 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856560 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856558 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856559 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856556 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856554 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856555 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856552 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856550 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856551 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856548 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856546 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856547 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856544 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856542 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  OpenCL Function Call'
	DB	' Failed: %s (file ''%s'', line %d)', 0aH, 07H, 0aH, '  Hit an'
	DB	'y key to exit.', 00H
	ORG $+3
$SG4294856543 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856540 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856538 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856539 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856536 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856534 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856535 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856532 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856530 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856531 DB 'Failed to start a OpenCL device search thread.', 00H
	ORG $+1
$SG4294856528 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856526 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856527 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856524 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856522 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856523 DB 'Failed to start a OpenCL device search thread.', 00H
	ORG $+1
$SG4294856520 DB '[error],%d', 0aH, 00H
	ORG $+12
$SG4294856518 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856519 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856516 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856515 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856512 DB '..\SourceFiles\Main.cpp', 00H
$SG4294856513 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856511 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  Assertion Failed: fi'
	DB	'le %s, line %d', 0aH, 07H, 0aH, '  Hit any key to exit.', 00H
	ORG $+5
$SG4294856508 DB 'Failed to start a CPU search thread.', 00H
	ORG $+3
$SG4294856509 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856506 DB '%d: `%s'' @ %d', 0aH, 00H
	ORG $+1
$SG4294856507 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856504 DB '--list-expanded-patterns', 00H
	ORG $+7
$SG4294856505 DB '--display-device-information', 00H
	ORG $+3
$SG4294856502 DB '--output-for-redirection', 00H
	ORG $+7
$SG4294856503 DB '--gpu-list', 00H
	ORG $+5
$SG4294856501 DB '--gpu-list', 00H
	ORG $+5
$SG4294856498 DB 'Failed to open an event.', 00H
	ORG $+7
$SG4294856499 DB '[error],%d', 0aH, 00H
	ORG $+4
$SG4294856496 DB 'TRIPCODES', 0aH, 00H
	ORG $+5
$SG4294856497 DB 0aH, 'ERROR', 0aH, '=====', 0aH, '  %s', 0aH, 07H, 0aH, ' '
	DB	' Hit any key to exit.', 00H
	ORG $+5
$SG4294856494 DB '[started]', 0aH, 00H
	ORG $+5
$SG4294856495 DB '=========', 0aH, 00H
PUBLIC	??$_Fixarg@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z ; std::_Fixarg<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64,std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>,std::tuple<> >
PUBLIC	??$get@$0A@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@@Z ; std::get<0,OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Fixarg@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z ; std::_Fixarg<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64,std::tuple<CUDADeviceSearchThreadInfo * __ptr64>,std::tuple<> >
PUBLIC	??$get@$0A@PEAUCUDADeviceSearchThreadInfo@@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@@Z ; std::get<0,CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??$?0PEAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64>::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$?0PEAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z ; std::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64>::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>
PUBLIC	??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Do_call<,0>
PUBLIC	??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Do_call<,0>
PUBLIC	??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ		; std::tie<>
PUBLIC	??$forward@AEAP6AXXZ@std@@YAAEAP6AXXZAEAP6AXXZ@Z ; std::forward<void (__cdecl*& __ptr64)(void)>
PUBLIC	??$?0PEAUOpenCLDeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
PUBLIC	??$forward@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$?0PEAUCUDADeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
PUBLIC	??$forward@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64)>
PUBLIC	?_Get_rest@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::_Get_rest
PUBLIC	?_Get_rest@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::_Get_rest
PUBLIC	??$forward@V?$tuple@$$$V@std@@@std@@YA$$QEAV?$tuple@$$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$forward@P6AXXZ@std@@YA$$QEAP6AXXZAEAP6AXXZ@Z	; std::forward<void (__cdecl*)(void)>
PUBLIC	??$?0PEAUOpenCLDeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
PUBLIC	??$forward@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV10@@Z ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$forward@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$?0PEAUCUDADeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
PUBLIC	??$forward@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV10@@Z ; std::forward<std::tuple<CUDADeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$forward@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXXZ	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::operator()<>
PUBLIC	??$?R$$$V@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::operator()<>
PUBLIC	??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@AEAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$?0AEAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@AEAP6AXXZ@Z ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*& __ptr64)(void)>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$?0AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$?0AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??0?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@$$QEAV01@@Z	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>
PUBLIC	??0?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??0?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Run
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Run
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Go
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Go
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >
PUBLIC	??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z ; std::bind<void>
PUBLIC	??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z	; std::_Decay_copy<void (__cdecl&)(void)>
PUBLIC	??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z		; std::forward<void (__cdecl&)(void)>
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$bind@XPEAUOpenCLDeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::bind<void,OpenCLDeviceSearchThreadInfo * __ptr64,OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Decay_copy@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAPEAUOpenCLDeviceSearchThreadInfo@@$$QEAPEAU1@@Z ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$forward@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QEAPEAUOpenCLDeviceSearchThreadInfo@@AEAPEAU1@@Z ; std::forward<OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Decay_copy@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$forward@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
PUBLIC	??$bind@XPEAUCUDADeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::bind<void,CUDADeviceSearchThreadInfo * __ptr64,CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Decay_copy@PEAUCUDADeviceSearchThreadInfo@@@std@@YAPEAUCUDADeviceSearchThreadInfo@@$$QEAPEAU1@@Z ; std::_Decay_copy<CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??$forward@PEAUCUDADeviceSearchThreadInfo@@@std@@YA$$QEAPEAUCUDADeviceSearchThreadInfo@@AEAPEAU1@@Z ; std::forward<CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	??$_Decay_copy@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$forward@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>
PUBLIC	??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z	; std::thread::thread<void (__cdecl&)(void)>
PUBLIC	??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
PUBLIC	??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
PUBLIC	main
PUBLIC	?ListExpandedPatterns@@YAXXZ			; ListExpandedPatterns
PUBLIC	?GetParentProcessID@@YAHXZ			; GetParentProcessID
PUBLIC	?StartCPUSearchThreads@@YAXXZ			; StartCPUSearchThreads
PUBLIC	?StartGPUSearchThreads@@YAXXZ			; StartGPUSearchThreads
PUBLIC	?StartOpenCLDeviceSearchThreads@@YAXXZ		; StartOpenCLDeviceSearchThreads
PUBLIC	?StartCUDADeviceSearchThreads@@YAXXZ		; StartCUDADeviceSearchThreads
PUBLIC	?UpdateCurrentStatus@@YAN_K@Z			; UpdateCurrentStatus
PUBLIC	?SetTerminationState@@YAXXZ			; SetTerminationState
PUBLIC	?SetPauseState@@YAXH@Z				; SetPauseState
PUBLIC	?GetNumGeneratedTripcodesByGPU@@YANXZ		; GetNumGeneratedTripcodesByGPU
PUBLIC	?GetNumGeneratedTripcodesByCPU@@YANXZ		; GetNumGeneratedTripcodesByCPU
PUBLIC	?AddToNumGeneratedTripcodesByGPU@@YAXI@Z	; AddToNumGeneratedTripcodesByGPU
PUBLIC	?OpenTripcodeFile@@YAXXZ			; OpenTripcodeFile
PUBLIC	?ObtainOptions@@YAXHPEAPEAD@Z			; ObtainOptions
PUBLIC	?InitSearchDevices@@YAXH@Z			; InitSearchDevices
PUBLIC	?ListGPUsAndExit@@YAXXZ				; ListGPUsAndExit
PUBLIC	?ListOpenCLDevices@@YAXXZ			; ListOpenCLDevices
PUBLIC	?CountOpenCLDevices@@YAXXZ			; CountOpenCLDevices
PUBLIC	?ListCUDADevices@@YAXXZ				; ListCUDADevices
PUBLIC	?InitProcess@@YAXXZ				; InitProcess
PUBLIC	?ControlHandler@@YAHK@Z				; ControlHandler
PUBLIC	?PrintStatus@@YAXXZ				; PrintStatus
PUBLIC	?KeepSearchThreadsAlive@@YAXXZ			; KeepSearchThreadsAlive
PUBLIC	??_Gthread@std@@QEAAPEAXI@Z			; std::thread::`scalar deleting destructor'
PUBLIC	?CheckSearchThreads@@YAXXZ			; CheckSearchThreads
PUBLIC	?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z ; UpdateCUDADeviceStatus
PUBLIC	?DisplayCopyrights@@YAXXZ			; DisplayCopyrights
PUBLIC	?CreateCharacterTables@@YAXXZ			; CreateCharacterTables
PUBLIC	?CreateKey8AndKey9@@YAXPEAE@Z			; CreateKey8AndKey9
PUBLIC	?hide_cursor@@YAXXZ				; hide_cursor
PUBLIC	?ReleaseResources@@YAXXZ			; ReleaseResources
PUBLIC	?native_handle@thread@std@@QEAAPEAXXZ		; std::thread::native_handle
PUBLIC	?detach@thread@std@@QEAAXXZ			; std::thread::detach
PUBLIC	?joinable@thread@std@@QEBA_NXZ			; std::thread::joinable
PUBLIC	??1thread@std@@QEAA@XZ				; std::thread::~thread
PUBLIC	?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z		; std::_Thrd_detachX
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	??0?$tuple@$$$V@std@@QEAA@AEBV01@@Z		; std::tuple<>::tuple<>
PUBLIC	??0?$tuple@$$$V@std@@QEAA@XZ			; std::tuple<>::tuple<>
PUBLIC	?ProcessValidTripcodePair@@YAXPEAE0@Z		; ProcessValidTripcodePair
PUBLIC	?ProcessInvalidTripcodePair@@YAXPEAE0@Z		; ProcessInvalidTripcodePair
PUBLIC	?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z ; UpdateOpenCLDeviceStatus_ChildProcess
PUBLIC	?SetErrorState@@YAXXZ				; SetErrorState
PUBLIC	?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z ; UpdateOpenCLDeviceStatus
PUBLIC	?GetErrorMessage@@YAPEADH@Z			; GetErrorMessage
PUBLIC	?GetErrorState@@YAHXZ				; GetErrorState
PUBLIC	?reset_cursor_pos@@YAXH@Z			; reset_cursor_pos
PUBLIC	?show_cursor@@YAXXZ				; show_cursor
PUBLIC	?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z	; ProcessGPUOutput
PUBLIC	?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z ; SetCharactersInTripcodeKeyForSHA1Tripcode
PUBLIC	?GetPauseState@@YAHXZ				; GetPauseState
PUBLIC	?AddToNumGeneratedTripcodesByCPU@@YAXI@Z	; AddToNumGeneratedTripcodesByCPU
PUBLIC	?IsValidKey@@YAHPEAE@Z				; IsValidKey
PUBLIC	?GetTerminationState@@YAHXZ			; GetTerminationState
PUBLIC	?RandomByte@@YAEXZ				; RandomByte
PUBLIC	?IsFirstByteSJIS@@YAHE@Z			; IsFirstByteSJIS
PUBLIC	?SetCharactersInTripcodeKey@@YAXPEAEH@Z		; SetCharactersInTripcodeKey
PUBLIC	?num_generated_tripcodes_spinlock@@3Vspinlock@@A ; num_generated_tripcodes_spinlock
PUBLIC	?process_tripcode_pair_spinlock@@3Vspinlock@@A	; process_tripcode_pair_spinlock
PUBLIC	?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; cuda_device_search_thread_info_array_spinlock
PUBLIC	?current_state_spinlock@@3Vspinlock@@A		; current_state_spinlock
PUBLIC	?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A ; opencl_device_search_thread_info_array_spinlock
PUBLIC	?boost_process_spinlock@@3Vspinlock@@A		; boost_process_spinlock
PUBLIC	?system_command_spinlock@@3Vspinlock@@A		; system_command_spinlock
_Tuple_alloc DB	01H DUP (?)
	ALIGN	8

errno_ecat DQ	01H DUP (?)
ignore	DB	01H DUP (?)
	ALIGN	4

?num_generated_tripcodes_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; num_generated_tripcodes_spinlock
allocator_arg DB 01H DUP (?)
	ALIGN	4

?process_tripcode_pair_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; process_tripcode_pair_spinlock
native_ecat DQ	01H DUP (?)
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; cuda_device_search_thread_info_array_spinlock
?current_state_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; current_state_spinlock
	ALIGN	8

posix_category DQ 01H DUP (?)
?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A DD 01H DUP (?) ; opencl_device_search_thread_info_array_spinlock
?boost_process_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; boost_process_spinlock
?system_command_spinlock@@3Vspinlock@@A DD 01H DUP (?)	; system_command_spinlock
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+11
	DD	imagerel $unwind$??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+18
	DD	imagerel $unwind$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+18
	DD	imagerel $unwind$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+52
	DD	imagerel $unwind$??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z DD imagerel $LN27
	DD	imagerel $LN27+60
	DD	imagerel $unwind$??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z DD imagerel $LN27
	DD	imagerel $LN27+60
	DD	imagerel $unwind$??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z DD imagerel $LN22
	DD	imagerel $LN22+25
	DD	imagerel $unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z DD imagerel $LN38
	DD	imagerel $LN38+41
	DD	imagerel $unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z DD imagerel $LN38
	DD	imagerel $LN38+41
	DD	imagerel $unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ DD imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ DD imagerel $LN40
	DD	imagerel $LN40+41
	DD	imagerel $unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ DD imagerel $LN40
	DD	imagerel $LN40+41
	DD	imagerel $unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD imagerel $LN21
	DD	imagerel $LN21+91
	DD	imagerel $unwind$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD imagerel $LN33
	DD	imagerel $LN33+100
	DD	imagerel $unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD imagerel $LN33
	DD	imagerel $LN33+100
	DD	imagerel $unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z DD imagerel $LN37
	DD	imagerel $LN37+91
	DD	imagerel $unwind$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD imagerel $LN67
	DD	imagerel $LN67+109
	DD	imagerel $unwind$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD imagerel $LN67
	DD	imagerel $LN67+109
	DD	imagerel $unwind$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN664
	DD	imagerel $LN664+850
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$main DD imagerel $LN664+850
	DD	imagerel $LN664+1418
	DD	imagerel $chain$1$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$main DD imagerel $LN664+1418
	DD	imagerel $LN664+1945
	DD	imagerel $chain$2$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListExpandedPatterns@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+16
	DD	imagerel $unwind$?ListExpandedPatterns@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ListExpandedPatterns@@YAXXZ DD imagerel $LN11+16
	DD	imagerel $LN11+91
	DD	imagerel $chain$0$?ListExpandedPatterns@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ListExpandedPatterns@@YAXXZ DD imagerel $LN11+91
	DD	imagerel $LN11+97
	DD	imagerel $chain$1$?ListExpandedPatterns@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetParentProcessID@@YAHXZ DD imagerel $LN13
	DD	imagerel $LN13+190
	DD	imagerel $unwind$?GetParentProcessID@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartCPUSearchThreads@@YAXXZ DD imagerel $LN536
	DD	imagerel $LN536+1529
	DD	imagerel $unwind$?StartCPUSearchThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA DD imagerel ?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA DD imagerel ?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA
	DD	imagerel ?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartGPUSearchThreads@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$?StartGPUSearchThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartOpenCLDeviceSearchThreads@@YAXXZ DD imagerel $LN1652
	DD	imagerel $LN1652+5703
	DD	imagerel $unwind$?StartOpenCLDeviceSearchThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartCUDADeviceSearchThreads@@YAXXZ DD imagerel $LN1345
	DD	imagerel $LN1345+3947
	DD	imagerel $unwind$?StartCUDADeviceSearchThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD imagerel ?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD imagerel ?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	imagerel ?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD imagerel ?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	imagerel ?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateCurrentStatus@@YAN_K@Z DD imagerel $LN191
	DD	imagerel $LN191+543
	DD	imagerel $unwind$?UpdateCurrentStatus@@YAN_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetTerminationState@@YAXXZ DD imagerel $LN50
	DD	imagerel $LN50+64
	DD	imagerel $unwind$?SetTerminationState@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetPauseState@@YAXH@Z DD imagerel $LN50
	DD	imagerel $LN50+73
	DD	imagerel $unwind$?SetPauseState@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetNumGeneratedTripcodesByGPU@@YANXZ DD imagerel $LN49
	DD	imagerel $LN49+104
	DD	imagerel $unwind$?GetNumGeneratedTripcodesByGPU@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetNumGeneratedTripcodesByCPU@@YANXZ DD imagerel $LN49
	DD	imagerel $LN49+104
	DD	imagerel $unwind$?GetNumGeneratedTripcodesByCPU@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddToNumGeneratedTripcodesByGPU@@YAXI@Z DD imagerel $LN52
	DD	imagerel $LN52+135
	DD	imagerel $unwind$?AddToNumGeneratedTripcodesByGPU@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenTripcodeFile@@YAXXZ DD imagerel $LN103
	DD	imagerel $LN103+35
	DD	imagerel $unwind$?OpenTripcodeFile@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ObtainOptions@@YAXHPEAPEAD@Z DD imagerel $LN1438
	DD	imagerel $LN1438+178
	DD	imagerel $unwind$?ObtainOptions@@YAXHPEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ObtainOptions@@YAXHPEAPEAD@Z DD imagerel $LN1438+178
	DD	imagerel $LN1438+4001
	DD	imagerel $chain$2$?ObtainOptions@@YAXHPEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ObtainOptions@@YAXHPEAPEAD@Z DD imagerel $LN1438+4001
	DD	imagerel $LN1438+8411
	DD	imagerel $chain$4$?ObtainOptions@@YAXHPEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ObtainOptions@@YAXHPEAPEAD@Z DD imagerel $LN1438+8411
	DD	imagerel $LN1438+8417
	DD	imagerel $chain$5$?ObtainOptions@@YAXHPEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InitSearchDevices@@YAXH@Z DD imagerel $LN1084
	DD	imagerel $LN1084+761
	DD	imagerel $unwind$?InitSearchDevices@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?InitSearchDevices@@YAXH@Z DD imagerel $LN1084+761
	DD	imagerel $LN1084+841
	DD	imagerel $chain$2$?InitSearchDevices@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?InitSearchDevices@@YAXH@Z DD imagerel $LN1084+841
	DD	imagerel $LN1084+1240
	DD	imagerel $chain$3$?InitSearchDevices@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?InitSearchDevices@@YAXH@Z DD imagerel $LN1084+1240
	DD	imagerel $LN1084+4851
	DD	imagerel $chain$4$?InitSearchDevices@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListGPUsAndExit@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$?ListGPUsAndExit@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListOpenCLDevices@@YAXXZ DD imagerel $LN394
	DD	imagerel $LN394+52
	DD	imagerel $unwind$?ListOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ListOpenCLDevices@@YAXXZ DD imagerel $LN394+52
	DD	imagerel $LN394+608
	DD	imagerel $chain$1$?ListOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ListOpenCLDevices@@YAXXZ DD imagerel $LN394+608
	DD	imagerel $LN394+641
	DD	imagerel $chain$2$?ListOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ListOpenCLDevices@@YAXXZ DD imagerel $LN394+641
	DD	imagerel $LN394+1455
	DD	imagerel $chain$3$?ListOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376
	DD	imagerel $LN376+58
	DD	imagerel $unwind$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+58
	DD	imagerel $LN376+80
	DD	imagerel $chain$0$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+80
	DD	imagerel $LN376+591
	DD	imagerel $chain$2$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+591
	DD	imagerel $LN376+1212
	DD	imagerel $chain$6$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+1212
	DD	imagerel $LN376+1220
	DD	imagerel $chain$7$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+1220
	DD	imagerel $LN376+1248
	DD	imagerel $chain$8$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?CountOpenCLDevices@@YAXXZ DD imagerel $LN376+1248
	DD	imagerel $LN376+1803
	DD	imagerel $chain$9$?CountOpenCLDevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListCUDADevices@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+115
	DD	imagerel $unwind$?ListCUDADevices@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InitProcess@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+61
	DD	imagerel $unwind$?InitProcess@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ControlHandler@@YAHK@Z DD imagerel $LN74
	DD	imagerel $LN74+100
	DD	imagerel $unwind$?ControlHandler@@YAHK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PrintStatus@@YAXXZ DD imagerel $LN332
	DD	imagerel $LN332+120
	DD	imagerel $unwind$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?PrintStatus@@YAXXZ DD imagerel $LN332+120
	DD	imagerel $LN332+395
	DD	imagerel $chain$5$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?PrintStatus@@YAXXZ DD imagerel $LN332+395
	DD	imagerel $LN332+686
	DD	imagerel $chain$7$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?PrintStatus@@YAXXZ DD imagerel $LN332+686
	DD	imagerel $LN332+1571
	DD	imagerel $chain$8$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?PrintStatus@@YAXXZ DD imagerel $LN332+1571
	DD	imagerel $LN332+1682
	DD	imagerel $chain$13$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?PrintStatus@@YAXXZ DD imagerel $LN332+1682
	DD	imagerel $LN332+1951
	DD	imagerel $chain$15$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?PrintStatus@@YAXXZ DD imagerel $LN332+1951
	DD	imagerel $LN332+3016
	DD	imagerel $chain$16$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?PrintStatus@@YAXXZ DD imagerel $LN332+3016
	DD	imagerel $LN332+3595
	DD	imagerel $chain$17$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$18$?PrintStatus@@YAXXZ DD imagerel $LN332+3595
	DD	imagerel $LN332+3621
	DD	imagerel $chain$18$?PrintStatus@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?KeepSearchThreadsAlive@@YAXXZ DD imagerel $LN183
	DD	imagerel $LN183+318
	DD	imagerel $unwind$?KeepSearchThreadsAlive@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gthread@std@@QEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+35
	DD	imagerel $unwind$??_Gthread@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckSearchThreads@@YAXXZ DD imagerel $LN486
	DD	imagerel $LN486+1328
	DD	imagerel $unwind$?CheckSearchThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z DD imagerel $LN87
	DD	imagerel $LN87+150
	DD	imagerel $unwind$?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DisplayCopyrights@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+113
	DD	imagerel $unwind$?DisplayCopyrights@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateCharacterTables@@YAXXZ DD imagerel $LN495
	DD	imagerel $LN495+1171
	DD	imagerel $unwind$?CreateCharacterTables@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateKey8AndKey9@@YAXPEAE@Z DD imagerel $LN146
	DD	imagerel $LN146+397
	DD	imagerel $unwind$?CreateKey8AndKey9@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CreateKey8AndKey9@@YAXPEAE@Z DD imagerel $LN146+397
	DD	imagerel $LN146+540
	DD	imagerel $chain$0$?CreateKey8AndKey9@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?CreateKey8AndKey9@@YAXPEAE@Z DD imagerel $LN146+540
	DD	imagerel $LN146+634
	DD	imagerel $chain$2$?CreateKey8AndKey9@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?CreateKey8AndKey9@@YAXPEAE@Z DD imagerel $LN146+634
	DD	imagerel $LN146+672
	DD	imagerel $chain$4$?CreateKey8AndKey9@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hide_cursor@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+43
	DD	imagerel $unwind$?hide_cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReleaseResources@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+135
	DD	imagerel $unwind$?ReleaseResources@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Enative_ecat@system@boost@@YAXXZ DD imagerel ??__Enative_ecat@system@boost@@YAXXZ
	DD	imagerel ??__Enative_ecat@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Enative_ecat@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eerrno_ecat@system@boost@@YAXXZ DD imagerel ??__Eerrno_ecat@system@boost@@YAXXZ
	DD	imagerel ??__Eerrno_ecat@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Eerrno_ecat@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eposix_category@system@boost@@YAXXZ DD imagerel ??__Eposix_category@system@boost@@YAXXZ
	DD	imagerel ??__Eposix_category@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Eposix_category@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?detach@thread@std@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$?detach@thread@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1thread@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+21
	DD	imagerel $unwind$??1thread@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z DD imagerel $LN8
	DD	imagerel $LN8+46
	DD	imagerel $unwind$?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_C_return@std@@YAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+25
	DD	imagerel $unwind$?_Check_C_return@std@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessValidTripcodePair@@YAXPEAE0@Z DD imagerel $LN442
	DD	imagerel $LN442+522
	DD	imagerel $unwind$?ProcessValidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ProcessValidTripcodePair@@YAXPEAE0@Z DD imagerel $LN442+522
	DD	imagerel $LN442+547
	DD	imagerel $chain$0$?ProcessValidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ProcessValidTripcodePair@@YAXPEAE0@Z DD imagerel $LN442+547
	DD	imagerel $LN442+853
	DD	imagerel $chain$1$?ProcessValidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ProcessValidTripcodePair@@YAXPEAE0@Z DD imagerel $LN442+853
	DD	imagerel $LN442+1488
	DD	imagerel $chain$2$?ProcessValidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ProcessValidTripcodePair@@YAXPEAE0@Z DD imagerel $LN442+1488
	DD	imagerel $LN442+1597
	DD	imagerel $chain$3$?ProcessValidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247
	DD	imagerel $LN247+6
	DD	imagerel $unwind$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+6
	DD	imagerel $LN247+182
	DD	imagerel $chain$1$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+182
	DD	imagerel $LN247+187
	DD	imagerel $chain$2$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+187
	DD	imagerel $LN247+480
	DD	imagerel $chain$3$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+480
	DD	imagerel $LN247+736
	DD	imagerel $chain$4$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+736
	DD	imagerel $LN247+753
	DD	imagerel $chain$5$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD imagerel $LN247+753
	DD	imagerel $LN247+902
	DD	imagerel $chain$6$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z DD imagerel $LN187
	DD	imagerel $LN187+538
	DD	imagerel $unwind$?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetErrorState@@YAXXZ DD imagerel $LN50
	DD	imagerel $LN50+64
	DD	imagerel $unwind$?SetErrorState@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z DD imagerel $LN187
	DD	imagerel $LN187+451
	DD	imagerel $unwind$?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetErrorState@@YAHXZ DD imagerel $LN49
	DD	imagerel $LN49+60
	DD	imagerel $unwind$?GetErrorState@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset_cursor_pos@@YAXH@Z DD imagerel $LN7
	DD	imagerel $LN7+128
	DD	imagerel $unwind$?reset_cursor_pos@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?show_cursor@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?show_cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD imagerel $LN165
	DD	imagerel $LN165+82
	DD	imagerel $unwind$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD imagerel $LN165+82
	DD	imagerel $LN165+418
	DD	imagerel $chain$2$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD imagerel $LN165+418
	DD	imagerel $LN165+751
	DD	imagerel $chain$4$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD imagerel $LN165+751
	DD	imagerel $LN165+763
	DD	imagerel $chain$5$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD imagerel $LN239
	DD	imagerel $LN239+276
	DD	imagerel $unwind$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD imagerel $LN239+276
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD imagerel $LN239+296
	DD	imagerel $LN239+1050
	DD	imagerel $chain$1$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD imagerel $LN239+1050
	DD	imagerel $LN239+1055
	DD	imagerel $chain$2$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD imagerel $LN239+1055
	DD	imagerel $LN239+1064
	DD	imagerel $chain$3$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetPauseState@@YAHXZ DD imagerel $LN49
	DD	imagerel $LN49+60
	DD	imagerel $unwind$?GetPauseState@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddToNumGeneratedTripcodesByCPU@@YAXI@Z DD imagerel $LN52
	DD	imagerel $LN52+135
	DD	imagerel $unwind$?AddToNumGeneratedTripcodesByCPU@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsValidKey@@YAHPEAE@Z DD imagerel $LN103
	DD	imagerel $LN103+40
	DD	imagerel $unwind$?IsValidKey@@YAHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?IsValidKey@@YAHPEAE@Z DD imagerel $LN103+40
	DD	imagerel $LN103+629
	DD	imagerel $chain$3$?IsValidKey@@YAHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?IsValidKey@@YAHPEAE@Z DD imagerel $LN103+629
	DD	imagerel $LN103+633
	DD	imagerel $chain$5$?IsValidKey@@YAHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?IsValidKey@@YAHPEAE@Z DD imagerel $LN103+633
	DD	imagerel $LN103+654
	DD	imagerel $chain$6$?IsValidKey@@YAHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTerminationState@@YAHXZ DD imagerel $LN57
	DD	imagerel $LN57+356
	DD	imagerel $unwind$?GetTerminationState@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RandomByte@@YAEXZ DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$?RandomByte@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210
	DD	imagerel $LN210+142
	DD	imagerel $unwind$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+142
	DD	imagerel $LN210+275
	DD	imagerel $chain$0$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+275
	DD	imagerel $LN210+293
	DD	imagerel $chain$3$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+293
	DD	imagerel $LN210+956
	DD	imagerel $chain$4$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+956
	DD	imagerel $LN210+961
	DD	imagerel $chain$5$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+961
	DD	imagerel $LN210+966
	DD	imagerel $chain$2$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD imagerel $LN210+966
	DD	imagerel $LN210+976
	DD	imagerel $chain$6$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 021H
	DD	imagerel $LN210
	DD	imagerel $LN210+142
	DD	imagerel $unwind$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 020021H
	DD	0c5400H
	DD	imagerel $LN210
	DD	imagerel $LN210+142
	DD	imagerel $unwind$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 021H
	DD	imagerel $LN210+275
	DD	imagerel $LN210+293
	DD	imagerel $chain$3$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 020521H
	DD	0dc405H
	DD	imagerel $LN210+275
	DD	imagerel $LN210+293
	DD	imagerel $chain$3$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN210+961
	DD	imagerel $LN210+966
	DD	imagerel $chain$2$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 020521H
	DD	0c5405H
	DD	imagerel $LN210
	DD	imagerel $LN210+142
	DD	imagerel $unwind$?SetCharactersInTripcodeKey@@YAXPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetCharactersInTripcodeKey@@YAXPEAEH@Z DD 050a01H
	DD	0f006620aH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RandomByte@@YAEXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTerminationState@@YAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?IsValidKey@@YAHPEAE@Z DD 021H
	DD	imagerel $LN103
	DD	imagerel $LN103+40
	DD	imagerel $unwind$?IsValidKey@@YAHPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?IsValidKey@@YAHPEAE@Z DD 080021H
	DD	09e400H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel $LN103
	DD	imagerel $LN103+40
	DD	imagerel $unwind$?IsValidKey@@YAHPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?IsValidKey@@YAHPEAE@Z DD 081d21H
	DD	09e41dH
	DD	086418H
	DD	075410H
	DD	063405H
	DD	imagerel $LN103
	DD	imagerel $LN103+40
	DD	imagerel $unwind$?IsValidKey@@YAHPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsValidKey@@YAHPEAE@Z DD 021519H
	DD	070023206H
	DD	imagerel __GSHandlerCheck
	DD	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddToNumGeneratedTripcodesByCPU@@YAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetPauseState@@YAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD 021H
	DD	imagerel $LN239
	DD	imagerel $LN239+276
	DD	imagerel $unwind$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD 021H
	DD	imagerel $LN239+276
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD 020521H
	DD	06f405H
	DD	imagerel $LN239+276
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD 020521H
	DD	0ce405H
	DD	imagerel $LN239
	DD	imagerel $LN239+276
	DD	imagerel $unwind$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z DD 050901H
	DD	070056209H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD 021H
	DD	imagerel $LN165
	DD	imagerel $LN165+82
	DD	imagerel $unwind$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD 060021H
	DD	0cf400H
	DD	0d7400H
	DD	0146400H
	DD	imagerel $LN165
	DD	imagerel $LN165+82
	DD	imagerel $unwind$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD 061321H
	DD	0cf413H
	DD	0d740bH
	DD	0146404H
	DD	imagerel $LN165
	DD	imagerel $LN165+82
	DD	imagerel $unwind$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z DD 061f19H
	DD	056810H
	DD	0e007d20bH
	DD	030045005H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?show_cursor@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset_cursor_pos@@YAXH@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetErrorState@@YAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetErrorState@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z DD 081401H
	DD	037814H
	DD	04680fH
	DD	0d340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 021H
	DD	imagerel $LN247
	DD	imagerel $LN247+6
	DD	imagerel $unwind$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 021H
	DD	imagerel $LN247+6
	DD	imagerel $LN247+182
	DD	imagerel $chain$1$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 021H
	DD	imagerel $LN247+182
	DD	imagerel $LN247+187
	DD	imagerel $chain$2$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 020521H
	DD	097405H
	DD	imagerel $LN247+182
	DD	imagerel $LN247+187
	DD	imagerel $chain$2$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 020521H
	DD	063405H
	DD	imagerel $LN247+6
	DD	imagerel $LN247+182
	DD	imagerel $chain$1$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 040a21H
	DD	08640aH
	DD	075405H
	DD	imagerel $LN247
	DD	imagerel $LN247+6
	DD	imagerel $unwind$?ProcessInvalidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessInvalidTripcodePair@@YAXPEAE0@Z DD 020601H
	DD	0e0023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ProcessValidTripcodePair@@YAXPEAE0@Z DD 021H
	DD	imagerel $LN442
	DD	imagerel $LN442+522
	DD	imagerel $unwind$?ProcessValidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ProcessValidTripcodePair@@YAXPEAE0@Z DD 021H
	DD	imagerel $LN442+522
	DD	imagerel $LN442+547
	DD	imagerel $chain$0$?ProcessValidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ProcessValidTripcodePair@@YAXPEAE0@Z DD 020521H
	DD	065405H
	DD	imagerel $LN442+522
	DD	imagerel $LN442+547
	DD	imagerel $chain$0$?ProcessValidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ProcessValidTripcodePair@@YAXPEAE0@Z DD 020521H
	DD	077405H
	DD	imagerel $LN442
	DD	imagerel $LN442+522
	DD	imagerel $unwind$?ProcessValidTripcodePair@@YAXPEAE0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessValidTripcodePair@@YAXPEAE0@Z DD 061001H
	DD	096410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_C_return@std@@YAHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1thread@std@@QEAA@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?detach@thread@std@@QEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eposix_category@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eerrno_ecat@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Enative_ecat@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReleaseResources@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hide_cursor@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?CreateKey8AndKey9@@YAXPEAE@Z DD 020021H
	DD	086400H
	DD	imagerel $LN146
	DD	imagerel $LN146+397
	DD	imagerel $unwind$?CreateKey8AndKey9@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?CreateKey8AndKey9@@YAXPEAE@Z DD 020021H
	DD	086400H
	DD	imagerel $LN146
	DD	imagerel $LN146+397
	DD	imagerel $unwind$?CreateKey8AndKey9@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CreateKey8AndKey9@@YAXPEAE@Z DD 020521H
	DD	086405H
	DD	imagerel $LN146
	DD	imagerel $LN146+397
	DD	imagerel $unwind$?CreateKey8AndKey9@@YAXPEAE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateKey8AndKey9@@YAXPEAE@Z DD 030701H
	DD	070038207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateCharacterTables@@YAXXZ DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DisplayCopyrights@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CheckSearchThreads@@YAXXZ DD imagerel ?CheckSearchThreads@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?CheckSearchThreads@@YAXXZ+340
	DD	00H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+423
	DD	01H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+436
	DD	00H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+450
	DD	0ffffffffH
	DD	imagerel ?CheckSearchThreads@@YAXXZ+911
	DD	02H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+995
	DD	03H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+1008
	DD	02H
	DD	imagerel ?CheckSearchThreads@@YAXXZ+1022
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CheckSearchThreads@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??CheckSearchThreads@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??CheckSearchThreads@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??CheckSearchThreads@@YAXXZ@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??CheckSearchThreads@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?CheckSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?CheckSearchThreads@@YAXXZ
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?CheckSearchThreads@@YAXXZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckSearchThreads@@YAXXZ DD 0a2211H
	DD	01b0119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?CheckSearchThreads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gthread@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?KeepSearchThreadsAlive@@YAXXZ DD 063a01H
	DD	08743aH
	DD	09340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$18$?PrintStatus@@YAXXZ DD 021H
	DD	imagerel $LN332
	DD	imagerel $LN332+120
	DD	imagerel $unwind$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?PrintStatus@@YAXXZ DD 01a0021H
	DD	0a0bf800H
	DD	0a0ce800H
	DD	0a0dd800H
	DD	0a0ec800H
	DD	0a0fb800H
	DD	0a10a800H
	DD	0a119800H
	DD	0a128800H
	DD	0a137800H
	DD	0a146800H
	DD	0142af400H
	DD	014327400H
	DD	014303400H
	DD	imagerel $LN332
	DD	imagerel $LN332+120
	DD	imagerel $unwind$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?PrintStatus@@YAXXZ DD 021H
	DD	imagerel $LN332+1571
	DD	imagerel $LN332+1682
	DD	imagerel $chain$13$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?PrintStatus@@YAXXZ DD 041021H
	DD	0142be410H
	DD	014316408H
	DD	imagerel $LN332+1571
	DD	imagerel $LN332+1682
	DD	imagerel $chain$13$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?PrintStatus@@YAXXZ DD 0a6421H
	DD	0a0ce864H
	DD	0a0ec85bH
	DD	0a0fb852H
	DD	0a119849H
	DD	0a10a809H
	DD	imagerel $LN332+686
	DD	imagerel $LN332+1571
	DD	imagerel $chain$8$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?PrintStatus@@YAXXZ DD 020821H
	DD	014327408H
	DD	imagerel $LN332+395
	DD	imagerel $LN332+686
	DD	imagerel $chain$7$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?PrintStatus@@YAXXZ DD 041021H
	DD	0142af410H
	DD	014303408H
	DD	imagerel $LN332+120
	DD	imagerel $LN332+395
	DD	imagerel $chain$5$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?PrintStatus@@YAXXZ DD 0c3321H
	DD	0a0bf833H
	DD	0a0dd82aH
	DD	0a128821H
	DD	0a137818H
	DD	0a146810H
	DD	0142cc408H
	DD	imagerel $LN332
	DD	imagerel $LN332+120
	DD	imagerel $unwind$?PrintStatus@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PrintStatus@@YAXXZ DD 042a19H
	DD	0142d0119H
	DD	05002d004H
	DD	imagerel __GSHandlerCheck
	DD	0a0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ControlHandler@@YAHK@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InitProcess@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListCUDADevices@@YAXXZ DD 031b19H
	DD	0560109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?CountOpenCLDevices@@YAXXZ DD 0e0021H
	DD	08cf400H
	DD	08de400H
	DD	08ed400H
	DD	08fc400H
	DD	0946400H
	DD	0935400H
	DD	0923400H
	DD	imagerel $LN376
	DD	imagerel $LN376+58
	DD	imagerel $unwind$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?CountOpenCLDevices@@YAXXZ DD 021H
	DD	imagerel $LN376
	DD	imagerel $LN376+58
	DD	imagerel $unwind$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?CountOpenCLDevices@@YAXXZ DD 021H
	DD	imagerel $LN376+58
	DD	imagerel $LN376+80
	DD	imagerel $chain$0$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?CountOpenCLDevices@@YAXXZ DD 082221H
	DD	08cf422H
	DD	08ed418H
	DD	08fc410H
	DD	0935408H
	DD	imagerel $LN376+80
	DD	imagerel $LN376+591
	DD	imagerel $chain$2$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?CountOpenCLDevices@@YAXXZ DD 041021H
	DD	08de410H
	DD	0946408H
	DD	imagerel $LN376+58
	DD	imagerel $LN376+80
	DD	imagerel $chain$0$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CountOpenCLDevices@@YAXXZ DD 020821H
	DD	0923408H
	DD	imagerel $LN376
	DD	imagerel $LN376+58
	DD	imagerel $unwind$?CountOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CountOpenCLDevices@@YAXXZ DD 031b19H
	DD	0900109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0450H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ListOpenCLDevices@@YAXXZ DD 040021H
	DD	010f7400H
	DD	010e3400H
	DD	imagerel $LN394
	DD	imagerel $LN394+52
	DD	imagerel $unwind$?ListOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ListOpenCLDevices@@YAXXZ DD 021H
	DD	imagerel $LN394
	DD	imagerel $LN394+52
	DD	imagerel $unwind$?ListOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ListOpenCLDevices@@YAXXZ DD 041021H
	DD	010f7410H
	DD	010e3408H
	DD	imagerel $LN394
	DD	imagerel $LN394+52
	DD	imagerel $unwind$?ListOpenCLDevices@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListOpenCLDevices@@YAXXZ DD 051f19H
	DD	0110540dH
	DD	010c010dH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	0850H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListGPUsAndExit@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?InitSearchDevices@@YAXH@Z DD 021H
	DD	imagerel $LN1084+761
	DD	imagerel $LN1084+841
	DD	imagerel $chain$2$?InitSearchDevices@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?InitSearchDevices@@YAXH@Z DD 020821H
	DD	01366808H
	DD	imagerel $LN1084+761
	DD	imagerel $LN1084+841
	DD	imagerel $chain$2$?InitSearchDevices@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?InitSearchDevices@@YAXH@Z DD 041721H
	DD	02747417H
	DD	02736408H
	DD	imagerel $LN1084
	DD	imagerel $LN1084+761
	DD	imagerel $unwind$?InitSearchDevices@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InitSearchDevices@@YAXH@Z DD 075919H
	DD	02723459H
	DD	026e011bH
	DD	0e004f006H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	01350H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ObtainOptions@@YAXHPEAPEAD@Z DD 021H
	DD	imagerel $LN1438
	DD	imagerel $LN1438+178
	DD	imagerel $unwind$?ObtainOptions@@YAXHPEAPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ObtainOptions@@YAXHPEAPEAD@Z DD 060021H
	DD	019bf400H
	DD	019ad400H
	DD	01987400H
	DD	imagerel $LN1438
	DD	imagerel $LN1438+178
	DD	imagerel $unwind$?ObtainOptions@@YAXHPEAPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ObtainOptions@@YAXHPEAPEAD@Z DD 062f21H
	DD	019bf42fH
	DD	019ad410H
	DD	01987408H
	DD	imagerel $LN1438
	DD	imagerel $LN1438+178
	DD	imagerel $unwind$?ObtainOptions@@YAXHPEAPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ObtainOptions@@YAXHPEAPEAD@Z DD 072819H
	DD	01920117H
	DD	0c006e008H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0c80H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenTripcodeFile@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddToNumGeneratedTripcodesByGPU@@YAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetNumGeneratedTripcodesByCPU@@YANXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetNumGeneratedTripcodesByGPU@@YANXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetPauseState@@YAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetTerminationState@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateCurrentStatus@@YAN_K@Z DD 081701H
	DD	027817H
	DD	03680fH
	DD	0b340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?StartCUDADeviceSearchThreads@@YAXXZ DD imagerel ?StartCUDADeviceSearchThreads@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+2601
	DD	00H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+2652
	DD	01H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+2665
	DD	00H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+2679
	DD	0ffffffffH
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3403
	DD	02H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3456
	DD	03H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3469
	DD	02H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3482
	DD	0ffffffffH
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3497
	DD	04H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3564
	DD	05H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3577
	DD	04H
	DD	imagerel ?StartCUDADeviceSearchThreads@@YAXXZ+3590
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?StartCUDADeviceSearchThreads@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	02H
	DD	imagerel ?dtor$5@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
	DD	04H
	DD	imagerel ?dtor$7@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?StartCUDADeviceSearchThreads@@YAXXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?StartCUDADeviceSearchThreads@@YAXXZ
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?StartCUDADeviceSearchThreads@@YAXXZ
	DD	0b8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartCUDADeviceSearchThreads@@YAXXZ DD 0a2111H
	DD	0270119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?StartCUDADeviceSearchThreads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?StartOpenCLDeviceSearchThreads@@YAXXZ DD imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+4503
	DD	00H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+4584
	DD	01H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+4597
	DD	00H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+4610
	DD	0ffffffffH
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+5266
	DD	02H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+5347
	DD	03H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+5360
	DD	02H
	DD	imagerel ?StartOpenCLDeviceSearchThreads@@YAXXZ+5373
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?StartOpenCLDeviceSearchThreads@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?StartOpenCLDeviceSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?StartOpenCLDeviceSearchThreads@@YAXXZ
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?StartOpenCLDeviceSearchThreads@@YAXXZ
	DD	088H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartOpenCLDeviceSearchThreads@@YAXXZ DD 0d3f19H
	DD	0b2742eH
	DD	0b1642aH
	DD	0b03426H
	DD	0aa011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?StartOpenCLDeviceSearchThreads@@YAXXZ
	DD	0542H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartGPUSearchThreads@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?StartCPUSearchThreads@@YAXXZ DD imagerel ?StartCPUSearchThreads@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+773
	DD	00H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+795
	DD	01H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+808
	DD	00H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+822
	DD	0ffffffffH
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+912
	DD	02H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+934
	DD	03H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+947
	DD	02H
	DD	imagerel ?StartCPUSearchThreads@@YAXXZ+961
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?StartCPUSearchThreads@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??StartCPUSearchThreads@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA
	DD	02H
	DD	imagerel ?dtor$4@?0??StartCPUSearchThreads@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?StartCPUSearchThreads@@YAXXZ DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?StartCPUSearchThreads@@YAXXZ
	DD	00H
	DD	00H
	DD	09H
	DD	imagerel $ip2state$?StartCPUSearchThreads@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartCPUSearchThreads@@YAXXZ DD 0a2111H
	DD	0130119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?StartCPUSearchThreads@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetParentProcessID@@YAHXZ DD 072419H
	DD	0516412H
	DD	0503412H
	DD	04e0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0260H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ListExpandedPatterns@@YAXXZ DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+16
	DD	imagerel $unwind$?ListExpandedPatterns@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ListExpandedPatterns@@YAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN11
	DD	imagerel $LN11+16
	DD	imagerel $unwind$?ListExpandedPatterns@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListExpandedPatterns@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$main DD 021H
	DD	imagerel $LN664
	DD	imagerel $LN664+850
	DD	imagerel $unwind$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$main DD 020521H
	DD	036805H
	DD	imagerel $LN664
	DD	imagerel $LN664+850
	DD	imagerel $unwind$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	085001H
	DD	0ef450H
	DD	0e007720bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD imagerel ??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z+66
	DD	00H
	DD	imagerel ??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z+80
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 061911H
	DD	0f6419H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD imagerel ??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z+66
	DD	00H
	DD	imagerel ??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z+80
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z DD 061911H
	DD	0f6419H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z DD imagerel ??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
	DD	0ffffffffH
	DD	imagerel ??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z+53
	DD	00H
	DD	imagerel ??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z+67
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z+65
	DD	00H
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z+79
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z+65
	DD	00H
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z+79
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD imagerel ??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z+56
	DD	00H
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z+70
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z DD 010401H
	DD	04204H
posix_category$initializer$ DQ FLAT:??__Eposix_category@system@boost@@YAXXZ
errno_ecat$initializer$ DQ FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
native_ecat$initializer$ DQ FLAT:??__Enative_ecat@system@boost@@YAXXZ
num_generated_tripcodes_spinlock$initializer$ DQ FLAT:??__Enum_generated_tripcodes_spinlock@@YAXXZ
process_tripcode_pair_spinlock$initializer$ DQ FLAT:??__Eprocess_tripcode_pair_spinlock@@YAXXZ
current_state_spinlock$initializer$ DQ FLAT:??__Ecurrent_state_spinlock@@YAXXZ
cuda_device_search_thread_info_array_spinlock$initializer$ DQ FLAT:??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ
opencl_device_search_thread_info_array_spinlock$initializer$ DQ FLAT:??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ
system_command_spinlock$initializer$ DQ FLAT:??__Esystem_command_spinlock@@YAXXZ
boost_process_spinlock$initializer$ DQ FLAT:??__Eboost_process_spinlock@@YAXXZ
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetCharactersInTripcodeKey@@YAXPEAEH@Z
_TEXT	SEGMENT
randomValue$1 = 32
randomValue$2 = 36
key$ = 96
n$ = 104
randomValue$3 = 112
randomValue$4 = 112
randomValue$5 = 112
randomValue$6 = 120
randomValue$7 = 120
randomValue$8 = 120
?SetCharactersInTripcodeKey@@YAXPEAEH@Z PROC		; SetCharactersInTripcodeKey, COMDAT

; 1723 : {

$LN210:
	push	rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 56					; 00000038H

; 1724 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1725 : 		for (int32_t i = 0; i < n; i++){

	xor	edi, edi
	mov	rsi, rcx
	movsxd	r15, edx
	cmp	DWORD PTR ?options@@3UOptions@@A+84, edi
	je	SHORT $LN72@SetCharact
	test	edx, edx
	jle	$LN188@SetCharact
	mov	rbx, 5764634383759704063		; 5000186dffffffffH
	npad	4
$LL71@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$5[rsp]
	call	rand_s

; 1726 : 			key[i] = RandomByte();

	movzx	eax, BYTE PTR randomValue$5[rsp]
$LN191@SetCharact:
	mov	BYTE PTR [rdi+rsi], al

; 1727 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))

	test	rdi, rdi
	jne	SHORT $LN65@SetCharact
	movzx	eax, BYTE PTR [rsi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN61@SetCharact
$LN65@SetCharact:
	movzx	ecx, BYTE PTR [rdi+rsi]
	cmp	cl, 62					; 0000003eH
	ja	SHORT $LN145@SetCharact
	bt	rbx, rcx
	jb	SHORT $LN61@SetCharact
$LN145@SetCharact:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN70@SetCharact
$LN61@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$8[rsp]
	call	rand_s

; 1728 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$8[rsp]
	jmp	SHORT $LN191@SetCharact
$LN70@SetCharact:

; 1724 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1725 : 		for (int32_t i = 0; i < n; i++){

	inc	rdi
	cmp	rdi, r15
	jl	SHORT $LL71@SetCharact

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN72@SetCharact:

; 1729 : 		}
; 1730 : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	mov	QWORD PTR [rsp+96], rbp
	je	SHORT $LN59@SetCharact

; 1731 : 		for (int32_t i = 0; i < n; i++){

	test	edx, edx
	jle	$LN189@SetCharact
	mov	rbp, 26534307954687			; 00001821ffffffffH
	npad	9
$LL58@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$4[rsp]
	call	rand_s

; 1732 : 			key[i] = RandomByte();

	movzx	eax, BYTE PTR randomValue$4[rsp]
$LN192@SetCharact:
	mov	BYTE PTR [rdi+rsi], al

; 1733 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))

	test	rdi, rdi
	jne	SHORT $LN52@SetCharact
	movzx	eax, BYTE PTR [rsi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN48@SetCharact
$LN52@SetCharact:
	movzx	ecx, BYTE PTR [rdi+rsi]
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN48@SetCharact
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN148@SetCharact
	bt	rbp, rcx
	jb	SHORT $LN48@SetCharact
$LN148@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN57@SetCharact
$LN48@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$7[rsp]
	call	rand_s

; 1734 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$7[rsp]
	jmp	SHORT $LN192@SetCharact
$LN57@SetCharact:

; 1731 : 		for (int32_t i = 0; i < n; i++){

	inc	rdi
	cmp	rdi, r15
	jl	SHORT $LL58@SetCharact
	mov	rbp, QWORD PTR [rsp+96]

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN59@SetCharact:
	mov	QWORD PTR [rsp+48], r14

; 1735 : 		}
; 1736 : 	} else {
; 1737 : 		BOOL isSecondByteSJIS = FALSE;

	mov	ebx, edi

; 1738 : 		for (int32_t i = 0; i < n; i++){

	mov	r14, rdi
	test	edx, edx
	jle	$LN190@SetCharact
	mov	QWORD PTR [rsp+104], r12
	mov	rbp, 26534307954687			; 00001821ffffffffH
	mov	r12d, 2147483535			; 7fffff8fH
	npad	6
$LL46@SetCharact:

; 1739 : 			if (!isSecondByteSJIS) {

	test	ebx, ebx
	jne	$LN43@SetCharact

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$3[rsp]
	call	rand_s

; 1740 : 				key[i] = RandomByte();

	movzx	eax, BYTE PTR randomValue$3[rsp]
$LN194@SetCharact:
	mov	BYTE PTR [r14+rsi], al

; 1741 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))

	test	r14, r14
	jne	SHORT $LN39@SetCharact
	movzx	eax, BYTE PTR [rsi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN40@SetCharact
$LN39@SetCharact:
	movzx	ecx, BYTE PTR [r14+rsi]
	mov	edx, DWORD PTR ?options@@3UOptions@@A+88
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN35@SetCharact
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN151@SetCharact
	movzx	eax, cl
	bt	rbp, rax
	jb	SHORT $LN35@SetCharact
$LN151@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN91@SetCharact
$LN35@SetCharact:

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN86@SetCharact
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	SHORT $LN91@SetCharact
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN91@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 10
	jmp	SHORT $LN193@SetCharact
$LN86@SetCharact:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN95@SetCharact
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN95@SetCharact
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN91@SetCharact
$LN95@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 9
$LN193@SetCharact:
	jbe	SHORT $LN91@SetCharact
$LN40@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$6[rsp]
	call	rand_s

; 1742 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$6[rsp]
	jmp	SHORT $LN194@SetCharact
$LN91@SetCharact:

; 1743 : 				if (IsFirstByteSJIS(key[i]))

	movzx	ecx, BYTE PTR [r14+rsi]

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN102@SetCharact
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	SHORT $LN143@SetCharact
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN143@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 10
	jmp	SHORT $LN195@SetCharact
$LN102@SetCharact:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN111@SetCharact
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN111@SetCharact
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN143@SetCharact
$LN111@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 9
$LN195@SetCharact:
	ja	$LN45@SetCharact
$LN143@SetCharact:

; 1744 : 					isSecondByteSJIS = TRUE;

	mov	ebx, 1

; 1745 : 			} else {

	jmp	$LN45@SetCharact
$LN43@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$1[rsp]
	call	rand_s

; 1746 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$1[rsp]
$LN208@SetCharact:
	mov	BYTE PTR [r14+rsi], al

; 1747 : 				while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))

	test	r14, r14
	jne	SHORT $LN29@SetCharact
	movzx	eax, BYTE PTR [rsi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	$LN20@SetCharact
$LN29@SetCharact:
	movzx	edx, BYTE PTR [r14+rsi]
	lea	eax, DWORD PTR [rdx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN28@SetCharact
	lea	eax, DWORD PTR [rdx+127]
	cmp	al, 123					; 0000007bH
	ja	$LN20@SetCharact
$LN28@SetCharact:
	movzx	eax, BYTE PTR [r14+rsi-1]
	lea	ecx, DWORD PTR [rax+127]
	cmp	cl, 30
	ja	SHORT $LN159@SetCharact
	bt	r12d, ecx
	jb	SHORT $LN25@SetCharact
$LN159@SetCharact:
	lea	ecx, DWORD PTR [rax+32]
	cmp	cl, 10
	ja	$LN20@SetCharact
$LN25@SetCharact:
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 62					; 0000003eH
	jbe	SHORT $LN22@SetCharact
	lea	ecx, DWORD PTR [rdx+127]
	cmp	cl, 123					; 0000007bH
	ja	$LN20@SetCharact
$LN22@SetCharact:
	cmp	al, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+83]
	cmp	cl, 10
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+64]
	cmp	cl, 7
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+49]
	cmp	cl, 10
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+23]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+8]
	cmp	cl, 3
	jbe	$LN20@SetCharact
$LN15@SetCharact:
	cmp	al, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 14
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-89]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-122]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx+101]
	cmp	cl, 3
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx+14]
	cmp	cl, 10
	jbe	SHORT $LN20@SetCharact
$LN10@SetCharact:
	cmp	al, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+105]
	cmp	cl, 7
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+73]
	cmp	cl, 7
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+41]
	cmp	cl, 37					; 00000025H
	jbe	SHORT $LN20@SetCharact
$LN7@SetCharact:
	cmp	al, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx-97]
	cmp	cl, 14
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx+110]
	cmp	cl, 12
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx+65]
	cmp	cl, 61					; 0000003dH
	jbe	SHORT $LN20@SetCharact
$LN4@SetCharact:
	cmp	al, 136					; 00000088H
	jne	SHORT $LN3@SetCharact
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 94					; 0000005eH
	jbe	SHORT $LN20@SetCharact
$LN3@SetCharact:
	cmp	al, 152					; 00000098H
	jne	SHORT $LN2@SetCharact
	lea	ecx, DWORD PTR [rdx-115]
	cmp	cl, 43					; 0000002bH
	jbe	SHORT $LN20@SetCharact
$LN2@SetCharact:
	cmp	al, 234					; 000000eaH
	jne	SHORT $LN1@SetCharact
	lea	ecx, DWORD PTR [rdx+91]
	cmp	cl, 87					; 00000057H
	jbe	SHORT $LN20@SetCharact
$LN1@SetCharact:
	cmp	al, 129					; 00000081H
	jne	SHORT $LN31@SetCharact
	cmp	dl, 240					; 000000f0H
	jne	SHORT $LN31@SetCharact
$LN20@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$2[rsp]
	call	rand_s

; 1748 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$2[rsp]
	jmp	$LN208@SetCharact
$LN31@SetCharact:

; 1749 : 				isSecondByteSJIS = FALSE;

	mov	ebx, edi
$LN45@SetCharact:

; 1738 : 		for (int32_t i = 0; i < n; i++){

	inc	r14
	cmp	r14, r15
	jl	$LL46@SetCharact
	mov	r12, QWORD PTR [rsp+104]
$LN190@SetCharact:
	mov	r14, QWORD PTR [rsp+48]
$LN189@SetCharact:
	mov	rbp, QWORD PTR [rsp+96]
$LN188@SetCharact:

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}
; 1753 : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?SetCharactersInTripcodeKey@@YAXPEAEH@Z ENDP		; SetCharactersInTripcodeKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?IsFirstByteSJIS@@YAHE@Z
_TEXT	SEGMENT
ch$ = 8
?IsFirstByteSJIS@@YAHE@Z PROC				; IsFirstByteSJIS, COMDAT

; 1715 : 	if (options.maximizeKeySpace) {

	cmp	DWORD PTR ?options@@3UOptions@@A+88, 0
	je	SHORT $LN2@IsFirstByt
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 30
	ja	SHORT $LN15@IsFirstByt
	mov	edx, 2147483535				; 7fffff8fH
	bt	edx, eax
	jb	SHORT $LN12@IsFirstByt
$LN15@IsFirstByt:
	add	cl, 32					; 00000020H
	cmp	cl, 10

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	jmp	SHORT $LN19@IsFirstByt
$LN2@IsFirstByt:
	lea	eax, DWORD PTR [rcx+119]
	cmp	al, 22
	ja	SHORT $LN17@IsFirstByt
	mov	edx, 8355839				; 007f7fffH
	bt	edx, eax
	jb	SHORT $LN12@IsFirstByt
$LN17@IsFirstByt:
	add	cl, 32					; 00000020H
	cmp	cl, 9
$LN19@IsFirstByt:
	ja	SHORT $LN13@IsFirstByt
$LN12@IsFirstByt:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	mov	eax, 1

; 1719 : 	}
; 1720 : }

	ret	0
$LN13@IsFirstByt:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	xor	eax, eax

; 1719 : 	}
; 1720 : }

	ret	0
?IsFirstByteSJIS@@YAHE@Z ENDP				; IsFirstByteSJIS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?RandomByte@@YAEXZ
_TEXT	SEGMENT
randomValue$ = 48
?RandomByte@@YAEXZ PROC					; RandomByte, COMDAT

; 226  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 227  : 	uint32_t randomValue;
; 228  : 
; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$[rsp]
	call	rand_s

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);

	movzx	eax, BYTE PTR randomValue$[rsp]

; 231  : }

	add	rsp, 40					; 00000028H
	ret	0
?RandomByte@@YAEXZ ENDP					; RandomByte
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetTerminationState@@YAHXZ
_TEXT	SEGMENT
?GetTerminationState@@YAHXZ PROC			; GetTerminationState, COMDAT

; 1662 : {

$LN57:
	sub	rsp, 40					; 00000028H
$LL9@GetTermina:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN8@GetTermina
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN23@GetTermina

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL9@GetTermina
$LN23@GetTermina:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL9@GetTermina
$LN8@GetTermina:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	$LN4@GetTermina
	cmp	WORD PTR nameEventForTerminatingWC, 0
	je	$LN4@GetTermina
	mov	rax, QWORD PTR ?eventForTerminating@@3PEAXEA ; eventForTerminating
	test	rax, rax
	jne	$LN53@GetTermina

; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);

	lea	r8, OFFSET FLAT:nameEventForTerminatingWC
	xor	edx, edx
	mov	ecx, 2031619				; 001f0003H
	call	QWORD PTR __imp_OpenEventW
	mov	QWORD PTR ?eventForTerminating@@3PEAXEA, rax ; eventForTerminating

; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 

	test	rax, rax
	jne	$LN53@GetTermina
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN4@GetTermina
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN3@GetTermina
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856617
	mov	r8d, 21
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856616
	mov	edx, 21
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN2@GetTermina
$LN3@GetTermina:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856615
	lea	rcx, OFFSET FLAT:$SG4294856614
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN2@GetTermina:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN4@GetTermina:

; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)

	mov	rax, QWORD PTR ?eventForTerminating@@3PEAXEA ; eventForTerminating
	test	rax, rax
	je	SHORT $LN54@GetTermina
$LN53@GetTermina:
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_WaitForSingleObject
	mov	ecx, DWORD PTR ?wasSearchTerminated@@3HA ; wasSearchTerminated
	mov	edx, 1
	test	eax, eax
	cmove	ecx, edx
	mov	DWORD PTR ?wasSearchTerminated@@3HA, ecx ; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1681 : 	return ret;

	mov	eax, ecx

; 1682 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN54@GetTermina:

; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)

	mov	ecx, DWORD PTR ?wasSearchTerminated@@3HA ; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1681 : 	return ret;

	mov	eax, ecx

; 1682 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN56@GetTermina:
?GetTerminationState@@YAHXZ ENDP			; GetTerminationState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?IsValidKey@@YAHPEAE@Z
_TEXT	SEGMENT
results$ = 0
__$ArrayPad$ = 16
key$ = 48
?IsValidKey@@YAHPEAE@Z PROC				; IsValidKey, COMDAT

; 371  : {

$LN103:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	eax, BYTE PTR [rcx]

; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;

	xor	r10d, r10d
	mov	rdi, rcx
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	$LN46@IsValidKey

; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {

	mov	QWORD PTR [rsp+48], rbx
	mov	ebx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	mov	QWORD PTR [rsp+56], rbp
	xor	r9d, r9d
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], r14
	test	ebx, ebx
	jle	$LN43@IsValidKey
	lea	r11, QWORD PTR results$[rsp]
	mov	rsi, rcx
	mov	r8, rcx
	sub	r11, rcx
	mov	ebp, 2147483535				; 7fffff8fH
	mov	r14, 26534307954687			; 00001821ffffffffH
	neg	rsi
	npad	4
$LL45@IsValidKey:

; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {

	movzx	ecx, BYTE PTR [r8]
	test	r10d, r10d
	jne	SHORT $LN55@IsValidKey
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN56@IsValidKey
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN58@IsValidKey
	bt	r14, rcx
	jb	SHORT $LN56@IsValidKey
$LN58@IsValidKey:
	cmp	cl, 224					; 000000e0H
	jae	SHORT $LN56@IsValidKey

; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';

	mov	BYTE PTR [r11+r8], 79			; 0000004fH
	jmp	$LN44@IsValidKey
$LN56@IsValidKey:

; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {

	lea	eax, DWORD PTR [rbx-1]
	cmp	r9d, eax
	jge	$LN51@IsValidKey
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 30
	ja	SHORT $LN60@IsValidKey
	movzx	eax, al
	bt	ebp, eax
	jb	SHORT $LN35@IsValidKey
$LN60@IsValidKey:
	add	cl, 32					; 00000020H
	cmp	cl, 10
	ja	$LN51@IsValidKey
$LN35@IsValidKey:

; 388  : 			isSecondByteSJIS = TRUE;

	mov	r10d, 1

; 389  : 			results[i] = '1';

	mov	BYTE PTR [r11+r8], 49			; 00000031H
	jmp	$LN44@IsValidKey
$LN55@IsValidKey:
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN30@IsValidKey
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	$LN51@IsValidKey
$LN30@IsValidKey:

; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {

	lea	rax, QWORD PTR [rsi+r8]
	xor	r10d, r10d
	movzx	edx, BYTE PTR [rax+rdi-1]
	lea	eax, DWORD PTR [rdx+127]
	cmp	al, 30
	ja	SHORT $LN63@IsValidKey
	movzx	eax, al
	bt	ebp, eax
	jb	SHORT $LN26@IsValidKey
$LN63@IsValidKey:
	lea	eax, DWORD PTR [rdx+32]
	cmp	al, 10
	ja	$LN51@IsValidKey
$LN26@IsValidKey:
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN23@IsValidKey
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	$LN51@IsValidKey
$LN23@IsValidKey:
	cmp	dl, 129					; 00000081H
	jne	SHORT $LN16@IsValidKey
	lea	eax, DWORD PTR [rcx+83]
	cmp	al, 10
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN16@IsValidKey
	lea	eax, DWORD PTR [rcx+64]
	cmp	al, 7
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN16@IsValidKey
	lea	eax, DWORD PTR [rcx+49]
	cmp	al, 10
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN16@IsValidKey
	lea	eax, DWORD PTR [rcx+23]
	cmp	al, 6
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN16@IsValidKey
	lea	eax, DWORD PTR [rcx+8]
	cmp	al, 3
	jbe	$LN51@IsValidKey
$LN16@IsValidKey:
	cmp	dl, 130					; 00000082H
	jne	SHORT $LN11@IsValidKey
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 14
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN11@IsValidKey
	lea	eax, DWORD PTR [rcx-89]
	cmp	al, 6
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN11@IsValidKey
	lea	eax, DWORD PTR [rcx-122]
	cmp	al, 6
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN11@IsValidKey
	lea	eax, DWORD PTR [rcx+101]
	cmp	al, 3
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN11@IsValidKey
	lea	eax, DWORD PTR [rcx+14]
	cmp	al, 10
	jbe	$LN51@IsValidKey
$LN11@IsValidKey:
	cmp	dl, 131					; 00000083H
	jne	SHORT $LN8@IsValidKey
	lea	eax, DWORD PTR [rcx+105]
	cmp	al, 7
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN8@IsValidKey
	lea	eax, DWORD PTR [rcx+73]
	cmp	al, 7
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN8@IsValidKey
	lea	eax, DWORD PTR [rcx+41]
	cmp	al, 37					; 00000025H
	jbe	$LN51@IsValidKey
$LN8@IsValidKey:
	cmp	dl, 132					; 00000084H
	jne	SHORT $LN5@IsValidKey
	lea	eax, DWORD PTR [rcx-97]
	cmp	al, 14
	jbe	$LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN5@IsValidKey
	lea	eax, DWORD PTR [rcx+110]
	cmp	al, 12
	jbe	SHORT $LN51@IsValidKey
	cmp	dl, dl
	jne	SHORT $LN5@IsValidKey
	lea	eax, DWORD PTR [rcx+65]
	cmp	al, 61					; 0000003dH
	jbe	SHORT $LN51@IsValidKey
$LN5@IsValidKey:
	cmp	dl, 136					; 00000088H
	jne	SHORT $LN4@IsValidKey
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 94					; 0000005eH
	jbe	SHORT $LN51@IsValidKey
$LN4@IsValidKey:
	cmp	dl, 152					; 00000098H
	jne	SHORT $LN3@IsValidKey
	lea	eax, DWORD PTR [rcx-115]
	cmp	al, 43					; 0000002bH
	jbe	SHORT $LN51@IsValidKey
$LN3@IsValidKey:
	cmp	dl, 234					; 000000eaH
	jne	SHORT $LN2@IsValidKey
	lea	eax, DWORD PTR [rcx+91]
	cmp	al, 87					; 00000057H
	jbe	SHORT $LN51@IsValidKey
$LN2@IsValidKey:
	cmp	dl, 129					; 00000081H
	jne	SHORT $LN28@IsValidKey
	cmp	cl, 240					; 000000f0H
	je	SHORT $LN51@IsValidKey
$LN28@IsValidKey:

; 398  : 			}
; 399  : 			results[i] = '2';

	mov	BYTE PTR [r11+r8], 50			; 00000032H
$LN44@IsValidKey:

; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {

	inc	r9d
	inc	r8
	cmp	r9d, ebx
	jl	$LL45@IsValidKey
$LN43@IsValidKey:

; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;

	mov	eax, 1
$LN89@IsValidKey:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+72]

; 409  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN51@IsValidKey:

; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN89@IsValidKey
$LN46@IsValidKey:

; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;

	xor	eax, eax

; 409  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?IsValidKey@@YAHPEAE@Z ENDP				; IsValidKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?AddToNumGeneratedTripcodesByCPU@@YAXI@Z
_TEXT	SEGMENT
num$ = 48
?AddToNumGeneratedTripcodesByCPU@@YAXI@Z PROC		; AddToNumGeneratedTripcodesByCPU, COMDAT

; 1573 : {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx
	npad	8
$LL5@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN4@AddToNumGe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN19@AddToNumGe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@AddToNumGe
$LN19@AddToNumGe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@AddToNumGe
$LN4@AddToNumGe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1575 : 	numGeneratedTripcodes_CPU += num;

	mov	ecx, DWORD PTR ?numGeneratedTripcodes_CPU@@3IA ; numGeneratedTripcodes_CPU
	add	ecx, ebx
	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, ecx ; numGeneratedTripcodes_CPU

; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {

	cmp	ecx, 1000000				; 000f4240H
	jb	SHORT $LN49@AddToNumGe

; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;

	mov	eax, 1125899907				; 431bde83H
	mul	ecx
	shr	edx, 18
	add	DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA, edx ; numGeneratedTripcodesByCPUInMillions

; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;

	imul	eax, edx, -1000000			; fff0bdc0H
	add	ecx, eax
	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, ecx ; numGeneratedTripcodes_CPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1581 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN49@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1581 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?AddToNumGeneratedTripcodesByCPU@@YAXI@Z ENDP		; AddToNumGeneratedTripcodesByCPU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetPauseState@@YAHXZ
_TEXT	SEGMENT
?GetPauseState@@YAHXZ PROC				; GetPauseState, COMDAT

; 1630 : {

$LN49:
	sub	rsp, 40					; 00000028H
$LL4@GetPauseSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN3@GetPauseSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@GetPauseSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetPauseSt
$LN18@GetPauseSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetPauseSt
$LN3@GetPauseSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1633 : 	ret = isSearchPaused;

	mov	eax, DWORD PTR ?isSearchPaused@@3HA	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1636 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetPauseState@@YAHXZ ENDP				; GetPauseState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z
_TEXT	SEGMENT
randomValue$1 = 32
randomValue$2 = 36
key$ = 96
randomValue$3 = 104
randomValue$4 = 104
randomValue$5 = 104
randomValue$6 = 112
randomValue$7 = 112
randomValue$8 = 112
randomValue$9 = 120
?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z PROC ; SetCharactersInTripcodeKeyForSHA1Tripcode, COMDAT

; 1756 : {

$LN239:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 1757 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1758 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	xor	esi, esi
	mov	rdi, rcx
	cmp	DWORD PTR ?options@@3UOptions@@A+84, esi
	je	SHORT $LN79@SetCharact
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	$LN217@SetCharact
	mov	ebx, esi
	mov	rbp, 5764634383759704063		; 5000186dffffffffH
	npad	2
$LL78@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$5[rsp]
	call	rand_s

; 1759 : 			key[i] = RandomByte();

	movzx	eax, BYTE PTR randomValue$5[rsp]
$LN222@SetCharact:
	mov	BYTE PTR [rbx+rdi], al

; 1760 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ASCII_KEY_CHAR(key[i]))

	test	rbx, rbx
	jne	SHORT $LN72@SetCharact
	movzx	eax, BYTE PTR [rdi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN68@SetCharact
$LN72@SetCharact:
	movzx	ecx, BYTE PTR [rbx+rdi]
	cmp	cl, 62					; 0000003eH
	ja	SHORT $LN164@SetCharact
	bt	rbp, rcx
	jb	SHORT $LN68@SetCharact
$LN164@SetCharact:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN77@SetCharact
$LN68@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$8[rsp]
	call	rand_s

; 1761 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$8[rsp]
	jmp	SHORT $LN222@SetCharact
$LN77@SetCharact:

; 1757 : 	if (options.useOnlyASCIICharactersForKeys) {
; 1758 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL78@SetCharact

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN79@SetCharact:

; 1762 : 		}
; 1763 : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, 0
	je	SHORT $LN66@SetCharact

; 1764 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, esi	; lenTripcodeKey
	jle	$LN217@SetCharact
	mov	rbx, rsi
	mov	rbp, 26534307954687			; 00001821ffffffffH
	npad	3
$LL65@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$4[rsp]
	call	rand_s

; 1765 : 			key[i] = RandomByte();

	movzx	eax, BYTE PTR randomValue$4[rsp]
$LN223@SetCharact:
	mov	BYTE PTR [rbx+rdi], al

; 1766 : 			while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !IS_ONE_BYTE_KEY_CHAR(key[i]))

	test	rbx, rbx
	jne	SHORT $LN59@SetCharact
	movzx	eax, BYTE PTR [rdi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN55@SetCharact
$LN59@SetCharact:
	movzx	ecx, BYTE PTR [rbx+rdi]
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN55@SetCharact
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN167@SetCharact
	bt	rbp, rcx
	jb	SHORT $LN55@SetCharact
$LN167@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN64@SetCharact
$LN55@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$7[rsp]
	call	rand_s

; 1767 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$7[rsp]
	jmp	SHORT $LN223@SetCharact
$LN64@SetCharact:

; 1764 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL65@SetCharact

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN66@SetCharact:

; 1768 : 		}
; 1769 : 	} else {
; 1770 : 		BOOL isSecondByteSJIS = FALSE;

	mov	eax, esi
	mov	QWORD PTR [rsp+96], r14

; 1771 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	mov	r14d, esi
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, eax	; lenTripcodeKey
	jle	$LN221@SetCharact
	mov	QWORD PTR [rsp+48], r15
	mov	rbx, rsi
	mov	rbp, 26534307954687			; 00001821ffffffffH
	mov	r15d, 2147483535			; 7fffff8fH
$LL53@SetCharact:

; 1772 : 			if (!isSecondByteSJIS) {

	test	eax, eax
	jne	$LN50@SetCharact

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$3[rsp]
	call	rand_s

; 1773 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$3[rsp]
	mov	BYTE PTR [rbx+rdi], al

; 1774 : 				if (i == 3 || i == lenTripcodeKey - 1) {

	cmp	rbx, 3
	je	$LL47@SetCharact
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	dec	eax
	cmp	r14d, eax
	je	$LL47@SetCharact
$LL40@SetCharact:

; 1777 : 				} else {
; 1778 : 					while ((i == 0 && (key[i] == '#' || key[i] == '$')) || !(IS_ONE_BYTE_KEY_CHAR(key[i]) || IsFirstByteSJIS(key[i])))

	test	rbx, rbx
	jne	SHORT $LN37@SetCharact
	movzx	eax, BYTE PTR [rdi]
	sub	al, 35					; 00000023H
	cmp	al, 1
	jbe	SHORT $LN38@SetCharact
$LN37@SetCharact:
	movzx	ecx, BYTE PTR [rbx+rdi]
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN33@SetCharact
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN170@SetCharact
	movzx	eax, cl
	bt	rbp, rax
	jb	SHORT $LN33@SetCharact
$LN170@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	$LN218@SetCharact
$LN33@SetCharact:

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	mov	edx, DWORD PTR ?options@@3UOptions@@A+88
	test	edx, edx
	je	SHORT $LN95@SetCharact
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	$LN46@SetCharact
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN46@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 10
	jmp	SHORT $LN224@SetCharact
$LN95@SetCharact:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN104@SetCharact
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN104@SetCharact
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN46@SetCharact
$LN104@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 9
$LN224@SetCharact:
	jbe	SHORT $LN46@SetCharact
$LN38@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$6[rsp]
	call	rand_s

; 1779 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$6[rsp]
	mov	BYTE PTR [rbx+rdi], al
	jmp	SHORT $LL40@SetCharact
$LL47@SetCharact:

; 1775 : 					while (!IS_ONE_BYTE_KEY_CHAR(key[i]))

	movzx	ecx, BYTE PTR [rbx+rdi]
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN42@SetCharact
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN174@SetCharact
	movzx	eax, cl
	bt	rbp, rax
	jb	SHORT $LN42@SetCharact
$LN174@SetCharact:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN218@SetCharact
$LN42@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$9[rsp]
	call	rand_s

; 1776 : 						key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$9[rsp]
	mov	BYTE PTR [rbx+rdi], al
	jmp	SHORT $LL47@SetCharact
$LN218@SetCharact:
	mov	edx, DWORD PTR ?options@@3UOptions@@A+88
$LN46@SetCharact:

; 1780 : 				}
; 1781 : 				isSecondByteSJIS = IsFirstByteSJIS(key[i]);

	movzx	ecx, BYTE PTR [rbx+rdi]

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN111@SetCharact
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	SHORT $LN121@SetCharact
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN121@SetCharact

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 10
	ja	$LN30@SetCharact
	mov	eax, 1
	jmp	$LN52@SetCharact
$LN111@SetCharact:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN120@SetCharact
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN120@SetCharact
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN121@SetCharact
$LN120@SetCharact:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	add	cl, 32					; 00000020H
	cmp	cl, 9
	ja	$LN30@SetCharact
$LN121@SetCharact:
	mov	eax, 1
	jmp	$LN52@SetCharact
$LN50@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$1[rsp]
	call	rand_s

; 1782 : 			} else {
; 1783 : 				key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$1[rsp]
$LN237@SetCharact:

; 1784 : 				while (!IS_SECOND_BYTE_SJIS(key[i]) || !IS_VALID_SJIS_CHAR(key[i - 1], key[i]))

	movzx	edx, al
	mov	BYTE PTR [rbx+rdi], al
	lea	eax, DWORD PTR [rdx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN28@SetCharact
	lea	eax, DWORD PTR [rdx+127]
	cmp	al, 123					; 0000007bH
	ja	$LN20@SetCharact
$LN28@SetCharact:
	movzx	eax, BYTE PTR [rbx+rdi-1]
	lea	ecx, DWORD PTR [rax+127]
	cmp	cl, 30
	ja	SHORT $LN179@SetCharact
	bt	r15d, ecx
	jb	SHORT $LN25@SetCharact
$LN179@SetCharact:
	lea	ecx, DWORD PTR [rax+32]
	cmp	cl, 10
	ja	$LN20@SetCharact
$LN25@SetCharact:
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 62					; 0000003eH
	jbe	SHORT $LN22@SetCharact
	lea	ecx, DWORD PTR [rdx+127]
	cmp	cl, 123					; 0000007bH
	ja	$LN20@SetCharact
$LN22@SetCharact:
	cmp	al, 129					; 00000081H
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+83]
	cmp	cl, 10
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+64]
	cmp	cl, 7
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+49]
	cmp	cl, 10
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+23]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN15@SetCharact
	lea	ecx, DWORD PTR [rdx+8]
	cmp	cl, 3
	jbe	$LN20@SetCharact
$LN15@SetCharact:
	cmp	al, 130					; 00000082H
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 14
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-89]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx-122]
	cmp	cl, 6
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx+101]
	cmp	cl, 3
	jbe	$LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN10@SetCharact
	lea	ecx, DWORD PTR [rdx+14]
	cmp	cl, 10
	jbe	$LN20@SetCharact
$LN10@SetCharact:
	cmp	al, 131					; 00000083H
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+105]
	cmp	cl, 7
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+73]
	cmp	cl, 7
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN7@SetCharact
	lea	ecx, DWORD PTR [rdx+41]
	cmp	cl, 37					; 00000025H
	jbe	SHORT $LN20@SetCharact
$LN7@SetCharact:
	cmp	al, 132					; 00000084H
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx-97]
	cmp	cl, 14
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx+110]
	cmp	cl, 12
	jbe	SHORT $LN20@SetCharact
	cmp	al, al
	jne	SHORT $LN4@SetCharact
	lea	ecx, DWORD PTR [rdx+65]
	cmp	cl, 61					; 0000003dH
	jbe	SHORT $LN20@SetCharact
$LN4@SetCharact:
	cmp	al, 136					; 00000088H
	jne	SHORT $LN3@SetCharact
	lea	ecx, DWORD PTR [rdx-64]
	cmp	cl, 94					; 0000005eH
	jbe	SHORT $LN20@SetCharact
$LN3@SetCharact:
	cmp	al, 152					; 00000098H
	jne	SHORT $LN2@SetCharact
	lea	ecx, DWORD PTR [rdx-115]
	cmp	cl, 43					; 0000002bH
	jbe	SHORT $LN20@SetCharact
$LN2@SetCharact:
	cmp	al, 234					; 000000eaH
	jne	SHORT $LN1@SetCharact
	lea	ecx, DWORD PTR [rdx+91]
	cmp	cl, 87					; 00000057H
	jbe	SHORT $LN20@SetCharact
$LN1@SetCharact:
	cmp	al, 129					; 00000081H
	jne	SHORT $LN30@SetCharact
	cmp	dl, 240					; 000000f0H
	jne	SHORT $LN30@SetCharact
$LN20@SetCharact:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$2[rsp]
	call	rand_s

; 1785 : 					key[i] = (unsigned char)(RandomByte() & 0xff);

	movzx	eax, BYTE PTR randomValue$2[rsp]
	jmp	$LN237@SetCharact
$LN30@SetCharact:

; 1786 : 				isSecondByteSJIS = FALSE;

	mov	eax, esi
$LN52@SetCharact:

; 1771 : 		for (int32_t i = 0; i < lenTripcodeKey; i++){

	inc	r14d
	inc	rbx
	cmp	r14d, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	$LL53@SetCharact
	mov	r15, QWORD PTR [rsp+48]
$LN221@SetCharact:
	mov	r14, QWORD PTR [rsp+96]
$LN217@SetCharact:

; 1787 : 			}
; 1788 : 		}
; 1789 : 	}
; 1790 : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?SetCharactersInTripcodeKeyForSHA1Tripcode@@YAXPEAE@Z ENDP ; SetCharactersInTripcodeKeyForSHA1Tripcode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z
_TEXT	SEGMENT
key$ = 32
tripcode$ = 48
__$ArrayPad$ = 64
partialKey$ = 144
outputArray$ = 152
sizeOutputArray$ = 160
newFormat$ = 168
?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z PROC	; ProcessGPUOutput, COMDAT

; 335  : {

$LN165:
	mov	r11, rsp
	push	rbx
	push	rbp
	push	r14
	sub	rsp, 112				; 00000070H
	movaps	XMMWORD PTR [rsp+80], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';

	movsxd	rax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	mov	r14d, r9d
	mov	ebp, r8d
	mov	rbx, rdx
	xorps	xmm6, xmm6
	cmp	rax, 13
	jae	$LN17@ProcessGPU

; 341  : 	key     [lenTripcodeKey] = '\0';

	movsxd	r8, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	mov	BYTE PTR tripcode$[rsp+rax], 0
	cmp	r8, 13
	jae	$LN164@ProcessGPU

; 342  : 	memcpy(key, partialKey, lenTripcodeKey);

	mov	QWORD PTR [r11+24], rsi
	mov	rdx, rcx
	mov	QWORD PTR [r11-32], rdi
	lea	rcx, QWORD PTR [r11-104]
	mov	QWORD PTR [r11-40], r15
	mov	BYTE PTR key$[rsp+r8], 0
	call	memcpy

; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){

	xor	r15d, r15d
	mov	esi, r15d
	test	ebp, ebp
	je	$LN156@ProcessGPU
	add	rbx, 5
$LL14@ProcessGPU:

; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);

	mov	ecx, DWORD PTR [rbx-5]
	call	?AddToNumGeneratedTripcodesByGPU@@YAXI@Z ; AddToNumGeneratedTripcodesByGPU

; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;

	mov	eax, DWORD PTR [rbx-5]
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	addsd	xmm6, xmm0

; 347  : 		if (output->numMatchingTripcodes > 0) {

	cmp	BYTE PTR [rbx-1], r15b
	jbe	$LN13@ProcessGPU

; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);

	movsxd	rdi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	lea	rcx, QWORD PTR tripcode$[rsp]
	mov	rdx, rbx
	mov	r8, rdi
	call	memcpy

; 349  : 			if (lenTripcode == 12 && newFormat) {

	cmp	edi, 12
	jne	SHORT $LN8@ProcessGPU
	test	r14d, r14d
	je	SHORT $LN152@ProcessGPU

; 350  : 				memcpy(key, output->pair.key.c, 4);

	mov	eax, DWORD PTR [rbx+12]
	mov	DWORD PTR key$[rsp], eax

; 351  : 				key[7]  = output->pair.key.c[7];

	movzx	eax, BYTE PTR [rbx+19]
	mov	BYTE PTR key$[rsp+7], al

; 352  : 				key[11] = output->pair.key.c[11];

	movzx	eax, BYTE PTR [rbx+23]
	mov	BYTE PTR key$[rsp+11], al
	jmp	SHORT $LN7@ProcessGPU
$LN152@ProcessGPU:

; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);

	mov	eax, DWORD PTR [rbx+19]
	mov	DWORD PTR key$[rsp+7], eax
	movzx	eax, BYTE PTR [rbx+23]
	mov	BYTE PTR key$[rsp+11], al

; 355  : 			} else {

	jmp	SHORT $LN7@ProcessGPU
$LN8@ProcessGPU:

; 356  : 				ASSERT(lenTripcode == 10);

	cmp	edi, 10
	je	SHORT $LN6@ProcessGPU
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN141@ProcessGPU
$LN6@ProcessGPU:

; 357  : 				memcpy(key,  output->pair.key.c, 8);

	mov	rax, QWORD PTR [rbx+12]

; 358  : 				CreateKey8AndKey9(key);

	lea	rcx, QWORD PTR key$[rsp]
	mov	QWORD PTR key$[rsp], rax
	call	?CreateKey8AndKey9@@YAXPEAE@Z		; CreateKey8AndKey9
$LN7@ProcessGPU:

; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	lea	rcx, QWORD PTR tripcode$[rsp]
	call	?IsTripcodeChunkValid@@YAHPEAE@Z	; IsTripcodeChunkValid
	test	eax, eax
	jne	SHORT $LN3@ProcessGPU
$LL24@ProcessGPU:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN23@ProcessGPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN38@ProcessGPU

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL24@ProcessGPU
$LN38@ProcessGPU:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL24@ProcessGPU
$LN23@ProcessGPU:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	test	eax, eax
	je	SHORT $LL68@ProcessGPU
$LN3@ProcessGPU:

; 364  : 			ProcessPossibleMatch(tripcode, key);

	lea	rdx, QWORD PTR key$[rsp]
	lea	rcx, QWORD PTR tripcode$[rsp]
	call	?ProcessPossibleMatch@@YAXPEAE0@Z	; ProcessPossibleMatch
$LN13@ProcessGPU:

; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){

	inc	esi
	add	rbx, 32					; 00000020H
	cmp	esi, ebp
	jb	$LL14@ProcessGPU
$LN156@ProcessGPU:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+160]
	mov	r15, QWORD PTR [rsp+96]

; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;

	movaps	xmm0, xmm6

; 368  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 112				; 00000070H
	pop	r14
	pop	rbp
	pop	rbx
	ret	0
$LL68@ProcessGPU:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN67@ProcessGPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN82@ProcessGPU

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL68@ProcessGPU
$LN82@ProcessGPU:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL68@ProcessGPU
$LN67@ProcessGPU:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));

	je	SHORT $LN2@ProcessGPU
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294857004
	mov	r8d, 20
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294857003
	mov	edx, 20
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN1@ProcessGPU
$LN2@ProcessGPU:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857019
	lea	rcx, OFFSET FLAT:$SG4294857002
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN1@ProcessGPU:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN141@ProcessGPU:

; 356  : 				ASSERT(lenTripcode == 10);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN5@ProcessGPU
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294857008
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294857007
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN4@ProcessGPU
$LN5@ProcessGPU:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857006
	lea	rcx, OFFSET FLAT:$SG4294857005
	mov	r8d, 356				; 00000164H
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN4@ProcessGPU:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN164@ProcessGPU:

; 341  : 	key     [lenTripcodeKey] = '\0';

	call	__report_rangecheckfailure
	int	3
$LN17@ProcessGPU:

; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';

	call	__report_rangecheckfailure
	int	3
$LN163@ProcessGPU:
?ProcessGPUOutput@@YANPEAEPEAUGPUOutput@@IH@Z ENDP	; ProcessGPUOutput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?show_cursor@@YAXXZ
_TEXT	SEGMENT
info$ = 48
?show_cursor@@YAXXZ PROC				; show_cursor, COMDAT

; 287  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$[rsp+4], 1
	mov	DWORD PTR info$[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo

; 293  : }

	add	rsp, 40					; 00000028H
	ret	0
?show_cursor@@YAXXZ ENDP				; show_cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?reset_cursor_pos@@YAXH@Z
_TEXT	SEGMENT
cursorPos$ = 32
scrnBufInfo$ = 40
__$ArrayPad$ = 64
n$ = 96
?reset_cursor_pos@@YAXH@Z PROC				; reset_cursor_pos, COMDAT

; 255  : {

$LN7:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, ecx

; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR scrnBufInfo$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_GetConsoleScreenBufferInfo
	test	eax, eax
	je	SHORT $LN2@reset_curs

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	movsx	ecx, WORD PTR scrnBufInfo$[rsp+6]
	xor	edx, edx
	mov	eax, ecx
	mov	WORD PTR cursorPos$[rsp], dx
	add	eax, ebx
	js	SHORT $LN4@reset_curs
	add	bx, cx
	mov	WORD PTR cursorPos$[rsp+2], bx
	jmp	SHORT $LN5@reset_curs
$LN4@reset_curs:
	mov	WORD PTR cursorPos$[rsp+2], dx
$LN5@reset_curs:

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	edx, DWORD PTR cursorPos$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorPosition
$LN2@reset_curs:

; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?reset_cursor_pos@@YAXH@Z ENDP				; reset_cursor_pos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetErrorState@@YAHXZ
_TEXT	SEGMENT
?GetErrorState@@YAHXZ PROC				; GetErrorState, COMDAT

; 1646 : {

$LN49:
	sub	rsp, 40					; 00000028H
$LL4@GetErrorSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN3@GetErrorSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@GetErrorSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetErrorSt
$LN18@GetErrorSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetErrorSt
$LN3@GetErrorSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1652 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetErrorState@@YAHXZ ENDP				; GetErrorState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetErrorMessage@@YAPEADH@Z
_TEXT	SEGMENT
errorCode$ = 8
?GetErrorMessage@@YAPEADH@Z PROC			; GetErrorMessage, COMDAT

; 172  : 	switch (errorCode) {

	cmp	ecx, 24
	ja	$LN1@GetErrorMe
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, ecx
	mov	ecx, DWORD PTR $LN30@GetErrorMe[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN25@GetErrorMe:

; 173  :     case ERROR_INVALID_TARGET_PATTERN: 
; 174  : 		return "ERROR_INVALID_TARGET_PATTERN";

	lea	rax, OFFSET FLAT:$SG4294857039

; 222  : 	}
; 223  : }

	ret	0
$LN24@GetErrorMe:

; 175  :     case ERROR_INVALID_REGEX: 
; 176  : 		return "ERROR_INVALID_REGEX";

	lea	rax, OFFSET FLAT:$SG4294857038

; 222  : 	}
; 223  : }

	ret	0
$LN23@GetErrorMe:

; 177  :     case ERROR_PATTERN_TOO_LONG: 
; 178  : 		return "ERROR_PATTERN_TOO_LONG";

	lea	rax, OFFSET FLAT:$SG4294857037

; 222  : 	}
; 223  : }

	ret	0
$LN22@GetErrorMe:

; 179  :     case ERROR_PATTERN_TOO_SHORT: 
; 180  : 		return "ERROR_PATTERN_TOO_SHORT";

	lea	rax, OFFSET FLAT:$SG4294857036

; 222  : 	}
; 223  : }

	ret	0
$LN21@GetErrorMe:

; 181  :     case ERROR_CUDA:
; 182  : 		return "CUDA fucnction call failed.";

	lea	rax, OFFSET FLAT:$SG4294857035

; 222  : 	}
; 223  : }

	ret	0
$LN20@GetErrorMe:

; 183  :     case ERROR_NO_MEMORY: 
; 184  : 		return "ERROR_NO_MEMORY";

	lea	rax, OFFSET FLAT:$SG4294857034

; 222  : 	}
; 223  : }

	ret	0
$LN19@GetErrorMe:

; 185  :     case ERROR_PATTERN_FILE: 
; 186  : 		return "ERROR_PATTERN_FILE";

	lea	rax, OFFSET FLAT:$SG4294857033

; 222  : 	}
; 223  : }

	ret	0
$LN18@GetErrorMe:

; 187  :     case ERROR_IGNORE_DIRECTIVE:
; 188  : 		return "ERROR_IGNORE_DIRECTIVE";

	lea	rax, OFFSET FLAT:$SG4294857032

; 222  : 	}
; 223  : }

	ret	0
$LN17@GetErrorMe:

; 189  :     case ERROR_NO_TARGET_PATTERNS: 
; 190  : 		return "ERROR_NO_TARGET_PATTERNS";

	lea	rax, OFFSET FLAT:$SG4294857031

; 222  : 	}
; 223  : }

	ret	0
$LN16@GetErrorMe:

; 191  :     case ERROR_CRYPTOGRAPHIC_SERVICE: 
; 192  : 		return "ERROR_CRYPTOGRAPHIC_SERVICE";

	lea	rax, OFFSET FLAT:$SG4294857030

; 222  : 	}
; 223  : }

	ret	0
$LN15@GetErrorMe:

; 193  :     case ERROR_INVALID_OPTION: 
; 194  : 		return "ERROR_INVALID_OPTION";

	lea	rax, OFFSET FLAT:$SG4294857029

; 222  : 	}
; 223  : }

	ret	0
$LN14@GetErrorMe:

; 195  :     case ERROR_TRIPCODE_FILE:
; 196  : 		return "ERROR_TRIPCODE_FILE";

	lea	rax, OFFSET FLAT:$SG4294857028

; 222  : 	}
; 223  : }

	ret	0
$LN13@GetErrorMe:

; 197  :     case ERROR_SEARCH_THREAD: 
; 198  : 		return "ERROR_SEARCH_THREAD";

	lea	rax, OFFSET FLAT:$SG4294857027

; 222  : 	}
; 223  : }

	ret	0
$LN12@GetErrorMe:

; 199  :     case ERROR_MUTEX:
; 200  : 		return "ERROR_MUTEX";

	lea	rax, OFFSET FLAT:$SG4294857026

; 222  : 	}
; 223  : }

	ret	0
$LN11@GetErrorMe:

; 201  :     case ERROR_ASSERTION:
; 202  : 		return "Assertion failed.";

	lea	rax, OFFSET FLAT:$SG4294857025

; 222  : 	}
; 223  : }

	ret	0
$LN10@GetErrorMe:

; 203  :     case ERROR_OPENCL:
; 204  : 		return "OpenCL fucnction call failed.";

	lea	rax, OFFSET FLAT:$SG4294857024

; 222  : 	}
; 223  : }

	ret	0
$LN9@GetErrorMe:

; 205  :     case ERROR_DES: 
; 206  : 		return "ERROR_DES";

	lea	rax, OFFSET FLAT:$SG4294857023

; 222  : 	}
; 223  : }

	ret	0
$LN8@GetErrorMe:

; 207  :     case ERROR_SHA1: 
; 208  : 		return "ERROR_SHA1";

	lea	rax, OFFSET FLAT:$SG4294857022

; 222  : 	}
; 223  : }

	ret	0
$LN7@GetErrorMe:

; 209  :     case ERROR_INTEL_HD_GRAPHICS:
; 210  : 		return "ERROR_INTEL_HD_GRAPHICS";

	lea	rax, OFFSET FLAT:$SG4294857021

; 222  : 	}
; 223  : }

	ret	0
$LN6@GetErrorMe:

; 211  :     case ERROR_CHILD_PROCESS:
; 212  : 		return "ERROR_CHILD_PROCESS";

	lea	rax, OFFSET FLAT:$SG4294857020

; 222  : 	}
; 223  : }

	ret	0
$LN5@GetErrorMe:

; 213  :     case ERROR_TRIPCODE_VERIFICATION_FAILED: 
; 214  : 		return "A corrupt tripcode was generated.\n  The hardware or device driver may be malfunctioning.\n  Please check the temperatures of CPU(s) and GPU(s).";

	lea	rax, OFFSET FLAT:$SG4294857019

; 222  : 	}
; 223  : }

	ret	0
$LN4@GetErrorMe:

; 215  :     case ERROR_EVENT: 
; 216  : 		return "ERROR_EVENT";

	lea	rax, OFFSET FLAT:$SG4294857018

; 222  : 	}
; 223  : }

	ret	0
$LN3@GetErrorMe:

; 217  :     case ERROR_SEARCH_THREAD_UNRESPONSIVE:
; 218  : 		return "ERROR_SEARCH_THREAD_UNRESPONSIVE";

	lea	rax, OFFSET FLAT:$SG4294857017

; 222  : 	}
; 223  : }

	ret	0
$LN2@GetErrorMe:

; 219  :     case ERROR_GCN_ASSEMBLER: 
; 220  : 		return "GCN assembler failed.";

	lea	rax, OFFSET FLAT:$SG4294857016

; 222  : 	}
; 223  : }

	ret	0
$LN1@GetErrorMe:

; 221  :     default: return "ERROR_UNKNOWN";

	lea	rax, OFFSET FLAT:$SG4294857015

; 222  : 	}
; 223  : }

	ret	0
	npad	1
$LN30@GetErrorMe:
	DD	$LN25@GetErrorMe
	DD	$LN24@GetErrorMe
	DD	$LN23@GetErrorMe
	DD	$LN22@GetErrorMe
	DD	$LN21@GetErrorMe
	DD	$LN20@GetErrorMe
	DD	$LN19@GetErrorMe
	DD	$LN18@GetErrorMe
	DD	$LN17@GetErrorMe
	DD	$LN16@GetErrorMe
	DD	$LN15@GetErrorMe
	DD	$LN14@GetErrorMe
	DD	$LN13@GetErrorMe
	DD	$LN12@GetErrorMe
	DD	$LN11@GetErrorMe
	DD	$LN10@GetErrorMe
	DD	$LN9@GetErrorMe
	DD	$LN8@GetErrorMe
	DD	$LN7@GetErrorMe
	DD	$LN6@GetErrorMe
	DD	$LN5@GetErrorMe
	DD	$LN4@GetErrorMe
	DD	$LN3@GetErrorMe
	DD	$LN1@GetErrorMe
	DD	$LN2@GetErrorMe
?GetErrorMessage@@YAPEADH@Z ENDP			; GetErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z
_TEXT	SEGMENT
info$1 = 48
info$ = 48
status$ = 56
$T2 = 64
?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z PROC ; UpdateOpenCLDeviceStatus, COMDAT

; 550  : {

$LN187:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
$LL8@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN7@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN22@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL8@UpdateOpen
$LN22@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL8@UpdateOpen
$LN7@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 552  : 	ASSERT(!info->runChildProcess);

	cmp	DWORD PTR [rdi+1080], 0
	je	$LN3@UpdateOpen
$LL28@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN27@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN42@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL28@UpdateOpen
$LN42@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL28@UpdateOpen
$LN27@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 552  : 	ASSERT(!info->runChildProcess);

	test	eax, eax
	jne	$LN3@UpdateOpen
	npad	5
$LL72@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN71@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN86@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL72@UpdateOpen
$LN86@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL72@UpdateOpen
$LN71@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 552  : 	ASSERT(!info->runChildProcess);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 552  : 	ASSERT(!info->runChildProcess);

	je	SHORT $LN2@UpdateOpen
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856991
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856990
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN113@UpdateOpen
$LN2@UpdateOpen:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856989
	lea	rcx, OFFSET FLAT:$SG4294856988
	mov	r8d, 552				; 00000228H
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$1[rsp+4], 1
	mov	DWORD PTR info$1[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN113@UpdateOpen:

; 552  : 	ASSERT(!info->runChildProcess);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN3@UpdateOpen:

; 553  : 	strcpy(info->status, status);

	mov	rcx, rdi
	sub	rcx, rbx
	npad	2
$LL6@UpdateOpen:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rcx+rbx+15], al
	test	al, al
	jne	SHORT $LL6@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T2[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	QWORD PTR [rdi+1096], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 556  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN186@UpdateOpen:
?UpdateOpenCLDeviceStatus@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEAD@Z ENDP ; UpdateOpenCLDeviceStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetErrorState@@YAXXZ
_TEXT	SEGMENT
?SetErrorState@@YAXXZ PROC				; SetErrorState, COMDAT

; 1639 : {

$LN50:
	sub	rsp, 40					; 00000028H
$LL4@SetErrorSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN48@SetErrorSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@SetErrorSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetErrorSt
$LN18@SetErrorSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetErrorSt
$LN48@SetErrorSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1643 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetErrorState@@YAXXZ ENDP				; SetErrorState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z
_TEXT	SEGMENT
$T1 = 32
info$2 = 96
info$ = 96
status$ = 104
currentSpeed$ = 112
averageSpeed$ = 120
totalNumGeneratedTripcodes$ = 128
numDiscardedTripcodes$ = 136
child_process$ = 144
?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z PROC ; UpdateOpenCLDeviceStatus_ChildProcess, COMDAT

; 559  : {

$LN187:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	mov	rbx, rdx
	movaps	xmm7, xmm2
	movaps	xmm6, xmm3
	mov	rdi, rcx
$LL8@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN7@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN22@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL8@UpdateOpen
$LN22@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL8@UpdateOpen
$LN7@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 561  : 	ASSERT(info->runChildProcess);

	cmp	DWORD PTR [rdi+1080], 0
	jne	$LN3@UpdateOpen
$LL28@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN27@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN42@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL28@UpdateOpen
$LN42@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL28@UpdateOpen
$LN27@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 561  : 	ASSERT(info->runChildProcess);

	test	eax, eax
	jne	$LN3@UpdateOpen
	npad	5
$LL72@UpdateOpen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN71@UpdateOpen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN86@UpdateOpen

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL72@UpdateOpen
$LN86@UpdateOpen:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL72@UpdateOpen
$LN71@UpdateOpen:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 561  : 	ASSERT(info->runChildProcess);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 561  : 	ASSERT(info->runChildProcess);

	je	SHORT $LN2@UpdateOpen
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856987
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856986
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN113@UpdateOpen
$LN2@UpdateOpen:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856985
	lea	rcx, OFFSET FLAT:$SG4294856984
	mov	r8d, 561				; 00000231H
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$2[rsp+4], 1
	mov	DWORD PTR info$2[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$2[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN113@UpdateOpen:

; 561  : 	ASSERT(info->runChildProcess);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN3@UpdateOpen:

; 562  : 	strcpy(info->status, status);

	mov	rcx, rdi
	sub	rcx, rbx
	npad	2
$LL6@UpdateOpen:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rcx+rbx+15], al
	test	al, al
	jne	SHORT $LL6@UpdateOpen

; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;

	mov	eax, DWORD PTR numDiscardedTripcodes$[rsp]
	movsdx	xmm0, QWORD PTR totalNumGeneratedTripcodes$[rsp]
	movsdx	QWORD PTR [rdi+1048], xmm7
	mov	DWORD PTR [rdi+1072], eax

; 567  : 	info->child_process = child_process;

	mov	rax, QWORD PTR child_process$[rsp]
	movsdx	QWORD PTR [rdi+1056], xmm6
	movsdx	QWORD PTR [rdi+1064], xmm0
	mov	QWORD PTR [rdi+1088], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T1[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	QWORD PTR [rdi+1096], rdx

; 570  : }

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 570  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN186@UpdateOpen:
?UpdateOpenCLDeviceStatus_ChildProcess@@YAXPEAUOpenCLDeviceSearchThreadInfo@@PEADNNNIPEAVchild@windows@process@boost@@@Z ENDP ; UpdateOpenCLDeviceStatus_ChildProcess
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessInvalidTripcodePair@@YAXPEAE0@Z
_TEXT	SEGMENT
tripcode$ = 48
key$ = 56
?ProcessInvalidTripcodePair@@YAXPEAE0@Z PROC		; ProcessInvalidTripcodePair, COMDAT

; 1509 : {

$LN247:
	push	r14
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	rbp, rdx
	npad	10
$LL29@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, 0 ; process_tripcode_pair_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN28@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN43@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL29@ProcessInv
$LN43@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL29@ProcessInv
$LN28@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {

	xor	r14d, r14d
	cmp	DWORD PTR ?options@@3UOptions@@A+12, r14d
	je	$LN25@ProcessInv
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	jne	$LN25@ProcessInv
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN25@ProcessInv
	npad	3
$LL49@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN48@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN63@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL49@ProcessInv
$LN63@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL49@ProcessInv
$LN48@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {

	test	eax, eax
	jne	$LN25@ProcessInv

; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856640
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+72], rdi
	call	fprintf

; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	cmp	DWORD PTR ?lenTripcode@@3HA, r14d	; lenTripcode
	mov	edi, r14d
	jle	SHORT $LN22@ProcessInv
	mov	rbx, rsi
$LL24@ProcessInv:

; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);

	movzx	r8d, BYTE PTR [rbx]
	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856639
	call	fprintf
	inc	edi
	lea	rbx, QWORD PTR [rbx+1]
	cmp	edi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL24@ProcessInv
$LN22@ProcessInv:

; 1519 : 		fprintf(tripcodeFile, "  ");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856638
	call	fprintf

; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN19@ProcessInv
	npad	9
$LL21@ProcessInv:

; 1521 : 			fprintf(tripcodeFile, " ");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856637
	call	fprintf
	inc	ebx
	cmp	ebx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL21@ProcessInv
$LN19@ProcessInv:

; 1522 : 		fprintf(tripcodeFile, " (");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856636
	call	fprintf

; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN16@ProcessInv
	mov	rdi, rbp
	npad	2
$LL18@ProcessInv:

; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);

	movzx	r8d, BYTE PTR [rdi]
	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856635
	call	fprintf

; 1525 : 			if (i + 1 < lenTripcodeKey)

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	inc	ebx
	cmp	ebx, eax
	jge	SHORT $LN17@ProcessInv

; 1526 : 				fprintf(tripcodeFile, " ");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856634
	call	fprintf
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
$LN17@ProcessInv:

; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	rdi
	cmp	ebx, eax
	jl	SHORT $LL18@ProcessInv
$LN16@ProcessInv:

; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856633
	call	fprintf

; 1529 : 		fflush(tripcodeFile);

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	call	fflush

; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");

	lea	rcx, OFFSET FLAT:$SG4294856632
	call	printf
	mov	rdi, QWORD PTR [rsp+72]

; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcode@@3HA, ebx	; lenTripcode
	jle	SHORT $LN12@ProcessInv
	npad	2
$LL14@ProcessInv:

; 1537 : 			printf("%c", tripcode[i]);

	movzx	edx, BYTE PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG4294856631
	call	printf
	inc	ebx
	lea	rsi, QWORD PTR [rsi+1]
	cmp	ebx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL14@ProcessInv
$LN12@ProcessInv:

; 1538 : 		printf("  ");

	lea	rcx, OFFSET FLAT:$SG4294856630
	call	printf

; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN9@ProcessInv
$LL11@ProcessInv:

; 1540 : 			printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856629
	call	printf
	inc	ebx
	cmp	ebx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL11@ProcessInv
$LN9@ProcessInv:

; 1541 : 		printf(" (");

	lea	rcx, OFFSET FLAT:$SG4294856628
	call	printf

; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN6@ProcessInv
	npad	15
$LL8@ProcessInv:

; 1543 : 			printf("%02X", key[i]);

	movzx	edx, BYTE PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG4294856627
	call	printf

; 1544 : 			if (i + 1 < lenTripcodeKey)

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	inc	ebx
	cmp	ebx, eax
	jge	SHORT $LN7@ProcessInv

; 1545 : 				printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856626
	call	printf
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
$LN7@ProcessInv:

; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	rbp
	cmp	ebx, eax
	jl	SHORT $LL8@ProcessInv
$LN6@ProcessInv:

; 1546 : 		}
; 1547 : 		printf(")");

	lea	rcx, OFFSET FLAT:$SG4294856625
	call	printf

; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;

	mov	edx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	mov	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	edx, 2
	lea	edx, DWORD PTR [rcx+rdx*4]

; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {

	cmp	edx, 79					; 0000004fH
	jge	SHORT $LN2@ProcessInv

; 1546 : 		}
; 1547 : 		printf(")");

	mov	ebx, 79					; 0000004fH
	sub	ebx, edx
	npad	1
$LL4@ProcessInv:

; 1551 : 			printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856624
	call	printf
	dec	rbx
	jne	SHORT $LL4@ProcessInv
$LN2@ProcessInv:

; 1552 : 		}
; 1553 : 		printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856623
	call	printf

; 1554 : 		fflush(stdout);

	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	mov	rbx, QWORD PTR [rsp+48]
$LN25@ProcessInv:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, r14d ; process_tripcode_pair_spinlock
$LL115@ProcessInv:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN114@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN129@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL115@ProcessInv
$LN129@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL115@ProcessInv
$LN114@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1559 : 	++numDiscardedTripcodes;

	inc	DWORD PTR ?numDiscardedTripcodes@@3IA	; numDiscardedTripcodes

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	cmp	DWORD PTR ?options@@3UOptions@@A+12, r14d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	je	SHORT $LN1@ProcessInv
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	jne	SHORT $LN1@ProcessInv
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN1@ProcessInv
	npad	4
$LL159@ProcessInv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN158@ProcessInv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN173@ProcessInv

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL159@ProcessInv
$LN173@ProcessInv:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL159@ProcessInv
$LN158@ProcessInv:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())

	test	eax, eax
	jne	SHORT $LN1@ProcessInv

; 1564 : }

	add	rsp, 32					; 00000020H
	pop	r14

; 1563 : 		PrintStatus();

	jmp	?PrintStatus@@YAXXZ			; PrintStatus
$LN1@ProcessInv:

; 1564 : }

	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?ProcessInvalidTripcodePair@@YAXPEAE0@Z ENDP		; ProcessInvalidTripcodePair
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ProcessValidTripcodePair@@YAXPEAE0@Z
_TEXT	SEGMENT
tripcode$ = 48
key$ = 56
?ProcessValidTripcodePair@@YAXPEAE0@Z PROC		; ProcessValidTripcodePair, COMDAT

; 1430 : {

$LN442:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	xor	r14d, r14d
	mov	rsi, rdx
	add	eax, -10				; fffffff6H
	mov	rbx, rcx
	test	eax, -3					; fffffffdH
	je	$LN45@ProcessVal
	npad	3
$LL51@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN50@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN65@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL51@ProcessVal
$LN65@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL51@ProcessVal
$LN50@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);

	test	eax, eax
	jne	$LN45@ProcessVal
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	je	SHORT $LN44@ProcessVal
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856675
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856674
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN43@ProcessVal
$LN44@ProcessVal:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856673
	lea	rcx, OFFSET FLAT:$SG4294856672
	mov	r8d, 1431				; 00000597H
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN43@ProcessVal:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN45@ProcessVal:
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	add	eax, -10				; fffffff6H
	test	eax, -3					; fffffffdH
	je	$LL137@ProcessVal
	npad	2
$LL95@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN94@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN109@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL95@ProcessVal
$LN109@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL95@ProcessVal
$LN94@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);

	test	eax, eax
	jne	$LL137@ProcessVal
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	je	SHORT $LN41@ProcessVal
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856671
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856670
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN40@ProcessVal
$LN41@ProcessVal:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856669
	lea	rcx, OFFSET FLAT:$SG4294856668
	mov	r8d, 1432				; 00000598H
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN40@ProcessVal:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	6
$LL137@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, 0 ; process_tripcode_pair_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN136@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN151@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL137@ProcessVal
$LN151@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL137@ProcessVal
$LN136@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1435 : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	mov	QWORD PTR [rsp+56], rdi
	jne	$LN345@ProcessVal

; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856667
	mov	QWORD PTR [rsp+48], rbp
	call	fprintf

; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	cmp	DWORD PTR ?lenTripcode@@3HA, r14d	; lenTripcode
	mov	ebp, r14d
	jle	SHORT $LN36@ProcessVal
	mov	rdi, rbx
	npad	4
$LL38@ProcessVal:

; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);

	movzx	r8d, BYTE PTR [rdi]
	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856666
	call	fprintf
	inc	ebp
	lea	rdi, QWORD PTR [rdi+1]
	cmp	ebp, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL38@ProcessVal
$LN36@ProcessVal:

; 1443 : 		fprintf(tripcodeFile, " #");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856665
	call	fprintf

; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, r14d	; lenTripcodeKey
	mov	ebp, r14d
	jle	SHORT $LN33@ProcessVal
	mov	rdi, rsi
	npad	9
$LL35@ProcessVal:

; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);

	movzx	r8d, BYTE PTR [rdi]
	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856664
	call	fprintf
	inc	ebp
	lea	rdi, QWORD PTR [rdi+1]
	cmp	ebp, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL35@ProcessVal
$LN33@ProcessVal:

; 1446 : 		fprintf(tripcodeFile, " (");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856663
	call	fprintf

; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	cmp	DWORD PTR ?lenTripcodeKey@@3HA, r14d	; lenTripcodeKey
	mov	edi, r14d
	jle	SHORT $LN30@ProcessVal
	mov	rbp, rsi
	npad	9
$LL32@ProcessVal:

; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);

	movzx	r8d, BYTE PTR [rbp]
	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856662
	call	fprintf

; 1449 : 			if (i + 1 < lenTripcodeKey)

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	inc	edi
	cmp	edi, eax
	jge	SHORT $LN31@ProcessVal

; 1450 : 				fprintf(tripcodeFile, " ");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856661
	call	fprintf
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
$LN31@ProcessVal:

; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	rbp
	cmp	edi, eax
	jl	SHORT $LL32@ProcessVal
$LN30@ProcessVal:

; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	lea	rdx, OFFSET FLAT:$SG4294856660
	call	fprintf

; 1453 : 		fflush(tripcodeFile);

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	call	fflush

; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	mov	rbp, QWORD PTR [rsp+48]
	jne	$LN345@ProcessVal
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN28@ProcessVal
$LL157@ProcessVal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN156@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN171@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL157@ProcessVal
$LN171@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL157@ProcessVal
$LN156@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {

	test	eax, eax
	jne	$LN28@ProcessVal

; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");

	lea	rcx, OFFSET FLAT:$SG4294856659
	call	printf

; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	cmp	DWORD PTR ?lenTripcode@@3HA, r14d	; lenTripcode
	mov	edi, r14d
	jle	SHORT $LN25@ProcessVal
	npad	14
$LL27@ProcessVal:

; 1463 : 			printf("%c", tripcode[i]);

	movzx	edx, BYTE PTR [rbx]
	lea	rcx, OFFSET FLAT:$SG4294856658
	call	printf
	inc	edi
	lea	rbx, QWORD PTR [rbx+1]
	cmp	edi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL27@ProcessVal
$LN25@ProcessVal:

; 1464 : 		printf(" #");

	lea	rcx, OFFSET FLAT:$SG4294856657
	call	printf

; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN22@ProcessVal
	mov	rdi, rsi
	npad	9
$LL24@ProcessVal:

; 1466 : 			printf("%c", key[i]);

	movzx	edx, BYTE PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG4294856656
	call	printf
	inc	ebx
	lea	rdi, QWORD PTR [rdi+1]
	cmp	ebx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL24@ProcessVal
$LN22@ProcessVal:

; 1467 : 		printf(" (");

	lea	rcx, OFFSET FLAT:$SG4294856655
	call	printf

; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN19@ProcessVal
	npad	12
$LL21@ProcessVal:

; 1469 : 			printf("%02X", key[i]);

	movzx	edx, BYTE PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG4294856654
	call	printf

; 1470 : 			if (i + 1 < lenTripcodeKey)

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	inc	ebx
	cmp	ebx, eax
	jge	SHORT $LN20@ProcessVal

; 1471 : 				printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856653
	call	printf
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
$LN20@ProcessVal:

; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	rsi
	cmp	ebx, eax
	jl	SHORT $LL21@ProcessVal
$LN19@ProcessVal:

; 1472 : 		}
; 1473 : 		printf(")");

	lea	rcx, OFFSET FLAT:$SG4294856652
	call	printf

; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;

	mov	edx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	mov	ecx, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	add	edx, 2
	lea	edx, DWORD PTR [rcx+rdx*4]

; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {

	cmp	edx, 79					; 0000004fH
	jge	SHORT $LN15@ProcessVal

; 1472 : 		}
; 1473 : 		printf(")");

	mov	ebx, 79					; 0000004fH
	sub	ebx, edx
	npad	2
$LL17@ProcessVal:

; 1477 : 			printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856651
	call	printf
	dec	rbx
	jne	SHORT $LL17@ProcessVal
$LN15@ProcessVal:

; 1478 : 		}
; 1479 : 		printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856650
	jmp	$LN440@ProcessVal
$LN28@ProcessVal:

; 1480 : 	} else if (options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	je	$LN13@ProcessVal
$LN345@ProcessVal:

; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);

	mov	edx, 129				; 00000081H
	lea	rcx, OFFSET FLAT:$SG4294856649
	lea	r8d, QWORD PTR [rdx+30]
	call	printf

; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)

	cmp	DWORD PTR ?lenTripcode@@3HA, r14d	; lenTripcode
	mov	edi, r14d
	jle	SHORT $LN10@ProcessVal
	npad	5
$LL12@ProcessVal:

; 1483 : 			printf("%c", tripcode[i]);

	movzx	edx, BYTE PTR [rbx]
	lea	rcx, OFFSET FLAT:$SG4294856648
	call	printf
	inc	edi
	lea	rbx, QWORD PTR [rbx+1]
	cmp	edi, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	jl	SHORT $LL12@ProcessVal
$LN10@ProcessVal:

; 1484 : 		printf(",#");

	lea	rcx, OFFSET FLAT:$SG4294856647
	call	printf

; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN7@ProcessVal
	mov	rdi, rsi
	npad	9
$LL9@ProcessVal:

; 1486 : 			printf("%c", key[i]);

	movzx	edx, BYTE PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG4294856646
	call	printf
	inc	ebx
	lea	rdi, QWORD PTR [rdi+1]
	cmp	ebx, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	jl	SHORT $LL9@ProcessVal
$LN7@ProcessVal:

; 1487 : 		printf(",(");

	lea	rcx, OFFSET FLAT:$SG4294856645
	call	printf

; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	ebx, r14d
	cmp	DWORD PTR ?lenTripcodeKey@@3HA, ebx	; lenTripcodeKey
	jle	SHORT $LN4@ProcessVal
	npad	12
$LL6@ProcessVal:

; 1489 : 			printf("%02X", key[i]);

	movzx	edx, BYTE PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG4294856644
	call	printf

; 1490 : 			if (i + 1 < lenTripcodeKey)

	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	inc	ebx
	cmp	ebx, eax
	jge	SHORT $LN5@ProcessVal

; 1491 : 				printf(" ");

	lea	rcx, OFFSET FLAT:$SG4294856643
	call	printf
	mov	eax, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
$LN5@ProcessVal:

; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	rsi
	cmp	ebx, eax
	jl	SHORT $LL6@ProcessVal
$LN4@ProcessVal:

; 1492 : 		}
; 1493 : 		printf(")\n");

	lea	rcx, OFFSET FLAT:$SG4294856642
$LN440@ProcessVal:
	call	printf
$LN13@ProcessVal:

; 1494 : 	}
; 1495 : 	fflush(stdout);

	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	mov	rdi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, r14d ; process_tripcode_pair_spinlock
	npad	6
$LL223@ProcessVal:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN222@ProcessVal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN237@ProcessVal

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL223@ProcessVal
$LN237@ProcessVal:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL223@ProcessVal
$LN222@ProcessVal:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1499 : 	++numValidTripcodes;

	inc	DWORD PTR ?numValidTripcodes@@3IA	; numValidTripcodes

; 1502 : 	if (!options.redirection)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1502 : 	if (!options.redirection)

	jne	SHORT $LN1@ProcessVal

; 1503 : 		PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus

; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	jne	SHORT $LN1@ProcessVal
	cmp	DWORD PTR ?options@@3UOptions@@A+8, r14d
	je	SHORT $LN1@ProcessVal

; 1505 : 		printf("\a");

	lea	rcx, OFFSET FLAT:$SG4294856641
	call	printf
$LN1@ProcessVal:

; 1506 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN441@ProcessVal:
?ProcessValidTripcodePair@@YAXPEAE0@Z ENDP		; ProcessValidTripcodePair
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$$V@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$tuple@$$$V@std@@QEAA@XZ PROC			; std::tuple<>::tuple<>, COMDAT

; 136  : 		{	// default construct
; 137  : 		}

	mov	rax, rcx
	ret	0
??0?$tuple@$$$V@std@@QEAA@XZ ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$$V@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$tuple@$$$V@std@@QEAA@AEBV01@@Z PROC		; std::tuple<>::tuple<>, COMDAT

; 145  : 		{	// copy construct
; 146  : 		}

	mov	rax, rcx
	ret	0
??0?$tuple@$$$V@std@@QEAA@AEBV01@@Z ENDP		; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
_Res$ = 48
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 31   : 	{	// throw exception on failure

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx

; 32   : 	if (_Res != _Thrd_success)

	test	ecx, ecx
	je	SHORT $LN4@Check_C_re

; 33   : 		_Throw_C_error(_Res);

	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN4@Check_C_re:

; 34   : 	return (_Res);

	mov	eax, ebx

; 35   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z
_TEXT	SEGMENT
$T1 = 32
_Thr$ = 64
?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z PROC		; std::_Thrd_detachX, COMDAT

; 52   : 	{	// throw exception on failure

$LN8:
	push	rbx
	sub	rsp, 48					; 00000030H

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	movaps	xmm0, XMMWORD PTR [rcx]
	lea	rcx, QWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	call	_Thrd_detach
	mov	ebx, eax

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN3@Thrd_detac

; 33   : 		_Throw_C_error(_Res);

	mov	ecx, eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	mov	eax, ebx
$LN3@Thrd_detac:

; 54   : 	}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?_Thrd_detachX@std@@YAHU_Thrd_imp_t@@@Z ENDP		; std::_Thrd_detachX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??1thread@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1thread@std@@QEAA@XZ PROC				; std::thread::~thread, COMDAT

; 54   : 		{	// clean up

$LN9:
	sub	rsp, 40					; 00000028H

; 58   : 
; 59   : 	thread(thread&& _Other) _NOEXCEPT
; 60   : 		: _Thr(_Other._Thr)
; 61   : 		{	// move from _Other
; 62   : 		_Thr_set_null(_Other._Thr);
; 63   : 		}
; 64   : 
; 65   : 	thread& operator=(thread&& _Other) _NOEXCEPT
; 66   : 		{	// move from _Other
; 67   : 		return (_Move_thread(_Other));
; 68   : 		}
; 69   : 
; 70   : 	thread(const thread&) = delete;
; 71   : 	thread& operator=(const thread&) = delete;
; 72   : 
; 73   : 	void swap(thread& _Other) _NOEXCEPT
; 74   : 		{	// swap with _Other
; 75   : 		_STD swap(_Thr, _Other._Thr);
; 76   : 		}
; 77   : 
; 78   : 	bool joinable() const _NOEXCEPT
; 79   : 		{	// return true if this thread can be joined
; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rcx+8], 0

; 55   : 		if (joinable())

	jne	SHORT $LN7@thread

; 57   : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN7@thread:

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
	int	3
$LN6@thread:
??1thread@std@@QEAA@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?joinable@thread@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?joinable@thread@std@@QEBA_NXZ PROC			; std::thread::joinable, COMDAT

; 80   : 		return (!_Thr_is_null(_Thr));

	xor	eax, eax
	cmp	DWORD PTR [rcx+8], eax
	setne	al

; 81   : 		}

	ret	0
?joinable@thread@std@@QEBA_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?detach@thread@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?detach@thread@std@@QEAAXXZ PROC			; std::thread::detach, COMDAT

; 86   : 		{	// detach thread

$LN13:
	push	rbx
	sub	rsp, 48					; 00000030H

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rcx+8], 0

; 86   : 		{	// detach thread

	mov	rbx, rcx

; 87   : 		if (!joinable())

	jne	SHORT $LN1@detach

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	ecx, 1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN1@detach:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	movups	xmm0, XMMWORD PTR [rbx]
	lea	rcx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	_Thrd_detach

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN11@detach

; 33   : 		_Throw_C_error(_Res);

	mov	ecx, eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN11@detach:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	DWORD PTR [rbx+8], 0

; 91   : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?detach@thread@std@@QEAAXXZ ENDP			; std::thread::detach
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ?native_handle@thread@std@@QEAAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?native_handle@thread@std@@QEAAPEAXXZ PROC		; std::thread::native_handle, COMDAT

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR [rcx]

; 103  : 		}

	ret	0
?native_handle@thread@std@@QEAAPEAXXZ ENDP		; std::thread::native_handle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	sub	rsp, 40					; 00000028H
	call	?generic_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::generic_category
	mov	QWORD PTR posix_category, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	sub	rsp, 40					; 00000028H
	call	?generic_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::generic_category
	mov	QWORD PTR errno_ecat, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	sub	rsp, 40					; 00000028H
	call	?system_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::system_category
	mov	QWORD PTR native_ecat, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Enum_generated_tripcodes_spinlock@@YAXXZ
text$di	SEGMENT
??__Enum_generated_tripcodes_spinlock@@YAXXZ PROC	; `dynamic initializer for 'num_generated_tripcodes_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, eax ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 152  : spinlock num_generated_tripcodes_spinlock;

	ret	0
??__Enum_generated_tripcodes_spinlock@@YAXXZ ENDP	; `dynamic initializer for 'num_generated_tripcodes_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eprocess_tripcode_pair_spinlock@@YAXXZ
text$di	SEGMENT
??__Eprocess_tripcode_pair_spinlock@@YAXXZ PROC		; `dynamic initializer for 'process_tripcode_pair_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?process_tripcode_pair_spinlock@@3Vspinlock@@A, eax ; process_tripcode_pair_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 153  : spinlock process_tripcode_pair_spinlock;

	ret	0
??__Eprocess_tripcode_pair_spinlock@@YAXXZ ENDP		; `dynamic initializer for 'process_tripcode_pair_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Ecurrent_state_spinlock@@YAXXZ
text$di	SEGMENT
??__Ecurrent_state_spinlock@@YAXXZ PROC			; `dynamic initializer for 'current_state_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, eax ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 154  : spinlock current_state_spinlock;

	ret	0
??__Ecurrent_state_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'current_state_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ
text$di	SEGMENT
??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ PROC ; `dynamic initializer for 'cuda_device_search_thread_info_array_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, eax ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 155  : spinlock cuda_device_search_thread_info_array_spinlock;

	ret	0
??__Ecuda_device_search_thread_info_array_spinlock@@YAXXZ ENDP ; `dynamic initializer for 'cuda_device_search_thread_info_array_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ
text$di	SEGMENT
??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ PROC ; `dynamic initializer for 'opencl_device_search_thread_info_array_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, eax ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 156  : spinlock opencl_device_search_thread_info_array_spinlock;

	ret	0
??__Eopencl_device_search_thread_info_array_spinlock@@YAXXZ ENDP ; `dynamic initializer for 'opencl_device_search_thread_info_array_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Esystem_command_spinlock@@YAXXZ
text$di	SEGMENT
??__Esystem_command_spinlock@@YAXXZ PROC		; `dynamic initializer for 'system_command_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?system_command_spinlock@@3Vspinlock@@A, eax ; system_command_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 157  : spinlock system_command_spinlock;

	ret	0
??__Esystem_command_spinlock@@YAXXZ ENDP		; `dynamic initializer for 'system_command_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ??__Eboost_process_spinlock@@YAXXZ
text$di	SEGMENT
??__Eboost_process_spinlock@@YAXXZ PROC			; `dynamic initializer for 'boost_process_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR ?boost_process_spinlock@@3Vspinlock@@A, eax ; boost_process_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 158  : spinlock boost_process_spinlock;

	ret	0
??__Eboost_process_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'boost_process_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ReleaseResources@@YAXXZ
_TEXT	SEGMENT
?ReleaseResources@@YAXXZ PROC				; ReleaseResources, COMDAT

; 234  : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);

	mov	rcx, QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA ; expandedPatternArray
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN6@ReleaseRes
	call	free
	mov	QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA, rbx ; expandedPatternArray
$LN6@ReleaseRes:

; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);

	mov	rcx, QWORD PTR ?tripcodeChunkArray@@3PEAIEA ; tripcodeChunkArray
	test	rcx, rcx
	je	SHORT $LN5@ReleaseRes
	call	free
	mov	QWORD PTR ?tripcodeChunkArray@@3PEAIEA, rbx ; tripcodeChunkArray
$LN5@ReleaseRes:

; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);

	mov	rcx, QWORD PTR ?regexPatternArray@@3PEAURegexPattern@@EA ; regexPatternArray
	test	rcx, rcx
	je	SHORT $LN4@ReleaseRes
	call	free
	mov	QWORD PTR ?regexPatternArray@@3PEAURegexPattern@@EA, rbx ; regexPatternArray
$LN4@ReleaseRes:

; 238  : 	if (tripcodeFile) {

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	test	rcx, rcx
	je	SHORT $LN2@ReleaseRes

; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);

	call	fclose
	mov	QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA, rbx ; tripcodeFile
$LN2@ReleaseRes:

; 240  : 	}
; 241  : 	if (eventForTerminating) {

	mov	rcx, QWORD PTR ?eventForTerminating@@3PEAXEA ; eventForTerminating
	test	rcx, rcx
	je	SHORT $LN1@ReleaseRes

; 242  : 		CloseHandle(eventForTerminating);

	call	QWORD PTR __imp_CloseHandle

; 243  : 		eventForTerminating = NULL;

	mov	QWORD PTR ?eventForTerminating@@3PEAXEA, rbx ; eventForTerminating
$LN1@ReleaseRes:

; 244  : 	}
; 245  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ReleaseResources@@YAXXZ ENDP				; ReleaseResources
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?hide_cursor@@YAXXZ
_TEXT	SEGMENT
info$ = 48
?hide_cursor@@YAXXZ PROC				; hide_cursor, COMDAT

; 278  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	mov	ecx, -11				; fffffff5H
	mov	QWORD PTR info$[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo

; 284  : }

	add	rsp, 40					; 00000028H
	ret	0
?hide_cursor@@YAXXZ ENDP				; hide_cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CreateKey8AndKey9@@YAXPEAE@Z
_TEXT	SEGMENT
randomValue$1 = 32
randomValue$2 = 36
randomValue$3 = 40
randomValue$4 = 44
info$5 = 48
key$ = 96
randomValue$6 = 104
randomValue$7 = 112
randomValue$8 = 120
?CreateKey8AndKey9@@YAXPEAE@Z PROC			; CreateKey8AndKey9, COMDAT

; 308  : {

$LN146:
	push	rbx
	push	rdi
	sub	rsp, 72					; 00000048H

; 309  : 	ASSERT(lenTripcode == 10);

	xor	ebx, ebx
	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode
	mov	rdi, rcx
	je	$LN12@CreateKey8
	npad	7
$LL28@CreateKey8:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	setb	al
	movzx	ecx, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\atomic

; 204  : 	return _ATOMIC_FLAG_TEST_AND_SET(&_My_flag, _Order);

	test	al, al
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	je	SHORT $LN27@CreateKey8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN42@CreateKey8

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL28@CreateKey8
$LN42@CreateKey8:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL28@CreateKey8
$LN27@CreateKey8:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 309  : 	ASSERT(lenTripcode == 10);

	test	eax, eax
	jne	$LN12@CreateKey8
	npad	1
$LL72@CreateKey8:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN71@CreateKey8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN86@CreateKey8

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL72@CreateKey8
$LN86@CreateKey8:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL72@CreateKey8
$LN71@CreateKey8:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 309  : 	ASSERT(lenTripcode == 10);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 309  : 	ASSERT(lenTripcode == 10);

	je	SHORT $LN11@CreateKey8
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294857012
	mov	r8d, 14
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294857011
	mov	edx, 14
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN113@CreateKey8
$LN11@CreateKey8:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857010
	lea	rcx, OFFSET FLAT:$SG4294857009
	mov	r8d, 309				; 00000135H
	call	printf
	call	_getch

; 230  : 	return (unsigned char)(randomValue & 0x000000ff);
; 231  : }
; 232  : 
; 233  : void ReleaseResources()
; 234  : {
; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);
; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);
; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);
; 238  : 	if (tripcodeFile) {
; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);
; 240  : 	}
; 241  : 	if (eventForTerminating) {
; 242  : 		CloseHandle(eventForTerminating);
; 243  : 		eventForTerminating = NULL;
; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;
; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);
; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$5[rsp+4], 1
	mov	DWORD PTR info$5[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$5[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN113@CreateKey8:

; 309  : 	ASSERT(lenTripcode == 10);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN12@CreateKey8:

; 310  : 	if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, ebx
	je	SHORT $LN9@CreateKey8

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$6[rsp]
	call	rand_s

; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];

	movzx	eax, BYTE PTR randomValue$6[rsp]
	lea	rbx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rax+rbx]

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$7[rsp]

; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];

	mov	BYTE PTR [rdi+8], al

; 229  : 	rand_s(&randomValue);

	call	rand_s

; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];

	movzx	eax, BYTE PTR randomValue$7[rsp]
	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rax+rbx]
	mov	BYTE PTR [rdi+9], al

; 330  : 		}
; 331  : 	}
; 332  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
$LN9@CreateKey8:
	mov	QWORD PTR [rsp+64], rsi

; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;

	mov	eax, ebx
	mov	rdx, rdi
	mov	esi, 2147483535				; 7fffff8fH
	mov	r8d, 8
$LL7@CreateKey8:

; 316  : 			if (!isSecondByte) {

	test	eax, eax
	jne	SHORT $LN4@CreateKey8

; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);

	movzx	ecx, BYTE PTR [rdx]
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 30
	ja	SHORT $LN139@CreateKey8
	movzx	eax, al
	bt	esi, eax
	jb	SHORT $LN17@CreateKey8
$LN139@CreateKey8:
	add	cl, 32					; 00000020H
	cmp	cl, 10
	ja	SHORT $LN4@CreateKey8
$LN17@CreateKey8:
	mov	eax, 1
	jmp	SHORT $LN6@CreateKey8
$LN4@CreateKey8:

; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;

	mov	eax, ebx
$LN6@CreateKey8:

; 315  : 		for (int32_t i = 0; i < 8; ++i) {

	inc	rdx
	dec	r8
	jne	SHORT $LL7@CreateKey8

; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {

	test	eax, eax
	je	SHORT $LN2@CreateKey8

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$8[rsp]
	call	rand_s

; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];

	movzx	eax, BYTE PTR randomValue$8[rsp]
	lea	rbx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[rax+rbx]

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$1[rsp]

; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];

	mov	BYTE PTR [rdi+8], al

; 229  : 	rand_s(&randomValue);

	call	rand_s

; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];

	movzx	eax, BYTE PTR randomValue$1[rsp]
	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rax+rbx]
	mov	rsi, QWORD PTR [rsp+64]
	mov	BYTE PTR [rdi+9], al

; 330  : 		}
; 331  : 	}
; 332  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
$LN2@CreateKey8:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$2[rsp]
	call	rand_s

; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];

	movzx	eax, BYTE PTR randomValue$2[rsp]
	lea	rbx, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR ?keyCharTable_FirstByte@@3PAEA[rax+rbx]
	mov	BYTE PTR [rdi+8], cl
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 30
	ja	SHORT $LN141@CreateKey8
	movzx	eax, al
	bt	esi, eax
	jb	SHORT $LN22@CreateKey8
$LN141@CreateKey8:
	add	cl, 32					; 00000020H
	cmp	cl, 10
	ja	SHORT $LN23@CreateKey8
$LN22@CreateKey8:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$3[rsp]
	call	rand_s

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	movzx	eax, BYTE PTR randomValue$3[rsp]
	mov	rsi, QWORD PTR [rsp+64]
	movzx	ecx, BYTE PTR ?keyCharTable_SecondByte@@3PAEA[rax+rbx]
	mov	BYTE PTR [rdi+9], cl

; 330  : 		}
; 331  : 	}
; 332  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
$LN23@CreateKey8:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$4[rsp]
	call	rand_s

; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];

	movzx	eax, BYTE PTR randomValue$4[rsp]
	mov	rsi, QWORD PTR [rsp+64]
	movzx	ecx, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rax+rbx]
	mov	BYTE PTR [rdi+9], cl

; 330  : 		}
; 331  : 	}
; 332  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
$LN145@CreateKey8:
?CreateKey8AndKey9@@YAXPEAE@Z ENDP			; CreateKey8AndKey9
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CreateCharacterTables@@YAXXZ
_TEXT	SEGMENT
randomValue$1 = 48
randomValue$2 = 48
randomValue$3 = 48
randomValue$4 = 48
randomValue$5 = 48
?CreateCharacterTables@@YAXXZ PROC			; CreateCharacterTables, COMDAT

; 412  : {

$LN495:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;

	xor	ebx, ebx

; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {

	mov	rbp, 3458737653095071744		; 2fffe79200000000H
	mov	rsi, 26534307954687			; 00001821ffffffffH
	cmp	DWORD PTR ?options@@3UOptions@@A+84, ebx
	mov	DWORD PTR ?numOneByte@@3HA, ebx		; numOneByte
	mov	DWORD PTR ?numSecondByte@@3HA, ebx	; numSecondByte
	mov	DWORD PTR ?numFirstByte@@3HA, ebx	; numFirstByte
	je	SHORT $LL112@CreateChar
$LL129@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$5[rsp]
	call	rand_s

; 428  : 		do {
; 429  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR randomValue$5[rsp]
	cmp	cl, 61					; 0000003dH
	ja	SHORT $LN123@CreateChar
	movzx	eax, cl
	bt	rbp, rax
	jb	SHORT $LN126@CreateChar
$LN123@CreateChar:

; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));

	lea	eax, DWORD PTR [rcx-63]
	cmp	al, 63					; 0000003fH
	ja	SHORT $LL129@CreateChar
$LN126@CreateChar:

; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rdx, rbx
	mov	r8, 5764634392349638655			; 5000186fffffffffH
	lea	rdi, OFFSET FLAT:__ImageBase
	npad	5
$LL243@CreateChar:

; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl

; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))

	cmp	cl, 33					; 00000021H
	je	SHORT $LN472@CreateChar
$LL244@CreateChar:
	cmp	cl, 62					; 0000003eH
	ja	SHORT $LN369@CreateChar
	bt	r8, rcx
	jb	SHORT $LN248@CreateChar
$LN369@CreateChar:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN472@CreateChar
$LN248@CreateChar:

; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	cmp	cl, 33					; 00000021H
	jne	SHORT $LL244@CreateChar
$LN472@CreateChar:

; 435  : 			keyCharTable_OneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_OneByte@@3PAEA[rdx+rdi], cl
	inc	rdx
	cmp	rdx, 512				; 00000200H
	jl	SHORT $LL243@CreateChar

; 436  : 		}

	jmp	SHORT $LN103@CreateChar
$LL112@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$4[rsp]
	call	rand_s

; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR randomValue$4[rsp]
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN371@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LN106@CreateChar
$LN371@CreateChar:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN109@CreateChar
$LN106@CreateChar:

; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));

	lea	eax, DWORD PTR [rcx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL112@CreateChar
$LN109@CreateChar:

; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rdx, rbx
	lea	rdi, OFFSET FLAT:__ImageBase
$LL251@CreateChar:

; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LL251@CreateChar
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN373@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LL251@CreateChar
$LN373@CreateChar:
	cmp	cl, 224					; 000000e0H

; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	jae	SHORT $LL251@CreateChar

; 445  : 			keyCharTable_OneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_OneByte@@3PAEA[rdx+rdi], cl
	inc	rdx
	cmp	rdx, 512				; 00000200H
	jl	SHORT $LL251@CreateChar
$LN103@CreateChar:

; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+84, ebx
	je	SHORT $LN96@CreateChar

; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rcx, rbx
	npad	1
$LL259@CreateChar:

; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];

	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rcx+rdi]
	inc	rcx
	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[rcx+rdi-1], al

; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[rcx+rdi-1], al

; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[rcx+rdi-1], al
	cmp	rcx, 512				; 00000200H
	jl	SHORT $LL259@CreateChar

; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	ecx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	mov	edx, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	r8d, DWORD PTR ?numOneByte@@3HA		; numOneByte
	npad	4
$LL92@CreateChar:
	cmp	ebx, 61					; 0000003dH
	ja	SHORT $LN85@CreateChar
	movsxd	rax, ebx
	bt	rbp, rax
	jb	SHORT $LN88@CreateChar
$LN85@CreateChar:

; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {

	lea	eax, DWORD PTR [rbx-63]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN91@CreateChar
$LN88@CreateChar:

; 458  : 				++numFirstByte;

	inc	ecx

; 459  : 				++numSecondByte;

	inc	edx

; 460  : 				++numOneByte;

	inc	r8d
$LN91@CreateChar:

; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ebx
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LL92@CreateChar

; 461  : 			}
; 462  : 		}

	jmp	$LN490@CreateChar
$LN96@CreateChar:

; 463  : 	} else if (options.useOneByteCharactersForKeys) {

	cmp	DWORD PTR ?options@@3UOptions@@A+48, ebx
	je	$LL70@CreateChar

; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rcx, rbx
	npad	5
$LL261@CreateChar:

; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];

	movzx	eax, BYTE PTR ?keyCharTable_OneByte@@3PAEA[rcx+rdi]
	inc	rcx
	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[rcx+rdi-1], al

; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[rcx+rdi-1], al

; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[rcx+rdi-1], al
	cmp	rcx, 512				; 00000200H
	jl	SHORT $LL261@CreateChar

; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	ecx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	mov	edx, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	r8d, DWORD PTR ?numOneByte@@3HA		; numOneByte
	mov	r9, 8650064134144			; 000007de00000000H
$LL79@CreateChar:
	cmp	ebx, 42					; 0000002aH
	ja	SHORT $LN376@CreateChar
	bt	r9, rbx
	jb	SHORT $LN75@CreateChar
$LN376@CreateChar:
	lea	eax, DWORD PTR [rbx-45]
	cmp	eax, 81					; 00000051H
	jbe	SHORT $LN75@CreateChar

; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {

	lea	eax, DWORD PTR [rbx-161]
	cmp	eax, 62					; 0000003eH
	ja	SHORT $LN78@CreateChar
$LN75@CreateChar:

; 471  : 				++numFirstByte;

	inc	ecx

; 472  : 				++numSecondByte;

	inc	edx

; 473  : 				++numOneByte;

	inc	r8d
$LN78@CreateChar:

; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ebx
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LL79@CreateChar

; 474  : 			}
; 475  : 		}

	jmp	$LN490@CreateChar
	npad	6
$LL70@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$3[rsp]
	call	rand_s

; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR randomValue$3[rsp]
	mov	edx, DWORD PTR ?options@@3UOptions@@A+88
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN63@CreateChar
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN378@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LN63@CreateChar
$LN378@CreateChar:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN67@CreateChar
$LN63@CreateChar:

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN140@CreateChar
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	SHORT $LN67@CreateChar
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN67@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	lea	eax, DWORD PTR [rcx+32]
	cmp	al, 10
	jmp	SHORT $LN491@CreateChar
$LN140@CreateChar:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN149@CreateChar
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN149@CreateChar
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN67@CreateChar
$LN149@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	lea	eax, DWORD PTR [rcx+32]
	cmp	al, 9
$LN491@CreateChar:
	ja	SHORT $LL70@CreateChar
$LN67@CreateChar:

; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	r8, rbx
$LL62@CreateChar:

; 482  : 			keyCharTable_FirstByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_FirstByte@@3PAEA[r8+rdi], cl
	npad	8
$LL59@CreateChar:

; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	lea	eax, DWORD PTR [rcx-127]
	cmp	al, 33					; 00000021H
	jbe	SHORT $LN52@CreateChar
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN382@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LN52@CreateChar
$LN382@CreateChar:
	cmp	cl, 224					; 000000e0H
	jb	SHORT $LN56@CreateChar
$LN52@CreateChar:

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	edx, edx
	je	SHORT $LN154@CreateChar
	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 3
	jbe	SHORT $LN56@CreateChar
	lea	eax, DWORD PTR [rcx+120]
	cmp	al, 23
	jbe	SHORT $LN56@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	lea	eax, DWORD PTR [rcx+32]
	cmp	al, 10
	jmp	SHORT $LN492@CreateChar
$LN154@CreateChar:
	cmp	cl, 152					; 00000098H
	je	SHORT $LN163@CreateChar
	cmp	cl, 136					; 00000088H
	jbe	SHORT $LN163@CreateChar
	cmp	cl, 160					; 000000a0H
	jb	SHORT $LN56@CreateChar
$LN163@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	lea	eax, DWORD PTR [rcx+32]
	cmp	al, 9
$LN492@CreateChar:
	ja	SHORT $LL59@CreateChar
$LN56@CreateChar:

; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	r8
	cmp	r8, 512					; 00000200H
	jl	SHORT $LL62@CreateChar
	npad	9
$LL51@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$2[rsp]
	call	rand_s

; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR randomValue$2[rsp]
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN48@CreateChar

; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));

	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL51@CreateChar
$LN48@CreateChar:

; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rdx, rbx
	npad	1
$LL263@CreateChar:

; 493  : 			keyCharTable_SecondByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_SecondByte@@3PAEA[rdx+rdi], cl
$LL264@CreateChar:

; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN266@CreateChar

; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));

	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL264@CreateChar
$LN266@CreateChar:

; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	rdx
	cmp	rdx, 512				; 00000200H
	jl	SHORT $LL263@CreateChar
$LL38@CreateChar:

; 229  : 	rand_s(&randomValue);

	lea	rcx, QWORD PTR randomValue$1[rsp]
	call	rand_s

; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();

	mov	ecx, DWORD PTR randomValue$1[rsp]
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN35@CreateChar

; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));

	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL38@CreateChar
$LN35@CreateChar:
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN389@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LN30@CreateChar
$LN389@CreateChar:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN33@CreateChar
$LN30@CreateChar:
	lea	eax, DWORD PTR [rcx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL38@CreateChar
$LN33@CreateChar:

; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	mov	rdx, rbx
	npad	4
$LL268@CreateChar:

; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;

	mov	BYTE PTR ?keyCharTable_SecondByteAndOneByte@@3PAEA[rdx+rdi], cl
$LL269@CreateChar:

; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;

	inc	cl
	lea	eax, DWORD PTR [rcx-64]
	cmp	al, 62					; 0000003eH
	jbe	SHORT $LN271@CreateChar

; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));

	lea	eax, DWORD PTR [rcx+127]
	cmp	al, 123					; 0000007bH
	ja	SHORT $LL269@CreateChar
$LN271@CreateChar:
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN392@CreateChar
	movzx	eax, cl
	bt	rsi, rax
	jb	SHORT $LN274@CreateChar
$LN392@CreateChar:
	cmp	cl, 127					; 0000007fH
	jb	SHORT $LN275@CreateChar
$LN274@CreateChar:
	lea	eax, DWORD PTR [rcx+95]
	cmp	al, 62					; 0000003eH
	ja	SHORT $LL269@CreateChar
$LN275@CreateChar:

; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {

	inc	rdx
	cmp	rdx, 512				; 00000200H
	jl	SHORT $LL268@CreateChar

; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {

	mov	r10d, DWORD PTR ?options@@3UOptions@@A+88
	mov	ecx, DWORD PTR ?numFirstByte@@3HA	; numFirstByte
	mov	edx, DWORD PTR ?numSecondByte@@3HA	; numSecondByte
	mov	r8d, DWORD PTR ?numOneByte@@3HA		; numOneByte
	mov	r9, 8650064134144			; 000007de00000000H
$LL17@CreateChar:
	cmp	ebx, 42					; 0000002aH
	ja	SHORT $LN394@CreateChar
	movsxd	rax, ebx
	bt	r9, rax
	jb	SHORT $LN13@CreateChar
$LN394@CreateChar:
	lea	eax, DWORD PTR [rbx-45]
	cmp	eax, 81					; 00000051H
	jbe	SHORT $LN13@CreateChar
	lea	eax, DWORD PTR [rbx-161]
	cmp	eax, 62					; 0000003eH
	jbe	SHORT $LN13@CreateChar

; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);
; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)
; 1024 : 		ListCUDADevices();
; 1025 : 	ListOpenCLDevices();
; 1026 : 	exit(0);
; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");
; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }
; 1571 : 
; 1572 : void AddToNumGeneratedTripcodesByCPU(uint32_t num)
; 1573 : {
; 1574 : 	num_generated_tripcodes_spinlock.lock();
; 1575 : 	numGeneratedTripcodes_CPU += num;
; 1576 : 	if (numGeneratedTripcodes_CPU >= 1000000) {
; 1577 : 		numGeneratedTripcodesByCPUInMillions += numGeneratedTripcodes_CPU / 1000000;
; 1578 : 		numGeneratedTripcodes_CPU           %= 1000000;
; 1579 : 	}
; 1580 : 	num_generated_tripcodes_spinlock.unlock();
; 1581 : }
; 1582 : 
; 1583 : void AddToNumGeneratedTripcodesByGPU(uint32_t num)
; 1584 : {
; 1585 : 	num_generated_tripcodes_spinlock.lock();
; 1586 : 	numGeneratedTripcodes_GPU += num;
; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {
; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;
; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;
; 1590 : 	}
; 1591 : 	num_generated_tripcodes_spinlock.unlock();
; 1592 : }
; 1593 : 
; 1594 : double GetNumGeneratedTripcodesByCPU()
; 1595 : {
; 1596 : 	num_generated_tripcodes_spinlock.lock();
; 1597 : 
; 1598 : 	double ret =   (double)numGeneratedTripcodesByCPUInMillions * 1000000
; 1599 : 	             +         numGeneratedTripcodes_CPU;
; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;
; 1601 : 	numGeneratedTripcodes_CPU           = 0;
; 1602 : 
; 1603 : 	num_generated_tripcodes_spinlock.unlock();
; 1604 : 	
; 1605 : 	return ret;
; 1606 : }
; 1607 : 
; 1608 : double GetNumGeneratedTripcodesByGPU()
; 1609 : {
; 1610 : 	num_generated_tripcodes_spinlock.lock();
; 1611 : 
; 1612 : 	double ret =   (double)numGeneratedTripcodesByGPUInMillions * 1000000
; 1613 : 	             +         numGeneratedTripcodes_GPU;
; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;
; 1615 : 	numGeneratedTripcodes_GPU           = 0;
; 1616 : 
; 1617 : 	num_generated_tripcodes_spinlock.unlock();
; 1618 : 	
; 1619 : 	return ret;
; 1620 : }
; 1621 : 
; 1622 : void SetPauseState(BOOL newPauseState)
; 1623 : {
; 1624 : 	current_state_spinlock.lock();
; 1625 : 	isSearchPaused = newPauseState;
; 1626 : 	current_state_spinlock.unlock();
; 1627 : }
; 1628 : 
; 1629 : BOOL GetPauseState()
; 1630 : {
; 1631 : 	BOOL ret;
; 1632 : 	current_state_spinlock.lock();
; 1633 : 	ret = isSearchPaused;
; 1634 : 	current_state_spinlock.unlock();
; 1635 : 	return ret;
; 1636 : }
; 1637 : 
; 1638 : void SetErrorState()
; 1639 : {
; 1640 : 	current_state_spinlock.lock();
; 1641 : 	wasSearchAbortedWithError = TRUE;
; 1642 : 	current_state_spinlock.unlock();
; 1643 : }
; 1644 : 
; 1645 : BOOL GetErrorState()
; 1646 : {
; 1647 : 	BOOL ret;
; 1648 : 	current_state_spinlock.lock();
; 1649 : 	ret = wasSearchAbortedWithError;
; 1650 : 	current_state_spinlock.unlock();
; 1651 : 	return ret;
; 1652 : }
; 1653 : 
; 1654 : void SetTerminationState()
; 1655 : {
; 1656 : 	current_state_spinlock.lock();
; 1657 : 	wasSearchTerminated = TRUE;
; 1658 : 	current_state_spinlock.unlock();
; 1659 : }
; 1660 : 
; 1661 : BOOL GetTerminationState()
; 1662 : {
; 1663 : 	BOOL ret;
; 1664 : 
; 1665 : 	current_state_spinlock.lock();
; 1666 : 
; 1667 : 	// Prepare for termination.
; 1668 : 	if (options.redirection && nameEventForTerminatingWC[0] != 0x0 && eventForTerminating == NULL) {
; 1669 : 		eventForTerminating = OpenEvent(EVENT_ALL_ACCESS, false, nameEventForTerminatingWC);
; 1670 : 		ERROR0(!eventForTerminating, ERROR_EVENT, "Failed to open an event.") 
; 1671 : 	}
; 1672 : 
; 1673 : 	// Check to see if a termination event has occured.
; 1674 : 	if (eventForTerminating && WaitForSingleObject(eventForTerminating, 0) == WAIT_OBJECT_0)
; 1675 : 		wasSearchTerminated = true;
; 1676 : 
; 1677 : 	ret = wasSearchTerminated;
; 1678 : 
; 1679 : 	current_state_spinlock.unlock();
; 1680 : 
; 1681 : 	return ret;
; 1682 : }
; 1683 : 
; 1684 : double UpdateCurrentStatus(uint64_t startingTime)
; 1685 : {
; 1686 : 	current_state_spinlock.lock();
; 1687 : 	
; 1688 : 	double numGeneratedTripcodes_GPU = GetNumGeneratedTripcodesByGPU();
; 1689 : 	double numGeneratedTripcodes_CPU = GetNumGeneratedTripcodesByCPU();
; 1690 : 	uint64_t  endingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;
; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;
; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;
; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;
; 1696 : 	totalTime += deltaTime;
; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);
; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);
; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)
; 1701 : 		maximumSpeed = currentSpeed_thisProcess;
; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;
; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;
; 1707 : 
; 1708 : 	current_state_spinlock.unlock();
; 1709 : 
; 1710 : 	return deltaTime;
; 1711 : }
; 1712 : 
; 1713 : BOOL IsFirstByteSJIS(unsigned char ch)
; 1714 : {
; 1715 : 	if (options.maximizeKeySpace) {

	test	r10d, r10d
	je	SHORT $LN172@CreateChar
	lea	eax, DWORD PTR [rbx+127]
	cmp	al, 3
	jbe	SHORT $LN13@CreateChar
	lea	eax, DWORD PTR [rbx+120]
	cmp	al, 23
	jbe	SHORT $LN13@CreateChar

; 1716 : 		return IS_FIRST_BYTE_SJIS_FULL(ch);

	lea	eax, DWORD PTR [rbx+32]
	cmp	al, 10
	jmp	SHORT $LN493@CreateChar
$LN172@CreateChar:
	cmp	bl, 152					; 00000098H
	je	SHORT $LN181@CreateChar
	cmp	bl, 136					; 00000088H
	jbe	SHORT $LN181@CreateChar
	cmp	bl, 160					; 000000a0H
	jb	SHORT $LN13@CreateChar
$LN181@CreateChar:

; 1717 : 	} else {
; 1718 : 		return IS_FIRST_BYTE_SJIS_CONSERVATIVE(ch);

	lea	eax, DWORD PTR [rbx+32]
	cmp	al, 9
$LN493@CreateChar:
	ja	SHORT $LN14@CreateChar
$LN13@CreateChar:

; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;

	inc	ecx
$LN14@CreateChar:
	lea	eax, DWORD PTR [rbx-64]
	cmp	eax, 62					; 0000003eH
	jbe	SHORT $LN7@CreateChar

; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;

	lea	eax, DWORD PTR [rbx-129]
	cmp	eax, 123				; 0000007bH
	ja	SHORT $LN8@CreateChar
$LN7@CreateChar:
	inc	edx
$LN8@CreateChar:
	cmp	ebx, 42					; 0000002aH
	ja	SHORT $LN399@CreateChar
	movsxd	rax, ebx
	bt	r9, rax
	jb	SHORT $LN4@CreateChar
$LN399@CreateChar:
	lea	eax, DWORD PTR [rbx-45]
	cmp	eax, 81					; 00000051H
	jbe	SHORT $LN4@CreateChar

; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;

	lea	eax, DWORD PTR [rbx-161]
	cmp	eax, 62					; 0000003eH
	ja	SHORT $LN16@CreateChar
$LN4@CreateChar:
	inc	r8d
$LN16@CreateChar:

; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {

	inc	ebx
	cmp	ebx, 256				; 00000100H
	jl	$LL17@CreateChar
$LN490@CreateChar:

; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	DWORD PTR ?numFirstByte@@3HA, ecx	; numFirstByte
	mov	DWORD PTR ?numSecondByte@@3HA, edx	; numSecondByte
	mov	DWORD PTR ?numOneByte@@3HA, r8d		; numOneByte
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?CreateCharacterTables@@YAXXZ ENDP			; CreateCharacterTables
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?DisplayCopyrights@@YAXXZ
_TEXT	SEGMENT
?DisplayCopyrights@@YAXXZ PROC				; DisplayCopyrights, COMDAT

; 525  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);

	lea	rdx, OFFSET FLAT:$SG4294857001
	lea	rcx, OFFSET FLAT:$SG4294857000
	call	printf

; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);

	lea	r8, OFFSET FLAT:$SG4294856999
	lea	rdx, OFFSET FLAT:$SG4294856998
	lea	rcx, OFFSET FLAT:$SG4294856997
	call	printf

; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");

	lea	rcx, OFFSET FLAT:$SG4294856996
	call	printf

; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");

	lea	rcx, OFFSET FLAT:$SG4294856995
	call	printf

; 536  :     printf("This is free software, and you are welcome to redistribute it\n");

	lea	rcx, OFFSET FLAT:$SG4294856994
	call	printf

; 537  :     printf("under certain conditions.\n");

	lea	rcx, OFFSET FLAT:$SG4294856993
	call	printf

; 538  :     printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856992

; 539  : }

	add	rsp, 40					; 00000028H

; 538  :     printf("\n");

	jmp	printf
?DisplayCopyrights@@YAXXZ ENDP				; DisplayCopyrights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z
_TEXT	SEGMENT
$T1 = 48
info$ = 48
status$ = 56
?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z PROC ; UpdateCUDADeviceStatus, COMDAT

; 542  : {

$LN87:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
$LL5@UpdateCUDA:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN4@UpdateCUDA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN19@UpdateCUDA

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@UpdateCUDA
$LN19@UpdateCUDA:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@UpdateCUDA
$LN4@UpdateCUDA:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 544  : 	strcpy(info->status, status);

	mov	rcx, rdi
	sub	rcx, rbx
	npad	7
$LL3@UpdateCUDA:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rcx+rbx+639], al
	test	al, al
	jne	SHORT $LL3@UpdateCUDA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T1[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	QWORD PTR [rdi+1672], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 547  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?UpdateCUDADeviceStatus@@YAXPEAUCUDADeviceSearchThreadInfo@@PEAD@Z ENDP ; UpdateCUDADeviceStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CheckSearchThreads@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 56
$T4 = 72
_Launcher$5 = 88
$T6 = 144
_Launcher$7 = 160
info$8 = 288
$T9 = 296
$T10 = 304
$T11 = 304
$T12 = 312
?CheckSearchThreads@@YAXXZ PROC				; CheckSearchThreads, COMDAT

; 573  : {

$LN486:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-31]
	sub	rsp, 216				; 000000d8H
	mov	QWORD PTR $T2[rsp], -2
$LL25@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN24@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN39@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL25@CheckSearc
$LN39@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL25@CheckSearc
$LN24@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {

	xor	r13d, r13d
	mov	r12d, r13d
	mov	rdi, 3777893186295716171		; 346dc5d63886594bH
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, r13d ; numCUDADeviceSearchThreads
	jle	$LN481@CheckSearc
	mov	r14d, r13d
	mov	r15d, r13d
	npad	8
$LL11@CheckSearc:

; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];

	mov	rbx, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, rdi
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T9[rbp-185], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sub	rdx, QWORD PTR [r15+rbx+1672]

; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {

	cmp	rdx, 60000				; 0000ea60H
	jbe	$LN10@CheckSearc

; 584  : 			strcpy(info->status, "Restarting search thread...");

	movups	xmm0, XMMWORD PTR $SG4294856983
	movups	XMMWORD PTR [r15+rbx+640], xmm0
	movsdx	xmm1, QWORD PTR $SG4294856983+16
	movsdx	QWORD PTR [r15+rbx+656], xmm1
	mov	eax, DWORD PTR $SG4294856983+24
	mov	DWORD PTR [r15+rbx+664], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
	mov	rbx, QWORD PTR [r14+rax]
	mov	rdi, QWORD PTR [rbx]

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rbx+8], 0

; 81   : 		}
; 82   : 
; 83   : 	void join();
; 84   : 
; 85   : 	void detach()
; 86   : 		{	// detach thread
; 87   : 		if (!joinable())

	jne	SHORT $LN78@CheckSearc

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	ecx, 1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN78@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	movups	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR $T6[rbp-185], xmm0
	lea	rcx, QWORD PTR $T6[rbp-185]
	call	_Thrd_detach

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN85@CheckSearc

; 33   : 		_Throw_C_error(_Res);

	mov	ecx, eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN85@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	DWORD PTR [rbx+8], r13d
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 587  : 			delete cuda_device_search_threads[index];

	mov	rax, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
	mov	rcx, QWORD PTR [r14+rax]
	test	rcx, rcx
	je	SHORT $LN88@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rcx+8], 0

; 55   : 		if (joinable())

	jne	$LN447@CheckSearc
	call	??3@YAXPEAX@Z				; operator delete
$LN88@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 589  : 			TerminateThread(native_handle, 0);

	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_TerminateThread

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
	mov	QWORD PTR $T11[rbp-185], rax
	test	rax, rax
	je	SHORT $LN16@CheckSearc
	movsxd	rcx, r12d
	imul	rdi, rcx, 1680				; 00000690H
	add	rdi, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	lea	rbx, OFFSET FLAT:?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnCUDADevice
	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode
	lea	rax, OFFSET FLAT:?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice
	cmove	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T4[rbp-185], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T4[rbp-177], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$5[rbp-185]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$5[rbp-185], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$5[rbp-153], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$5[rbp-145], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Launcher$5[rbp-185]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$5[rbp-185]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));

	jmp	SHORT $LN17@CheckSearc
$LN16@CheckSearc:
	mov	rsi, r13
$LN17@CheckSearc:
	mov	rax, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
	mov	QWORD PTR [r14+rax], rsi
	mov	rdi, 3777893186295716171		; 346dc5d63886594bH
$LN10@CheckSearc:

; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {

	inc	r12d
	add	r15, 1680				; 00000690H
	add	r14, 8
	cmp	r12d, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jge	SHORT $LN481@CheckSearc
	jmp	$LL11@CheckSearc
$LN447@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
	int	3
$LN481@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, r13d ; cuda_device_search_thread_info_array_spinlock
$LL189@CheckSearc:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN188@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN203@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL189@CheckSearc
$LN203@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL189@CheckSearc
$LN188@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {

	mov	r12d, r13d
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, r13d ; numOpenCLDeviceSearchThreads
	jle	$LN482@CheckSearc
	mov	r15, r13
	mov	rsi, r13
	npad	7
$LL7@CheckSearc:

; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];

	mov	rbx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, rdi
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T12[rbp-185], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;

	sub	rdx, QWORD PTR [rsi+rbx+1096]

; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {

	cmp	rdx, 60000				; 0000ea60H
	jbe	$LN6@CheckSearc

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	cmp	DWORD PTR [rsi+rbx+1080], 0
	jne	SHORT $LN3@CheckSearc
	npad	10
$LL243@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN242@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN257@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL243@CheckSearc
$LN257@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL243@CheckSearc
$LN242@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r13d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	test	eax, eax
	je	$LL287@CheckSearc
$LN3@CheckSearc:

; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");

	movups	xmm0, XMMWORD PTR $SG4294856978
	movups	XMMWORD PTR [rsi+rbx+16], xmm0
	movups	xmm1, XMMWORD PTR $SG4294856978+16
	movups	XMMWORD PTR [rsi+rbx+32], xmm1
	mov	eax, DWORD PTR $SG4294856978+32
	mov	DWORD PTR [rsi+rbx+48], eax
	movzx	eax, WORD PTR $SG4294856978+36
	mov	WORD PTR [rsi+rbx+52], ax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
	mov	rdi, QWORD PTR [r15+rax]
	mov	r14, QWORD PTR [rdi]

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rdi+8], 0

; 81   : 		}
; 82   : 
; 83   : 	void join();
; 84   : 
; 85   : 	void detach()
; 86   : 		{	// detach thread
; 87   : 		if (!joinable())

	jne	SHORT $LN332@CheckSearc

; 88   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	ecx, 1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN332@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 53   : 	return (_Check_C_return(_Thrd_detach(_Thr)));

	movups	xmm0, XMMWORD PTR [rdi]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	_Thrd_detach

; 32   : 	if (_Res != _Thrd_success)

	test	eax, eax
	je	SHORT $LN339@CheckSearc

; 33   : 		_Throw_C_error(_Res);

	mov	ecx, eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN339@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 90   : 		_Thr_set_null(_Thr);

	mov	DWORD PTR [rdi+8], r13d
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 617  : 			delete opencl_device_search_threads[index];

	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
	mov	rcx, QWORD PTR [r15+rax]
	test	rcx, rcx
	je	SHORT $LN342@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rcx+8], 0

; 55   : 		if (joinable())

	jne	$LN448@CheckSearc
	call	??3@YAXPEAX@Z				; operator delete
$LN342@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 625  : 			info->child_process = NULL;

	mov	QWORD PTR [rsi+rbx+1088], r13

; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);

	xor	edx, edx
	mov	rcx, r14
	call	QWORD PTR __imp_TerminateThread

; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;

	mov	QWORD PTR [rsi+rbx+1048], r13

; 633  : 			info->averageSpeed = 0;

	mov	QWORD PTR [rsi+rbx+1056], r13

; 634  : 			++info->numRestarts;

	inc	DWORD PTR [rsi+rbx+1076]

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T10[rbp-185], rax
	test	rax, rax
	je	SHORT $LN20@CheckSearc
	movsxd	rcx, r12d
	imul	rdi, rcx, 1104				; 00000450H
	add	rdi, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	lea	rbx, OFFSET FLAT:?Thread_SearchForSHA1TripcodesOnOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnOpenCLDevice
	cmp	DWORD PTR ?lenTripcode@@3HA, 10		; lenTripcode
	lea	rax, OFFSET FLAT:?Thread_SearchForDESTripcodesOnOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnOpenCLDevice
	cmove	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T3[rsp], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T3[rbp-177], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$7[rbp-185]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$7[rbp-185], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$7[rbp-153], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$7[rbp-145], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, r14
	lea	rcx, QWORD PTR _Launcher$7[rbp-185]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$7[rbp-185]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));

	jmp	SHORT $LN21@CheckSearc
$LN20@CheckSearc:
	mov	r14, r13
$LN21@CheckSearc:
	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
	mov	QWORD PTR [r15+rax], r14
	mov	rdi, 3777893186295716171		; 346dc5d63886594bH
$LN6@CheckSearc:

; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {

	inc	r12d
	add	rsi, 1104				; 00000450H
	add	r15, 8
	cmp	r12d, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jge	$LN482@CheckSearc
	jmp	$LL7@CheckSearc
$LL287@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN286@CheckSearc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN301@CheckSearc

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL287@CheckSearc
$LN301@CheckSearc:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL287@CheckSearc
$LN286@CheckSearc:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r13d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@CheckSearc
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 22
	lea	rdx, OFFSET FLAT:$SG4294856982
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 22
	lea	rcx, OFFSET FLAT:$SG4294856981
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN328@CheckSearc
$LN2@CheckSearc:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856980
	lea	rcx, OFFSET FLAT:$SG4294856979
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$8[rbp-181], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$8[rbp-185], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$8[rbp-185]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN328@CheckSearc:

; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN448@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
	int	3
$LN482@CheckSearc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, r13d ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 645  : }

	add	rsp, 216				; 000000d8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN485@CheckSearc:
?CheckSearchThreads@@YAXXZ ENDP				; CheckSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 56
$T4 = 72
_Launcher$5 = 88
$T6 = 144
_Launcher$7 = 160
info$8 = 288
$T9 = 296
$T10 = 304
$T11 = 304
$T12 = 312
?dtor$0@?0??CheckSearchThreads@@YAXXZ@4HA PROC		; `CheckSearchThreads'::`1'::dtor$0
	mov	rcx, QWORD PTR $T11[rdx]
	jmp	??3@YAXPEAX@Z				; operator delete
?dtor$0@?0??CheckSearchThreads@@YAXXZ@4HA ENDP		; `CheckSearchThreads'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 56
$T4 = 72
_Launcher$5 = 88
$T6 = 144
_Launcher$7 = 160
info$8 = 288
$T9 = 296
$T10 = 304
$T11 = 304
$T12 = 312
?dtor$2@?0??CheckSearchThreads@@YAXXZ@4HA PROC		; `CheckSearchThreads'::`1'::dtor$2
	lea	rcx, QWORD PTR _Launcher$5[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$2@?0??CheckSearchThreads@@YAXXZ@4HA ENDP		; `CheckSearchThreads'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 56
$T4 = 72
_Launcher$5 = 88
$T6 = 144
_Launcher$7 = 160
info$8 = 288
$T9 = 296
$T10 = 304
$T11 = 304
$T12 = 312
?dtor$1@?0??CheckSearchThreads@@YAXXZ@4HA PROC		; `CheckSearchThreads'::`1'::dtor$1
	mov	rcx, QWORD PTR $T10[rdx]
	jmp	??3@YAXPEAX@Z				; operator delete
?dtor$1@?0??CheckSearchThreads@@YAXXZ@4HA ENDP		; `CheckSearchThreads'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 56
$T4 = 72
_Launcher$5 = 88
$T6 = 144
_Launcher$7 = 160
info$8 = 288
$T9 = 296
$T10 = 304
$T11 = 304
$T12 = 312
?dtor$4@?0??CheckSearchThreads@@YAXXZ@4HA PROC		; `CheckSearchThreads'::`1'::dtor$4
	lea	rcx, QWORD PTR _Launcher$7[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$4@?0??CheckSearchThreads@@YAXXZ@4HA ENDP		; `CheckSearchThreads'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??_Gthread@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_Gthread@std@@QEAAPEAXI@Z PROC			; std::thread::`scalar deleting destructor', COMDAT
$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 80   : 		return (!_Thr_is_null(_Thr));

	cmp	DWORD PTR [rcx+8], 0
	mov	rbx, rcx

; 55   : 		if (joinable())

	jne	SHORT $LN11@scalar
	call	??3@YAXPEAX@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN11@scalar:

; 56   : 			_XSTD terminate();

	call	?terminate@@YAXXZ			; terminate
	int	3
$LN10@scalar:
??_Gthread@std@@QEAAPEAXI@Z ENDP			; std::thread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?KeepSearchThreadsAlive@@YAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
?KeepSearchThreadsAlive@@YAXXZ PROC			; KeepSearchThreadsAlive, COMDAT

; 648  : {

$LN183:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	sub	rsp, 32					; 00000020H
	npad	6
$LL10@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN9@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN24@KeepSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL10@KeepSearch
$LN24@KeepSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL10@KeepSearch
$LN9@KeepSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)

	xor	ebx, ebx
	mov	QWORD PTR [rsp+64], rdi
	mov	rbp, 3777893186295716171		; 346dc5d63886594bH
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, ebx ; numCUDADeviceSearchThreads
	jle	SHORT $LN4@KeepSearch
	xor	edi, edi
	npad	2
$LL6@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)

	inc	ebx
	lea	rdi, QWORD PTR [rdi+1680]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, rbp
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)

	cmp	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads

; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	rax, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	mov	QWORD PTR [rdi+rax-8], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T1[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)

	jl	SHORT $LL6@KeepSearch
$LN4@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
	npad	8
$LL86@KeepSearch:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN85@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN100@KeepSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL86@KeepSearch
$LN100@KeepSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL86@KeepSearch
$LN85@KeepSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)

	xor	ebx, ebx
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, ebx ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN181@KeepSearch
	xor	edi, edi
	npad	1
$LL3@KeepSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)

	inc	ebx
	lea	rdi, QWORD PTR [rdi+1104]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, rbp
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)

	cmp	ebx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads

; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	rax, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rdi+rax-8], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T2[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)

	jl	SHORT $LL3@KeepSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
	mov	rdi, QWORD PTR [rsp+64]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 658  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN181@KeepSearch:
	mov	rdi, QWORD PTR [rsp+64]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, ebx ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 658  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?KeepSearchThreadsAlive@@YAXXZ ENDP			; KeepSearchThreadsAlive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?PrintStatus@@YAXXZ
_TEXT	SEGMENT
cursorPos$1 = 128
matchingProbDiff$ = 128
timeForOneMatch$ = 128
averageSpeed_CPU$ = 128
averageSpeed_GPU$ = 128
averageSpeed$ = 128
scrnBufInfo$2 = 136
msg$ = 160
__$ArrayPad$ = 41120
?PrintStatus@@YAXXZ PROC				; PrintStatus, COMDAT

; 661  : {

$LN332:
	push	rbp
	push	r13
	lea	rbp, QWORD PTR [rsp-41064]
	mov	eax, 41320				; 0000a168H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	npad	6
$LL70@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN69@PrintStatu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN84@PrintStatu

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL70@PrintStatu
$LN84@PrintStatu:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL70@PrintStatu
$LN69@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r13d, r13d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r13d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 662  : 	if (GetErrorState() || GetTerminationState())

	test	eax, eax
	jne	$LN274@PrintStatu
	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN274@PrintStatu
	mov	QWORD PTR [rsp+41312], r12
	movaps	XMMWORD PTR [rsp+41280], xmm6
	movaps	XMMWORD PTR [rsp+41264], xmm7
	movaps	XMMWORD PTR [rsp+41248], xmm8
	movaps	XMMWORD PTR [rsp+41168], xmm13
	movaps	XMMWORD PTR [rsp+41136], xmm15
	npad	5
$LL112@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN111@PrintStatu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN126@PrintStatu

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL112@PrintStatu
$LN126@PrintStatu:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL112@PrintStatu
$LN111@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 672  : 	sprintf(NEXT_LINE, "%-79s", "");

	lea	r8, OFFSET FLAT:$SG4294856977
	lea	rdx, OFFSET FLAT:$SG4294856976
	lea	rcx, QWORD PTR msg$[rbp-256]
	call	sprintf

; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");

	lea	r8, OFFSET FLAT:$SG4294856975
	lea	rdx, OFFSET FLAT:$SG4294856974
	lea	rcx, QWORD PTR msg$[rbp+768]
	call	sprintf

; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");

	lea	r8, OFFSET FLAT:$SG4294856973
	lea	rdx, OFFSET FLAT:$SG4294856972
	lea	rcx, QWORD PTR msg$[rbp+1792]
	call	sprintf

; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	cmp	eax, 3
	jne	SHORT $LN59@PrintStatu
	lea	r9, OFFSET FLAT:$SG4294856971
	jmp	SHORT $LN60@PrintStatu
$LN59@PrintStatu:
	lea	rcx, OFFSET FLAT:$SG4294856970
	lea	r9, OFFSET FLAT:$SG4294856969
	cmp	eax, 2
	cmove	r9, rcx
$LN60@PrintStatu:
	mov	eax, DWORD PTR ?searchMode@@3HA		; searchMode
	test	eax, eax
	jne	SHORT $LN63@PrintStatu
	lea	r8, OFFSET FLAT:$SG4294856968
	jmp	SHORT $LN62@PrintStatu
$LN63@PrintStatu:
	cmp	eax, 1
	jne	SHORT $LN61@PrintStatu
	lea	r8, OFFSET FLAT:$SG4294856967
	jmp	SHORT $LN62@PrintStatu
$LN61@PrintStatu:
	lea	rcx, OFFSET FLAT:$SG4294856966
	lea	r8, OFFSET FLAT:$SG4294856965
	cmp	eax, 2
	cmove	r8, rcx
$LN62@PrintStatu:
	lea	rdx, OFFSET FLAT:$SG4294856964
	lea	rcx, QWORD PTR msg$[rbp+2816]
	mov	QWORD PTR [rsp+41344], rbx
	mov	QWORD PTR [rsp+41296], r15
	call	sprintf

; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {

	mov	r10d, DWORD PTR ?minLenExpandedPattern@@3HA ; minLenExpandedPattern
	mov	r11d, DWORD PTR ?maxLenExpandedPattern@@3HA ; maxLenExpandedPattern

; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");

	mov	edx, DWORD PTR ?numTripcodeChunk@@3IA	; numTripcodeChunk
	cmp	r10d, r11d
	je	SHORT $LN54@PrintStatu
	cmp	DWORD PTR ?searchDevice@@3HA, 3		; searchDevice
	lea	r8, OFFSET FLAT:$SG4294856961
	lea	rax, OFFSET FLAT:$SG4294856963
	lea	rcx, OFFSET FLAT:$SG4294856962
	lea	rbx, OFFSET FLAT:$SG4294856959
	lea	r9, OFFSET FLAT:$SG4294856958
	cmove	rcx, rax
	cmp	edx, 1
	lea	rax, OFFSET FLAT:$SG4294856960
	mov	QWORD PTR [rsp+64], rcx
	cmove	rax, r8
	mov	r8d, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	mov	DWORD PTR [rsp+56], r11d
	mov	DWORD PTR [rsp+48], r10d
	mov	QWORD PTR [rsp+40], rax
	cmp	r8d, 1
	mov	DWORD PTR [rsp+32], edx
	lea	rcx, QWORD PTR msg$[rbp+3840]
	lea	rdx, OFFSET FLAT:$SG4294856957
	cmove	r9, rbx
	call	sprintf

; 693  : 		
; 694  : 	} else {

	jmp	SHORT $LN326@PrintStatu
$LN54@PrintStatu:

; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");

	cmp	DWORD PTR ?searchDevice@@3HA, 3		; searchDevice
	lea	r8, OFFSET FLAT:$SG4294856954
	lea	rax, OFFSET FLAT:$SG4294856956
	lea	r11, OFFSET FLAT:$SG4294856952
	lea	rcx, OFFSET FLAT:$SG4294856955
	lea	r9, OFFSET FLAT:$SG4294856951
	cmove	rcx, rax
	cmp	edx, 1
	lea	rax, OFFSET FLAT:$SG4294856953
	mov	QWORD PTR [rsp+56], rcx
	cmove	rax, r8
	mov	r8d, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	mov	DWORD PTR [rsp+48], r10d
	mov	QWORD PTR [rsp+40], rax
	cmp	r8d, 1
	mov	DWORD PTR [rsp+32], edx
	lea	rcx, QWORD PTR msg$[rbp+3840]
	lea	rdx, OFFSET FLAT:$SG4294856950
	cmove	r9, r11
	call	sprintf
$LN326@PrintStatu:

; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	mov	r15d, 5
	mov	QWORD PTR [rsp+41360], rdi
	cmp	eax, 3
	je	$LN323@PrintStatu
	cmp	QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA, r13 ; CUDADeviceSearchThreadInfoArray
	je	$LN161@PrintStatu
	npad	4
$LL130@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; cuda_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN129@PrintStatu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN144@PrintStatu

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL130@PrintStatu
$LN144@PrintStatu:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL130@PrintStatu
$LN129@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 706  : 		if (numCUDADeviceSearchThreads == 1) {

	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	cmp	eax, 1
	jne	SHORT $LN51@PrintStatu

; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);

	mov	r8, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	lea	rdx, OFFSET FLAT:$SG4294856949
	lea	rcx, QWORD PTR msg$[rbp+4864]
	add	r8, 640					; 00000280H
	call	sprintf
	mov	r15d, 6

; 708  : 		} else {

	jmp	SHORT $LN47@PrintStatu
$LN51@PrintStatu:

; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)

	mov	ebx, r13d
	test	eax, eax
	jle	SHORT $LN47@PrintStatu
	mov	rdi, r13
$LL49@PrintStatu:

; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);

	mov	r8, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	mov	r9d, DWORD PTR [r8+rdi+4]
	shl	rax, 10
	add	rcx, rax
	movsxd	rax, ebx
	imul	rdx, rax, 1680				; 00000690H
	lea	rax, QWORD PTR [r8+640]
	mov	r8d, DWORD PTR [r8+rdi]
	add	rax, rdx
	lea	rdx, OFFSET FLAT:$SG4294856948
	mov	QWORD PTR [rsp+32], rax
	call	sprintf
	inc	ebx
	inc	r15d
	cmp	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	lea	rdi, QWORD PTR [rdi+1680]
	jl	SHORT $LL49@PrintStatu
$LN47@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	mov	DWORD PTR ?cuda_device_search_thread_info_array_spinlock@@3Vspinlock@@A, r13d ; cuda_device_search_thread_info_array_spinlock
$LN161@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {

	cmp	eax, 3
	je	$LN323@PrintStatu
	cmp	QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA, r13 ; openCLDeviceSearchThreadInfoArray
	je	$LN323@PrintStatu
	npad	5
$LL172@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN171@PrintStatu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN186@PrintStatu

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL172@PrintStatu
$LN186@PrintStatu:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL172@PrintStatu
$LN171@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {

	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	cmp	eax, 1
	jne	SHORT $LN45@PrintStatu

; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);

	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	shl	rax, 10
	lea	rdx, OFFSET FLAT:$SG4294856947
	add	r8, 16
	add	rcx, rax
	call	sprintf
	inc	r15d

; 718  : 		} else {

	jmp	$LN41@PrintStatu
$LN45@PrintStatu:

; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	ebx, r13d
	test	eax, eax
	jle	$LN41@PrintStatu
	mov	rdi, r13
	npad	7
$LL43@PrintStatu:

; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {

	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray

; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);

	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	mov	r9d, DWORD PTR [r8+rdi+12]
	shl	rax, 10
	add	rcx, rax
	movsxd	rax, ebx
	imul	rdx, rax, 1104				; 00000450H
	test	r9d, r9d
	jns	SHORT $LN40@PrintStatu
	lea	r9, QWORD PTR [r8+16]
	mov	r8d, DWORD PTR [r8+rdi+8]
	add	r9, rdx
	lea	rdx, OFFSET FLAT:$SG4294856946
	call	sprintf

; 722  : 				} else {

	jmp	SHORT $LN327@PrintStatu
$LN40@PrintStatu:

; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);

	lea	rax, QWORD PTR [r8+16]
	mov	r8d, DWORD PTR [r8+rdi+8]
	add	rax, rdx
	lea	rdx, OFFSET FLAT:$SG4294856945
	mov	QWORD PTR [rsp+32], rax
	call	sprintf
$LN327@PrintStatu:
	inc	ebx
	inc	r15d
	add	rdi, 1104				; 00000450H
	cmp	ebx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LL43@PrintStatu
$LN41@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, r13d ; opencl_device_search_thread_info_array_spinlock
$LN323@PrintStatu:
	xorps	xmm13, xmm13
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;

	mov	r12d, r13d

; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {

	cmp	QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA, r12 ; openCLDeviceSearchThreadInfoArray
	movaps	xmm6, xmm13
	movaps	xmm7, xmm13
	movaps	xmm8, xmm13
	je	$LN245@PrintStatu
	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, r13d ; openCLRunChildProcesses
	je	$LN245@PrintStatu
	npad	8
$LL214@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, 0 ; opencl_device_search_thread_info_array_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN213@PrintStatu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN228@PrintStatu

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL214@PrintStatu
$LN228@PrintStatu:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL214@PrintStatu
$LN213@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	r8d, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	mov	r10, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	r9d, r13d
	cmp	r8d, 4
	jl	$LC307@PrintStatu
	lea	eax, DWORD PTR [r8-4]
	lea	rcx, QWORD PTR [r10+1048]
	shr	eax, 2
	inc	eax
	mov	edx, eax
	lea	r9d, DWORD PTR [rax*4]
$LL312@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [rcx+32], r13d
	je	SHORT $LN308@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	addsd	xmm6, QWORD PTR [rcx]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;

	addsd	xmm7, QWORD PTR [rcx+8]

; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;

	addsd	xmm8, QWORD PTR [rcx+16]

; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	r12d, DWORD PTR [rcx+24]
$LN308@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [rcx+1136], r13d
	je	SHORT $LN309@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	addsd	xmm6, QWORD PTR [rcx+1104]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;

	addsd	xmm7, QWORD PTR [rcx+1112]

; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;

	addsd	xmm8, QWORD PTR [rcx+1120]

; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	r12d, DWORD PTR [rcx+1128]
$LN309@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [rcx+2240], r13d
	je	SHORT $LN310@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	addsd	xmm6, QWORD PTR [rcx+2208]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;

	addsd	xmm7, QWORD PTR [rcx+2216]

; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;

	addsd	xmm8, QWORD PTR [rcx+2224]

; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	r12d, DWORD PTR [rcx+2232]
$LN310@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [rcx+3344], r13d
	je	SHORT $LN311@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	addsd	xmm6, QWORD PTR [rcx+3312]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;

	addsd	xmm7, QWORD PTR [rcx+3320]

; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;

	addsd	xmm8, QWORD PTR [rcx+3328]

; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	r12d, DWORD PTR [rcx+3336]
$LN311@PrintStatu:

; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	add	rcx, 4416				; 00001140H
	dec	rdx
	jne	$LL312@PrintStatu
$LC307@PrintStatu:
	cmp	r9d, r8d
	jge	SHORT $LN306@PrintStatu
	movsxd	rax, r9d
	imul	rcx, rax, 1104				; 00000450H
	lea	rax, QWORD PTR [r10+1048]
	add	rax, rcx
	sub	r8d, r9d
	mov	ecx, r8d
$LC37@PrintStatu:

; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))

	cmp	DWORD PTR [rax+32], r13d
	je	SHORT $LN36@PrintStatu

; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;

	addsd	xmm6, QWORD PTR [rax]

; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;

	addsd	xmm7, QWORD PTR [rax+8]

; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;

	addsd	xmm8, QWORD PTR [rax+16]

; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;

	add	r12d, DWORD PTR [rax+24]
$LN36@PrintStatu:

; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	add	rax, 1104				; 00000450H
	dec	rcx
	jne	SHORT $LC37@PrintStatu
$LN306@PrintStatu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?opencl_device_search_thread_info_array_spinlock@@3Vspinlock@@A, r13d ; opencl_device_search_thread_info_array_spinlock
$LN245@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 761  : 										: 0;

	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movaps	XMMWORD PTR [rsp+41216], xmm10
	lea	ecx, DWORD PTR [rax+r8]
	test	ecx, ecx
	je	SHORT $LN65@PrintStatu
	xorps	xmm10, xmm10
	xorps	xmm0, xmm0
	cvtsi2sd xmm10, rax
	mov	eax, ecx
	cvtsi2sd xmm0, rax
	divsd	xmm10, xmm0
	jmp	SHORT $LN66@PrintStatu
$LN65@PrintStatu:
	movaps	xmm10, xmm13
$LN66@PrintStatu:

; 762  : 	if (totalTime > 0) {

	movsdx	xmm1, QWORD PTR ?totalTime@@3NA		; totalTime
	movsdx	xmm15, QWORD PTR __real@4059000000000000
	movaps	XMMWORD PTR [rsp+41232], xmm9
	movaps	XMMWORD PTR [rsp+41200], xmm11
	movaps	XMMWORD PTR [rsp+41184], xmm12
	movaps	XMMWORD PTR [rsp+41152], xmm14
	comisd	xmm1, xmm13
	jbe	$LN325@PrintStatu

; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;

	mov	QWORD PTR [rsp+41352], rsi
	mov	QWORD PTR [rsp+41304], r14
	cvttsd2si r14, xmm1

; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;

	mov	eax, -1037155065			; c22e4507H

; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");

	lea	rcx, QWORD PTR msg$[rbp-256]
	mul	r14d
	mov	esi, edx
	shr	esi, 16
	imul	eax, esi, -86400			; fffeae80H
	add	r14d, eax
	mov	eax, -1851608123			; 91a2b3c5H
	mul	r14d
	mov	edi, edx
	shr	edi, 11
	imul	eax, edi, -3600				; fffff1f0H
	add	r14d, eax
	mov	eax, -2004318071			; 88888889H
	mul	r14d
	movsxd	rax, r15d
	mov	ebx, edx
	shl	rax, 10
	lea	rdx, OFFSET FLAT:$SG4294856944
	add	rcx, rax
	shr	ebx, 5
	call	sprintf
	inc	r15d

; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);

	lea	rcx, QWORD PTR msg$[rbp-256]
	movsdx	xmm2, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA ; prevTotalNumGeneratedTripcodes
	addsd	xmm2, xmm8
	movsxd	rax, r15d
	lea	rdx, OFFSET FLAT:$SG4294856943
	mov	r9d, esi
	mulsd	xmm2, QWORD PTR __real@3d719799812dea11
	shl	rax, 10
	add	rcx, rax
	movd	r8, xmm2
	imul	eax, ebx, 60				; 0000003cH
	sub	r14d, eax
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], edi
	call	sprintf
	inc	r15d

; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);

	lea	rcx, QWORD PTR msg$[rbp-256]
	movsdx	xmm2, QWORD PTR ?currentSpeed_thisProcess@@3NA ; currentSpeed_thisProcess
	movsdx	xmm9, QWORD PTR __real@412e848000000000
	movsxd	rax, r15d
	lea	rdx, OFFSET FLAT:$SG4294856942
	addsd	xmm2, xmm6
	shl	rax, 10
	add	rcx, rax
	divsd	xmm2, xmm9
	movd	r8, xmm2
	call	sprintf
	mov	r14, QWORD PTR [rsp+41304]
	mov	rsi, QWORD PTR [rsp+41352]
	inc	r15d

; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	jne	SHORT $LN32@PrintStatu

; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);

	movsdx	xmm2, QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA ; currentSpeed_thisProcess_GPU
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	addsd	xmm2, xmm6
	shl	rax, 10
	lea	rdx, OFFSET FLAT:$SG4294856941
	add	rcx, rax
	divsd	xmm2, xmm9
	movd	r8, xmm2
	call	sprintf

; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);

	movsdx	xmm2, QWORD PTR ?currentSpeed_CPU@@3NA	; currentSpeed_CPU
	inc	r15d
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	lea	rdx, OFFSET FLAT:$SG4294856940
	divsd	xmm2, xmm9
	shl	rax, 10
	add	rcx, rax
	movd	r8, xmm2
	call	sprintf
	inc	r15d
$LN32@PrintStatu:

; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;

	movsdx	xmm0, QWORD PTR ?totalTime@@3NA		; totalTime
	movsdx	xmm11, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA ; prevTotalNumGeneratedTripcodes

; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;

	movsdx	xmm12, QWORD PTR ?prevTotalNumGeneratedTripcodes_GPU@@3NA ; prevTotalNumGeneratedTripcodes_GPU

; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);

	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	lea	rdx, OFFSET FLAT:$SG4294856939
	shl	rax, 10
	divsd	xmm11, xmm0
	divsd	xmm12, xmm0
	add	rcx, rax
	movsdx	xmm14, QWORD PTR ?prevTotalNumGeneratedTripcodes_CPU@@3NA ; prevTotalNumGeneratedTripcodes_CPU
	addsd	xmm11, xmm7
	addsd	xmm12, xmm7
	movaps	xmm2, xmm11
	divsd	xmm2, xmm9
	divsd	xmm14, xmm0
	movd	r8, xmm2
	call	sprintf
	inc	r15d

; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	jne	SHORT $LN31@PrintStatu

; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);

	movaps	xmm2, xmm12
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	shl	rax, 10
	lea	rdx, OFFSET FLAT:$SG4294856938
	divsd	xmm2, xmm9
	add	rcx, rax
	movd	r8, xmm2
	call	sprintf

; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);

	movaps	xmm2, xmm14
	inc	r15d
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	lea	rdx, OFFSET FLAT:$SG4294856937
	divsd	xmm2, xmm9
	shl	rax, 10
	add	rcx, rax
	movd	r8, xmm2
	call	sprintf
	inc	r15d
$LN31@PrintStatu:

; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {

	comisd	xmm11, xmm13
	movsdx	xmm7, QWORD PTR ?numAverageTrialsForOneMatch@@3NA ; numAverageTrialsForOneMatch
	movsdx	xmm9, QWORD PTR __real@40ac200000000000
	divsd	xmm7, xmm11
	jbe	$LN18@PrintStatu
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, r13d ; searchForSpecialPatternsOnCPU
	jne	$LN18@PrintStatu

; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {

	movsdx	xmm0, QWORD PTR __real@41e77f03c0000000

; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			

	movaps	xmm2, xmm7
	comisd	xmm7, xmm0
	jb	SHORT $LN29@PrintStatu
	divsd	xmm2, xmm0
	lea	rdx, OFFSET FLAT:$SG4294856936
	jmp	$LN328@PrintStatu
$LN29@PrintStatu:

; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {

	movsdx	xmm0, QWORD PTR __real@417e133800000000
	comisd	xmm7, xmm0
	jb	SHORT $LN27@PrintStatu

; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			

	divsd	xmm2, xmm0
	lea	rdx, OFFSET FLAT:$SG4294856935
	jmp	SHORT $LN328@PrintStatu
$LN27@PrintStatu:

; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {

	movsdx	xmm0, QWORD PTR __real@414409ffffffffff
	comisd	xmm7, xmm0
	jb	SHORT $LN25@PrintStatu

; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			

	divsd	xmm2, xmm0
	lea	rdx, OFFSET FLAT:$SG4294856934
	jmp	SHORT $LN328@PrintStatu
$LN25@PrintStatu:

; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {

	movsdx	xmm0, QWORD PTR __real@40f5180000000000
	comisd	xmm7, xmm0
	jb	SHORT $LN23@PrintStatu

; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			

	divsd	xmm2, xmm0
	lea	rdx, OFFSET FLAT:$SG4294856933
	jmp	SHORT $LN328@PrintStatu
$LN23@PrintStatu:

; 803  : 			} else if (timeForOneMatch >= 60 * 60) {

	comisd	xmm7, xmm9
	jb	SHORT $LN21@PrintStatu

; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			

	divsd	xmm2, xmm9
	lea	rdx, OFFSET FLAT:$SG4294856932
	jmp	SHORT $LN328@PrintStatu
$LN21@PrintStatu:

; 805  : 			} else if (timeForOneMatch >= 60) {

	movsdx	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm7, xmm0
	jb	SHORT $LN19@PrintStatu

; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			

	divsd	xmm2, xmm0
	lea	rdx, OFFSET FLAT:$SG4294856931

; 807  : 			} else {

	jmp	SHORT $LN328@PrintStatu
$LN19@PrintStatu:

; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			

	lea	rdx, OFFSET FLAT:$SG4294856930
$LN328@PrintStatu:
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	movd	r8, xmm2
	shl	rax, 10
	add	rcx, rax
	call	sprintf
	inc	r15d
$LN18@PrintStatu:

; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");

	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	lea	rdx, OFFSET FLAT:$SG4294856929
	shl	rax, 10
	add	rcx, rax
	call	sprintf
	inc	r15d

; 812  : 		if (numValidTripcodes <= 0) {

	cmp	DWORD PTR ?numValidTripcodes@@3IA, r13d	; numValidTripcodes
	ja	SHORT $LN17@PrintStatu

; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");

	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	lea	rdx, OFFSET FLAT:$SG4294856928
	shl	rax, 10
	add	rcx, rax
	call	sprintf

; 814  : 		} else {

	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	inc	r15d
	movsdx	xmm1, QWORD PTR ?totalTime@@3NA		; totalTime
	jmp	$LN329@PrintStatu
$LN17@PrintStatu:

; 815  : 			if (prevNumValidTripcodes > 0) {

	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	test	r8d, r8d
	je	SHORT $LN15@PrintStatu

; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);

	movsdx	xmm0, QWORD PTR ?totalTime@@3NA		; totalTime
	movsdx	xmm1, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA ; prevTotalNumGeneratedTripcodes
	xorps	xmm2, xmm2
	divsd	xmm0, xmm9
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	shl	rax, 10
	lea	r9, OFFSET FLAT:$SG4294856926
	lea	rdx, OFFSET FLAT:$SG4294856925
	cvtsi2sd xmm2, r8
	addsd	xmm1, xmm8
	add	rcx, rax
	lea	rax, OFFSET FLAT:$SG4294856927
	cmp	r8d, 1
	cmove	r9, rax
	divsd	xmm1, xmm2
	divsd	xmm2, xmm0
	mulsd	xmm1, QWORD PTR __real@3e112e0be826d695
	movsdx	QWORD PTR [rsp+40], xmm1
	movsdx	QWORD PTR [rsp+32], xmm2
	call	sprintf
	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	inc	r15d
$LN15@PrintStatu:

; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);

	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movsdx	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA ; prevTotalNumGeneratedTripcodes
	xorps	xmm9, xmm9
	add	eax, r8d
	addsd	xmm0, xmm8
	add	eax, r12d

; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {

	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, r13d ; searchForSpecialPatternsOnCPU
	cvtsi2sd xmm9, rax
	divsd	xmm9, xmm0
	subsd	xmm9, QWORD PTR ?matchingProb@@3NA	; matchingProb
	divsd	xmm9, QWORD PTR ?matchingProb@@3NA	; matchingProb
	jne	SHORT $LN10@PrintStatu

; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);

	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	shl	rax, 10
	add	rcx, rax
	comisd	xmm9, QWORD PTR __real@3f847ae147ae147b
	jbe	SHORT $LN13@PrintStatu
	movaps	xmm2, xmm9
	lea	rdx, OFFSET FLAT:$SG4294856924
	mulsd	xmm2, xmm15
	movd	r8, xmm2
	call	sprintf
	jmp	SHORT $LN330@PrintStatu
$LN13@PrintStatu:

; 830  : 				} else if (matchingProbDiff < -0.01) {

	movsdx	xmm0, QWORD PTR __real@bf847ae147ae147b
	comisd	xmm0, xmm9
	jbe	SHORT $LN11@PrintStatu

; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);

	movaps	xmm2, xmm9
	lea	rdx, OFFSET FLAT:$SG4294856923
	mulsd	xmm2, QWORD PTR __real@c059000000000000
	movd	r8, xmm2
	call	sprintf

; 833  : 				} else {

	jmp	SHORT $LN330@PrintStatu
$LN11@PrintStatu:

; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");

	lea	rdx, OFFSET FLAT:$SG4294856922
	call	sprintf
$LN330@PrintStatu:
	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	inc	r15d
$LN10@PrintStatu:

; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {

	mov	ecx, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	add	ecx, r8d
	je	SHORT $LN324@PrintStatu

; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);

	movaps	xmm2, xmm10
	movsxd	rax, r15d
	lea	rcx, QWORD PTR msg$[rbp-256]
	shl	rax, 10
	lea	rdx, OFFSET FLAT:$SG4294856921
	mulsd	xmm2, xmm15
	add	rcx, rax
	movd	r8, xmm2
	call	sprintf
	mov	r8d, DWORD PTR ?prevNumValidTripcodes@@3IA ; prevNumValidTripcodes
	inc	r15d
$LN324@PrintStatu:
	movsdx	xmm1, QWORD PTR ?totalTime@@3NA		; totalTime
	jmp	SHORT $LN9@PrintStatu
$LN325@PrintStatu:
	movsdx	xmm11, QWORD PTR averageSpeed$[rbp-256]
	movsdx	xmm12, QWORD PTR averageSpeed_GPU$[rbp-256]
	movsdx	xmm14, QWORD PTR averageSpeed_CPU$[rbp-256]
	movsdx	xmm7, QWORD PTR timeForOneMatch$[rbp-256]
$LN329@PrintStatu:
	movsdx	xmm9, QWORD PTR matchingProbDiff$[rbp-256]
$LN9@PrintStatu:

; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r13d
	mov	r12, QWORD PTR [rsp+41312]
	jne	$LN8@PrintStatu

; 845  : 		for (int32_t i = 0; i < lineCount; ++i)

	test	r15d, r15d
	jle	SHORT $LN5@PrintStatu
	lea	rbx, QWORD PTR msg$[rbp-256]
	mov	edi, r15d
	npad	12
$LL7@PrintStatu:

; 846  : 			printf("%-79s\n", &(msg[i][0]));

	lea	rcx, OFFSET FLAT:$SG4294856920
	mov	rdx, rbx
	call	printf
	add	rbx, 1024				; 00000400H
	dec	rdi
	jne	SHORT $LL7@PrintStatu
$LN5@PrintStatu:

; 847  : 		reset_cursor_pos(-lineCount);

	mov	ebx, r15d

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	mov	ecx, -11				; fffffff5H

; 847  : 		reset_cursor_pos(-lineCount);

	neg	ebx

; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))

	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR scrnBufInfo$2[rbp-256]
	mov	rcx, rax
	call	QWORD PTR __imp_GetConsoleScreenBufferInfo
	test	eax, eax
	je	SHORT $LN256@PrintStatu

; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;

	movsx	ecx, WORD PTR scrnBufInfo$2[rbp-250]
	mov	WORD PTR cursorPos$1[rbp-256], r13w
	mov	eax, ecx
	add	eax, ebx
	js	SHORT $LN258@PrintStatu
	add	bx, cx
	mov	WORD PTR cursorPos$1[rbp-254], bx
	jmp	SHORT $LN259@PrintStatu
$LN258@PrintStatu:
	mov	WORD PTR cursorPos$1[rbp-254], r13w
$LN259@PrintStatu:

; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	edx, DWORD PTR cursorPos$1[rbp-256]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorPosition
$LN256@PrintStatu:

; 848  : 		prevLineCount = lineCount;

	mov	DWORD PTR ?prevLineCount@@3HA, r15d	; prevLineCount
	jmp	$LN4@PrintStatu
$LN8@PrintStatu:

; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {

	comisd	xmm1, xmm13
	jbe	$LN1@PrintStatu
	cmp	DWORD PTR ?searchForSpecialPatternsOnCPU@@3HA, r13d ; searchForSpecialPatternsOnCPU

; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);

	movsdx	xmm3, QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA ; currentSpeed_thisProcess_GPU
	movsdx	xmm0, QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA ; prevTotalNumGeneratedTripcodes
	mulsd	xmm10, xmm15
	movsdx	xmm2, QWORD PTR ?currentSpeed_thisProcess@@3NA ; currentSpeed_thisProcess
	addsd	xmm3, xmm6
	addsd	xmm0, xmm8
	movd	r9, xmm3
	addsd	xmm2, xmm6
	jne	$LN3@PrintStatu
	movsdx	QWORD PTR [rsp+120], xmm10
	lea	rax, OFFSET FLAT:$SG4294856919
	mulsd	xmm9, xmm15
	lea	rcx, OFFSET FLAT:$SG4294856918
	cvttsd2si edx, xmm9
	test	edx, edx
	cmovg	rcx, rax
	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	mov	DWORD PTR [rsp+112], eax
	movsdx	QWORD PTR [rsp+104], xmm14
	movsdx	QWORD PTR [rsp+96], xmm12
	mov	QWORD PTR [rsp+88], r13
	mov	DWORD PTR [rsp+80], r8d
	movsdx	QWORD PTR [rsp+72], xmm0
	movsdx	xmm0, QWORD PTR ?currentSpeed_CPU@@3NA	; currentSpeed_CPU
	mov	DWORD PTR [rsp+64], edx
	mov	QWORD PTR [rsp+56], rcx
	movd	r8, xmm2
	lea	rcx, OFFSET FLAT:$SG4294856917
	movd	rdx, xmm1
	movsdx	QWORD PTR [rsp+48], xmm7
	movsdx	QWORD PTR [rsp+40], xmm11
	movsdx	QWORD PTR [rsp+32], xmm0
	call	printf
	jmp	SHORT $LN1@PrintStatu
$LN3@PrintStatu:

; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);

	mov	eax, DWORD PTR ?prevNumDiscardedTripcodes@@3IA ; prevNumDiscardedTripcodes
	movsdx	QWORD PTR [rsp+96], xmm10
	movd	rdx, xmm1
	mov	DWORD PTR [rsp+88], eax
	lea	rcx, OFFSET FLAT:$SG4294856916
	movsdx	QWORD PTR [rsp+80], xmm14
	movsdx	QWORD PTR [rsp+72], xmm12
	mov	QWORD PTR [rsp+64], r13
	mov	DWORD PTR [rsp+56], r8d
	movsdx	QWORD PTR [rsp+48], xmm0
	movsdx	xmm0, QWORD PTR ?currentSpeed_CPU@@3NA	; currentSpeed_CPU
	movd	r8, xmm2
	movsdx	QWORD PTR [rsp+40], xmm11
	movsdx	QWORD PTR [rsp+32], xmm0
	call	printf
$LN1@PrintStatu:

; 881  : 		}
; 882  : 		fflush(stdout);

	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
$LN4@PrintStatu:
	movaps	xmm15, XMMWORD PTR [rsp+41136]
	movaps	xmm14, XMMWORD PTR [rsp+41152]
	movaps	xmm13, XMMWORD PTR [rsp+41168]
	mov	r15, QWORD PTR [rsp+41296]
	mov	rdi, QWORD PTR [rsp+41360]
	mov	rbx, QWORD PTR [rsp+41344]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r13d ; current_state_spinlock
	movaps	xmm12, XMMWORD PTR [rsp+41184]
	movaps	xmm11, XMMWORD PTR [rsp+41200]
	movaps	xmm10, XMMWORD PTR [rsp+41216]
	movaps	xmm9, XMMWORD PTR [rsp+41232]
	movaps	xmm8, XMMWORD PTR [rsp+41248]
	movaps	xmm7, XMMWORD PTR [rsp+41264]
	movaps	xmm6, XMMWORD PTR [rsp+41280]
$LN274@PrintStatu:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 887  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 41320				; 0000a168H
	pop	r13
	pop	rbp
	ret	0
?PrintStatus@@YAXXZ ENDP				; PrintStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ControlHandler@@YAHK@Z
_TEXT	SEGMENT
dwCtrlType$ = 48
?ControlHandler@@YAHK@Z PROC				; ControlHandler, COMDAT

; 890  : {

$LN74:
	sub	rsp, 40					; 00000028H
	cmp	ecx, 6
	ja	SHORT $LN71@ControlHan
	mov	eax, 101				; 00000065H
	bt	eax, ecx
	jae	SHORT $LN71@ControlHan
$LL12@ControlHan:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN11@ControlHan
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN26@ControlHan

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL12@ControlHan
$LN26@ControlHan:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL12@ControlHan
$LN11@ControlHan:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1657 : 	wasSearchTerminated = TRUE;

	mov	DWORD PTR ?wasSearchTerminated@@3HA, 1	; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
	npad	6
$LL3@ControlHan:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 898  : 			Sleep(1000);

	mov	ecx, 1000				; 000003e8H
	call	QWORD PTR __imp_Sleep
	jmp	SHORT $LL3@ControlHan
$LN71@ControlHan:

; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;

	xor	eax, eax

; 902  : 	}
; 903  : }

	add	rsp, 40					; 00000028H
	ret	0
?ControlHandler@@YAHK@Z ENDP				; ControlHandler
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?InitProcess@@YAXXZ
_TEXT	SEGMENT
info$1 = 48
?InitProcess@@YAXXZ PROC				; InitProcess, COMDAT

; 906  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	mov	ecx, -11				; fffffff5H
	mov	QWORD PTR info$1[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo

; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);

	lea	rcx, OFFSET FLAT:?ControlHandler@@YAHK@Z ; ControlHandler
	mov	edx, 1

; 909  : }

	add	rsp, 40					; 00000028H

; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);

	rex_jmp	QWORD PTR __imp_SetConsoleCtrlHandler
?InitProcess@@YAXXZ ENDP				; InitProcess
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListCUDADevices@@YAXXZ
_TEXT	SEGMENT
CUDADeviceProperties$ = 32
__$ArrayPad$ = 672
?ListCUDADevices@@YAXXZ PROC				; ListCUDADevices, COMDAT

; 912  : {

$LN11:
	push	rbx
	sub	rsp, 688				; 000002b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);

	lea	rcx, OFFSET FLAT:?CUDADeviceCount@@3HA	; CUDADeviceCount
	call	QWORD PTR __imp_cudaGetDeviceCount

; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {

	xor	ebx, ebx
	cmp	DWORD PTR ?CUDADeviceCount@@3HA, ebx	; CUDADeviceCount
	jle	SHORT $LN1@ListCUDADe
$LL3@ListCUDADe:

; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);

	lea	rcx, QWORD PTR CUDADeviceProperties$[rsp]
	mov	edx, ebx
	call	QWORD PTR __imp_cudaGetDeviceProperties

; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 

	lea	rdx, QWORD PTR CUDADeviceProperties$[rsp]
	lea	rcx, OFFSET FLAT:$SG4294856915
	call	printf
	inc	ebx
	cmp	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jl	SHORT $LL3@ListCUDADe
$LN1@ListCUDADe:

; 921  : 	}
; 922  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 688				; 000002b0H
	pop	rbx
	ret	0
?ListCUDADevices@@YAXXZ ENDP				; ListCUDADevices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?CountOpenCLDevices@@YAXXZ
_TEXT	SEGMENT
deviceCount$ = 48
numPlatforms$ = 52
info$1 = 56
info$2 = 64
platforms$1$ = 72
platformVendor$3 = 80
__$ArrayPad$ = 1104
?CountOpenCLDevices@@YAXXZ PROC				; CountOpenCLDevices, COMDAT

; 925  : {

$LN376:
	push	rdi
	sub	rsp, 1152				; 00000480H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);

	lea	r8, QWORD PTR numPlatforms$[rsp]
	xor	edi, edi
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR ?openCLDeviceCount@@3HA, edi	; openCLDeviceCount
	call	QWORD PTR __imp_clGetPlatformIDs

; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)

	test	eax, eax
	jne	$LN44@CountOpenC
	mov	QWORD PTR [rsp+1168], rbx
	mov	ebx, DWORD PTR numPlatforms$[rsp]
	test	ebx, ebx
	je	$LN367@CountOpenC

; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);

	mov	ecx, ebx
	mov	QWORD PTR [rsp+1184], rsi
	mov	QWORD PTR [rsp+1128], r14
	shl	rcx, 3
	call	malloc

; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	r14d, -1				; ffffffffH
	mov	rsi, rax
	mov	QWORD PTR platforms$1$[rsp], rax
	test	rax, rax
	jne	$LN43@CountOpenC
$LL51@CountOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN50@CountOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, r14d
	je	SHORT $LN65@CountOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL51@CountOpenC
$LN65@CountOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL51@CountOpenC
$LN50@CountOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, edi ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN361@CountOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, edi
	je	SHORT $LN42@CountOpenC
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856914
	mov	r8d, 5
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856913
	mov	edx, 5
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN41@CountOpenC
$LN42@CountOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856912
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN41@CountOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN361@CountOpenC:
	mov	ebx, DWORD PTR numPlatforms$[rsp]
$LN43@CountOpenC:

; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);

	xor	r8d, r8d
	mov	rdx, rsi
	mov	ecx, ebx
	call	QWORD PTR __imp_clGetPlatformIDs
	mov	ebx, eax

; 940  :     OPENCL_ERROR(errorCode);

	test	eax, eax
	je	$LN40@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN40@CountOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, edi
	je	SHORT $LN39@CountOpenC
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856911
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856910
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN121@CountOpenC
$LN39@CountOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856909
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	4
$LL37@CountOpenC:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN33@CountOpenC
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN36@CountOpenC
$LN33@CountOpenC:
	lea	r8, QWORD PTR [rax+1]
$LN36@CountOpenC:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL37@CountOpenC
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856908
	mov	r9d, 940				; 000003acH
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$1[rsp+4], 1
	mov	DWORD PTR info$1[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN121@CountOpenC:

; 940  :     OPENCL_ERROR(errorCode);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN40@CountOpenC:
	mov	QWORD PTR [rsp+1176], rbp
	mov	QWORD PTR [rsp+1144], r12
	mov	QWORD PTR [rsp+1136], r13

; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rsp+1120], r15

; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {

	xor	r13d, r13d
	npad	12
$LL32@CountOpenC:

; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {

	xor	r12d, r12d
	cmp	DWORD PTR numPlatforms$[rsp], r12d
	jbe	$LN27@CountOpenC
	mov	r14, rsi
$LL29@CountOpenC:

; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);

	mov	rcx, QWORD PTR [r14]
	lea	r9, QWORD PTR platformVendor$3[rsp]
	mov	edx, 2307				; 00000903H
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], 0
	call	QWORD PTR __imp_clGetPlatformInfo

; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)

	test	eax, eax
	jne	$LN28@CountOpenC

; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )

	lea	rdx, OFFSET FLAT:$SG4294856907
	lea	rcx, QWORD PTR platformVendor$3[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN23@CountOpenC
	cmp	DWORD PTR ?options@@3UOptions@@A+76, eax
	je	$LN28@CountOpenC
$LN23@CountOpenC:
	lea	rdx, OFFSET FLAT:$SG4294856906
	lea	rcx, QWORD PTR platformVendor$3[rsp]
	call	strcmp
	test	eax, eax
	je	$LN28@CountOpenC

; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);

	mov	rcx, QWORD PTR [r14]
	lea	rax, QWORD PTR deviceCount$[rsp]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, -1					; ffffffffH
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_clGetDeviceIDs

; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)

	test	eax, eax
	jne	$LN28@CountOpenC

; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);

	mov	ebx, DWORD PTR deviceCount$[rsp]
	mov	ecx, ebx
	shl	rcx, 3
	call	malloc
	mov	rsi, rax

; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	rax, rax
	jne	SHORT $LN21@CountOpenC
	mov	ebx, -1					; ffffffffH
	npad	9
$LL126@CountOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN125@CountOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, ebx
	je	SHORT $LN140@CountOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL126@CountOpenC
$LN140@CountOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL126@CountOpenC
$LN125@CountOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	je	$LN324@CountOpenC
	mov	ebx, DWORD PTR deviceCount$[rsp]
$LN21@CountOpenC:

; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);

	mov	rcx, QWORD PTR [r14]
	lea	rax, QWORD PTR deviceCount$[rsp]
	mov	r9, rsi
	mov	r8d, ebx
	mov	edx, 12
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_clGetDeviceIDs
	mov	ebx, eax

; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {

	cmp	eax, -1
	je	SHORT $LN362@CountOpenC

; 966  : 				OPENCL_ERROR(errorCode);

	test	eax, eax
	je	SHORT $LN17@CountOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN325@CountOpenC
$LN17@CountOpenC:

; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {

	mov	ecx, DWORD PTR deviceCount$[rsp]
	xor	edx, edx
	test	ecx, ecx
	je	SHORT $LN362@CountOpenC
	mov	r8, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rax, rsi
$LL9@CountOpenC:

; 968  : 					if (pass == 0) {

	test	r13d, r13d
	jne	SHORT $LN6@CountOpenC

; 969  : 						++openCLDeviceCount;

	inc	DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount

; 970  : 					} else {

	jmp	SHORT $LN8@CountOpenC
$LN6@CountOpenC:

; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];

	mov	rcx, QWORD PTR [rax]
	inc	ebp
	inc	rdi
	mov	QWORD PTR [r8+rdi*8-8], rcx
	mov	ecx, DWORD PTR deviceCount$[rsp]
$LN8@CountOpenC:

; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {

	inc	edx
	add	rax, 8
	cmp	edx, ecx
	jb	SHORT $LL9@CountOpenC
$LN362@CountOpenC:

; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);

	mov	rcx, rsi
	call	free
$LN28@CountOpenC:

; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {

	inc	r12d
	add	r14, 8
	cmp	r12d, DWORD PTR numPlatforms$[rsp]
	jb	$LL29@CountOpenC
	mov	rsi, QWORD PTR platforms$1$[rsp]
	mov	r14d, -1				; ffffffffH
$LN27@CountOpenC:

; 976  : 		}
; 977  : 		if (pass == 0) {

	test	r13d, r13d
	jne	SHORT $LN31@CountOpenC

; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);

	movsxd	rcx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	shl	rcx, 3
	call	malloc
	mov	QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA, rax ; openCLDeviceIDArray

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	rax, rax
	jne	SHORT $LN31@CountOpenC
	npad	10
$LL199@CountOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN198@CountOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, r14d
	je	SHORT $LN213@CountOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL199@CountOpenC
$LN213@CountOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL199@CountOpenC
$LN198@CountOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	je	SHORT $LL243@CountOpenC
$LN31@CountOpenC:

; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {

	inc	r13d
	cmp	r13d, 1
	jle	$LL32@CountOpenC

; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);

	mov	rcx, rsi
	call	free
	mov	rbp, QWORD PTR [rsp+1176]
	mov	r13, QWORD PTR [rsp+1136]
	mov	r12, QWORD PTR [rsp+1144]
	mov	r15, QWORD PTR [rsp+1120]
	mov	rsi, QWORD PTR [rsp+1184]
	mov	r14, QWORD PTR [rsp+1128]
$LN367@CountOpenC:
	mov	rbx, QWORD PTR [rsp+1168]
$LN44@CountOpenC:

; 984  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1152				; 00000480H
	pop	rdi
	ret	0
	npad	3
$LL243@CountOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN242@CountOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, r14d
	je	SHORT $LN257@CountOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL243@CountOpenC
$LN257@CountOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL243@CountOpenC
$LN242@CountOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	je	SHORT $LN2@CountOpenC
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856898
	mov	r8d, 5
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856897
	mov	edx, 5
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN313@CountOpenC
$LN2@CountOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856896
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$2[rsp+4], 1
	mov	DWORD PTR info$2[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$2[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN313@CountOpenC:

; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN324@CountOpenC:

; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN20@CountOpenC
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856905
	mov	r8d, 5
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856904
	mov	edx, 5
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN19@CountOpenC
$LN20@CountOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856903
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN19@CountOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN325@CountOpenC:

; 966  : 				OPENCL_ERROR(errorCode);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN16@CountOpenC
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856902
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856901
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN15@CountOpenC
$LN16@CountOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856900
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	3
$LL14@CountOpenC:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN10@CountOpenC
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN13@CountOpenC
$LN10@CountOpenC:
	lea	r8, QWORD PTR [rax+1]
$LN13@CountOpenC:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL14@CountOpenC
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856899
	mov	r9d, 966				; 000003c6H
	mov	rdx, rax
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN15@CountOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN375@CountOpenC:
?CountOpenCLDevices@@YAXXZ ENDP				; CountOpenCLDevices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListOpenCLDevices@@YAXXZ
_TEXT	SEGMENT
numComputeUnits$ = 48
info$1 = 56
info$2 = 64
info$3 = 72
deviceVendor$ = 80
deviceName$ = 1104
__$ArrayPad$ = 2128
?ListOpenCLDevices@@YAXXZ PROC				; ListOpenCLDevices, COMDAT

; 987  : {

$LN394:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 2144				; 00000860H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();

	call	?CountOpenCLDevices@@YAXXZ		; CountOpenCLDevices

; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  

	xor	ebp, ebp
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, ebp	; openCLDeviceCount
	mov	esi, ebp
	jle	$LN368@ListOpenCL
	mov	QWORD PTR [rsp+2160], rbx
	mov	QWORD PTR [rsp+2168], rdi
	mov	edi, ebp
	npad	10
$LL35@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR deviceVendor$[rsp]
	mov	edx, 4140				; 0000102cH
	mov	rcx, QWORD PTR [rdi+rcx]
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN32@ListOpenCL
	npad	4
$LL41@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN40@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN55@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL41@ListOpenCL
$LN55@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL41@ListOpenCL
$LN40@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	test	eax, eax
	je	$LL85@ListOpenCL
$LN32@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR deviceName$[rsp]
	mov	edx, 4139				; 0000102bH
	mov	rcx, QWORD PTR [rdi+rcx]
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN24@ListOpenCL
	npad	10
$LL131@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN130@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN145@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL131@ListOpenCL
$LN145@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL131@ListOpenCL
$LN130@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	test	eax, eax
	je	$LL175@ListOpenCL
$LN24@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR numComputeUnits$[rsp]
	mov	edx, 4098				; 00001002H
	mov	rcx, QWORD PTR [rdi+rcx]
	mov	r8d, 4
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN16@ListOpenCL
$LL221@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN220@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN235@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL221@ListOpenCL
$LN235@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL221@ListOpenCL
$LN220@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	test	eax, eax
	je	$LL265@ListOpenCL
$LN16@ListOpenCL:

; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856883
	lea	rcx, QWORD PTR deviceVendor$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN8@ListOpenCL

; 1003 : 			printf("AMD ");

	lea	rcx, OFFSET FLAT:$SG4294856882
	call	printf
	jmp	SHORT $LN3@ListOpenCL
$LN8@ListOpenCL:

; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856881
	lea	rcx, QWORD PTR deviceVendor$[rsp]
	call	strcmp
	test	eax, eax
	je	SHORT $LN3@ListOpenCL

; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856880
	lea	rcx, QWORD PTR deviceVendor$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN4@ListOpenCL

; 1007 : 			printf("NVIDIA ");

	lea	rcx, OFFSET FLAT:$SG4294856879
	call	printf

; 1008 : 		} else {

	jmp	SHORT $LN3@ListOpenCL
$LN4@ListOpenCL:

; 1009 : 			printf("%s ", deviceVendor);

	lea	rdx, QWORD PTR deviceVendor$[rsp]
	lea	rcx, OFFSET FLAT:$SG4294856878
	call	printf
$LN3@ListOpenCL:

; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);

	mov	r8d, DWORD PTR numComputeUnits$[rsp]
	lea	rdx, QWORD PTR deviceName$[rsp]
	lea	rcx, QWORD PTR deviceVendor$[rsp]
	call	?GetProductNameForOpenCLDevice@@YAPEADPEAD0I@Z ; GetProductNameForOpenCLDevice

; 1012 : 		if (productName) {

	test	rax, rax
	je	SHORT $LN2@ListOpenCL

; 1013 : 			printf("%s", productName);

	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG4294856877

; 1014 : 		} else {

	jmp	SHORT $LN392@ListOpenCL
$LN2@ListOpenCL:

; 1015 : 			printf("%s", deviceName);

	lea	rdx, QWORD PTR deviceName$[rsp]
	lea	rcx, OFFSET FLAT:$SG4294856876
$LN392@ListOpenCL:
	call	printf

; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");

	lea	rcx, OFFSET FLAT:$SG4294856875
	call	printf
	inc	esi
	add	rdi, 8
	cmp	esi, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	$LL35@ListOpenCL
	mov	rbx, QWORD PTR [rsp+2160]
	mov	rdi, QWORD PTR [rsp+2168]
$LN368@ListOpenCL:

; 1018 : 	}
; 1019 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbp, QWORD PTR [rsp+2176]
	add	rsp, 2144				; 00000860H
	pop	rsi
	ret	0
$LL265@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN264@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN279@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL265@ListOpenCL
$LN279@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL265@ListOpenCL
$LN264@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	je	SHORT $LN15@ListOpenCL
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856887
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856886
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN306@ListOpenCL
$LN15@ListOpenCL:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856885
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	3
$LL13@ListOpenCL:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN9@ListOpenCL
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN12@ListOpenCL
$LN9@ListOpenCL:
	lea	r8, QWORD PTR [rax+1]
$LN12@ListOpenCL:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL13@ListOpenCL
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856884
	mov	r9d, 1000				; 000003e8H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$3[rsp+4], 1
	mov	DWORD PTR info$3[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$3[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN306@ListOpenCL:

; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	1
$LL175@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN174@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN189@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL175@ListOpenCL
$LN189@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL175@ListOpenCL
$LN174@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	je	SHORT $LN23@ListOpenCL
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856891
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856890
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN216@ListOpenCL
$LN23@ListOpenCL:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856889
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	4
$LL21@ListOpenCL:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN17@ListOpenCL
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN20@ListOpenCL
$LN17@ListOpenCL:
	lea	r8, QWORD PTR [rax+1]
$LN20@ListOpenCL:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL21@ListOpenCL
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856888
	mov	r9d, 999				; 000003e7H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$1[rsp+4], 1
	mov	DWORD PTR info$1[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN216@ListOpenCL:

; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	1
$LL85@ListOpenCL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN84@ListOpenCL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN99@ListOpenCL

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL85@ListOpenCL
$LN99@ListOpenCL:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL85@ListOpenCL
$LN84@ListOpenCL:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebp ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	je	SHORT $LN31@ListOpenCL
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856895
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856894
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN126@ListOpenCL
$LN31@ListOpenCL:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856893
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	4
$LL29@ListOpenCL:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN25@ListOpenCL
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN28@ListOpenCL
$LN25@ListOpenCL:
	lea	r8, QWORD PTR [rax+1]
$LN28@ListOpenCL:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL29@ListOpenCL
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856892
	mov	r9d, 998				; 000003e6H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$2[rsp+4], 1
	mov	DWORD PTR info$2[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$2[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN126@ListOpenCL:

; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN393@ListOpenCL:
?ListOpenCLDevices@@YAXXZ ENDP				; ListOpenCLDevices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListGPUsAndExit@@YAXXZ
_TEXT	SEGMENT
?ListGPUsAndExit@@YAXXZ PROC				; ListGPUsAndExit, COMDAT

; 1022 : {

$LN5:
	sub	rsp, 40					; 00000028H

; 1023 : 	if (!options.useOpenCLForCUDADevices)

	cmp	DWORD PTR ?options@@3UOptions@@A+76, 0
	jne	SHORT $LN1@ListGPUsAn

; 1024 : 		ListCUDADevices();

	call	?ListCUDADevices@@YAXXZ			; ListCUDADevices
$LN1@ListGPUsAn:

; 1025 : 	ListOpenCLDevices();

	call	?ListOpenCLDevices@@YAXXZ		; ListOpenCLDevices

; 1026 : 	exit(0);

	xor	ecx, ecx
	call	exit
	int	3
$LN4@ListGPUsAn:
?ListGPUsAndExit@@YAXXZ ENDP				; ListGPUsAndExit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?InitSearchDevices@@YAXH@Z
_TEXT	SEGMENT
numComputeUnits$1 = 48
clockFrequency$2 = 52
info$3 = 56
info$4 = 64
info$5 = 72
info$6 = 80
info$7 = 88
info$8 = 96
info$9 = 104
info$10 = 112
info$11 = 120
globalMemorySize$12 = 128
maxWorkGroupSize$13 = 136
results$14 = 144
sysInfo$15 = 160
CUDADeviceProperties$ = 208
deviceName$16 = 848
deviceVendor$17 = 1872
deviceVersion$18 = 2896
driverVersion$19 = 3920
__$ArrayPad$ = 4944
displayDeviceInformation$ = 5008
?InitSearchDevices@@YAXH@Z PROC				; InitSearchDevices, COMDAT

; 1030 : {

$LN1084:
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-4720]
	mov	eax, 4976				; 00001370H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {

	xor	r15d, r15d
	mov	r14d, ecx
	cmp	DWORD PTR ?options@@3UOptions@@A+76, r15d
	je	SHORT $LN110@InitSearch

; 1035 : 		CUDADeviceCount = 0;

	mov	DWORD PTR ?CUDADeviceCount@@3HA, r15d	; CUDADeviceCount

; 1036 : 	} else {

	jmp	SHORT $LN109@InitSearch
$LN110@InitSearch:

; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);

	lea	rcx, OFFSET FLAT:?CUDADeviceCount@@3HA	; CUDADeviceCount
	call	QWORD PTR __imp_cudaGetDeviceCount
$LN109@InitSearch:

; 1038 : 	}
; 1039 : 	CountOpenCLDevices();

	mov	QWORD PTR [rsp+5008], rbx
	call	?CountOpenCLDevices@@YAXXZ		; CountOpenCLDevices

; 1043 : 			"An invalid device was specified.");

	mov	edx, DWORD PTR ?options@@3UOptions@@A
	cmp	edx, -1
	je	$LN1023@InitSearch
	test	edx, edx
	js	SHORT $LL133@InitSearch
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	ecx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	add	ecx, ebx
	cmp	ecx, edx
	jg	$LN108@InitSearch
	npad	9
$LL133@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN132@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN147@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL133@InitSearch
$LN147@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL133@InitSearch
$LN132@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1043 : 			"An invalid device was specified.");

	test	eax, eax
	jne	$LN1024@InitSearch
	npad	8
$LL177@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN176@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN191@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL177@InitSearch
$LN191@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL177@InitSearch
$LN176@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1043 : 			"An invalid device was specified.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1043 : 			"An invalid device was specified.");

	je	SHORT $LN106@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856874
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856873
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN218@InitSearch
$LN106@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856872
	lea	rcx, OFFSET FLAT:$SG4294856871
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$9[rsp+4], 1
	mov	DWORD PTR info$9[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$9[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN218@InitSearch:

; 1043 : 			"An invalid device was specified.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1024@InitSearch:
	mov	edx, DWORD PTR ?options@@3UOptions@@A
$LN1023@InitSearch:
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
$LN108@InitSearch:

; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {

	mov	ecx, DWORD PTR ?options@@3UOptions@@A+20
	test	ecx, ecx
	jne	SHORT $LN104@InitSearch

; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);

	test	ebx, ebx
	jg	SHORT $LN113@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, r15d	; openCLDeviceCount
	jg	SHORT $LN113@InitSearch
	mov	ecx, 3
	mov	DWORD PTR ?searchDevice@@3HA, ecx	; searchDevice
	jmp	$LN102@InitSearch
$LN113@InitSearch:
	mov	ecx, 2
	mov	DWORD PTR ?searchDevice@@3HA, ecx	; searchDevice

; 1046 : 	} else {

	jmp	SHORT $LN101@InitSearch
$LN104@InitSearch:
	lea	eax, DWORD PTR [rcx-1]

; 1047 : 		searchDevice = options.searchDevice;

	mov	DWORD PTR ?searchDevice@@3HA, ecx	; searchDevice
	cmp	eax, 1
	ja	$LN102@InitSearch
$LN101@InitSearch:

; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");

	test	ebx, ebx
	jg	$LN102@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, r15d	; openCLDeviceCount
	jg	$LN102@InitSearch
	npad	10
$LL223@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN222@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN237@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL223@InitSearch
$LN237@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL223@InitSearch
$LN222@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");

	test	eax, eax
	jne	$LN1025@InitSearch
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN100@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856870
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856869
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN99@InitSearch
$LN100@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856868
	lea	rcx, OFFSET FLAT:$SG4294856867
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN99@InitSearch:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1025@InitSearch:
	mov	edx, DWORD PTR ?options@@3UOptions@@A
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN102@InitSearch:

; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;

	lea	eax, DWORD PTR [rcx-1]
	mov	QWORD PTR [rsp+5016], rsi
	mov	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, r15d ; numCUDADeviceSearchThreads
	mov	QWORD PTR [rsp+5024], rdi

; 1070 : 	numOpenCLDeviceSearchThreads = 0;

	mov	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, r15d ; numOpenCLDeviceSearchThreads

; 1071 : 	numCPUSearchThreads          = 0;

	mov	DWORD PTR ?numCPUSearchThreads@@3HA, r15d ; numCPUSearchThreads
	cmp	eax, 1
	ja	$LN90@InitSearch

; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {

	test	ebx, ebx
	jle	$LN90@InitSearch
	cmp	DWORD PTR ?options@@3UOptions@@A+76, r15d
	jne	$LN90@InitSearch
	cmp	edx, -1
	je	SHORT $LN96@InitSearch
	cmp	edx, ebx
	jge	$LN90@InitSearch
$LN96@InitSearch:
	movaps	XMMWORD PTR [rsp+4960], xmm6

; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {

	test	r14d, r14d
	je	SHORT $LN93@InitSearch
	cmp	ebx, 1
	jle	SHORT $LN95@InitSearch
	cmp	edx, -1
	jne	SHORT $LN95@InitSearch

; 1079 : 			printf("CUDA DEVICES\n");

	lea	rcx, OFFSET FLAT:$SG4294856866
	call	printf

; 1080 : 			printf("============\n");

	lea	rcx, OFFSET FLAT:$SG4294856865
	call	printf

; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);

	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	lea	rcx, OFFSET FLAT:$SG4294856864
	call	printf
	jmp	SHORT $LN1079@InitSearch
$LN95@InitSearch:

; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");

	lea	rcx, OFFSET FLAT:$SG4294856863
	call	printf

; 1084 : 			printf("===========\n");

	lea	rcx, OFFSET FLAT:$SG4294856862
	call	printf
$LN1079@InitSearch:
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	edx, DWORD PTR ?options@@3UOptions@@A
$LN93@InitSearch:

; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );

	movss	xmm6, DWORD PTR __real@3a83126f
	mov	edi, edx
	cmp	edx, -1
	cmove	edi, r15d
	lea	rsi, OFFSET FLAT:$SG4294856853
$LL92@InitSearch:

; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {

	mov	eax, ebx
	cmp	edx, -1
	je	SHORT $LN116@InitSearch
	lea	eax, DWORD PTR [rdx+1]
$LN116@InitSearch:
	cmp	edi, eax
	jge	$LN1026@InitSearch

; 1089 : 			if (displayDeviceInformation) {

	test	r14d, r14d
	je	$LN89@InitSearch

; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);

	lea	rcx, QWORD PTR CUDADeviceProperties$[rbp-256]
	mov	edx, edi
	call	QWORD PTR __imp_cudaGetDeviceProperties

; 1091 : 				printf(    "  Device No.:               %d\n",      i);

	lea	rcx, OFFSET FLAT:$SG4294856861
	mov	edx, edi
	call	printf

; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);

	lea	rdx, QWORD PTR CUDADeviceProperties$[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856860
	call	printf

; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);

	mov	edx, DWORD PTR CUDADeviceProperties$[rbp+100]
	lea	rcx, OFFSET FLAT:$SG4294856859
	call	printf

; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);

	lea	rcx, OFFSET FLAT:$SG4294856858
	movd	xmm0, DWORD PTR CUDADeviceProperties$[rbp+60]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm6
	cvtps2pd xmm1, xmm0
	movd	rdx, xmm1
	call	printf

; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);

	mov	r8d, DWORD PTR CUDADeviceProperties$[rbp+76]
	mov	edx, DWORD PTR CUDADeviceProperties$[rbp+72]
	lea	rcx, OFFSET FLAT:$SG4294856857
	call	printf

; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );

	mov	eax, DWORD PTR CUDADeviceProperties$[rbp+116]
	test	eax, eax
	jne	SHORT $LN121@InitSearch
	lea	rdx, OFFSET FLAT:$SG4294856856
	jmp	SHORT $LN118@InitSearch
$LN121@InitSearch:
	cmp	eax, 1
	jne	SHORT $LN119@InitSearch
	lea	rdx, OFFSET FLAT:$SG4294856855
	jmp	SHORT $LN118@InitSearch
$LN119@InitSearch:
	cmp	eax, 2
	jne	SHORT $LN117@InitSearch
	lea	rdx, OFFSET FLAT:$SG4294856854
	jmp	SHORT $LN118@InitSearch
$LN117@InitSearch:
	lea	rdx, OFFSET FLAT:$SG4294856852
	cmp	eax, 3
	cmove	rdx, rsi
$LN118@InitSearch:
	lea	rcx, OFFSET FLAT:$SG4294856851
	call	printf

; 1102 : 				printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856850
	call	printf
	mov	edx, DWORD PTR ?options@@3UOptions@@A
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
$LN89@InitSearch:

; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;

	add	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 2 ; numCUDADeviceSearchThreads
	inc	edi
	jmp	$LL92@InitSearch
$LN1026@InitSearch:

; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {

	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
	movaps	xmm6, XMMWORD PTR [rsp+4960]
$LN90@InitSearch:
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1
	ja	$LN80@InitSearch

; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {

	cmp	DWORD PTR ?openCLDeviceCount@@3HA, r15d	; openCLDeviceCount
	jle	$LN80@InitSearch
	cmp	edx, -1
	je	SHORT $LN86@InitSearch
	cmp	ebx, edx
	jg	$LN80@InitSearch
$LN86@InitSearch:

; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {

	test	r14d, r14d
	je	SHORT $LN83@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 1	; openCLDeviceCount
	jle	SHORT $LN85@InitSearch
	cmp	edx, -1
	jne	SHORT $LN85@InitSearch

; 1113 : 			printf("OPENCL DEVICES\n");

	lea	rcx, OFFSET FLAT:$SG4294856849
	call	printf

; 1114 : 			printf("==============\n");

	lea	rcx, OFFSET FLAT:$SG4294856848
	call	printf

; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);

	mov	edx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	lea	rcx, OFFSET FLAT:$SG4294856847
	call	printf
	jmp	SHORT $LN1080@InitSearch
$LN85@InitSearch:

; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");

	lea	rcx, OFFSET FLAT:$SG4294856846
	call	printf

; 1118 : 			printf("=============\n");

	lea	rcx, OFFSET FLAT:$SG4294856845
	call	printf
$LN1080@InitSearch:
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	mov	edx, DWORD PTR ?options@@3UOptions@@A
$LN83@InitSearch:

; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;

	cmp	DWORD PTR ?options@@3UOptions@@A+96, r15d
	je	SHORT $LN123@InitSearch
	cmp	DWORD PTR ?openCLDeviceCount@@3HA, 1	; openCLDeviceCount
	jle	SHORT $LN123@InitSearch
	cmp	edx, -1
	je	SHORT $LN124@InitSearch
$LN123@InitSearch:
	cmp	DWORD PTR ?options@@3UOptions@@A+100, 1
	mov	DWORD PTR ?openCLRunChildProcesses@@3HA, r15d ; openCLRunChildProcesses
	jle	SHORT $LN125@InitSearch
$LN124@InitSearch:
	mov	DWORD PTR ?openCLRunChildProcesses@@3HA, 1 ; openCLRunChildProcesses
$LN125@InitSearch:

; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));

	mov	esi, edx
	cmp	edx, -1
	cmove	esi, ebx
	npad	6
$LL82@InitSearch:

; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {

	cmp	edx, -1
	jne	SHORT $LN126@InitSearch
	mov	edx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	add	edx, ebx
	jmp	SHORT $LN127@InitSearch
$LN126@InitSearch:
	inc	edx
$LN127@InitSearch:
	cmp	esi, edx
	jge	$LN1027@InitSearch

; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	eax, esi
	lea	r9, QWORD PTR deviceVendor$17[rbp-256]
	sub	eax, ebx
	mov	edx, 4140				; 0000102cH
	mov	r8d, 1024				; 00000400H
	movsxd	rdi, eax
	mov	QWORD PTR [rsp+32], r15
	mov	rcx, QWORD PTR [rcx+rdi*8]
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN79@InitSearch
	npad	2
$LL267@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN266@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN281@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL267@InitSearch
$LN281@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL267@InitSearch
$LN266@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	test	eax, eax
	je	$LL311@InitSearch
$LN79@InitSearch:

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR deviceName$16[rbp-256]
	mov	edx, 4139				; 0000102bH
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN71@InitSearch
	npad	10
$LL357@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN356@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN371@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL357@InitSearch
$LN371@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL357@InitSearch
$LN356@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	test	eax, eax
	je	$LL401@InitSearch
$LN71@InitSearch:

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR deviceVersion$18[rbp-256]
	mov	edx, 4143				; 0000102fH
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN63@InitSearch
	npad	10
$LL447@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN446@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN461@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL447@InitSearch
$LN461@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL447@InitSearch
$LN446@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	test	eax, eax
	je	$LL491@InitSearch
$LN63@InitSearch:

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR driverVersion$19[rbp-256]
	mov	edx, 4141				; 0000102dH
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN55@InitSearch
	npad	10
$LL537@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN536@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN551@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL537@InitSearch
$LN551@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL537@InitSearch
$LN536@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	test	eax, eax
	je	$LL581@InitSearch
$LN55@InitSearch:

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR globalMemorySize$12[rbp-256]
	mov	edx, 4127				; 0000101fH
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 8
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN47@InitSearch
$LL627@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN626@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN641@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL627@InitSearch
$LN641@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL627@InitSearch
$LN626@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	test	eax, eax
	je	$LN788@InitSearch
$LN47@InitSearch:

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR clockFrequency$2[rsp]
	mov	edx, 4108				; 0000100cH
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 4
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN39@InitSearch
	npad	9
$LL673@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN672@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN687@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL673@InitSearch
$LN687@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL673@InitSearch
$LN672@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	test	eax, eax
	je	$LN789@InitSearch
$LN39@InitSearch:

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR numComputeUnits$1[rsp]
	mov	edx, 4098				; 00001002H
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 4
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN31@InitSearch
$LL719@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN718@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN733@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL719@InitSearch
$LN733@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL719@InitSearch
$LN718@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	test	eax, eax
	je	$LN790@InitSearch
$LN31@InitSearch:

; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));

	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	lea	r9, QWORD PTR maxWorkGroupSize$13[rbp-256]
	mov	edx, 4100				; 00001004H
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	r8d, 8
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN23@InitSearch
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN791@InitSearch
$LN23@InitSearch:

; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);

	mov	r8d, DWORD PTR numComputeUnits$1[rsp]
	lea	rdx, QWORD PTR deviceName$16[rbp-256]
	lea	rcx, QWORD PTR deviceVendor$17[rbp-256]
	call	?GetProductNameForOpenCLDevice@@YAPEADPEAD0I@Z ; GetProductNameForOpenCLDevice
	mov	rbx, rax

; 1147 : 			if (displayDeviceInformation) {

	test	r14d, r14d
	je	$LN15@InitSearch

; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);

	lea	rdx, QWORD PTR deviceVendor$17[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856812
	call	printf

; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);

	lea	rdx, QWORD PTR deviceName$16[rbp-256]
	test	rbx, rbx
	je	SHORT $LN14@InitSearch
	lea	rcx, OFFSET FLAT:$SG4294856811
	mov	r8, rbx
	call	printf

; 1151 : 				} else {

	jmp	SHORT $LN13@InitSearch
$LN14@InitSearch:

; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);

	lea	rcx, OFFSET FLAT:$SG4294856810
	call	printf
$LN13@InitSearch:

; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);

	mov	edx, DWORD PTR numComputeUnits$1[rsp]
	lea	rcx, OFFSET FLAT:$SG4294856809
	call	printf

; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);

	mov	edx, DWORD PTR clockFrequency$2[rsp]
	lea	rcx, OFFSET FLAT:$SG4294856808
	call	printf

; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));

	mov	rdx, QWORD PTR globalMemorySize$12[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856807
	shr	rdx, 20
	call	printf

; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);

	mov	edx, DWORD PTR maxWorkGroupSize$13[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856806
	call	printf

; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);

	lea	rdx, QWORD PTR deviceVersion$18[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856805
	call	printf

; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);

	lea	rdx, QWORD PTR driverVersion$19[rbp-256]
	lea	rcx, OFFSET FLAT:$SG4294856804
	call	printf

; 1160 : 				printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856803
	call	printf
$LN15@InitSearch:

; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, r15d ; openCLRunChildProcesses

; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;

	mov	eax, DWORD PTR ?options@@3UOptions@@A+100
	jne	SHORT $LN1081@InitSearch

; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;

	mov	eax, DWORD PTR ?options@@3UOptions@@A+44
$LN1081@InitSearch:
	add	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, eax ; numOpenCLDeviceSearchThreads
	mov	edx, DWORD PTR ?options@@3UOptions@@A
	mov	ebx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	inc	esi
	jmp	$LL82@InitSearch
	npad	9
$LL581@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN580@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN595@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL581@InitSearch
$LN595@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL581@InitSearch
$LN580@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	je	SHORT $LN54@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856832
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856831
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN622@InitSearch
$LN54@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856830
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL52@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN48@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN51@InitSearch
$LN48@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN51@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL52@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856829
	mov	r9d, 1141				; 00000475H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$8[rsp+4], 1
	mov	DWORD PTR info$8[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$8[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN622@InitSearch:

; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	1
$LL491@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN490@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN505@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL491@InitSearch
$LN505@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL491@InitSearch
$LN490@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	je	SHORT $LN62@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856836
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856835
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN532@InitSearch
$LN62@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856834
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL60@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN56@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN59@InitSearch
$LN56@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN59@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL60@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856833
	mov	r9d, 1140				; 00000474H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$6[rsp+4], 1
	mov	DWORD PTR info$6[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$6[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN532@InitSearch:

; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	1
$LL401@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN400@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN415@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL401@InitSearch
$LN415@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL401@InitSearch
$LN400@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	je	SHORT $LN70@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856840
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856839
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN442@InitSearch
$LN70@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856838
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL68@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN64@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN67@InitSearch
$LN64@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN67@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL68@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856837
	mov	r9d, 1139				; 00000473H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$10[rsp+4], 1
	mov	DWORD PTR info$10[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$10[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN442@InitSearch:

; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	1
$LL311@InitSearch:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN310@InitSearch
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN325@InitSearch

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL311@InitSearch
$LN325@InitSearch:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL311@InitSearch
$LN310@InitSearch:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError

; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	je	SHORT $LN78@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856844
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856843
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN352@InitSearch
$LN78@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856842
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL76@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN72@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN75@InitSearch
$LN72@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN75@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL76@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856841
	mov	r9d, 1138				; 00000472H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$4[rsp+4], 1
	mov	DWORD PTR info$4[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$4[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN352@InitSearch:

; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN788@InitSearch:

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN46@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856828
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856827
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN668@InitSearch
$LN46@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856826
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL44@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN40@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN43@InitSearch
$LN40@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN43@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL44@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856825
	mov	r9d, 1142				; 00000476H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$5[rsp+4], 1
	mov	DWORD PTR info$5[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$5[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN668@InitSearch:

; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN789@InitSearch:

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN38@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856824
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856823
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN714@InitSearch
$LN38@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856822
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL36@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN32@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN35@InitSearch
$LN32@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN35@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL36@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856821
	mov	r9d, 1143				; 00000477H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$7[rsp+4], 1
	mov	DWORD PTR info$7[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$7[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN714@InitSearch:

; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN790@InitSearch:

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN30@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856820
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856819
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN760@InitSearch
$LN30@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856818
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL28@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN24@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN27@InitSearch
$LN24@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN27@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL28@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856817
	mov	r9d, 1144				; 00000478H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$3[rsp+4], 1
	mov	DWORD PTR info$3[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$3[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN760@InitSearch:

; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN791@InitSearch:

; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN22@InitSearch
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856816
	mov	r8d, 15
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856815
	mov	edx, 15
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN762@InitSearch
$LN22@InitSearch:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856814
	mov	cl, 46					; 0000002eH
	mov	r8, rax
	npad	2
$LL20@InitSearch:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN16@InitSearch
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN19@InitSearch
$LN16@InitSearch:
	lea	r8, QWORD PTR [rax+1]
$LN19@InitSearch:
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL20@InitSearch
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	lea	rcx, OFFSET FLAT:$SG4294856813
	mov	r9d, 1145				; 00000479H
	mov	rdx, rax
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$11[rsp+4], 1
	mov	DWORD PTR info$11[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$11[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN762@InitSearch:

; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1027@InitSearch:
	mov	ecx, DWORD PTR ?searchDevice@@3HA	; searchDevice
$LN80@InitSearch:
	lea	eax, DWORD PTR [rcx-1]
	test	eax, -3					; fffffffdH
	jne	$LN1077@InitSearch

; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);

	lea	rcx, QWORD PTR sysInfo$15[rbp-256]
	call	QWORD PTR __imp_GetSystemInfo

; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 

	mov	eax, DWORD PTR ?options@@3UOptions@@A+28

; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;

	mov	ecx, DWORD PTR sysInfo$15[rbp-224]
	cmp	eax, -1
	jne	SHORT $LN8@InitSearch

; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jne	SHORT $LN5@InitSearch

; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;

	mov	edx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	mov	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	lea	eax, DWORD PTR [rdx+rbx]
	cmp	ecx, eax
	jle	SHORT $LN128@InitSearch
	sub	ecx, edx
	sub	ecx, ebx
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jmp	SHORT $LN921@InitSearch
$LN128@InitSearch:
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, r15d ; numCPUSearchThreads

; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;

	mov	DWORD PTR ?searchDevice@@3HA, 2		; searchDevice
	jmp	$LN1077@InitSearch
$LN8@InitSearch:

; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;

	cmp	eax, ecx
	cmovb	ecx, eax

; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {

	cmp	DWORD PTR ?searchDevice@@3HA, 1		; searchDevice
	mov	DWORD PTR ?numCPUSearchThreads@@3HA, ecx ; numCPUSearchThreads
	jne	SHORT $LN5@InitSearch
$LN921@InitSearch:
	test	ecx, ecx
	jg	SHORT $LN5@InitSearch

; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;

	mov	DWORD PTR ?searchDevice@@3HA, 2		; searchDevice
	jmp	SHORT $LN1077@InitSearch
$LN5@InitSearch:

; 1188 : 		} else 	if (displayDeviceInformation) {

	test	r14d, r14d
	je	SHORT $LN1077@InitSearch

; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);

	xor	ecx, ecx
	mov	eax, 1
	cpuid
	mov	DWORD PTR results$14[rbp-248], ecx

; 1191 : 
; 1192 : 			printf("CPU\n");

	lea	rcx, OFFSET FLAT:$SG4294856802
	mov	edi, eax
	mov	DWORD PTR results$14[rbp-252], ebx
	mov	DWORD PTR results$14[rbp-244], edx
	call	printf

; 1193 : 			printf("===\n");

	lea	rcx, OFFSET FLAT:$SG4294856801
	call	printf

; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {

	call	?IsCPUBasedOnNehalemMicroarchitecture@@YAHXZ ; IsCPUBasedOnNehalemMicroarchitecture

; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:$SG4294856800
	test	eax, eax
	jne	SHORT $LN1082@InitSearch

; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);

	lea	rcx, OFFSET FLAT:$SG4294856799
$LN1082@InitSearch:
	call	printf

; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);

	mov	edx, DWORD PTR sysInfo$15[rbp-224]
	lea	rcx, OFFSET FLAT:$SG4294856798
	call	printf

; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);

	mov	edx, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	lea	rcx, OFFSET FLAT:$SG4294856797
	call	printf

; 1201 : 			printf("\n");

	lea	rcx, OFFSET FLAT:$SG4294856796
	call	printf
$LN1077@InitSearch:
	mov	rsi, QWORD PTR [rsp+5016]
	mov	rdi, QWORD PTR [rsp+5024]
	mov	rbx, QWORD PTR [rsp+5008]

; 1202 : 		}
; 1203 : 	}
; 1204 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4976				; 00001370H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN1083@InitSearch:
?InitSearchDevices@@YAXH@Z ENDP				; InitSearchDevices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ObtainOptions@@YAXHPEAPEAD@Z
_TEXT	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
line$10 = 128
line$11 = 384
line$12 = 640
line$13 = 896
line$14 = 1152
line$15 = 1408
line$16 = 1664
line$17 = 1920
line$18 = 2176
line$19 = 2432
line$20 = 2688
line$21 = 2944
__$ArrayPad$ = 3200
argCount$ = 3264
arguments$ = 3272
?ObtainOptions@@YAXHPEAPEAD@Z PROC			; ObtainOptions, COMDAT

; 1207 : {

$LN1438:
	push	rbp
	push	rbx
	push	rsi
	push	r12
	push	r14
	lea	rbp, QWORD PTR [rsp-2960]
	sub	rsp, 3216				; 00000c90H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx

; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));

	mov	rdx, QWORD PTR [rdx]
	mov	esi, ecx
	lea	rbx, OFFSET FLAT:?applicationPath@@3PADA ; applicationPath
	mov	r8d, 1025				; 00000401H
	mov	rcx, rbx
	call	_fullpath

; 1213 : 	strcpy(applicationDirectory, applicationPath);

	xor	r12d, r12d
	lea	r8, OFFSET FLAT:?applicationDirectory@@3PADA ; applicationDirectory
	mov	edx, r12d
	npad	14
$LL142@ObtainOpti:
	movzx	eax, BYTE PTR [rdx+rbx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rdx+r8-1], al
	test	al, al
	jne	SHORT $LL142@ObtainOpti

; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {

	or	rax, -1
$LL1300@ObtainOpti:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r12b
	jne	SHORT $LL1300@ObtainOpti
	dec	eax
	movsxd	rcx, eax
	test	eax, eax
	jle	SHORT $LN1436@ObtainOpti
$LL139@ObtainOpti:

; 1215 : 		if (applicationDirectory[i] == '\\')

	cmp	BYTE PTR [rcx+r8], 92			; 0000005cH
	je	SHORT $LN1386@ObtainOpti

; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {

	dec	rcx
	dec	eax
	test	rcx, rcx
	jg	SHORT $LL139@ObtainOpti
$LN1386@ObtainOpti:

; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)

	test	eax, eax
$LN1436@ObtainOpti:
	cmovs	eax, r12d

; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';

	movsxd	rcx, eax
	cmp	rcx, 1025				; 00000401H
	jae	$LN143@ObtainOpti
	mov	BYTE PTR [rcx+r8], r12b
	mov	QWORD PTR [rsp+3264], rdi
	mov	QWORD PTR [rsp+3280], r13

; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));

	lea	r13, OFFSET FLAT:?tripcodeFilePath@@3PADA ; tripcodeFilePath
	lea	rdx, OFFSET FLAT:$SG4294856795
	mov	r8d, 1025				; 00000401H
	mov	rcx, r13
	mov	QWORD PTR [rsp+3288], r15
	call	strncpy

; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {

	mov	r15d, 1
	mov	edi, r15d
	cmp	esi, r15d
	jle	$LN1336@ObtainOpti
	lea	r8, OFFSET FLAT:?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
	npad	1
$LL134@ObtainOpti:

; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {

	movsxd	rax, edi
	mov	rbx, QWORD PTR [r14+rax*8]
	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856794
	jne	$LN131@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856794+1
	jne	$LN131@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856794+2
	jne	$LN131@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN131@ObtainOpti

; 1232 : 			++indexArg;

	movsxd	rdi, eax

; 1236 : 			       arguments[indexArg]);

	or	rax, -1
	lea	rbx, QWORD PTR [r14+rdi*8]
	mov	rcx, QWORD PTR [rbx]
	npad	1
$LL1299@ObtainOpti:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r12b
	jne	SHORT $LL1299@ObtainOpti
	inc	rax
	cmp	rax, 1025				; 00000401H
	jbe	SHORT $LN130@ObtainOpti
$LL164@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN163@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN178@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL164@ObtainOpti
$LN178@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL164@ObtainOpti
$LN163@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1236 : 			       arguments[indexArg]);

	test	eax, eax
	je	$LL208@ObtainOpti
	lea	r8, OFFSET FLAT:?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
$LN130@ObtainOpti:

; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, r13
	npad	7
$LL145@ObtainOpti:
	movzx	eax, BYTE PTR [rcx]
	lea	rdx, QWORD PTR [rdx+1]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx-1], al
	test	al, al
	jne	SHORT $LL145@ObtainOpti
	jmp	$LN133@ObtainOpti
$LN131@ObtainOpti:

; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856788
	jne	$LN126@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856788+1
	jne	$LN126@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856788+2
	jne	$LN126@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN126@ObtainOpti

; 1240 : 			++indexArg;

	movsxd	rdi, eax

; 1244 : 			       arguments[indexArg]);

	or	rax, -1
	lea	rbx, QWORD PTR [r14+rdi*8]
	mov	rcx, QWORD PTR [rbx]
	npad	1
$LL1298@ObtainOpti:
	inc	rax
	cmp	BYTE PTR [rcx+rax], r12b
	jne	SHORT $LL1298@ObtainOpti
	cmp	rax, 1024				; 00000400H
	jbe	SHORT $LN125@ObtainOpti
$LL254@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN253@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN268@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL254@ObtainOpti
$LN268@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL254@ObtainOpti
$LN253@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1244 : 			       arguments[indexArg]);

	test	eax, eax
	je	$LL298@ObtainOpti
	lea	r8, OFFSET FLAT:?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
$LN125@ObtainOpti:

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	cmp	DWORD PTR ?numPatternFiles@@3HA, 256	; numPatternFiles, 00000100H
	jl	SHORT $LN122@ObtainOpti
	npad	4
$LL344@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN343@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN358@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL344@ObtainOpti
$LN358@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL344@ObtainOpti
$LN343@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	test	eax, eax
	je	$LL388@ObtainOpti
	lea	r8, OFFSET FLAT:?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
$LN122@ObtainOpti:

; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);

	movsxd	rax, DWORD PTR ?numPatternFiles@@3HA	; numPatternFiles
	mov	rdx, QWORD PTR [rbx]
	imul	rcx, rax, 1025				; 00000401H
	add	rcx, r8
	inc	DWORD PTR ?numPatternFiles@@3HA		; numPatternFiles
	npad	7
$LL146@ObtainOpti:
	movzx	eax, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rcx+1]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rcx-1], al
	test	al, al
	jne	SHORT $LL146@ObtainOpti
	jmp	$LN133@ObtainOpti
$LN126@ObtainOpti:

; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856778
	jne	SHORT $LN118@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856778+1
	jne	SHORT $LN118@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856778+2
	jne	SHORT $LN118@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	SHORT $LN118@ObtainOpti

; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A, eax
	jmp	$LN1397@ObtainOpti
$LN118@ObtainOpti:

; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856777
	jne	$LN116@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856777+1
	jne	$LN116@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856777+2
	jne	$LN116@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN116@ObtainOpti

; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+4, eax

; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	cmp	eax, r15d
	jge	SHORT $LN115@ObtainOpti
	npad	7
$LL434@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN433@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN448@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL434@ObtainOpti
$LN448@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL434@ObtainOpti
$LN433@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	test	eax, eax
	je	$LL478@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+4
$LN115@ObtainOpti:

; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	cmp	eax, 256				; 00000100H
	jle	$LN1397@ObtainOpti
	npad	7
$LL524@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN523@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN538@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL524@ObtainOpti
$LN538@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL524@ObtainOpti
$LN523@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	test	eax, eax
	jne	$LN1397@ObtainOpti
	npad	8
$LL568@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	$LN567@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	$LN582@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL568@ObtainOpti
$LN116@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856766
	jne	$LN108@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856766+1
	jne	$LN108@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856766+2
	jne	$LN108@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN108@ObtainOpti

; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+36, eax

; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	cmp	eax, r15d
	jge	SHORT $LN107@ObtainOpti
$LL614@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN613@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN628@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL614@ObtainOpti
$LN628@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL614@ObtainOpti
$LN613@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	test	eax, eax
	je	$LL658@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+36
$LN107@ObtainOpti:

; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	cmp	eax, 16384				; 00004000H
	jle	$LN1397@ObtainOpti
	npad	2
$LL704@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN703@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN718@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL704@ObtainOpti
$LN718@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL704@ObtainOpti
$LN703@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	test	eax, eax
	jne	$LN1397@ObtainOpti
	npad	8
$LL748@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	$LN747@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	$LN762@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL748@ObtainOpti
$LN108@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856755
	jne	$LN100@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856755+1
	jne	$LN100@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856755+2
	jne	$LN100@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN100@ObtainOpti

; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+40, eax

; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	cmp	eax, r15d
	jge	SHORT $LN99@ObtainOpti
$LL794@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN793@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN808@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL794@ObtainOpti
$LN808@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL794@ObtainOpti
$LN793@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	test	eax, eax
	je	$LL838@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+40
$LN99@ObtainOpti:

; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	cmp	eax, 256				; 00000100H
	jle	SHORT $LN96@ObtainOpti
	npad	6
$LL884@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN883@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN898@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL884@ObtainOpti
$LN898@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL884@ObtainOpti
$LN883@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	test	eax, eax
	je	$LL928@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+40
$LN96@ObtainOpti:

; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN1297@ObtainOpti
	dec	eax
	or	eax, -8
	inc	eax
$LN1297@ObtainOpti:
	test	eax, eax
	je	$LN1397@ObtainOpti
$LL974@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN973@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN988@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL974@ObtainOpti
$LN988@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL974@ObtainOpti
$LN973@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	test	eax, eax
	jne	$LN1397@ObtainOpti
	npad	4
$LL1018@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	$LN1017@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	$LN1032@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1018@ObtainOpti
$LN100@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856740
	jne	$LN89@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856740+1
	jne	$LN89@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856740+2
	jne	$LN89@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN89@ObtainOpti

; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+44, eax

; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	cmp	eax, r15d
	jge	SHORT $LN88@ObtainOpti
$LL1062@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1061@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1076@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1062@ObtainOpti
$LN1076@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1062@ObtainOpti
$LN1061@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	test	eax, eax
	je	$LN1132@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+44
$LN88@ObtainOpti:

; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);

	cmp	eax, 32					; 00000020H
	jle	$LN1397@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1397@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	$LN84@ObtainOpti
	call	__iob_func
	mov	r9d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:$SG4294856734
	lea	rcx, QWORD PTR [rax+96]
	lea	r8d, QWORD PTR [r9-22]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856733
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN83@ObtainOpti
$LN89@ObtainOpti:

; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856729
	jne	$LN81@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856729+1
	jne	$LN81@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856729+2
	jne	$LN81@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN81@ObtainOpti

; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+100, eax

; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);

	cmp	eax, r15d
	jge	SHORT $LN80@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN1134@ObtainOpti
	mov	eax, DWORD PTR ?options@@3UOptions@@A+100
$LN80@ObtainOpti:

; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);

	cmp	eax, 32					; 00000020H
	jle	$LN1397@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1397@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	$LN76@ObtainOpti
	call	__iob_func
	mov	r9d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:$SG4294856723
	lea	rcx, QWORD PTR [rax+96]
	lea	r8d, QWORD PTR [r9-22]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856722
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN75@ObtainOpti
$LN81@ObtainOpti:

; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856718
	jne	$LN73@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856718+1
	jne	$LN73@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856718+2
	jne	$LN73@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN73@ObtainOpti

; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?lenTripcode@@3HA, eax	; lenTripcode

; 1302 : 			lenTripcodeKey = lenTripcode;

	mov	DWORD PTR ?lenTripcodeKey@@3HA, eax	; lenTripcodeKey
	add	eax, -10				; fffffff6H
	test	eax, -3					; fffffffdH
	je	$LN1397@ObtainOpti

; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");

	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1397@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	$LN71@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856717
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856716
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN70@ObtainOpti
$LN73@ObtainOpti:

; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856713
	jne	SHORT $LN68@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856713+1
	jne	SHORT $LN68@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856713+2
	jne	SHORT $LN68@ObtainOpti

; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+8, r15d
	jmp	$LN133@ObtainOpti
$LN68@ObtainOpti:

; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856712
	jne	SHORT $LN66@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856712+1
	jne	SHORT $LN66@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856712+2
	jne	SHORT $LN66@ObtainOpti

; 1311 : 			options.outputInvalidTripcode = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+12, r15d
	jmp	$LN133@ObtainOpti
$LN66@ObtainOpti:

; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856711
	jne	SHORT $LN64@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856711+1
	jne	SHORT $LN64@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856711+2
	jne	SHORT $LN64@ObtainOpti

; 1314 : 			options.warnSpeedDrop= TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+16, r15d
	jmp	$LN133@ObtainOpti
$LN64@ObtainOpti:

; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856710
	jne	SHORT $LN62@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856710+1
	jne	SHORT $LN62@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856710+2
	jne	SHORT $LN62@ObtainOpti

; 1317 : 			options.testNewCode = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+24, r15d
	jmp	$LN133@ObtainOpti
$LN62@ObtainOpti:

; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856709
	jne	SHORT $LN60@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856709+1
	jne	SHORT $LN60@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856709+2
	jne	SHORT $LN60@ObtainOpti

; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);

	cmp	DWORD PTR ?options@@3UOptions@@A+20, r12d
	jne	SHORT $LN147@ObtainOpti
	mov	DWORD PTR ?options@@3UOptions@@A+20, 3
	jmp	$LN133@ObtainOpti
$LN147@ObtainOpti:
	mov	eax, DWORD PTR ?options@@3UOptions@@A+20
	cmp	eax, 2
	cmove	eax, r15d
	mov	DWORD PTR ?options@@3UOptions@@A+20, eax
	jmp	$LN133@ObtainOpti
$LN60@ObtainOpti:

; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856708
	jne	SHORT $LN58@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856708+1
	jne	SHORT $LN58@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856708+2
	jne	SHORT $LN58@ObtainOpti

; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);

	cmp	DWORD PTR ?options@@3UOptions@@A+20, r12d
	jne	SHORT $LN149@ObtainOpti
	mov	DWORD PTR ?options@@3UOptions@@A+20, 2
	jmp	$LN133@ObtainOpti
$LN149@ObtainOpti:
	mov	eax, DWORD PTR ?options@@3UOptions@@A+20
	cmp	eax, 3
	cmove	eax, r15d
	mov	DWORD PTR ?options@@3UOptions@@A+20, eax
	jmp	$LN133@ObtainOpti
$LN58@ObtainOpti:

; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856707
	jne	$LN56@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856707+1
	jne	$LN56@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856707+2
	jne	$LN56@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	$LN56@ObtainOpti

; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);

	movsxd	rdi, eax
	mov	rcx, QWORD PTR [r14+rdi*8]
	call	atoi
	mov	DWORD PTR ?options@@3UOptions@@A+28, eax

; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");

	test	eax, eax
	jg	$LN1397@ObtainOpti
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1397@ObtainOpti
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	$LN54@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856706
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856705
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN53@ObtainOpti
$LN56@ObtainOpti:

; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856702
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN51@ObtainOpti

; 1336 : 			options.redirection = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+32, r15d
	jmp	$LN1397@ObtainOpti
$LN51@ObtainOpti:

; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856701
	jne	$LN49@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856701+1
	jne	$LN49@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856701+2
	jne	$LN49@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	SHORT $LN49@ObtainOpti

; 1339 : 			++indexArg;

	movsxd	rdi, eax

; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);

	lea	rdx, OFFSET FLAT:?nameMutexForPausing@@3PADA ; nameMutexForPausing
	mov	rcx, QWORD PTR [r14+rdi*8]
	lea	r8, QWORD PTR [r14+rdi*8]
	npad	2
$LL151@ObtainOpti:
	movzx	eax, BYTE PTR [rcx]
	lea	rdx, QWORD PTR [rdx+1]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx-1], al
	test	al, al
	jne	SHORT $LL151@ObtainOpti

; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);

	mov	r8, QWORD PTR [r8]
	lea	rbx, OFFSET FLAT:nameMutexForPausingWC
	or	r9d, -1
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR [rsp+40], 256			; 00000100H
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp_MultiByteToWideChar

; 1342 : 			if (len < 0) {

	cmp	eax, 256				; 00000100H
	ja	SHORT $LN46@ObtainOpti

; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;

	cdqe
	add	rax, rax
	cmp	rax, 514				; 00000202H
	jae	$LN1437@ObtainOpti
	mov	WORD PTR [rax+rbx], r12w
$LN46@ObtainOpti:

; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;

	mov	WORD PTR nameMutexForPausingWC+512, r12w
	jmp	$LN1397@ObtainOpti
$LN49@ObtainOpti:

; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, BYTE PTR $SG4294856700
	jne	$LN44@ObtainOpti
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, BYTE PTR $SG4294856700+1
	jne	$LN44@ObtainOpti
	movzx	eax, BYTE PTR [rbx+2]
	cmp	al, BYTE PTR $SG4294856700+2
	jne	$LN44@ObtainOpti
	lea	eax, DWORD PTR [rdi+1]
	cmp	eax, esi
	jge	SHORT $LN44@ObtainOpti

; 1350 : 			++indexArg;

	movsxd	rdi, eax

; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);

	lea	rdx, OFFSET FLAT:?nameEventForTerminating@@3PADA ; nameEventForTerminating
	mov	rcx, QWORD PTR [r14+rdi*8]
	lea	r8, QWORD PTR [r14+rdi*8]
	npad	7
$LL156@ObtainOpti:
	movzx	eax, BYTE PTR [rcx]
	lea	rdx, QWORD PTR [rdx+1]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx-1], al
	test	al, al
	jne	SHORT $LL156@ObtainOpti

; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);

	mov	r8, QWORD PTR [r8]
	lea	rbx, OFFSET FLAT:nameEventForTerminatingWC
	or	r9d, -1
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR [rsp+40], 256			; 00000100H
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp_MultiByteToWideChar

; 1353 : 			if (len < 0) {

	cmp	eax, 256				; 00000100H
	ja	SHORT $LN41@ObtainOpti

; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;

	cdqe
	add	rax, rax
	cmp	rax, 514				; 00000202H
	jae	$LN157@ObtainOpti
	mov	WORD PTR [rax+rbx], r12w
$LN41@ObtainOpti:

; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;

	mov	WORD PTR nameEventForTerminatingWC+512, r12w
	jmp	$LN1397@ObtainOpti
$LN44@ObtainOpti:

; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856699
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN39@ObtainOpti

; 1361 : 			options.useOneByteCharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, r15d
	jmp	$LN1397@ObtainOpti
$LN39@ObtainOpti:

; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856698
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN37@ObtainOpti

; 1364 : 			options.searchForHisekiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+52, r15d
	jmp	$LN1397@ObtainOpti
$LN37@ObtainOpti:

; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856697
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN35@ObtainOpti

; 1367 : 			options.searchForKakuhiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+56, r15d
	jmp	$LN1397@ObtainOpti
$LN35@ObtainOpti:

; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856696
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN33@ObtainOpti

; 1370 : 			options.searchForKaibunOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+60, r15d
	jmp	$LN1397@ObtainOpti
$LN33@ObtainOpti:

; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856695
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN31@ObtainOpti

; 1373 : 			options.searchForKagamiOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+72, r15d
	jmp	$LN1397@ObtainOpti
$LN31@ObtainOpti:

; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856694
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN29@ObtainOpti

; 1376 : 			options.searchForYamabikoOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+64, r15d
	jmp	$LN1397@ObtainOpti
$LN29@ObtainOpti:

; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856693
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN27@ObtainOpti

; 1379 : 			options.searchForSourenOnCPU = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+68, r15d
	jmp	$LN1397@ObtainOpti
$LN27@ObtainOpti:

; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856692
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN25@ObtainOpti

; 1382 : 			options.useOpenCLForCUDADevices = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+76, r15d
	jmp	$LN1397@ObtainOpti
$LN25@ObtainOpti:

; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856691
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN23@ObtainOpti

; 1385 : 			options.isAVXEnabled = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+80, r12d
	jmp	$LN1397@ObtainOpti
$LN23@ObtainOpti:

; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856690
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN21@ObtainOpti

; 1388 : 			options.isAVX2Enabled = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+92, r12d
	jmp	$LN1397@ObtainOpti
$LN21@ObtainOpti:

; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856689
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN19@ObtainOpti

; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, r12d

; 1392 : 			options.useOneByteCharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, r15d
	jmp	$LN1397@ObtainOpti
$LN19@ObtainOpti:

; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856688
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN17@ObtainOpti

; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, r15d

; 1396 : 			options.useOneByteCharactersForKeys = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, r15d
	jmp	$LN1397@ObtainOpti
$LN17@ObtainOpti:

; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856687
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN15@ObtainOpti

; 1399 : 			options.useOneByteCharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, r12d

; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, r12d
	jmp	$LN1397@ObtainOpti
$LN15@ObtainOpti:

; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856686
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@ObtainOpti

; 1403 : 			options.useOneByteCharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+48, r12d

; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+84, r12d

; 1405 : 			options.maximizeKeySpace = TRUE;

	mov	DWORD PTR ?options@@3UOptions@@A+88, r15d
	jmp	SHORT $LN1397@ObtainOpti
$LN13@ObtainOpti:

; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856685
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN11@ObtainOpti

; 1408 : 			options.checkTripcodes = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+104, r12d
	jmp	SHORT $LN1397@ObtainOpti
$LN11@ObtainOpti:

; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856684
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	jne	SHORT $LN9@ObtainOpti

; 1411 : 			options.enableGCNAssembler = FALSE;

	mov	DWORD PTR ?options@@3UOptions@@A+108, r12d

; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0

	jmp	SHORT $LN1397@ObtainOpti
$LN9@ObtainOpti:

; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {

	lea	rdx, OFFSET FLAT:$SG4294856683
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	je	SHORT $LN1397@ObtainOpti
	lea	rdx, OFFSET FLAT:$SG4294856682
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	je	SHORT $LN1397@ObtainOpti
	lea	rdx, OFFSET FLAT:$SG4294856681
	mov	rcx, rbx
	call	strcmp
	test	eax, eax
	je	SHORT $LN1397@ObtainOpti

; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");

	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN1138@ObtainOpti
$LN1397@ObtainOpti:
	lea	r8, OFFSET FLAT:?patternFilePathArray@@3PAY0EAB@DA ; patternFilePathArray
$LN133@ObtainOpti:

; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {

	inc	edi
	cmp	edi, esi
	jl	$LL134@ObtainOpti
$LN1336@ObtainOpti:

; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {

	cmp	DWORD PTR ?numPatternFiles@@3HA, r12d	; numPatternFiles
	jg	SHORT $LN1434@ObtainOpti

; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);

	mov	eax, DWORD PTR $SG4294856676+8
	movsdx	xmm0, QWORD PTR $SG4294856676

; 1425 : 		numPatternFiles = 1;

	mov	DWORD PTR ?numPatternFiles@@3HA, r15d	; numPatternFiles
	mov	DWORD PTR ?patternFilePathArray@@3PAY0EAB@DA+8, eax
	movzx	eax, BYTE PTR $SG4294856676+12
	movsdx	QWORD PTR ?patternFilePathArray@@3PAY0EAB@DA, xmm0
	mov	BYTE PTR ?patternFilePathArray@@3PAY0EAB@DA+12, al
$LN1434@ObtainOpti:
	mov	r13, QWORD PTR [rsp+3280]
	mov	rdi, QWORD PTR [rsp+3264]
	mov	r15, QWORD PTR [rsp+3288]

; 1426 : 	}
; 1427 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 3216				; 00000c90H
	pop	r14
	pop	r12
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN1032@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	$LL1018@ObtainOpti
$LN1017@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1279 : 				   "The number of work items per WG must be a multiple of 8.");

	je	SHORT $LN92@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856744
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856743
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN91@ObtainOpti
$LN92@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856742
	lea	rcx, OFFSET FLAT:$SG4294856741
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN91@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	2
$LL928@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN927@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN942@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL928@ObtainOpti
$LN942@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL928@ObtainOpti
$LN927@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	je	SHORT $LN95@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856749
	mov	r9d, 256				; 00000100H
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856748
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN969@ObtainOpti
$LN95@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$12[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856747
	dec	rcx
	movaps	XMMWORD PTR line$12[rbp-256], xmm0
$LL1296@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1296@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856746
	movups	xmm1, XMMWORD PTR $SG4294856746+16
	movzx	eax, WORD PTR $SG4294856746+48
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856746+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	WORD PTR [rcx+48], ax
	lea	rcx, QWORD PTR line$12[rbp-256]
	dec	rcx
	npad	1
$LL1295@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1295@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856745
	movsdx	xmm1, QWORD PTR $SG4294856745+16
	movzx	eax, WORD PTR $SG4294856745+24
	mov	edx, 256				; 00000100H
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$12[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$2[rsp+4], r15d
	mov	DWORD PTR info$2[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$2[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN969@ObtainOpti:

; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL838@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN837@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN852@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL838@ObtainOpti
$LN852@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL838@ObtainOpti
$LN837@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	je	SHORT $LN98@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856754
	mov	r9d, r15d
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856753
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN879@ObtainOpti
$LN98@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$10[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856752
	dec	rcx
	movaps	XMMWORD PTR line$10[rbp-256], xmm0
	npad	7
$LL1294@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1294@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856751
	mov	eax, DWORD PTR $SG4294856751+48
	movups	xmm1, XMMWORD PTR $SG4294856751+16
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856751+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+48], eax
	movzx	eax, BYTE PTR $SG4294856751+52
	mov	BYTE PTR [rcx+52], al
	lea	rcx, QWORD PTR line$10[rbp-256]
	dec	rcx
$LL1293@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1293@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856750
	movsdx	xmm1, QWORD PTR $SG4294856750+16
	movzx	eax, WORD PTR $SG4294856750+24
	mov	edx, r15d
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$10[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$6[rsp+4], r15d
	mov	DWORD PTR info$6[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$6[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN879@ObtainOpti:

; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN762@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	$LL748@ObtainOpti
$LN747@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	je	SHORT $LN103@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856760
	mov	r9d, 16384				; 00004000H
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856759
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN789@ObtainOpti
$LN103@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$20[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856758
	dec	rcx
	movaps	XMMWORD PTR line$20[rbp-256], xmm0
	npad	8
$LL1292@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1292@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856757
	movups	xmm1, XMMWORD PTR $SG4294856757+16
	movzx	eax, WORD PTR $SG4294856757+48
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856757+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	WORD PTR [rcx+48], ax
	lea	rcx, QWORD PTR line$20[rbp-256]
	dec	rcx
	npad	1
$LL1291@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1291@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856756
	movsdx	xmm1, QWORD PTR $SG4294856756+16
	movzx	eax, WORD PTR $SG4294856756+24
	mov	edx, 16384				; 00004000H
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$20[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$4[rsp+4], r15d
	mov	DWORD PTR info$4[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$4[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN789@ObtainOpti:

; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL658@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN657@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN672@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL658@ObtainOpti
$LN672@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL658@ObtainOpti
$LN657@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	je	SHORT $LN106@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856765
	mov	r9d, r15d
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856764
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN699@ObtainOpti
$LN106@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$14[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856763
	dec	rcx
	movaps	XMMWORD PTR line$14[rbp-256], xmm0
	npad	1
$LL1290@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1290@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856762
	mov	eax, DWORD PTR $SG4294856762+48
	movups	xmm1, XMMWORD PTR $SG4294856762+16
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856762+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+48], eax
	movzx	eax, BYTE PTR $SG4294856762+52
	mov	BYTE PTR [rcx+52], al
	lea	rcx, QWORD PTR line$14[rbp-256]
	dec	rcx
	npad	9
$LL1289@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1289@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856761
	movsdx	xmm1, QWORD PTR $SG4294856761+16
	movzx	eax, WORD PTR $SG4294856761+24
	mov	edx, r15d
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$14[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$8[rsp+4], r15d
	mov	DWORD PTR info$8[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$8[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN699@ObtainOpti:

; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN582@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	$LL568@ObtainOpti
$LN567@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	je	SHORT $LN111@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856771
	mov	r9d, 256				; 00000100H
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856770
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN609@ObtainOpti
$LN111@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$18[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856769
	dec	rcx
	movaps	XMMWORD PTR line$18[rbp-256], xmm0
	npad	9
$LL1288@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1288@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856768
	mov	eax, DWORD PTR $SG4294856768+40
	movups	xmm1, XMMWORD PTR $SG4294856768+16
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	xmm0, QWORD PTR $SG4294856768+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movsdx	QWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+40], eax
	movzx	eax, WORD PTR $SG4294856768+44
	mov	WORD PTR [rcx+44], ax
	lea	rcx, QWORD PTR line$18[rbp-256]
	dec	rcx
	npad	6
$LL1287@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1287@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856767
	movsdx	xmm1, QWORD PTR $SG4294856767+16
	movzx	eax, WORD PTR $SG4294856767+24
	mov	edx, 256				; 00000100H
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$18[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$1[rsp+4], r15d
	mov	DWORD PTR info$1[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN609@ObtainOpti:

; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL478@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN477@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN492@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL478@ObtainOpti
$LN492@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL478@ObtainOpti
$LN477@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	je	SHORT $LN114@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856776
	mov	r9d, r15d
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856775
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN519@ObtainOpti
$LN114@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$16[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856774
	dec	rcx
	movaps	XMMWORD PTR line$16[rbp-256], xmm0
	npad	1
$LL1286@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1286@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856773
	movups	xmm1, XMMWORD PTR $SG4294856773+16
	movzx	eax, BYTE PTR $SG4294856773+48
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856773+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	BYTE PTR [rcx+48], al
	lea	rcx, QWORD PTR line$16[rbp-256]
	dec	rcx
	npad	2
$LL1285@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1285@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856772
	movsdx	xmm1, QWORD PTR $SG4294856772+16
	movzx	eax, WORD PTR $SG4294856772+24
	mov	edx, r15d
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$16[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$3[rsp+4], r15d
	mov	DWORD PTR info$3[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$3[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN519@ObtainOpti:

; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL388@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN387@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN402@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL388@ObtainOpti
$LN402@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL388@ObtainOpti
$LN387@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	je	SHORT $LN121@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856782
	mov	r8d, 6
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856781
	mov	edx, 6
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN429@ObtainOpti
$LN121@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856780
	lea	rcx, OFFSET FLAT:$SG4294856779
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$5[rsp+4], r15d
	mov	DWORD PTR info$5[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$5[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN429@ObtainOpti:

; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	9
$LL298@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN297@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN312@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL298@ObtainOpti
$LN312@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL298@ObtainOpti
$LN297@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1244 : 			       arguments[indexArg]);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1244 : 			       arguments[indexArg]);

	je	SHORT $LN124@ObtainOpti
	call	__iob_func
	mov	r9, QWORD PTR [r14+rdi*8]
	lea	rdx, OFFSET FLAT:$SG4294856787
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 6
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856786
	mov	edx, 6
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN339@ObtainOpti
$LN124@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$11[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856785
	dec	rcx
	movaps	XMMWORD PTR line$11[rbp-256], xmm0
	npad	2
$LL1284@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1284@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856784
	mov	eax, DWORD PTR $SG4294856784+40
	movups	xmm1, XMMWORD PTR $SG4294856784+16
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	xmm0, QWORD PTR $SG4294856784+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movsdx	QWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+40], eax
	movzx	eax, WORD PTR $SG4294856784+44
	mov	WORD PTR [rcx+44], ax
	movzx	eax, BYTE PTR $SG4294856784+46
	mov	BYTE PTR [rcx+46], al
	lea	rcx, QWORD PTR line$11[rbp-256]
	dec	rcx
$LL1283@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1283@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856783
	movsdx	xmm1, QWORD PTR $SG4294856783+16
	movzx	eax, WORD PTR $SG4294856783+24
	mov	rdx, QWORD PTR [r14+rdi*8]
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$11[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$7[rsp+4], r15d
	mov	DWORD PTR info$7[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$7[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN339@ObtainOpti:

; 1244 : 			       arguments[indexArg]);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL208@ObtainOpti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN207@ObtainOpti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN222@ObtainOpti

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL208@ObtainOpti
$LN222@ObtainOpti:

; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL208@ObtainOpti
$LN207@ObtainOpti:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, r15d ; wasSearchAbortedWithError

; 1236 : 			       arguments[indexArg]);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1236 : 			       arguments[indexArg]);

	je	SHORT $LN129@ObtainOpti
	call	__iob_func
	mov	r9, QWORD PTR [r14+rdi*8]
	lea	rdx, OFFSET FLAT:$SG4294856793
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 11
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856792
	mov	edx, 11
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN249@ObtainOpti
$LN129@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, QWORD PTR line$13[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856791
	dec	rax
	movaps	XMMWORD PTR line$13[rbp-256], xmm0
$LL1282@ObtainOpti:
	cmp	BYTE PTR [rax+1], r12b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL1282@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856790
	movups	xmm1, XMMWORD PTR $SG4294856790+16
	lea	rcx, QWORD PTR line$13[rbp-256]
	dec	rcx
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856790+32
	movups	XMMWORD PTR [rax+16], xmm1
	movups	XMMWORD PTR [rax+32], xmm0
	npad	9
$LL1281@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1281@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856789
	movsdx	xmm1, QWORD PTR $SG4294856789+16
	movzx	eax, WORD PTR $SG4294856789+24
	mov	rdx, QWORD PTR [r14+rdi*8]
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$13[rbp-256]
	call	printf
	call	_getch

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	mov	DWORD PTR info$9[rsp+4], r15d
	mov	DWORD PTR info$9[rsp], 100		; 00000064H
	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$9[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN249@ObtainOpti:

; 1236 : 			       arguments[indexArg]);

	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1132@ObtainOpti:

; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	SHORT $LN87@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856739
	mov	r9d, r15d
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856738
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN86@ObtainOpti
$LN87@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$15[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856737
	dec	rcx
	movaps	XMMWORD PTR line$15[rbp-256], xmm0
$LL1280@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1280@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856736
	mov	eax, DWORD PTR $SG4294856736+48
	movups	xmm1, XMMWORD PTR $SG4294856736+16
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856736+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+48], eax
	movzx	eax, WORD PTR $SG4294856736+52
	mov	WORD PTR [rcx+52], ax
	movzx	eax, BYTE PTR $SG4294856736+54
	mov	BYTE PTR [rcx+54], al
	lea	rcx, QWORD PTR line$15[rbp-256]
	dec	rcx
$LL1279@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1279@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856735
	movsdx	xmm1, QWORD PTR $SG4294856735+16
	movzx	eax, WORD PTR $SG4294856735+24
	mov	edx, r15d
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$15[rbp-256]
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN86@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN84@ObtainOpti:

; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);

	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$17[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856732
	dec	rcx
	movaps	XMMWORD PTR line$17[rbp-256], xmm0
$LL1278@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1278@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856731
	movups	xmm1, XMMWORD PTR $SG4294856731+16
	mov	eax, DWORD PTR $SG4294856731+48
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856731+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+48], eax
	lea	rcx, QWORD PTR line$17[rbp-256]
	dec	rcx
$LL1277@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1277@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856730
	movsdx	xmm1, QWORD PTR $SG4294856730+16
	movzx	eax, WORD PTR $SG4294856730+24
	mov	edx, 32					; 00000020H
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$17[rbp-256]
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN83@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1134@ObtainOpti:

; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	SHORT $LN79@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856728
	mov	r9d, r15d
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 10
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856727
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN78@ObtainOpti
$LN79@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$19[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856726
	dec	rcx
	movaps	XMMWORD PTR line$19[rbp-256], xmm0
$LL1276@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1276@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856725
	movups	xmm1, XMMWORD PTR $SG4294856725+16
	movzx	eax, BYTE PTR $SG4294856725+56
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856725+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movsdx	xmm1, QWORD PTR $SG4294856725+48
	movups	XMMWORD PTR [rcx+32], xmm0
	movsdx	QWORD PTR [rcx+48], xmm1
	mov	BYTE PTR [rcx+56], al
	lea	rcx, QWORD PTR line$19[rbp-256]
	dec	rcx
$LL1275@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1275@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856724
	movsdx	xmm1, QWORD PTR $SG4294856724+16
	movzx	eax, WORD PTR $SG4294856724+24
	mov	edx, r15d
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$19[rbp-256]
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN78@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN76@ObtainOpti:

; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);

	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rcx, QWORD PTR line$21[rbp-256]
	movups	xmm0, XMMWORD PTR $SG4294856721
	dec	rcx
	movaps	XMMWORD PTR line$21[rbp-256], xmm0
$LL1274@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1274@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856720
	mov	eax, DWORD PTR $SG4294856720+48
	movups	xmm1, XMMWORD PTR $SG4294856720+16
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR $SG4294856720+32
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	DWORD PTR [rcx+48], eax
	movzx	eax, WORD PTR $SG4294856720+52
	mov	WORD PTR [rcx+52], ax
	lea	rcx, QWORD PTR line$21[rbp-256]
	dec	rcx
	npad	6
$LL1273@ObtainOpti:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL1273@ObtainOpti
	movups	xmm0, XMMWORD PTR $SG4294856719
	movsdx	xmm1, QWORD PTR $SG4294856719+16
	movzx	eax, WORD PTR $SG4294856719+24
	mov	edx, 32					; 00000020H
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	QWORD PTR [rcx+16], xmm1
	mov	WORD PTR [rcx+24], ax
	lea	rcx, QWORD PTR line$21[rbp-256]
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN75@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN71@ObtainOpti:

; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");

	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856715
	lea	rcx, OFFSET FLAT:$SG4294856714
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN70@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN54@ObtainOpti:

; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");

	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856704
	lea	rcx, OFFSET FLAT:$SG4294856703
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN53@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1138@ObtainOpti:

; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	SHORT $LN3@ObtainOpti
	call	__iob_func
	lea	rdx, OFFSET FLAT:$SG4294856680
	mov	r8d, 10
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	rcx, OFFSET FLAT:$SG4294856679
	mov	edx, 10
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN2@ObtainOpti
$LN3@ObtainOpti:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856678
	lea	rcx, OFFSET FLAT:$SG4294856677
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN2@ObtainOpti:
	mov	ecx, r15d
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1437@ObtainOpti:

; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;

	call	__report_rangecheckfailure
	int	3
$LN157@ObtainOpti:

; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;

	call	__report_rangecheckfailure
	int	3
$LN143@ObtainOpti:

; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';

	call	__report_rangecheckfailure
	int	3
$LN1435@ObtainOpti:
?ObtainOptions@@YAXHPEAPEAD@Z ENDP			; ObtainOptions
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?OpenTripcodeFile@@YAXXZ
_TEXT	SEGMENT
?OpenTripcodeFile@@YAXXZ PROC				; OpenTripcodeFile, COMDAT

; 1567 : {

$LN103:
	sub	rsp, 40					; 00000028H

; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");

	lea	rdx, OFFSET FLAT:$SG4294856622
	lea	rcx, OFFSET FLAT:?tripcodeFilePath@@3PADA ; tripcodeFilePath
	call	fopen
	mov	QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA, rax ; tripcodeFile

; 1569 : 	ERROR0(tripcodeFilePath == NULL, ERROR_TRIPCODE_FILE, "The output file cannot be opened.");
; 1570 : }

	add	rsp, 40					; 00000028H
	ret	0
?OpenTripcodeFile@@YAXXZ ENDP				; OpenTripcodeFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?AddToNumGeneratedTripcodesByGPU@@YAXI@Z
_TEXT	SEGMENT
num$ = 48
?AddToNumGeneratedTripcodesByGPU@@YAXI@Z PROC		; AddToNumGeneratedTripcodesByGPU, COMDAT

; 1584 : {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx
	npad	8
$LL5@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN4@AddToNumGe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN19@AddToNumGe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@AddToNumGe
$LN19@AddToNumGe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@AddToNumGe
$LN4@AddToNumGe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1586 : 	numGeneratedTripcodes_GPU += num;

	mov	ecx, DWORD PTR ?numGeneratedTripcodes_GPU@@3IA ; numGeneratedTripcodes_GPU
	add	ecx, ebx
	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, ecx ; numGeneratedTripcodes_GPU

; 1587 : 	if (numGeneratedTripcodes_GPU >= 1000000) {

	cmp	ecx, 1000000				; 000f4240H
	jb	SHORT $LN49@AddToNumGe

; 1588 : 		numGeneratedTripcodesByGPUInMillions += numGeneratedTripcodes_GPU / 1000000;

	mov	eax, 1125899907				; 431bde83H
	mul	ecx
	shr	edx, 18
	add	DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA, edx ; numGeneratedTripcodesByGPUInMillions

; 1589 : 		numGeneratedTripcodes_GPU           %= 1000000;

	imul	eax, edx, -1000000			; fff0bdc0H
	add	ecx, eax
	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, ecx ; numGeneratedTripcodes_GPU
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1592 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN49@AddToNumGe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1592 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?AddToNumGeneratedTripcodesByGPU@@YAXI@Z ENDP		; AddToNumGeneratedTripcodesByGPU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetNumGeneratedTripcodesByCPU@@YANXZ
_TEXT	SEGMENT
?GetNumGeneratedTripcodesByCPU@@YANXZ PROC		; GetNumGeneratedTripcodesByCPU, COMDAT

; 1595 : {

$LN49:
	sub	rsp, 40					; 00000028H
$LL4@GetNumGene:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN3@GetNumGene
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@GetNumGene

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetNumGene
$LN18@GetNumGene:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetNumGene
$LN3@GetNumGene:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1599 : 	             +         numGeneratedTripcodes_CPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA ; numGeneratedTripcodesByCPUInMillions
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	cvtsi2sd xmm0, rax
	mov	eax, DWORD PTR ?numGeneratedTripcodes_CPU@@3IA ; numGeneratedTripcodes_CPU
	cvtsi2sd xmm1, rax
	mulsd	xmm0, QWORD PTR __real@412e848000000000

; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;

	xor	eax, eax
	mov	DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA, eax ; numGeneratedTripcodesByCPUInMillions

; 1601 : 	numGeneratedTripcodes_CPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, eax ; numGeneratedTripcodes_CPU
	addsd	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, eax ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1606 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetNumGeneratedTripcodesByCPU@@YANXZ ENDP		; GetNumGeneratedTripcodesByCPU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetNumGeneratedTripcodesByGPU@@YANXZ
_TEXT	SEGMENT
?GetNumGeneratedTripcodesByGPU@@YANXZ PROC		; GetNumGeneratedTripcodesByGPU, COMDAT

; 1609 : {

$LN49:
	sub	rsp, 40					; 00000028H
$LL4@GetNumGene:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN3@GetNumGene
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@GetNumGene

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@GetNumGene
$LN18@GetNumGene:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@GetNumGene
$LN3@GetNumGene:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1613 : 	             +         numGeneratedTripcodes_GPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA ; numGeneratedTripcodesByGPUInMillions
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
	cvtsi2sd xmm0, rax
	mov	eax, DWORD PTR ?numGeneratedTripcodes_GPU@@3IA ; numGeneratedTripcodes_GPU
	cvtsi2sd xmm1, rax
	mulsd	xmm0, QWORD PTR __real@412e848000000000

; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;

	xor	eax, eax
	mov	DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA, eax ; numGeneratedTripcodesByGPUInMillions

; 1615 : 	numGeneratedTripcodes_GPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, eax ; numGeneratedTripcodes_GPU
	addsd	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, eax ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1620 : }

	add	rsp, 40					; 00000028H
	ret	0
?GetNumGeneratedTripcodesByGPU@@YANXZ ENDP		; GetNumGeneratedTripcodesByGPU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetPauseState@@YAXH@Z
_TEXT	SEGMENT
newPauseState$ = 48
?SetPauseState@@YAXH@Z PROC				; SetPauseState, COMDAT

; 1623 : {

$LN50:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx
	npad	8
$LL4@SetPauseSt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN48@SetPauseSt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@SetPauseSt

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetPauseSt
$LN18@SetPauseSt:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetPauseSt
$LN48@SetPauseSt:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, ebx	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1627 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?SetPauseState@@YAXH@Z ENDP				; SetPauseState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?SetTerminationState@@YAXXZ
_TEXT	SEGMENT
?SetTerminationState@@YAXXZ PROC			; SetTerminationState, COMDAT

; 1655 : {

$LN50:
	sub	rsp, 40					; 00000028H
$LL4@SetTermina:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN48@SetTermina
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN18@SetTermina

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL4@SetTermina
$LN18@SetTermina:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL4@SetTermina
$LN48@SetTermina:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1657 : 	wasSearchTerminated = TRUE;

	mov	DWORD PTR ?wasSearchTerminated@@3HA, 1	; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1659 : }

	add	rsp, 40					; 00000028H
	ret	0
?SetTerminationState@@YAXXZ ENDP			; SetTerminationState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?UpdateCurrentStatus@@YAN_K@Z
_TEXT	SEGMENT
$T1 = 80
startingTime$ = 80
?UpdateCurrentStatus@@YAN_K@Z PROC			; UpdateCurrentStatus, COMDAT

; 1685 : {

$LN191:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm7
	npad	9
$LL5@UpdateCurr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LL25@UpdateCurr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN19@UpdateCurr

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL5@UpdateCurr
$LN19@UpdateCurr:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL5@UpdateCurr
$LL25@UpdateCurr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN24@UpdateCurr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN39@UpdateCurr

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL25@UpdateCurr
$LN39@UpdateCurr:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL25@UpdateCurr
$LN24@UpdateCurr:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1613 : 	             +         numGeneratedTripcodes_GPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA ; numGeneratedTripcodesByGPUInMillions
	xorps	xmm6, xmm6

; 1614 : 	numGeneratedTripcodesByGPUInMillions = 0;

	xor	edi, edi
	xorps	xmm0, xmm0
	mov	DWORD PTR ?numGeneratedTripcodesByGPUInMillions@@3IA, edi ; numGeneratedTripcodesByGPUInMillions
	cvtsi2sd xmm6, rax
	mov	eax, DWORD PTR ?numGeneratedTripcodes_GPU@@3IA ; numGeneratedTripcodes_GPU

; 1615 : 	numGeneratedTripcodes_GPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_GPU@@3IA, edi ; numGeneratedTripcodes_GPU
	cvtsi2sd xmm0, rax
	mulsd	xmm6, QWORD PTR __real@412e848000000000
	addsd	xmm6, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, edi ; num_generated_tripcodes_spinlock
$LL69@UpdateCurr:

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, 0 ; num_generated_tripcodes_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN68@UpdateCurr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN83@UpdateCurr

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL69@UpdateCurr
$LN83@UpdateCurr:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL69@UpdateCurr
$LN68@UpdateCurr:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1599 : 	             +         numGeneratedTripcodes_CPU;

	mov	eax, DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA ; numGeneratedTripcodesByCPUInMillions
	xorps	xmm7, xmm7
	xorps	xmm0, xmm0

; 1600 : 	numGeneratedTripcodesByCPUInMillions = 0;

	mov	DWORD PTR ?numGeneratedTripcodesByCPUInMillions@@3IA, edi ; numGeneratedTripcodesByCPUInMillions
	cvtsi2sd xmm7, rax
	mov	eax, DWORD PTR ?numGeneratedTripcodes_CPU@@3IA ; numGeneratedTripcodes_CPU

; 1601 : 	numGeneratedTripcodes_CPU           = 0;

	mov	DWORD PTR ?numGeneratedTripcodes_CPU@@3IA, edi ; numGeneratedTripcodes_CPU
	cvtsi2sd xmm0, rax
	mulsd	xmm7, QWORD PTR __real@412e848000000000
	addsd	xmm7, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?num_generated_tripcodes_spinlock@@3Vspinlock@@A, edi ; num_generated_tripcodes_spinlock
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	xorps	xmm1, xmm1
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, 3777893186295716171		; 346dc5d63886594bH
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T1[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1691 : 	double deltaTime = (endingTime - startingTime             ) * 0.001;

	sub	rdx, rbx
	cvtsi2sd xmm1, rdx
	jns	SHORT $LN185@UpdateCurr
	addsd	xmm1, QWORD PTR __real@43f0000000000000
$LN185@UpdateCurr:
	mulsd	xmm1, QWORD PTR __real@3f50624dd2f1a9fc

; 1692 : 
; 1693 : 	totalNumGeneratedTripcodes     += numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU;

	movsdx	xmm3, QWORD PTR ?totalNumGeneratedTripcodes@@3NA ; totalNumGeneratedTripcodes

; 1694 : 	totalNumGeneratedTripcodes_GPU += numGeneratedTripcodes_GPU;

	movsdx	xmm4, QWORD PTR ?totalNumGeneratedTripcodes_GPU@@3NA ; totalNumGeneratedTripcodes_GPU

; 1695 : 	totalNumGeneratedTripcodes_CPU += numGeneratedTripcodes_CPU;

	movsdx	xmm5, QWORD PTR ?totalNumGeneratedTripcodes_CPU@@3NA ; totalNumGeneratedTripcodes_CPU

; 1696 : 	totalTime += deltaTime;

	movsdx	xmm0, QWORD PTR ?totalTime@@3NA		; totalTime
	movaps	xmm2, xmm7
	addsd	xmm2, xmm6
	addsd	xmm4, xmm6
	addsd	xmm5, xmm7

; 1697 : 	currentSpeed_thisProcess     = ((double)(numGeneratedTripcodes_GPU + numGeneratedTripcodes_CPU) / deltaTime);
; 1698 : 	currentSpeed_thisProcess_GPU = ((double) numGeneratedTripcodes_GPU                              / deltaTime);

	divsd	xmm6, xmm1

; 1699 : 	currentSpeed_CPU        = ((double)numGeneratedTripcodes_CPU        / deltaTime);

	divsd	xmm7, xmm1
	addsd	xmm3, xmm2
	addsd	xmm0, xmm1
	movsdx	QWORD PTR ?totalNumGeneratedTripcodes_GPU@@3NA, xmm4 ; totalNumGeneratedTripcodes_GPU
	movsdx	QWORD PTR ?totalNumGeneratedTripcodes@@3NA, xmm3 ; totalNumGeneratedTripcodes
	movsdx	QWORD PTR ?totalNumGeneratedTripcodes_CPU@@3NA, xmm5 ; totalNumGeneratedTripcodes_CPU
	movsdx	QWORD PTR ?totalTime@@3NA, xmm0		; totalTime
	movsdx	QWORD PTR ?currentSpeed_thisProcess_GPU@@3NA, xmm6 ; currentSpeed_thisProcess_GPU
	movsdx	QWORD PTR ?currentSpeed_CPU@@3NA, xmm7	; currentSpeed_CPU
	divsd	xmm2, xmm1

; 1700 : 	if (maximumSpeed < currentSpeed_thisProcess)

	comisd	xmm2, QWORD PTR ?maximumSpeed@@3NA	; maximumSpeed
	movsdx	QWORD PTR ?currentSpeed_thisProcess@@3NA, xmm2 ; currentSpeed_thisProcess
	jbe	SHORT $LN1@UpdateCurr

; 1701 : 		maximumSpeed = currentSpeed_thisProcess;

	movsdx	QWORD PTR ?maximumSpeed@@3NA, xmm2	; maximumSpeed
$LN1@UpdateCurr:

; 1702 : 	prevTotalNumGeneratedTripcodes     = totalNumGeneratedTripcodes;
; 1703 : 	prevTotalNumGeneratedTripcodes_GPU = totalNumGeneratedTripcodes_GPU;
; 1704 : 	prevTotalNumGeneratedTripcodes_CPU = totalNumGeneratedTripcodes_CPU;
; 1705 : 	prevNumValidTripcodes     = numValidTripcodes;

	mov	eax, DWORD PTR ?numValidTripcodes@@3IA	; numValidTripcodes
	movsdx	QWORD PTR ?prevTotalNumGeneratedTripcodes@@3NA, xmm3 ; prevTotalNumGeneratedTripcodes
	movsdx	QWORD PTR ?prevTotalNumGeneratedTripcodes_GPU@@3NA, xmm4 ; prevTotalNumGeneratedTripcodes_GPU
	mov	DWORD PTR ?prevNumValidTripcodes@@3IA, eax ; prevNumValidTripcodes

; 1706 : 	prevNumDiscardedTripcodes = numDiscardedTripcodes;

	mov	eax, DWORD PTR ?numDiscardedTripcodes@@3IA ; numDiscardedTripcodes
	movsdx	QWORD PTR ?prevTotalNumGeneratedTripcodes_CPU@@3NA, xmm5 ; prevTotalNumGeneratedTripcodes_CPU
	mov	DWORD PTR ?prevNumDiscardedTripcodes@@3IA, eax ; prevNumDiscardedTripcodes

; 1711 : }

	mov	rbx, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, edi ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1710 : 	return deltaTime;

	movaps	xmm0, xmm1

; 1711 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?UpdateCurrentStatus@@YAN_K@Z ENDP			; UpdateCurrentStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartCUDADeviceSearchThreads@@YAXXZ
_TEXT	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?StartCUDADeviceSearchThreads@@YAXXZ PROC		; StartCUDADeviceSearchThreads, COMDAT

; 1793 : {

$LN1345:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-56]
	sub	rsp, 312				; 00000138H
	mov	QWORD PTR $T13[rbp-256], -2

; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	xor	r15d, r15d
	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	test	eax, eax
	jg	$LN62@StartCUDAD
$LL77@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN76@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN91@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL77@StartCUDAD
$LN91@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL77@StartCUDAD
$LN76@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	test	eax, eax
	jne	$LN1318@StartCUDAD
	npad	6
$LL121@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN120@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN135@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL121@StartCUDAD
$LN135@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL121@StartCUDAD
$LN120@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN61@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856613
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856612
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN162@StartCUDAD
$LN61@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1797				; 00000705H
	lea	rdx, OFFSET FLAT:$SG4294856611
	lea	rcx, OFFSET FLAT:$SG4294856610
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$17[rbp-252], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$17[rbp-256], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$17[rbp-256]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN162@StartCUDAD:

; 1797 : 	ASSERT(numCUDADeviceSearchThreads > 0);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1318@StartCUDAD:
	mov	eax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
$LN62@StartCUDAD:

; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	movsxd	rcx, eax
	mov	eax, 8
	mul	rcx
	mov	rcx, -1
	cmovo	rax, rcx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, rax
	call	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new[]
	mov	QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA, rax ; cuda_device_search_threads
	test	rax, rax
	jne	$LN59@StartCUDAD
	npad	10
$LL167@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN166@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN181@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL167@StartCUDAD
$LN181@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL167@StartCUDAD
$LN166@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN59@StartCUDAD
	npad	8
$LL211@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN210@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN225@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL211@StartCUDAD
$LN225@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL211@StartCUDAD
$LN210@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN58@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG4294856609
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG4294856608
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN281@StartCUDAD
$LN58@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856607
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$18[rbp-252], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$18[rbp-256], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$18[rbp-256]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN281@StartCUDAD:

; 1799 : 	ERROR0((cuda_device_search_threads = new (std::nothrow) std::thread *[numCUDADeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN59@StartCUDAD:

; 1800 : 	ERROR0((CUDADeviceSearchThreadInfoArray = (struct CUDADeviceSearchThreadInfo *)malloc(sizeof(struct CUDADeviceSearchThreadInfo) * numCUDADeviceSearchThreads)) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	movsxd	rax, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	imul	rcx, rax, 1680				; 00000690H
	call	malloc
	mov	QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA, rax ; CUDADeviceSearchThreadInfoArray
	test	rax, rax
	jne	$LN1319@StartCUDAD
	npad	8
$LL286@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN285@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN300@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL286@StartCUDAD
$LN300@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL286@StartCUDAD
$LN285@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1800 : 	ERROR0((CUDADeviceSearchThreadInfoArray = (struct CUDADeviceSearchThreadInfo *)malloc(sizeof(struct CUDADeviceSearchThreadInfo) * numCUDADeviceSearchThreads)) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN1319@StartCUDAD
	npad	8
$LL330@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN329@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN344@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL330@StartCUDAD
$LN344@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL330@StartCUDAD
$LN329@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1800 : 	ERROR0((CUDADeviceSearchThreadInfoArray = (struct CUDADeviceSearchThreadInfo *)malloc(sizeof(struct CUDADeviceSearchThreadInfo) * numCUDADeviceSearchThreads)) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN55@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG4294856606
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG4294856605
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN54@StartCUDAD
$LN55@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856604
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN54@StartCUDAD:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1319@StartCUDAD:

; 1801 : 	if (options.GPUIndex == GPU_INDEX_ALL) {

	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	cmp	ecx, -1
	jne	$LN53@StartCUDAD

; 1802 : 		int32_t CUDADeviceIndex;
; 1803 : 		for (CUDADeviceIndex = 0, i = 0; CUDADeviceIndex < CUDADeviceCount; ++CUDADeviceIndex) {

	mov	r12d, r15d
	mov	edi, r15d
	cmp	DWORD PTR ?CUDADeviceCount@@3HA, r15d	; CUDADeviceCount
	jle	$LN1322@StartCUDAD
	mov	r14, r15
	mov	r13, 3777893186295716171		; 346dc5d63886594bH
	npad	6
$LL52@StartCUDAD:

; 1804 : 			for (int32_t j = 0; j < CUDA_NUM_THREADS_PER_DEVICE; ++j, ++i) {

	mov	ebx, r15d
	imul	rsi, r14, 1680				; 00000690H
	npad	6
$LL49@StartCUDAD:

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	cmp	edi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LN46@StartCUDAD
	npad	8
$LL403@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN402@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN417@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL403@StartCUDAD
$LN417@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL403@StartCUDAD
$LN402@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	test	eax, eax
	je	$LL447@StartCUDAD
$LN46@StartCUDAD:

; 1806 : 				CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = CUDADeviceIndex;

	mov	rax, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	mov	DWORD PTR [rsi+rax], r12d

; 1807 : 				CUDADeviceSearchThreadInfoArray[i].subindex = j;

	mov	DWORD PTR [rsi+rax+4], ebx

; 1808 : 				CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';

	mov	BYTE PTR [rsi+rax+640], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T11[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1809 : 				CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	r8, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	mov	QWORD PTR [rsi+r8+1672], rdx

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	movsxd	rax, edi
	imul	rcx, rax, 1680				; 00000690H
	add	rcx, 8
	add	rcx, r8
	mov	edx, r12d
	call	QWORD PTR __imp_cudaGetDeviceProperties
	mov	r15d, eax
	test	eax, eax
	je	SHORT $LN48@StartCUDAD
	npad	1
$LL527@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN526@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN541@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL527@StartCUDAD
$LN541@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL527@StartCUDAD
$LN526@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	test	eax, eax
	je	SHORT $LL571@StartCUDAD
$LN48@StartCUDAD:

; 1804 : 			for (int32_t j = 0; j < CUDA_NUM_THREADS_PER_DEVICE; ++j, ++i) {

	inc	ebx
	inc	edi
	inc	r14
	add	rsi, 1680				; 00000690H
	cmp	ebx, 2
	mov	r15d, 0
	jl	$LL49@StartCUDAD

; 1802 : 		int32_t CUDADeviceIndex;
; 1803 : 		for (CUDADeviceIndex = 0, i = 0; CUDADeviceIndex < CUDADeviceCount; ++CUDADeviceIndex) {

	inc	r12d
	cmp	r12d, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jge	$LN1322@StartCUDAD
	jmp	$LL52@StartCUDAD
	npad	7
$LL571@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN570@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN585@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL571@StartCUDAD
$LN585@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL571@StartCUDAD
$LN570@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN42@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG4294856599
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 4
	lea	rcx, OFFSET FLAT:$SG4294856598
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN612@StartCUDAD
$LN42@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856597
	mov	rbx, rax
	mov	cl, 46					; 0000002eH
$LL40@StartCUDAD:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN36@StartCUDAD
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN39@StartCUDAD
$LN36@StartCUDAD:
	lea	rbx, QWORD PTR [rax+1]
$LN39@StartCUDAD:
	inc	rax
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	jne	SHORT $LL40@StartCUDAD
	mov	ecx, r15d
	call	QWORD PTR __imp_cudaGetErrorString
	mov	rdx, rax
	mov	DWORD PTR [rsp+32], 1810		; 00000712H
	mov	r9, rbx
	mov	r8d, r15d
	lea	rcx, OFFSET FLAT:$SG4294856596
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$19[rbp-252], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$19[rbp-256], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$19[rbp-256]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN612@StartCUDAD:

; 1810 : 				CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, CUDADeviceIndex));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LL447@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN446@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN461@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL447@StartCUDAD
$LN461@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL447@StartCUDAD
$LN446@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN45@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856603
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856602
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN488@StartCUDAD
$LN45@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1805				; 0000070dH
	lea	rdx, OFFSET FLAT:$SG4294856601
	lea	rcx, OFFSET FLAT:$SG4294856600
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$20[rbp-252], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$20[rbp-256], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$20[rbp-256]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN488@StartCUDAD:

; 1805 : 				ASSERT(i < numCUDADeviceSearchThreads);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN53@StartCUDAD:

; 1811 : 			}
; 1812 : 		}
; 1813 : 	} else if (options.GPUIndex < CUDADeviceCount) {

	cmp	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	jge	$LN1322@StartCUDAD

; 1814 : 		ASSERT(numCUDADeviceSearchThreads == CUDA_NUM_THREADS_PER_DEVICE);

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 2 ; numCUDADeviceSearchThreads
	je	$LN33@StartCUDAD
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1321@StartCUDAD
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN32@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856595
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856594
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN31@StartCUDAD
$LN32@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1814				; 00000716H
	lea	rdx, OFFSET FLAT:$SG4294856593
	lea	rcx, OFFSET FLAT:$SG4294856592
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN31@StartCUDAD:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1321@StartCUDAD:
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
$LN33@StartCUDAD:

; 1815 : 		for (i = 0; i < CUDA_NUM_THREADS_PER_DEVICE; ++i) {

	mov	ebx, r15d
	mov	rdi, r15
	mov	r13, 3777893186295716171		; 346dc5d63886594bH
	npad	5
$LL30@StartCUDAD:

; 1816 : 			CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex = options.GPUIndex;

	mov	rax, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	mov	DWORD PTR [rdi+rax], ecx

; 1817 : 			CUDADeviceSearchThreadInfoArray[i].subindex = i;

	mov	DWORD PTR [rdi+rax+4], ebx

; 1818 : 			CUDADeviceSearchThreadInfoArray[i].status[0] = '\0';

	mov	BYTE PTR [rdi+rax+640], r15b
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T8[rsp], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1819 : 			CUDADeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	r8, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
	mov	QWORD PTR [rdi+r8+1672], rdx

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	movsxd	rax, ebx
	imul	rcx, rax, 1680				; 00000690H
	add	rcx, 8
	add	rcx, r8
	mov	edx, DWORD PTR ?options@@3UOptions@@A
	call	QWORD PTR __imp_cudaGetDeviceProperties
	mov	esi, eax
	test	eax, eax
	je	SHORT $LN29@StartCUDAD
	npad	7
$LL651@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN650@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN665@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL651@StartCUDAD
$LN665@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL651@StartCUDAD
$LN650@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	test	eax, eax
	je	SHORT $LN1186@StartCUDAD
$LN29@StartCUDAD:

; 1815 : 		for (i = 0; i < CUDA_NUM_THREADS_PER_DEVICE; ++i) {

	inc	ebx
	add	rdi, 1680				; 00000690H
	cmp	ebx, 2
	jge	$LN1322@StartCUDAD
	mov	ecx, DWORD PTR ?options@@3UOptions@@A
	jmp	$LL30@StartCUDAD
$LN1186@StartCUDAD:

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r15d
	je	SHORT $LN26@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG4294856591
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 4
	lea	rcx, OFFSET FLAT:$SG4294856590
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	$LN692@StartCUDAD
$LN26@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856589
	mov	rbx, rax
	mov	cl, 46					; 0000002eH
$LL24@StartCUDAD:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN20@StartCUDAD
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN23@StartCUDAD
$LN20@StartCUDAD:
	lea	rbx, QWORD PTR [rax+1]
$LN23@StartCUDAD:
	inc	rax
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	jne	SHORT $LL24@StartCUDAD
	mov	ecx, esi
	call	QWORD PTR __imp_cudaGetErrorString
	mov	rdx, rax
	mov	DWORD PTR [rsp+32], 1820		; 0000071cH
	mov	r9, rbx
	mov	r8d, esi
	lea	rcx, OFFSET FLAT:$SG4294856588
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$7[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$7[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$7[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN692@StartCUDAD:

; 1820 : 			CUDA_ERROR(cudaGetDeviceProperties(&CUDADeviceSearchThreadInfoArray[i].properties, options.GPUIndex));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1322@StartCUDAD:

; 1821 : 		}
; 1822 : 	}
; 1823 : 
; 1824 : 	if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12
	jne	$LN19@StartCUDAD

; 1825 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	mov	esi, r15d
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads
	jle	$LN1303@StartCUDAD
	mov	r14, r15
	lea	r13, OFFSET FLAT:?Thread_SearchForSHA1TripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnCUDADevice
	lea	r12, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	npad	6
$LL18@StartCUDAD:

; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	ecx, 16
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new
	mov	rdi, rax
	mov	QWORD PTR $T4[rsp], rax
	test	rax, rax
	je	SHORT $LN65@StartCUDAD
	movsxd	rcx, esi
	imul	rbx, rcx, 1680				; 00000690H
	add	rbx, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T15[rbp-256], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T15[rbp-248], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$12[rbp-256]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$12[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$12[rbp-224], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$12[rbp-216], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$12[rbp-256]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$12[rbp-256]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1826 : 			cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	jmp	SHORT $LN66@StartCUDAD
$LN65@StartCUDAD:
	mov	rdi, r15
$LN66@StartCUDAD:
	mov	rax, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
	mov	QWORD PTR [r14+rax], rdi

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	rdi, rdi
	jne	SHORT $LN17@StartCUDAD
	npad	9
$LL763@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN762@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN777@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL763@StartCUDAD
$LN777@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL763@StartCUDAD
$LN762@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	eax, eax
	je	SHORT $LL807@StartCUDAD
$LN17@StartCUDAD:

; 1825 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	esi
	add	r14, 8
	cmp	esi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jge	$LN1303@StartCUDAD
	jmp	$LL18@StartCUDAD
	npad	5
$LL807@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN806@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN821@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL807@StartCUDAD
$LN821@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL807@StartCUDAD
$LN806@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN14@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 12
	lea	rdx, OFFSET FLAT:$SG4294856587
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 12
	lea	rcx, OFFSET FLAT:$SG4294856586
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN848@StartCUDAD
$LN14@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856585
	lea	rcx, OFFSET FLAT:$SG4294856584
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$6[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$6[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$6[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN848@StartCUDAD:

; 1827 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN19@StartCUDAD:

; 1830 : 		ASSERT(lenTripcode == 10);

	cmp	eax, 10
	je	$LN1323@StartCUDAD
	npad	8
$LL853@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN852@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN867@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL853@StartCUDAD
$LN867@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL853@StartCUDAD
$LN852@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1830 : 		ASSERT(lenTripcode == 10);

	test	eax, eax
	jne	$LN1323@StartCUDAD
	npad	8
$LL897@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN896@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN911@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL897@StartCUDAD
$LN911@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL897@StartCUDAD
$LN896@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r15d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1830 : 		ASSERT(lenTripcode == 10);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN10@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856583
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856582
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN938@StartCUDAD
$LN10@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1830				; 00000726H
	lea	rdx, OFFSET FLAT:$SG4294856581
	lea	rcx, OFFSET FLAT:$SG4294856580
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$1[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$1[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$1[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN938@StartCUDAD:

; 1830 : 		ASSERT(lenTripcode == 10);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1323@StartCUDAD:

; 1831 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	mov	esi, r15d
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads
	jle	$LN1303@StartCUDAD
	mov	r14, r15
	lea	r12, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	lea	r13, OFFSET FLAT:?Thread_SearchForDESTripcodesOnCUDADevice_Registers@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice_Registers
	npad	10
$LL8@StartCUDAD:

; 1832 : 			if (CUDADeviceSearchThreadInfoArray[i].properties.major >= 5) {

	mov	rax, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray

; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	ecx, 16

; 1832 : 			if (CUDADeviceSearchThreadInfoArray[i].properties.major >= 5) {

	cmp	DWORD PTR [r15+rax+336], 5
	jl	SHORT $LN5@StartCUDAD

; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));

	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new
	mov	rdi, rax
	mov	QWORD PTR $T3[rsp], rax
	test	rax, rax
	je	SHORT $LN67@StartCUDAD
	movsxd	rcx, esi
	imul	rbx, rcx, 1680				; 00000690H
	add	rbx, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T9[rsp], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T9[rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$14[rbp-256]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$14[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$14[rbp-224], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$14[rbp-216], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$14[rbp-256]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$14[rbp-256]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1833 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice_Registers, &(CUDADeviceSearchThreadInfoArray[i]));

	jmp	SHORT $LN68@StartCUDAD
$LN67@StartCUDAD:
	xor	edi, edi
$LN68@StartCUDAD:

; 1834 : 			} else {

	jmp	SHORT $LN1344@StartCUDAD
$LN5@StartCUDAD:

; 1835 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new
	mov	rdi, rax
	mov	QWORD PTR $T2[rsp], rax
	test	rax, rax
	je	SHORT $LN69@StartCUDAD
	movsxd	rcx, esi
	imul	rbx, rcx, 1680				; 00000690H
	add	rbx, QWORD PTR ?CUDADeviceSearchThreadInfoArray@@3PEAUCUDADeviceSearchThreadInfo@@EA ; CUDADeviceSearchThreadInfoArray
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	lea	rax, OFFSET FLAT:?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice
	mov	QWORD PTR $T10[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T10[rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$16[rbp-256]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$16[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	lea	rax, OFFSET FLAT:?Thread_SearchForDESTripcodesOnCUDADevice@@YAXPEAUCUDADeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnCUDADevice
	mov	QWORD PTR _Launcher$16[rbp-224], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$16[rbp-216], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$16[rbp-256]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$16[rbp-256]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1835 : 				cuda_device_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCUDADevice, &(CUDADeviceSearchThreadInfoArray[i]));

	jmp	SHORT $LN70@StartCUDAD
$LN69@StartCUDAD:
	xor	edi, edi
$LN70@StartCUDAD:
$LN1344@StartCUDAD:
	mov	rcx, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
	add	rcx, r14
	mov	QWORD PTR [rcx], rdi

; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	rdi, rdi
	jne	SHORT $LN7@StartCUDAD
	npad	8
$LL1075@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1074@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1089@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1075@StartCUDAD
$LN1089@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1075@StartCUDAD
$LN1074@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	test	eax, eax
	je	SHORT $LL1119@StartCUDAD
$LN7@StartCUDAD:

; 1831 : 		for (i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	esi
	add	r15, 1680				; 00000690H
	add	r14, 8
	cmp	esi, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jge	$LN1303@StartCUDAD
	jmp	$LL8@StartCUDAD
$LL1119@StartCUDAD:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1118@StartCUDAD
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1133@StartCUDAD

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1119@StartCUDAD
$LN1133@StartCUDAD:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1119@StartCUDAD
$LN1118@StartCUDAD:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartCUDAD
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 12
	lea	rdx, OFFSET FLAT:$SG4294856579
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 12
	lea	rcx, OFFSET FLAT:$SG4294856578
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN1160@StartCUDAD
$LN2@StartCUDAD:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856577
	lea	rcx, OFFSET FLAT:$SG4294856576
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$5[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$5[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$5[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN1160@StartCUDAD:

; 1837 : 			ERROR0((cuda_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CUDA device search thread.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1303@StartCUDAD:

; 1838 : 		}
; 1839 : 	}
; 1840 : }

	add	rsp, 312				; 00000138H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN1343@StartCUDAD:
?StartCUDADeviceSearchThreads@@YAXXZ ENDP		; StartCUDADeviceSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAXAEBUnothrow_t@std@@@Z	; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$3@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$3
	lea	rcx, QWORD PTR _Launcher$12[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$3@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAXAEBUnothrow_t@std@@@Z	; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$5@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$5
	lea	rcx, QWORD PTR _Launcher$14[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$5@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXAEBUnothrow_t@std@@@Z	; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
info$5 = 64
info$6 = 72
info$7 = 80
$T8 = 88
$T9 = 96
$T10 = 112
$T11 = 128
_Launcher$12 = 136
$T13 = 184
_Launcher$14 = 192
$T15 = 240
_Launcher$16 = 256
info$17 = 384
info$18 = 392
info$19 = 400
info$20 = 408
?dtor$7@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA PROC ; `StartCUDADeviceSearchThreads'::`1'::dtor$7
	lea	rcx, QWORD PTR _Launcher$16[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$7@?0??StartCUDADeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartCUDADeviceSearchThreads'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartOpenCLDeviceSearchThreads@@YAXXZ
_TEXT	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
$T10 = 120
$T11 = 120
$T12 = 128
$T13 = 136
$T14 = 144
$T15 = 152
$T16 = 168
$T17 = 176
$T18 = 192
_Launcher$19 = 200
$T20 = 248
_Launcher$21 = 256
$T22 = 304
deviceVendor$ = 320
__$ArrayPad$ = 1344
?StartOpenCLDeviceSearchThreads@@YAXXZ PROC		; StartOpenCLDeviceSearchThreads, COMDAT

; 1843 : {

$LN1652:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1144]
	sub	rsp, 1360				; 00000550H
	mov	QWORD PTR $T13[rbp-256], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	xor	ebx, ebx
	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	test	eax, eax
	jg	$LN82@StartOpenC
	npad	1
$LL94@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN93@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN108@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL94@StartOpenC
$LN108@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL94@StartOpenC
$LN93@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	test	eax, eax
	jne	$LN1619@StartOpenC
	npad	9
$LL138@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN137@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN152@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL138@StartOpenC
$LN152@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL138@StartOpenC
$LN137@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	SHORT $LN81@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856575
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856574
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN179@StartOpenC
$LN81@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1848				; 00000738H
	lea	rdx, OFFSET FLAT:$SG4294856573
	lea	rcx, OFFSET FLAT:$SG4294856572
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$9[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$9[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$9[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN179@StartOpenC:

; 1848 : 	ASSERT(numOpenCLDeviceSearchThreads > 0);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1619@StartOpenC:
	mov	eax, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
$LN82@StartOpenC:

; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	movsxd	rcx, eax
	mov	eax, 8
	mul	rcx
	mov	rsi, -1
	cmovo	rax, rsi
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, rax
	call	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new[]
	mov	QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA, rax ; opencl_device_search_threads
	test	rax, rax
	jne	$LN79@StartOpenC
	npad	2
$LL184@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN183@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN198@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL184@StartOpenC
$LN198@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL184@StartOpenC
$LN183@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN79@StartOpenC
	npad	9
$LL228@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN227@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN242@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL228@StartOpenC
$LN242@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL228@StartOpenC
$LN227@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	SHORT $LN78@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG4294856571
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG4294856570
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN298@StartOpenC
$LN78@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856569
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$3[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$3[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$3[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN298@StartOpenC:

; 1850 : 	ERROR0((opencl_device_search_threads = new (std::nothrow) std::thread *[numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN79@StartOpenC:

; 1851 : 	ERROR0((openCLDeviceSearchThreadInfoArray = new (std::nothrow) struct OpenCLDeviceSearchThreadInfo [numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	movsxd	rcx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	mov	eax, 1104				; 00000450H
	mul	rcx
	cmovo	rax, rsi
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, rax
	call	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new[]
	mov	QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA, rax ; openCLDeviceSearchThreadInfoArray
	test	rax, rax
	jne	$LN1650@StartOpenC
	npad	1
$LL303@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN302@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN317@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL303@StartOpenC
$LN317@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL303@StartOpenC
$LN302@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1851 : 	ERROR0((openCLDeviceSearchThreadInfoArray = new (std::nothrow) struct OpenCLDeviceSearchThreadInfo [numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN76@StartOpenC
	npad	5
$LL347@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN346@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN361@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL347@StartOpenC
$LN361@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL347@StartOpenC
$LN346@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, ebx ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1851 : 	ERROR0((openCLDeviceSearchThreadInfoArray = new (std::nothrow) struct OpenCLDeviceSearchThreadInfo [numOpenCLDeviceSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, ebx
	je	SHORT $LN75@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG4294856568
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG4294856567
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN74@StartOpenC
$LN75@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856566
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN74@StartOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1650@StartOpenC:
	xor	r8d, r8d
$LN76@StartOpenC:

; 1852 : 	if (options.GPUIndex == GPU_INDEX_ALL) {

	mov	edi, DWORD PTR ?options@@3UOptions@@A
	cmp	edi, esi
	jne	$LN73@StartOpenC

; 1853 : 		int32_t openCLDeviceIDArrayIndex = 0;

	mov	r15d, r8d

; 1854 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	edi, r8d
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, ebx ; numOpenCLDeviceSearchThreads
	jle	$LN1649@StartOpenC
	mov	r14, r8

; 1853 : 		int32_t openCLDeviceIDArrayIndex = 0;

	mov	r12, r8
	mov	r13, 3777893186295716171		; 346dc5d63886594bH
	npad	4
$LL72@StartOpenC:

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	mov	QWORD PTR [rsp+32], r8
	lea	r9, QWORD PTR deviceVendor$[rbp-256]
	mov	edx, 4140				; 0000102cH
	mov	r8d, 1024				; 00000400H
	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [r12+rcx]
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN1646@StartOpenC
	npad	5
$LL420@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN419@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN434@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL420@StartOpenC
$LN434@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL420@StartOpenC
$LN419@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	test	eax, eax
	je	$LL464@StartOpenC
	jmp	SHORT $LN69@StartOpenC
$LN1646@StartOpenC:
	xor	r8d, r8d
$LN69@StartOpenC:

; 1856 : 			openCLDeviceSearchThreadInfoArray[i].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	imul	rbx, r14, 1104				; 00000450H
	mov	rdx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [r12+rax]
	mov	QWORD PTR [rbx+rdx], rcx

; 1857 : 			openCLDeviceSearchThreadInfoArray[i].index           = openCLDeviceIDArrayIndex;

	mov	DWORD PTR [rbx+rdx+8], r15d

; 1858 : 			openCLDeviceSearchThreadInfoArray[i].subindex        = -1;

	mov	DWORD PTR [rbx+rdx+12], esi

; 1859 : 			openCLDeviceSearchThreadInfoArray[i].status[0]       = '\0';

	mov	BYTE PTR [rbx+rdx+16], 0

; 1860 : 			openCLDeviceSearchThreadInfoArray[i].runChildProcess = openCLRunChildProcesses;

	mov	eax, DWORD PTR ?openCLRunChildProcesses@@3HA ; openCLRunChildProcesses
	mov	DWORD PTR [rbx+rdx+1080], eax

; 1861 : 			openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	QWORD PTR [rbx+rdx+1088], r8

; 1862 : 			//
; 1863 : 			openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	ecx, r15d
	mov	DWORD PTR [rbx+rdx+1040], ecx

; 1864 : 			openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;

	mov	QWORD PTR [rbx+rdx+1048], r8

; 1865 : 			openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;

	mov	QWORD PTR [rbx+rdx+1056], r8

; 1866 : 			openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;

	mov	QWORD PTR [rbx+rdx+1064], r8

; 1867 : 			openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;

	mov	QWORD PTR [rbx+rdx+1072], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T12[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1869 : 			openCLDeviceSearchThreadInfoArray[i].timeLastUpdated            = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	rax, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rbx+rax+1096], rdx

; 1870 : 			openCLDeviceSearchThreadInfoArray[i].subindex                   = 0;

	xor	r8d, r8d
	mov	DWORD PTR [rbx+rax+12], r8d

; 1872 : 				for (j = 1; j < options.openCLNumThreads; ++j) {

	lea	esi, QWORD PTR [r8+1]

; 1871 : 			if (!openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, r8d ; openCLRunChildProcesses
	jne	$LN61@StartOpenC

; 1872 : 				for (j = 1; j < options.openCLNumThreads; ++j) {

	cmp	DWORD PTR ?options@@3UOptions@@A+44, esi
	jle	$LN48@StartOpenC
	npad	8
$LL60@StartOpenC:

; 1873 : 					++i;

	inc	edi
	inc	r14
	lea	rbx, QWORD PTR [rbx+1104]

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LN57@StartOpenC
$LL544@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN543@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN558@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL544@StartOpenC
$LN558@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL544@StartOpenC
$LN543@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	test	eax, eax
	je	$LL588@StartOpenC
$LN57@StartOpenC:

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	r15d, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN54@StartOpenC
	npad	8
$LL634@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN633@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN648@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL634@StartOpenC
$LN648@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL634@StartOpenC
$LN633@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	test	eax, eax
	je	$LL678@StartOpenC
$LN54@StartOpenC:

; 1876 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	rdx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [r12+rax]
	mov	QWORD PTR [rbx+rdx], rcx

; 1877 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;

	mov	DWORD PTR [rbx+rdx+8], r15d

; 1878 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;

	mov	DWORD PTR [rbx+rdx+12], esi

; 1879 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';

	mov	BYTE PTR [rbx+rdx+16], 0

; 1882 : 					openCLDeviceSearchThreadInfoArray[i].numRestarts = 0;

	mov	QWORD PTR [rbx+rdx+1076], 0

; 1880 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = FALSE;
; 1881 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	QWORD PTR [rbx+rdx+1088], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T14[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1883 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	rax, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rbx+rax+1096], rdx

; 1872 : 				for (j = 1; j < options.openCLNumThreads; ++j) {

	inc	esi
	cmp	esi, DWORD PTR ?options@@3UOptions@@A+44
	mov	r8d, 0
	jl	$LL60@StartOpenC

; 1884 : 				}

	jmp	$LN48@StartOpenC
$LN61@StartOpenC:

; 1885 : 			} else {
; 1886 : 				openCLDeviceSearchThreadInfoArray[i].subindex       = 0;

	mov	DWORD PTR [rbx+rax+12], r8d

; 1887 : 				for (j = 1; j < options.openCLNumProcesses; ++j) {

	cmp	DWORD PTR ?options@@3UOptions@@A+100, esi
	jle	$LN48@StartOpenC
	npad	4
$LL50@StartOpenC:

; 1888 : 					++i;

	inc	edi
	inc	r14
	lea	rbx, QWORD PTR [rbx+1104]

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LN47@StartOpenC
$LL758@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN757@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN772@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL758@StartOpenC
$LN772@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL758@StartOpenC
$LN757@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	test	eax, eax
	je	$LL802@StartOpenC
$LN47@StartOpenC:

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	r15d, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN44@StartOpenC
	npad	8
$LL848@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN847@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN862@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL848@StartOpenC
$LN862@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL848@StartOpenC
$LN847@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	xor	r8d, r8d
	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r8d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	test	eax, eax
	je	$LL892@StartOpenC
$LN44@StartOpenC:

; 1891 : 					openCLDeviceSearchThreadInfoArray[i].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	rdx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [r12+rax]
	mov	QWORD PTR [rbx+rdx], rcx

; 1892 : 					openCLDeviceSearchThreadInfoArray[i].index          = openCLDeviceIDArrayIndex;

	mov	DWORD PTR [rbx+rdx+8], r15d

; 1893 : 					openCLDeviceSearchThreadInfoArray[i].subindex       = j;

	mov	DWORD PTR [rbx+rdx+12], esi

; 1894 : 					openCLDeviceSearchThreadInfoArray[i].status[0]      = '\0';

	mov	BYTE PTR [rbx+rdx+16], 0

; 1895 : 					openCLDeviceSearchThreadInfoArray[i].runChildProcess = TRUE;

	mov	DWORD PTR [rbx+rdx+1080], 1

; 1896 : 					openCLDeviceSearchThreadInfoArray[i].child_process = NULL;

	mov	QWORD PTR [rbx+rdx+1088], r8

; 1897 : 					//
; 1898 : 					openCLDeviceSearchThreadInfoArray[i].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	ecx, r15d
	mov	DWORD PTR [rbx+rdx+1040], ecx

; 1899 : 					openCLDeviceSearchThreadInfoArray[i].currentSpeed               = 0;

	mov	QWORD PTR [rbx+rdx+1048], r8

; 1900 : 					openCLDeviceSearchThreadInfoArray[i].averageSpeed               = 0;

	mov	QWORD PTR [rbx+rdx+1056], r8

; 1901 : 					openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes = 0;

	mov	QWORD PTR [rbx+rdx+1064], r8

; 1902 : 					openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes      = 0;

	mov	QWORD PTR [rbx+rdx+1072], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T22[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1904 : 					openCLDeviceSearchThreadInfoArray[i].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	rax, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rbx+rax+1096], rdx

; 1887 : 				for (j = 1; j < options.openCLNumProcesses; ++j) {

	inc	esi
	cmp	esi, DWORD PTR ?options@@3UOptions@@A+100
	mov	r8d, 0
	jl	$LL50@StartOpenC
$LN48@StartOpenC:

; 1905 : 				}
; 1906 : 			}
; 1907 : 			++openCLDeviceIDArrayIndex;

	inc	r15d
	add	r12, 8

; 1854 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	edi
	inc	r14
	cmp	edi, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jge	$LN1649@StartOpenC
	or	rsi, -1
	jmp	$LL72@StartOpenC
	npad	6
$LL892@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN891@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN906@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL892@StartOpenC
$LN906@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL892@StartOpenC
$LN891@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN43@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856549
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856548
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN933@StartOpenC
$LN43@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1890				; 00000762H
	lea	rdx, OFFSET FLAT:$SG4294856547
	lea	rcx, OFFSET FLAT:$SG4294856546
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$7[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$7[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$7[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN933@StartOpenC:

; 1890 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	8
$LL802@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN801@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN816@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL802@StartOpenC
$LN816@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL802@StartOpenC
$LN801@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN46@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856553
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856552
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN843@StartOpenC
$LN46@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1889				; 00000761H
	lea	rdx, OFFSET FLAT:$SG4294856551
	lea	rcx, OFFSET FLAT:$SG4294856550
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$5[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$5[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$5[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN843@StartOpenC:

; 1889 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	8
$LL678@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN677@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN692@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL678@StartOpenC
$LN692@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL678@StartOpenC
$LN677@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN53@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856557
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856556
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN719@StartOpenC
$LN53@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1875				; 00000753H
	lea	rdx, OFFSET FLAT:$SG4294856555
	lea	rcx, OFFSET FLAT:$SG4294856554
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$1[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$1[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$1[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN719@StartOpenC:

; 1875 : 					ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	8
$LL588@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN587@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN602@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL588@StartOpenC
$LN602@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL588@StartOpenC
$LN587@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN56@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856561
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856560
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN629@StartOpenC
$LN56@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1874				; 00000752H
	lea	rdx, OFFSET FLAT:$SG4294856559
	lea	rcx, OFFSET FLAT:$SG4294856558
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$2[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$2[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$2[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN629@StartOpenC:

; 1874 : 					ASSERT(i < numOpenCLDeviceSearchThreads);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	8
$LL464@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN463@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN478@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL464@StartOpenC
$LN478@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL464@StartOpenC
$LN463@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN68@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 15
	lea	rdx, OFFSET FLAT:$SG4294856565
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 15
	lea	rcx, OFFSET FLAT:$SG4294856564
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN505@StartOpenC
$LN68@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856563
	mov	r8, rax
	mov	cl, 46					; 0000002eH
$LL66@StartOpenC:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN62@StartOpenC
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN65@StartOpenC
$LN62@StartOpenC:
	lea	r8, QWORD PTR [rax+1]
$LN65@StartOpenC:
	inc	rax
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	jne	SHORT $LL66@StartOpenC
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	mov	rdx, rax
	mov	r9d, 1855				; 0000073fH
	lea	rcx, OFFSET FLAT:$SG4294856562
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$4[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$4[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$4[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN505@StartOpenC:

; 1855 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN73@StartOpenC:

; 1908 : 		}
; 1909 : 
; 1910 : 	} else if (CUDADeviceCount <= options.GPUIndex && options.GPUIndex < CUDADeviceCount + openCLDeviceCount) {

	mov	edx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	cmp	edx, edi
	jg	$LN1649@StartOpenC
	mov	ecx, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	add	ecx, edx
	cmp	edi, ecx
	jge	$LN1649@StartOpenC

; 1911 : 		int32_t openCLDeviceIDArrayIndex = options.GPUIndex - CUDADeviceCount;

	sub	edi, edx

; 1912 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIDArrayIndex], CL_DEVICE_VENDOR, sizeof(deviceVendor), &deviceVendor, NULL));

	movsxd	r14, edi
	mov	QWORD PTR [rsp+32], r8
	lea	r9, QWORD PTR deviceVendor$[rbp-256]
	mov	edx, 4140				; 0000102cH
	mov	r8d, 1024				; 00000400H
	mov	rcx, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [rcx+r14*8]
	call	QWORD PTR __imp_clGetDeviceInfo
	mov	ebx, eax
	test	eax, eax
	je	$LN39@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN39@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN38@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 15
	lea	rdx, OFFSET FLAT:$SG4294856545
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 15
	lea	rcx, OFFSET FLAT:$SG4294856544
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN37@StartOpenC
$LN38@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rax, OFFSET FLAT:$SG4294856543
	mov	r8, rax
	mov	cl, 46					; 0000002eH
	npad	3
$LL36@StartOpenC:
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN32@StartOpenC
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN35@StartOpenC
$LN32@StartOpenC:
	lea	r8, QWORD PTR [rax+1]
$LN35@StartOpenC:
	inc	rax
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	jne	SHORT $LL36@StartOpenC
	mov	ecx, ebx
	call	?ConvertOpenCLErrorCodeToString@@YAPEADH@Z ; ConvertOpenCLErrorCodeToString
	mov	rdx, rax
	mov	r9d, 1912				; 00000778H
	lea	rcx, OFFSET FLAT:$SG4294856542
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN37@StartOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN39@StartOpenC:

; 1913 : 		openCLDeviceSearchThreadInfoArray[0].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [rax+r14*8]
	mov	rdx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rdx], rcx

; 1914 : 		openCLDeviceSearchThreadInfoArray[0].index           = 0;

	xor	r12d, r12d
	mov	DWORD PTR [rdx+8], r12d

; 1915 : 		openCLDeviceSearchThreadInfoArray[0].subindex        = -1;

	mov	DWORD PTR [rdx+12], esi

; 1916 : 		openCLDeviceSearchThreadInfoArray[0].status[0]       = '\0';

	mov	BYTE PTR [rdx+16], r12b

; 1917 : 		openCLDeviceSearchThreadInfoArray[0].runChildProcess = openCLRunChildProcesses;

	mov	eax, DWORD PTR ?openCLRunChildProcesses@@3HA ; openCLRunChildProcesses
	mov	DWORD PTR [rdx+1080], eax

; 1918 : 		openCLDeviceSearchThreadInfoArray[0].child_process = NULL;

	mov	QWORD PTR [rdx+1088], r12

; 1919 : 		//
; 1920 : 		openCLDeviceSearchThreadInfoArray[0].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	ecx, edi
	mov	DWORD PTR [rdx+1040], ecx

; 1921 : 		openCLDeviceSearchThreadInfoArray[0].currentSpeed               = 0;

	mov	QWORD PTR [rdx+1048], r12

; 1922 : 		openCLDeviceSearchThreadInfoArray[0].averageSpeed               = 0;

	mov	QWORD PTR [rdx+1056], r12

; 1923 : 		openCLDeviceSearchThreadInfoArray[0].totalNumGeneratedTripcodes = 0;

	mov	QWORD PTR [rdx+1064], r12

; 1924 : 		openCLDeviceSearchThreadInfoArray[0].numDiscardedTripcodes = 0;

	mov	QWORD PTR [rdx+1072], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	r13, 3777893186295716171		; 346dc5d63886594bH
	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T16[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1926 : 		openCLDeviceSearchThreadInfoArray[0].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [r8+1096], rdx

; 1927 : 		if (!openCLRunChildProcesses) {

	cmp	DWORD PTR ?openCLRunChildProcesses@@3HA, r12d ; openCLRunChildProcesses
	jne	$LN31@StartOpenC

; 1928 : 			ASSERT(numOpenCLDeviceSearchThreads == options.openCLNumThreads);

	mov	eax, DWORD PTR ?options@@3UOptions@@A+44
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, eax ; numOpenCLDeviceSearchThreads
	je	$LN30@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN1620@StartOpenC
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	SHORT $LN29@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	lea	r8d, QWORD PTR [r12+14]
	lea	rdx, OFFSET FLAT:$SG4294856541
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	edx, QWORD PTR [r12+14]
	lea	rcx, OFFSET FLAT:$SG4294856540
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN28@StartOpenC
$LN29@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1928				; 00000788H
	lea	rdx, OFFSET FLAT:$SG4294856539
	lea	rcx, OFFSET FLAT:$SG4294856538
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN28@StartOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1620@StartOpenC:
	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
$LN30@StartOpenC:

; 1929 : 			openCLDeviceSearchThreadInfoArray[0].subindex       = 0;

	mov	DWORD PTR [r8+12], r12d

; 1930 : 			for (j = 1; j < options.openCLNumThreads; ++j) {

	mov	edi, 1
	cmp	DWORD PTR ?options@@3UOptions@@A+44, edi
	jle	$LN1621@StartOpenC
	mov	ebx, 1104				; 00000450H
$LL27@StartOpenC:

; 1931 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID  = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [rax+r14*8]
	mov	QWORD PTR [rbx+r8], rcx

; 1932 : 				openCLDeviceSearchThreadInfoArray[j].index           = 0;

	mov	DWORD PTR [rbx+r8+8], r12d

; 1933 : 				openCLDeviceSearchThreadInfoArray[j].subindex        = j;

	mov	DWORD PTR [rbx+r8+12], edi

; 1934 : 				openCLDeviceSearchThreadInfoArray[j].status[0]       = '\0';

	mov	BYTE PTR [rbx+r8+16], r12b

; 1935 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = FALSE;

	mov	DWORD PTR [rbx+r8+1080], r12d

; 1936 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;

	mov	QWORD PTR [rbx+r8+1088], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T20[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1937 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rbx+r8+1096], rdx

; 1930 : 			for (j = 1; j < options.openCLNumThreads; ++j) {

	inc	edi
	lea	rbx, QWORD PTR [rbx+1104]
	cmp	edi, DWORD PTR ?options@@3UOptions@@A+44
	jl	SHORT $LL27@StartOpenC

; 1938 : 			}

	jmp	$LN1621@StartOpenC
$LN31@StartOpenC:

; 1939 : 		} else {
; 1940 : 			openCLDeviceSearchThreadInfoArray[0].subindex = 0;

	mov	DWORD PTR [r8+12], r12d

; 1941 : 			for (j = 1; j < options.openCLNumProcesses; ++j) {

	mov	esi, 1
	cmp	DWORD PTR ?options@@3UOptions@@A+100, esi
	jle	$LN1621@StartOpenC
	mov	ebx, 1104				; 00000450H
	npad	3
$LL23@StartOpenC:

; 1942 : 				ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	cmp	edi, DWORD PTR ?openCLDeviceCount@@3HA	; openCLDeviceCount
	jl	SHORT $LN20@StartOpenC
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	je	$LN1457@StartOpenC
	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
$LN20@StartOpenC:

; 1943 : 				openCLDeviceSearchThreadInfoArray[j].openCLDeviceID = openCLDeviceIDArray[openCLDeviceIDArrayIndex];

	mov	rax, QWORD PTR ?openCLDeviceIDArray@@3PEAPEAU_cl_device_id@@EA ; openCLDeviceIDArray
	mov	rcx, QWORD PTR [rax+r14*8]
	mov	QWORD PTR [rbx+r8], rcx

; 1944 : 				openCLDeviceSearchThreadInfoArray[j].index          = 0;

	mov	DWORD PTR [rbx+r8+8], r12d

; 1945 : 				openCLDeviceSearchThreadInfoArray[j].subindex       = j;

	mov	DWORD PTR [rbx+r8+12], esi

; 1946 : 				openCLDeviceSearchThreadInfoArray[j].status[0]      = '\0';

	mov	BYTE PTR [rbx+r8+16], r12b

; 1947 : 				openCLDeviceSearchThreadInfoArray[j].runChildProcess = TRUE;

	mov	DWORD PTR [rbx+r8+1080], 1

; 1948 : 				openCLDeviceSearchThreadInfoArray[j].child_process = NULL;

	mov	QWORD PTR [rbx+r8+1088], r12

; 1949 : 				//
; 1950 : 				openCLDeviceSearchThreadInfoArray[j].deviceNo                   = CUDADeviceCount + openCLDeviceIDArrayIndex;

	mov	ecx, DWORD PTR ?CUDADeviceCount@@3HA	; CUDADeviceCount
	add	ecx, edi
	mov	DWORD PTR [rbx+r8+1040], ecx

; 1951 : 				openCLDeviceSearchThreadInfoArray[j].currentSpeed               = 0;

	mov	QWORD PTR [rbx+r8+1048], r12

; 1952 : 				openCLDeviceSearchThreadInfoArray[j].averageSpeed               = 0;

	mov	QWORD PTR [rbx+r8+1056], r12

; 1953 : 				openCLDeviceSearchThreadInfoArray[j].totalNumGeneratedTripcodes = 0;

	mov	QWORD PTR [rbx+r8+1064], r12

; 1954 : 				openCLDeviceSearchThreadInfoArray[j].numDiscardedTripcodes = 0;

	mov	QWORD PTR [rbx+r8+1072], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r13
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T18[rbp-256], rdx
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1956 : 				openCLDeviceSearchThreadInfoArray[j].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;

	mov	r8, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	mov	QWORD PTR [rbx+r8+1096], rdx

; 1941 : 			for (j = 1; j < options.openCLNumProcesses; ++j) {

	inc	esi
	add	rbx, 1104				; 00000450H
	cmp	esi, DWORD PTR ?options@@3UOptions@@A+100
	jge	$LN1621@StartOpenC
	jmp	$LL23@StartOpenC
$LN1457@StartOpenC:

; 1942 : 				ASSERT(openCLDeviceIDArrayIndex < openCLDeviceCount);

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, r12d
	je	SHORT $LN19@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856537
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856536
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN18@StartOpenC
$LN19@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1942				; 00000796H
	lea	rdx, OFFSET FLAT:$SG4294856535
	lea	rcx, OFFSET FLAT:$SG4294856534
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN18@StartOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1649@StartOpenC:
	xor	r12d, r12d
$LN1621@StartOpenC:

; 1957 : 			}	
; 1958 : 		}
; 1959 : 	}
; 1960 : 
; 1961 : 	if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12
	jne	$LN17@StartOpenC

; 1962 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	r14d, r12d
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads
	jle	$LN1602@StartOpenC
	mov	r15, r12
	lea	r13, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
$LL16@StartOpenC:

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
	mov	QWORD PTR $T11[rsp], rax
	test	rax, rax
	je	SHORT $LN85@StartOpenC
	movsxd	rcx, r14d
	imul	rdi, rcx, 1104				; 00000450H
	mov	rcx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	add	rdi, rcx
	lea	rbx, OFFSET FLAT:?Thread_SearchForSHA1TripcodesOnOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForSHA1TripcodesOnOpenCLDevice
	cmp	DWORD PTR [r12+rcx+1080], 0
	lea	rax, OFFSET FLAT:?Thread_RunChildProcessForOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_RunChildProcessForOpenCLDevice
	cmovne	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T15[rbp-256], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T15[rbp-248], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$19[rbp-256]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$19[rbp-256], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$19[rbp-224], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$19[rbp-216], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Launcher$19[rbp-256]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$19[rbp-256]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1965 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	jmp	SHORT $LN86@StartOpenC
$LN85@StartOpenC:
	xor	esi, esi
$LN86@StartOpenC:
	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
	mov	QWORD PTR [r15+rax], rsi

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	rsi, rsi
	jne	SHORT $LN15@StartOpenC
$LL1140@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1139@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1154@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1140@StartOpenC
$LN1154@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1140@StartOpenC
$LN1139@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	eax, eax
	je	SHORT $LL1184@StartOpenC
$LN15@StartOpenC:

; 1962 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	r14d
	add	r12, 1104				; 00000450H
	add	r15, 8
	cmp	r14d, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jge	$LN1602@StartOpenC
	jmp	$LL16@StartOpenC
	npad	7
$LL1184@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1183@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1198@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1184@StartOpenC
$LN1198@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1184@StartOpenC
$LN1183@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN12@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 12
	lea	rdx, OFFSET FLAT:$SG4294856533
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 12
	lea	rcx, OFFSET FLAT:$SG4294856532
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN1225@StartOpenC
$LN12@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856531
	lea	rcx, OFFSET FLAT:$SG4294856530
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$6[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$6[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$6[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN1225@StartOpenC:

; 1966 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN17@StartOpenC:

; 1969 : 		ASSERT(lenTripcode == 10);

	cmp	eax, 10
	je	$LN1622@StartOpenC
	npad	5
$LL1230@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1229@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1244@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1230@StartOpenC
$LN1244@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1230@StartOpenC
$LN1229@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1969 : 		ASSERT(lenTripcode == 10);

	test	eax, eax
	jne	$LN1622@StartOpenC
	npad	8
$LL1274@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1273@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1288@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1274@StartOpenC
$LN1288@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1274@StartOpenC
$LN1273@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r12d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1969 : 		ASSERT(lenTripcode == 10);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN8@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856529
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856528
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN7@StartOpenC
$LN8@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1969				; 000007b1H
	lea	rdx, OFFSET FLAT:$SG4294856527
	lea	rcx, OFFSET FLAT:$SG4294856526
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN7@StartOpenC:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1622@StartOpenC:

; 1970 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	r14d, r12d
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads
	jle	$LN1602@StartOpenC
	mov	r15, r12
	lea	r13, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	npad	5
$LL6@StartOpenC:

; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
	mov	QWORD PTR $T10[rsp], rax
	test	rax, rax
	je	SHORT $LN87@StartOpenC
	movsxd	rcx, r14d
	imul	rdi, rcx, 1104				; 00000450H
	mov	rcx, QWORD PTR ?openCLDeviceSearchThreadInfoArray@@3PEAUOpenCLDeviceSearchThreadInfo@@EA ; openCLDeviceSearchThreadInfoArray
	add	rdi, rcx
	lea	rbx, OFFSET FLAT:?Thread_SearchForDESTripcodesOnOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_SearchForDESTripcodesOnOpenCLDevice
	cmp	DWORD PTR [r12+rcx+1080], 0
	lea	rax, OFFSET FLAT:?Thread_RunChildProcessForOpenCLDevice@@YAXPEAUOpenCLDeviceSearchThreadInfo@@@Z ; Thread_RunChildProcessForOpenCLDevice
	cmovne	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR $T17[rbp-256], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR $T17[rbp-248], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$21[rbp-256]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$21[rbp-256], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$21[rbp-224], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$21[rbp-216], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Launcher$21[rbp-256]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$21[rbp-256]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1973 : 				&(openCLDeviceSearchThreadInfoArray[i]));

	jmp	SHORT $LN88@StartOpenC
$LN87@StartOpenC:
	xor	esi, esi
$LN88@StartOpenC:
	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
	mov	QWORD PTR [r15+rax], rsi

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	rsi, rsi
	jne	SHORT $LN5@StartOpenC
	npad	3
$LL1384@StartOpenC:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN1383@StartOpenC
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN1398@StartOpenC

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL1384@StartOpenC
$LN1398@StartOpenC:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL1384@StartOpenC
$LN1383@StartOpenC:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	test	eax, eax
	je	SHORT $LN1458@StartOpenC
$LN5@StartOpenC:

; 1970 : 		for (i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	r14d
	add	r12, 1104				; 00000450H
	add	r15, 8
	cmp	r14d, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jge	$LN1602@StartOpenC
	jmp	$LL6@StartOpenC
$LN1458@StartOpenC:

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartOpenC
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 12
	lea	rdx, OFFSET FLAT:$SG4294856525
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 12
	lea	rcx, OFFSET FLAT:$SG4294856524
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN1425@StartOpenC
$LN2@StartOpenC:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856523
	lea	rcx, OFFSET FLAT:$SG4294856522
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$8[rsp+4], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$8[rsp], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$8[rsp]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN1425@StartOpenC:

; 1974 : 			ERROR0((opencl_device_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a OpenCL device search thread.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN1602@StartOpenC:

; 1975 : 		}
; 1976 : 	}
; 1977 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1360]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1651@StartOpenC:
?StartOpenCLDeviceSearchThreads@@YAXXZ ENDP		; StartOpenCLDeviceSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
$T10 = 120
$T11 = 120
$T12 = 128
$T13 = 136
$T14 = 144
$T15 = 152
$T16 = 168
$T17 = 176
$T18 = 192
_Launcher$19 = 200
$T20 = 248
_Launcher$21 = 256
$T22 = 304
deviceVendor$ = 320
__$ArrayPad$ = 1344
?dtor$0@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA PROC ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$0
	mov	rcx, QWORD PTR $T11[rdx]
	jmp	??3@YAXPEAX@Z				; operator delete
?dtor$0@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
$T10 = 120
$T11 = 120
$T12 = 128
$T13 = 136
$T14 = 144
$T15 = 152
$T16 = 168
$T17 = 176
$T18 = 192
_Launcher$19 = 200
$T20 = 248
_Launcher$21 = 256
$T22 = 304
deviceVendor$ = 320
__$ArrayPad$ = 1344
?dtor$2@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA PROC ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$2
	lea	rcx, QWORD PTR _Launcher$19[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$2@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
$T10 = 120
$T11 = 120
$T12 = 128
$T13 = 136
$T14 = 144
$T15 = 152
$T16 = 168
$T17 = 176
$T18 = 192
_Launcher$19 = 200
$T20 = 248
_Launcher$21 = 256
$T22 = 304
deviceVendor$ = 320
__$ArrayPad$ = 1344
?dtor$1@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA PROC ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$1
	mov	rcx, QWORD PTR $T10[rdx]
	jmp	??3@YAXPEAX@Z				; operator delete
?dtor$1@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
info$1 = 48
info$2 = 56
info$3 = 64
info$4 = 72
info$5 = 80
info$6 = 88
info$7 = 96
info$8 = 104
info$9 = 112
$T10 = 120
$T11 = 120
$T12 = 128
$T13 = 136
$T14 = 144
$T15 = 152
$T16 = 168
$T17 = 176
$T18 = 192
_Launcher$19 = 200
$T20 = 248
_Launcher$21 = 256
$T22 = 304
deviceVendor$ = 320
__$ArrayPad$ = 1344
?dtor$4@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA PROC ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$4
	lea	rcx, QWORD PTR _Launcher$21[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$4@?0??StartOpenCLDeviceSearchThreads@@YAXXZ@4HA ENDP ; `StartOpenCLDeviceSearchThreads'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartGPUSearchThreads@@YAXXZ
_TEXT	SEGMENT
?StartGPUSearchThreads@@YAXXZ PROC			; StartGPUSearchThreads, COMDAT

; 1980 : {

$LN6:
	sub	rsp, 40					; 00000028H

; 1981 : 	if (numCUDADeviceSearchThreads > 0)

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, 0 ; numCUDADeviceSearchThreads
	jle	SHORT $LN2@StartGPUSe

; 1982 : 		StartCUDADeviceSearchThreads();

	call	?StartCUDADeviceSearchThreads@@YAXXZ	; StartCUDADeviceSearchThreads
$LN2@StartGPUSe:

; 1983 : 	if (numOpenCLDeviceSearchThreads > 0)

	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, 0 ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN1@StartGPUSe

; 1985 : }

	add	rsp, 40					; 00000028H

; 1984 : 		StartOpenCLDeviceSearchThreads();

	jmp	?StartOpenCLDeviceSearchThreads@@YAXXZ	; StartOpenCLDeviceSearchThreads
$LN1@StartGPUSe:

; 1985 : }

	add	rsp, 40					; 00000028H
	ret	0
?StartGPUSearchThreads@@YAXXZ ENDP			; StartGPUSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?StartCPUSearchThreads@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
_Launcher$4 = 48
_Launcher$5 = 96
info$6 = 224
info$7 = 232
info$8 = 240
info$9 = 248
?StartCPUSearchThreads@@YAXXZ PROC			; StartCPUSearchThreads, COMDAT

; 1988 : {

$LN536:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-31]
	sub	rsp, 152				; 00000098H
	mov	QWORD PTR $T1[rbp-121], -2

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	xor	r14d, r14d
	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, r14d ; numCPUSearchThreads
	jg	$LN530@StartCPUSe
$LL30@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN29@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN44@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL30@StartCPUSe
$LN44@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL30@StartCPUSe
$LN29@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	test	eax, eax
	jne	$LN530@StartCPUSe
	npad	7
$LL74@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN73@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN88@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL74@StartCPUSe
$LN88@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL74@StartCPUSe
$LN73@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	je	SHORT $LN17@StartCPUSe
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856521
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856520
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN115@StartCPUSe
$LN17@StartCPUSe:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 1989				; 000007c5H
	lea	rdx, OFFSET FLAT:$SG4294856519
	lea	rcx, OFFSET FLAT:$SG4294856518
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$6[rbp-117], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$6[rbp-121], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$6[rbp-121]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN115@StartCPUSe:

; 1989 : 	ASSERT(numCPUSearchThreads > 0);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN530@StartCPUSe:

; 1990 : 
; 1991 : 	uint32_t winThreadID;
; 1992 : 	
; 1993 : 	if (cpu_search_threads)

	mov	rcx, QWORD PTR ?cpu_search_threads@@3PEAPEAVthread@std@@EA ; cpu_search_threads
	test	rcx, rcx
	je	SHORT $LN15@StartCPUSe

; 1994 : 		delete [] cpu_search_threads;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN15@StartCPUSe:

; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	movsxd	rcx, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	mov	eax, 8
	mul	rcx
	mov	rcx, -1
	cmovo	rax, rcx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, rax
	call	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new[]
	mov	QWORD PTR ?cpu_search_threads@@3PEAPEAVthread@std@@EA, rax ; cpu_search_threads
	test	rax, rax
	jne	$LN14@StartCPUSe
	npad	4
$LL120@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN119@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN134@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL120@StartCPUSe
$LN134@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL120@StartCPUSe
$LN119@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	test	eax, eax
	jne	$LN14@StartCPUSe
	npad	8
$LL164@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN163@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN178@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL164@StartCPUSe
$LN178@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL164@StartCPUSe
$LN163@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	cmp	DWORD PTR ?options@@3UOptions@@A+32, r14d
	je	SHORT $LN13@StartCPUSe
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG4294856517
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 5
	lea	rcx, OFFSET FLAT:$SG4294856516
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN234@StartCPUSe
$LN13@StartCPUSe:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294857034
	lea	rcx, OFFSET FLAT:$SG4294856515
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$7[rbp-117], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$7[rbp-121], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$7[rbp-121]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN234@StartCPUSe:

; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN14@StartCPUSe:

; 1996 : 	
; 1997 : 	for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	mov	esi, r14d
	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, r14d ; numCPUSearchThreads
	jle	$LN527@StartCPUSe
	mov	rdi, r14
	lea	r15, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
	lea	r12, OFFSET FLAT:?Thread_SearchForSHA1TripcodesOnCPU@@YAXXZ ; Thread_SearchForSHA1TripcodesOnCPU
	lea	r13, OFFSET FLAT:?Thread_SearchForDESTripcodesOnCPU@@YAXXZ ; Thread_SearchForDESTripcodesOnCPU
$LL11@StartCPUSe:

; 1998 : 		if (lenTripcode == 12) {

	mov	eax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	eax, 12
	jne	SHORT $LN8@StartCPUSe

; 1999 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCPU);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	lea	ecx, QWORD PTR [rax+4]
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new
	mov	rbx, rax
	mov	QWORD PTR $T3[rbp-121], rax
	test	rax, rax
	je	SHORT $LN21@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$4[rbp-121]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$4[rbp-121], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$4[rbp-89], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rbx
	lea	rcx, QWORD PTR _Launcher$4[rbp-121]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$4[rbp-121]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1999 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCPU);

	jmp	SHORT $LN22@StartCPUSe
$LN21@StartCPUSe:
	mov	rbx, r14
$LN22@StartCPUSe:

; 2000 : 		} else {

	jmp	$LN535@StartCPUSe
$LN8@StartCPUSe:

; 2001 : 			ASSERT(lenTripcode == 10);

	cmp	eax, 10
	je	SHORT $LN6@StartCPUSe
$LL275@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN274@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN289@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL275@StartCPUSe
$LN289@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL275@StartCPUSe
$LN274@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2001 : 			ASSERT(lenTripcode == 10);

	test	eax, eax
	je	$LL319@StartCPUSe
$LN6@StartCPUSe:

; 2002 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCPU);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	ecx, 16
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new
	mov	rbx, rax
	mov	QWORD PTR $T2[rbp-121], rax
	test	rax, rax
	je	SHORT $LN23@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$5[rbp-121]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	mov	QWORD PTR _Launcher$5[rbp-121], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$5[rbp-89], r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rbx
	lea	rcx, QWORD PTR _Launcher$5[rbp-121]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$5[rbp-121]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2002 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCPU);

	jmp	SHORT $LN24@StartCPUSe
$LN23@StartCPUSe:
	mov	rbx, r14
$LN24@StartCPUSe:
$LN535@StartCPUSe:
	mov	rcx, QWORD PTR ?cpu_search_threads@@3PEAPEAVthread@std@@EA ; cpu_search_threads
	add	rcx, rdi
	mov	QWORD PTR [rcx], rbx

; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	test	rbx, rbx
	jne	SHORT $LN10@StartCPUSe
$LL401@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN400@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN415@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL401@StartCPUSe
$LN415@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL401@StartCPUSe
$LN400@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1649 : 	ret = wasSearchAbortedWithError;

	mov	eax, DWORD PTR ?wasSearchAbortedWithError@@3HA ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	test	eax, eax
	je	SHORT $LL445@StartCPUSe
$LN10@StartCPUSe:

; 1996 : 	
; 1997 : 	for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	inc	esi
	add	rdi, 8
	cmp	esi, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	jge	$LN527@StartCPUSe
	jmp	$LL11@StartCPUSe
	npad	2
$LL445@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN444@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN459@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL445@StartCPUSe
$LN459@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL445@StartCPUSe
$LN444@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN2@StartCPUSe
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 12
	lea	rdx, OFFSET FLAT:$SG4294856510
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 12
	lea	rcx, OFFSET FLAT:$SG4294856509
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN486@StartCPUSe
$LN2@StartCPUSe:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856508
	lea	rcx, OFFSET FLAT:$SG4294856507
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$8[rbp-117], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$8[rbp-121], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$8[rbp-121]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN486@StartCPUSe:

; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
	npad	4
$LL319@StartCPUSe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN318@StartCPUSe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN333@StartCPUSe

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL319@StartCPUSe
$LN333@StartCPUSe:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL319@StartCPUSe
$LN318@StartCPUSe:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1641 : 	wasSearchAbortedWithError = TRUE;

	mov	DWORD PTR ?wasSearchAbortedWithError@@3HA, 1 ; wasSearchAbortedWithError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, r14d ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2001 : 			ASSERT(lenTripcode == 10);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, 0
	je	SHORT $LN5@StartCPUSe
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	mov	r8d, 14
	lea	rdx, OFFSET FLAT:$SG4294856514
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	mov	edx, 14
	lea	rcx, OFFSET FLAT:$SG4294856513
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN360@StartCPUSe
$LN5@StartCPUSe:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	mov	r8d, 2001				; 000007d1H
	lea	rdx, OFFSET FLAT:$SG4294856512
	lea	rcx, OFFSET FLAT:$SG4294856511
	call	printf
	call	_getch

; 290  : 	info.bVisible = true;

	mov	DWORD PTR info$9[rbp-117], 1

; 291  : 	info.dwSize = 100;

	mov	DWORD PTR info$9[rbp-121], 100		; 00000064H

; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	rcx, rax
	lea	rdx, QWORD PTR info$9[rbp-121]
	call	QWORD PTR __imp_SetConsoleCursorInfo
$LN360@StartCPUSe:

; 2001 : 			ASSERT(lenTripcode == 10);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN527@StartCPUSe:

; 2005 : 	}
; 2006 : }

	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN534@StartCPUSe:
?StartCPUSearchThreads@@YAXXZ ENDP			; StartCPUSearchThreads
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
_Launcher$4 = 48
_Launcher$5 = 96
info$6 = 224
info$7 = 232
info$8 = 240
info$9 = 248
?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA PROC	; `StartCPUSearchThreads'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAXAEBUnothrow_t@std@@@Z	; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StartCPUSearchThreads@@YAXXZ@4HA ENDP	; `StartCPUSearchThreads'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
_Launcher$4 = 48
_Launcher$5 = 96
info$6 = 224
info$7 = 232
info$8 = 240
info$9 = 248
?dtor$2@?0??StartCPUSearchThreads@@YAXXZ@4HA PROC	; `StartCPUSearchThreads'::`1'::dtor$2
	lea	rcx, QWORD PTR _Launcher$4[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ
?dtor$2@?0??StartCPUSearchThreads@@YAXXZ@4HA ENDP	; `StartCPUSearchThreads'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
_Launcher$4 = 48
_Launcher$5 = 96
info$6 = 224
info$7 = 232
info$8 = 240
info$9 = 248
?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA PROC	; `StartCPUSearchThreads'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXAEBUnothrow_t@std@@@Z	; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StartCPUSearchThreads@@YAXXZ@4HA ENDP	; `StartCPUSearchThreads'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
_Launcher$4 = 48
_Launcher$5 = 96
info$6 = 224
info$7 = 232
info$8 = 240
info$9 = 248
?dtor$4@?0??StartCPUSearchThreads@@YAXXZ@4HA PROC	; `StartCPUSearchThreads'::`1'::dtor$4
	lea	rcx, QWORD PTR _Launcher$5[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ
?dtor$4@?0??StartCPUSearchThreads@@YAXXZ@4HA ENDP	; `StartCPUSearchThreads'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?GetParentProcessID@@YAHXZ
_TEXT	SEGMENT
processEntry$ = 32
__$ArrayPad$ = 608
?GetParentProcessID@@YAHXZ PROC				; GetParentProcessID, COMDAT

; 2009 : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 624				; 00000270H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2010 : 	int32_t processID = GetCurrentProcessId();

	call	QWORD PTR __imp_GetCurrentProcessId

; 2011 : 	int32_t parentProcessID = -1;

	or	esi, -1

; 2012 : 	HANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	xor	edx, edx
	lea	ecx, QWORD PTR [rsi+3]
	mov	edi, eax
	call	QWORD PTR __imp_CreateToolhelp32Snapshot

; 2013 : 	PROCESSENTRY32 processEntry = {0};

	lea	rcx, QWORD PTR processEntry$[rsp+4]
	xor	edx, edx
	mov	r8d, 564				; 00000234H
	mov	rbx, rax
	call	memset

; 2014 : 	processEntry.dwSize = sizeof(PROCESSENTRY32);
; 2015 : 
; 2016 : 	if(Process32First(hSnapProcess, &processEntry)) {

	lea	rdx, QWORD PTR processEntry$[rsp]
	mov	rcx, rbx
	mov	DWORD PTR processEntry$[rsp], 568	; 00000238H
	call	QWORD PTR __imp_Process32FirstW
	test	eax, eax
	je	SHORT $LN2@GetParentP
	npad	7
$LL4@GetParentP:

; 2017 : 		do {
; 2018 :     		if (processEntry.th32ProcessID == processID) {

	cmp	DWORD PTR processEntry$[rsp+8], edi
	je	SHORT $LN9@GetParentP

; 2020 :     			break;
; 2021 : 			}
; 2022 : 		} while( Process32Next(hSnapProcess, &processEntry));

	lea	rdx, QWORD PTR processEntry$[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_Process32NextW
	test	eax, eax
	jne	SHORT $LL4@GetParentP
	jmp	SHORT $LN2@GetParentP
$LN9@GetParentP:

; 2019 :     			parentProcessID = processEntry.th32ParentProcessID;

	mov	esi, DWORD PTR processEntry$[rsp+32]
$LN2@GetParentP:

; 2023 : 	}
; 2024 : 
; 2025 : 	CloseHandle(hSnapProcess);

	mov	rcx, rbx
	call	QWORD PTR __imp_CloseHandle

; 2026 : 	return parentProcessID;

	mov	eax, esi

; 2027 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+624]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?GetParentProcessID@@YAHXZ ENDP				; GetParentProcessID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT ?ListExpandedPatterns@@YAXXZ
_TEXT	SEGMENT
?ListExpandedPatterns@@YAXXZ PROC			; ListExpandedPatterns, COMDAT

; 2030 : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2031 : 	for (int32_t i = 0; i < numExpandedPatterns; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR ?numExpandedPatterns@@3IA, ebx ; numExpandedPatterns
	jbe	SHORT $LN1@ListExpand
	mov	QWORD PTR [rsp+48], rdi
	mov	edi, ebx
	npad	9
$LL3@ListExpand:

; 2032 : 		printf("%d: `%s' @ %d\n", i, expandedPatternArray[i].c, expandedPatternArray[i].pos);

	mov	rdx, QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA ; expandedPatternArray
	movsxd	rax, ebx
	movzx	r9d, BYTE PTR [rdi+rdx]
	lea	r8, QWORD PTR [rdx+1]
	mov	edx, ebx
	imul	rcx, rax, 14
	add	r8, rcx
	lea	rcx, OFFSET FLAT:$SG4294856506
	call	printf
	inc	ebx
	lea	rdi, QWORD PTR [rdi+14]
	cmp	ebx, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	jb	SHORT $LL3@ListExpand
	mov	rdi, QWORD PTR [rsp+48]
$LN1@ListExpand:

; 2033 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ListExpandedPatterns@@YAXXZ ENDP			; ListExpandedPatterns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp
;	COMDAT main
_TEXT	SEGMENT
$T1 = 32
argc$ = 112
argv$ = 120
info$2 = 128
$T3 = 136
main	PROC						; COMDAT

; 2036 : {

$LN664:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 2037 : 	BOOL   displayDeviceInformationAndExit = false;

	xor	esi, esi
	mov	r14, rdx
	mov	ebp, ecx
	mov	edi, esi

; 2038 : 	BOOL   listExpandedPatternsAndExit     = false;

	mov	ebx, esi

; 2039 : 
; 2040 : 	if (argc > 1) {

	cmp	ecx, 1
	jle	SHORT $LN56@main

; 2041 : 		displayDeviceInformationAndExit = (strcmp(argv[1], "--display-device-information") == 0);

	mov	rcx, QWORD PTR [r14+8]
	lea	rdx, OFFSET FLAT:$SG4294856505
	call	strcmp

; 2042 : 		listExpandedPatternsAndExit     = (strcmp(argv[1], "--list-expanded-patterns"    ) == 0);

	mov	rcx, QWORD PTR [r14+8]
	lea	rdx, OFFSET FLAT:$SG4294856504
	test	eax, eax
	sete	dil
	call	strcmp
	test	eax, eax
	sete	bl
$LN56@main:

; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	mov	ecx, -11				; fffffff5H
	mov	QWORD PTR [rsp+112], r15

; 244  : 	}
; 245  : }
; 246  : 
; 247  : void PrintUsage()
; 248  : {
; 249  : 	printf("Usage: %s [-c] [-g] [-d device_no] [-x blocks_per_SM] [-y global_work_size] [-z local_work_size] [-o tripcode_file] [-f pattern_file] [-i] [-w]\n", COMMAND);
; 250  : 	getchar();
; 251  : 	exit(-1);
; 252  : }
; 253  : 
; 254  : void reset_cursor_pos(int n)
; 255  : {
; 256  : #ifdef _WINDOWS_
; 257  : 	CONSOLE_SCREEN_BUFFER_INFO scrnBufInfo;
; 258  : 	COORD                      cursorPos;
; 259  : 	if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &scrnBufInfo))
; 260  : 		return;
; 261  : 	cursorPos.X = 0;
; 262  : 	cursorPos.Y = (scrnBufInfo.dwCursorPosition.Y + n) >= 0
; 263  : 		? (scrnBufInfo.dwCursorPosition.Y + n)
; 264  : 		: 0;
; 265  : 	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
; 266  : #else
; 267  : 	if (n >= 0) {
; 268  : 		std::cout << "\033[" << n << "B";
; 269  : 	} else {
; 270  : 		std::cout << "\033[" << -n << "A";
; 271  : 	}
; 272  : #endif
; 273  : }
; 274  : 
; 275  : #ifdef _WINDOWS_
; 276  : 
; 277  : void hide_cursor()
; 278  : {
; 279  : 	CONSOLE_CURSOR_INFO info;
; 280  : 
; 281  : 	info.bVisible = false;
; 282  : 	info.dwSize = 100;

	mov	QWORD PTR info$2[rsp], 100		; 00000064H

; 283  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info);

	call	QWORD PTR __imp_GetStdHandle
	lea	rdx, QWORD PTR info$2[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleCursorInfo

; 284  : }
; 285  : 
; 286  : void show_cursor()
; 287  : {
; 288  : 	CONSOLE_CURSOR_INFO info;
; 289  : 
; 290  : 	info.bVisible = true;
; 291  : 	info.dwSize = 100;
; 292  : 	SetConsoleCursorInfo((HWND)GetStdHandle(STD_OUTPUT_HANDLE), &info); 
; 293  : }
; 294  : 
; 295  : #else
; 296  : 
; 297  : void hide_cursor()
; 298  : {
; 299  : }
; 300  : 
; 301  : void show_cursor()
; 302  : {
; 303  : }
; 304  : 
; 305  : #endif
; 306  : 
; 307  : void CreateKey8AndKey9(unsigned char *key)
; 308  : {
; 309  : 	ASSERT(lenTripcode == 10);
; 310  : 	if (options.useOneByteCharactersForKeys) {
; 311  : 		key[8] = keyCharTable_OneByte[RandomByte()];
; 312  : 		key[9] = keyCharTable_OneByte[RandomByte()];
; 313  : 	} else {
; 314  : 		BOOL isSecondByte = FALSE;
; 315  : 		for (int32_t i = 0; i < 8; ++i) {
; 316  : 			if (!isSecondByte) {
; 317  : 				isSecondByte = IS_FIRST_BYTE_SJIS_FULL(key[i]);
; 318  : 			} else {
; 319  : 				isSecondByte = FALSE;
; 320  : 			}
; 321  : 		}
; 322  : 		if (isSecondByte) {
; 323  : 			key[8] = keyCharTable_SecondByte[RandomByte()];
; 324  : 			key[9] = keyCharTable_OneByte   [RandomByte()];
; 325  : 		} else {
; 326  : 			key[8] = keyCharTable_FirstByte[RandomByte()];
; 327  : 			key[9] = (IS_FIRST_BYTE_SJIS_FULL(key[8]))
; 328  : 							? keyCharTable_SecondByte[RandomByte()]
; 329  : 							: keyCharTable_OneByte   [RandomByte()];
; 330  : 		}
; 331  : 	}
; 332  : }
; 333  : 
; 334  : double ProcessGPUOutput(unsigned char *partialKey, GPUOutput *outputArray, uint32_t sizeOutputArray, BOOL newFormat)
; 335  : {
; 336  : 	unsigned char  tripcode[MAX_LEN_TRIPCODE     + 1];
; 337  : 	unsigned char  key     [MAX_LEN_TRIPCODE_KEY + 1];
; 338  : 	double numGeneratedTripcodesInThisOutput = 0;
; 339  : 	
; 340  : 	tripcode[lenTripcode   ] = '\0';
; 341  : 	key     [lenTripcodeKey] = '\0';
; 342  : 	memcpy(key, partialKey, lenTripcodeKey);
; 343  : 	for (uint32_t indexOutput = 0; indexOutput < sizeOutputArray; indexOutput++){
; 344  : 		GPUOutput *output = &outputArray[indexOutput];
; 345  : 		AddToNumGeneratedTripcodesByGPU(output->numGeneratedTripcodes);
; 346  : 		numGeneratedTripcodesInThisOutput += output->numGeneratedTripcodes;
; 347  : 		if (output->numMatchingTripcodes > 0) {
; 348  : 			memcpy(tripcode, output->pair.tripcode.c, lenTripcode);
; 349  : 			if (lenTripcode == 12 && newFormat) {
; 350  : 				memcpy(key, output->pair.key.c, 4);
; 351  : 				key[7]  = output->pair.key.c[7];
; 352  : 				key[11] = output->pair.key.c[11];
; 353  : 			} else if (lenTripcode == 12) {
; 354  : 				memcpy(key + 7,  output->pair.key.c + 7, lenTripcode - 7);
; 355  : 			} else {
; 356  : 				ASSERT(lenTripcode == 10);
; 357  : 				memcpy(key,  output->pair.key.c, 8);
; 358  : 				CreateKey8AndKey9(key);
; 359  : 			}
; 360  : 			//printf("{%s, %s}\n", tripcode, key);
; 361  : 			ERROR0(!IsTripcodeChunkValid(tripcode),
; 362  : 				   ERROR_TRIPCODE_VERIFICATION_FAILED, 
; 363  : 				   GetErrorMessage(ERROR_TRIPCODE_VERIFICATION_FAILED));
; 364  : 			ProcessPossibleMatch(tripcode, key);
; 365  : 		}
; 366  : 	}
; 367  : 	return numGeneratedTripcodesInThisOutput;
; 368  : }
; 369  : 
; 370  : BOOL IsValidKey(unsigned char *key)
; 371  : {
; 372  : 	int32_t i;
; 373  : 	BOOL isSecondByteSJIS = FALSE;
; 374  : 	char results[13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
; 375  : 	
; 376  : 	if (key[0] == '#' || key[0] == '$') {
; 377  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 378  : 		printf("  results: %c                                                     \n", key[0]);
; 379  : #endif
; 380  : 		return FALSE;
; 381  : 	}
; 382  : 
; 383  : 	for (i = 0; i < lenTripcode; ++i) {
; 384  : 		if (!isSecondByteSJIS && IS_ONE_BYTE_KEY_CHAR(key[i])) {
; 385  : 			// Don't do anything
; 386  : 			results[i] = 'O';
; 387  : 		} else if (!isSecondByteSJIS && i < lenTripcode - 1 && IS_FIRST_BYTE_SJIS_FULL(key[i])) {
; 388  : 			isSecondByteSJIS = TRUE;
; 389  : 			results[i] = '1';
; 390  : 		} else if (isSecondByteSJIS && IS_SECOND_BYTE_SJIS(key[i])) {
; 391  : 		    isSecondByteSJIS = FALSE;
; 392  : 		    if (!IS_VALID_SJIS_CHAR(key[i - 1], key[i])) {
; 393  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 394  : 				printf("  results: %sx                                                     \n", results);
; 395  : 				printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 396  : #endif
; 397  : 				return FALSE;
; 398  : 			}
; 399  : 			results[i] = '2';
; 400  : 		} else {
; 401  : #ifdef DEBUG_PRINT_INVALID_KEY_INFO
; 402  : 			printf("  results: %sX                                                     \n", results);
; 403  : 			printf("  key[%2d]: 0x%02x ('%c')                                            \n", i, key[i], key[i]);
; 404  : #endif
; 405  : 			return FALSE;
; 406  : 		}
; 407  : 	}
; 408  : 	return TRUE;
; 409  : }
; 410  : 
; 411  : void CreateCharacterTables(void)
; 412  : {
; 413  : 	unsigned char keyChar;
; 414  : 	int32_t i;
; 415  : 
; 416  : #if FALSE
; 417  : 	for (i = 0; i < 64; ++i)
; 418  : 		base64CharTable[i] = i + ((i < 26) ?  'A'       :
; 419  : 		                          (i < 52) ? ('a' - 26) :
; 420  : 		                          (i < 62) ? ('0' - 52) :
; 421  : 		                                     ('.' - 62));
; 422  : #endif
; 423  : 
; 424  : 	numFirstByte = numSecondByte = numOneByte = 0;
; 425  : 
; 426  : 	// Set keyCharTable_OneByte[]
; 427  : 	if (options.useOnlyASCIICharactersForKeys) {
; 428  : 		do {
; 429  : 			keyChar = RandomByte();
; 430  : 		} while (!IS_ASCII_KEY_CHAR(keyChar));
; 431  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 432  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 433  : 			while (!IS_ASCII_KEY_CHAR(keyChar))
; 434  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 435  : 			keyCharTable_OneByte[i] = keyChar;
; 436  : 		}
; 437  : 	} else {
; 438  : 		do {
; 439  : 			keyChar = RandomByte();
; 440  : 		} while (!IS_ONE_BYTE_KEY_CHAR(keyChar));
; 441  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 442  : 			keyChar = ((int32_t)keyChar + 1) & 0xff;
; 443  : 			while (!IS_ONE_BYTE_KEY_CHAR(keyChar))
; 444  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 445  : 			keyCharTable_OneByte[i] = keyChar;
; 446  : 		}
; 447  : 	}
; 448  : 
; 449  : 	// Set keyCharTable_FirstByte[], keyCharTable_SecondByte[], and keyCharTable_SecondByteAndOneByte[].
; 450  : 	if (options.useOnlyASCIICharactersForKeys) {
; 451  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 452  : 			keyCharTable_FirstByte [i]           = keyCharTable_OneByte[i];
; 453  : 			keyCharTable_SecondByte[i]           = keyCharTable_OneByte[i];
; 454  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 455  : 		}
; 456  : 		for (int32_t i = 0; i < 256; ++i) {
; 457  : 			if (IS_ASCII_KEY_CHAR(i)) {
; 458  : 				++numFirstByte;
; 459  : 				++numSecondByte;
; 460  : 				++numOneByte;
; 461  : 			}
; 462  : 		}
; 463  : 	} else if (options.useOneByteCharactersForKeys) {
; 464  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 465  : 			keyCharTable_FirstByte           [i] = keyCharTable_OneByte[i];
; 466  : 			keyCharTable_SecondByte          [i] = keyCharTable_OneByte[i];
; 467  : 			keyCharTable_SecondByteAndOneByte[i] = keyCharTable_OneByte[i];
; 468  : 		}
; 469  : 		for (int32_t i = 0; i < 256; ++i) {
; 470  : 			if (IS_ONE_BYTE_KEY_CHAR(i)) {
; 471  : 				++numFirstByte;
; 472  : 				++numSecondByte;
; 473  : 				++numOneByte;
; 474  : 			}
; 475  : 		}
; 476  : 	} else {
; 477  : 		// Set keyCharTable_FirstByte[].
; 478  : 		do {
; 479  : 			keyChar = RandomByte();
; 480  : 		} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 481  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 482  : 			keyCharTable_FirstByte[i] = keyChar;
; 483  : 			do {
; 484  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 485  : 			} while (!(IS_ONE_BYTE_KEY_CHAR(keyChar) || IsFirstByteSJIS(keyChar)));
; 486  : 		}
; 487  : 
; 488  : 		// Set keyCharTable_SecondByte[].
; 489  : 		do {
; 490  : 			keyChar = RandomByte();
; 491  : 		} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 492  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 493  : 			keyCharTable_SecondByte[i] = keyChar;
; 494  : 			do {
; 495  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 496  : 			} while (!IS_SECOND_BYTE_SJIS(keyChar));
; 497  : 		}
; 498  : 
; 499  : 		// Set keyCharTable_SecondByteAndOneByte[].
; 500  : 		do {
; 501  : 			keyChar = RandomByte();
; 502  : 		} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 503  : 		for (i = 0; i < SIZE_KEY_CHAR_TABLE; ++i) {
; 504  : 			keyCharTable_SecondByteAndOneByte[i] = keyChar;
; 505  : 			do {
; 506  : 				keyChar = ((int32_t)keyChar + 1) & 0xff;
; 507  : 			} while (!(IS_SECOND_BYTE_SJIS(keyChar) && IS_ONE_BYTE_KEY_CHAR(keyChar)));
; 508  : 		}
; 509  : 
; 510  : 		// Count characters in each table.
; 511  : 		for (int32_t i = 0; i < 256; ++i) {
; 512  : 			if (IS_ONE_BYTE_KEY_CHAR(i) || IsFirstByteSJIS(i) ) ++numFirstByte;
; 513  : 			if (                           IS_SECOND_BYTE_SJIS(i)) ++numSecondByte;
; 514  : 			if (IS_ONE_BYTE_KEY_CHAR(i)                          ) ++numOneByte;
; 515  : 		}
; 516  : 	}
; 517  : #if FALSE
; 518  : 	printf("numFirstByte  = %d\n", numFirstByte);
; 519  : 	printf("numSecondByte = %d\n", numSecondByte);
; 520  : 	printf("numOneByte    = %d\n", numOneByte);
; 521  : #endif
; 522  : }
; 523  : 
; 524  : void DisplayCopyrights()
; 525  : {
; 526  : #ifdef ENGLISH_VERSION
; 527  : 	printf("%s English\n", PRODUCT_NAME);
; 528  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 529  : 	printf("Copyright (C) 2014-2016 !/Meriken/. <meriken.ygch.net@gmail.com>\n");
; 530  : #else
; 531  : 	printf("%s\n", PRODUCT_NAME);
; 532  : 	printf("[compiled at %s on %s (PST)]\n", __TIME__, __DATE__);
; 533  : 	printf("Copyright (C) 2011-2016 %c%c/Meriken/. <meriken.ygch.net@gmail.com>\n", 0x81, 0x9f);
; 534  : #endif
; 535  : 	printf("This program comes with ABSOLUTELY NO WARRANTY.\n");
; 536  :     printf("This is free software, and you are welcome to redistribute it\n");
; 537  :     printf("under certain conditions.\n");
; 538  :     printf("\n");
; 539  : }
; 540  : 
; 541  : void UpdateCUDADeviceStatus(struct CUDADeviceSearchThreadInfo *info, char *status)
; 542  : {
; 543  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 544  : 	strcpy(info->status, status);
; 545  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 546  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 547  : }
; 548  : 
; 549  : void UpdateOpenCLDeviceStatus(struct OpenCLDeviceSearchThreadInfo *info, char *status)
; 550  : {
; 551  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 552  : 	ASSERT(!info->runChildProcess);
; 553  : 	strcpy(info->status, status);
; 554  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 555  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 556  : }
; 557  : 
; 558  : void UpdateOpenCLDeviceStatus_ChildProcess(struct OpenCLDeviceSearchThreadInfo *info, char *status, double currentSpeed, double averageSpeed, double totalNumGeneratedTripcodes, uint32_t numDiscardedTripcodes, boost::process::child *child_process)
; 559  : {
; 560  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 561  : 	ASSERT(info->runChildProcess);
; 562  : 	strcpy(info->status, status);
; 563  : 	info->currentSpeed = currentSpeed;
; 564  : 	info->averageSpeed = averageSpeed;
; 565  : 	info->totalNumGeneratedTripcodes = totalNumGeneratedTripcodes;
; 566  : 	info->numDiscardedTripcodes = numDiscardedTripcodes;
; 567  : 	info->child_process = child_process;
; 568  : 	info->timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 569  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 570  : }
; 571  : 
; 572  : void CheckSearchThreads()
; 573  : {
; 574  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 575  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index) {
; 576  : 		struct CUDADeviceSearchThreadInfo *info = &CUDADeviceSearchThreadInfoArray[index];
; 577  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 578  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 579  : 		// if (deltaTime > 60 * 1000)
; 580  : 		//	strcpy(info->status, "Search thread became unresponsive.");
; 581  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 582  : 		///*
; 583  : 		if (deltaTime > 60 * 1000) {
; 584  : 			strcpy(info->status, "Restarting search thread...");
; 585  : 			auto native_handle = cuda_device_search_threads[index]->native_handle();
; 586  : 			cuda_device_search_threads[index]->detach();
; 587  : 			delete cuda_device_search_threads[index];
; 588  : #ifdef _WINDOWS_
; 589  : 			TerminateThread(native_handle, 0);
; 590  : #elif defined(_POSIX_THREADS)
; 591  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 592  : 			pthread_cancel(native_handle);
; 593  : #endif
; 594  : 			cuda_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 595  : 														          ? Thread_SearchForDESTripcodesOnCUDADevice
; 596  : 															      : Thread_SearchForSHA1TripcodesOnCUDADevice,
; 597  : 															    &(CUDADeviceSearchThreadInfoArray[index]));
; 598  : 		}
; 599  : 		//*/
; 600  : 	}
; 601  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 602  : 
; 603  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 604  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index) {
; 605  : 		struct OpenCLDeviceSearchThreadInfo *info = &openCLDeviceSearchThreadInfoArray[index];
; 606  : 		uint64_t  currentTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 607  : 		uint64_t  deltaTime = currentTime - info->timeLastUpdated;
; 608  : 		//ERROR0(deltaTime > 1 * 60 * 1000, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 609  : 		///*
; 610  : 		if (deltaTime > 60 * 1000) {
; 611  : 			// If we restart the search thread while the OpenCL kernel is running, amdocl64.dll may crash.
; 612  : 			ERROR0(!info->runChildProcess, ERROR_SEARCH_THREAD_UNRESPONSIVE, "Search thread became unresponsive.");
; 613  : 
; 614  : 			strcpy(info->status, "[process] Restarting search thread...");
; 615  : 			auto native_handle = opencl_device_search_threads[index]->native_handle();
; 616  : 			opencl_device_search_threads[index]->detach();
; 617  : 			delete opencl_device_search_threads[index];
; 618  : #if 0
; 619  : 			if (info->child_process) {
; 620  : 				boost_process_spinlock.lock();
; 621  : 				boost::process::terminate(*(info->child_process));
; 622  : 				boost_process_spinlock.unlock();
; 623  : 			}
; 624  : #endif
; 625  : 			info->child_process = NULL;
; 626  : #ifdef _WINDOWS_
; 627  : 			TerminateThread(native_handle, 0);
; 628  : #elif defined(_POSIX_THREADS)
; 629  : 			pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
; 630  : 			pthread_cancel(native_handle);
; 631  : #endif
; 632  : 			info->currentSpeed = 0;
; 633  : 			info->averageSpeed = 0;
; 634  : 			++info->numRestarts;
; 635  : 
; 636  : 			uint32_t winThreadID;
; 637  : 			opencl_device_search_threads[index] = new std::thread((lenTripcode == 10) 
; 638  : 																	       ? Thread_SearchForDESTripcodesOnOpenCLDevice
; 639  : 													                       : Thread_SearchForSHA1TripcodesOnOpenCLDevice,
; 640  : 																	   &(openCLDeviceSearchThreadInfoArray[index]));
; 641  : 		}
; 642  : 		//*/
; 643  : 	}
; 644  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 645  : }
; 646  : 
; 647  : void KeepSearchThreadsAlive()
; 648  : {
; 649  : 	cuda_device_search_thread_info_array_spinlock.lock();
; 650  : 	for (int32_t index = 0; index < numCUDADeviceSearchThreads; ++index)
; 651  : 		CUDADeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 652  : 	cuda_device_search_thread_info_array_spinlock.unlock();
; 653  : 
; 654  : 	opencl_device_search_thread_info_array_spinlock.lock();
; 655  : 	for (int32_t index = 0; index < numOpenCLDeviceSearchThreads; ++index)
; 656  : 		openCLDeviceSearchThreadInfoArray[index].timeLastUpdated = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 657  : 	opencl_device_search_thread_info_array_spinlock.unlock();
; 658  : }
; 659  : 
; 660  : void PrintStatus()
; 661  : {
; 662  : 	if (GetErrorState() || GetTerminationState())
; 663  : 		return;
; 664  : 
; 665  : 	current_state_spinlock.lock();
; 666  : 
; 667  : 	char msg[MAX_NUM_LINES_STATUS_MSG][LEN_LINE_BUFFER_FOR_SCREEN];
; 668  : 	int32_t lineCount = 0;
; 669  : 
; 670  : #define NEXT_LINE &(msg[lineCount++][0])
; 671  : 
; 672  : 	sprintf(NEXT_LINE, "%-79s", "");
; 673  : 	sprintf(NEXT_LINE, "%-79s", "STATUS");
; 674  : 	sprintf(NEXT_LINE, "%-79s", "======");
; 675  : 	sprintf(NEXT_LINE, "  Performing a %s search on %s",
; 676  : 			(searchMode == SEARCH_MODE_FORWARD_MATCHING             ) ? "forward-matching"  :
; 677  : 			(searchMode == SEARCH_MODE_BACKWARD_MATCHING            ) ? "backward-matching" :
; 678  : 			(searchMode == SEARCH_MODE_FORWARD_AND_BACKWARD_MATCHING) ? "forward- and backward-matching" :
; 679  : 	                                                                    "flexible",
; 680  : 			(searchDevice == SEARCH_DEVICE_CPU) ? "CPU" :
; 681  : 			(searchDevice == SEARCH_DEVICE_GPU) ? "GPU(s)" :
; 682  : 	                                              "CPU and GPU(s)");
; 683  : 	if (minLenExpandedPattern != maxLenExpandedPattern) {
; 684  : 		sprintf(NEXT_LINE,
; 685  : 				"  for %d pattern%s (%d chunk%s) with %d to %d characters%s",
; 686  : 				numExpandedPatterns,
; 687  : 				(numExpandedPatterns == 1) ? "" : "s",
; 688  : 				numTripcodeChunk,
; 689  : 				(numTripcodeChunk == 1) ? "" : "s",
; 690  : 				minLenExpandedPattern,
; 691  : 				maxLenExpandedPattern,
; 692  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 693  : 		
; 694  : 	} else {
; 695  : 		sprintf(NEXT_LINE,
; 696  : 				"  for %d pattern%s (%d chunk%s) with %d characters%s",
; 697  : 				numExpandedPatterns,
; 698  : 				(numExpandedPatterns == 1) ? "" : "s",
; 699  : 				numTripcodeChunk,
; 700  : 				(numTripcodeChunk == 1) ? "" : "s",
; 701  : 				minLenExpandedPattern,
; 702  : 				(searchDevice == SEARCH_DEVICE_CPU) ? "." : ":");
; 703  : 	}
; 704  : 	if (searchDevice != SEARCH_DEVICE_CPU && CUDADeviceSearchThreadInfoArray) {
; 705  : 		cuda_device_search_thread_info_array_spinlock.lock();
; 706  : 		if (numCUDADeviceSearchThreads == 1) {
; 707  : 			sprintf(NEXT_LINE, "      CUDA0:     %s", CUDADeviceSearchThreadInfoArray[0].status);
; 708  : 		} else {
; 709  : 			for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i)
; 710  : 				sprintf(NEXT_LINE, "      CUDA%d-%d:     %s", CUDADeviceSearchThreadInfoArray[i].CUDADeviceIndex, CUDADeviceSearchThreadInfoArray[i].subindex, CUDADeviceSearchThreadInfoArray[i].status);
; 711  : 		}
; 712  : 		cuda_device_search_thread_info_array_spinlock.unlock();
; 713  : 	}
; 714  : 	if (searchDevice != SEARCH_DEVICE_CPU && openCLDeviceSearchThreadInfoArray) {
; 715  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 716  : 		if (numOpenCLDeviceSearchThreads == 1) {
; 717  : 			sprintf(NEXT_LINE, "      OpenCL0:   %s", openCLDeviceSearchThreadInfoArray[0].status);
; 718  : 		} else {
; 719  : 			for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 720  : 				if (openCLDeviceSearchThreadInfoArray[i].subindex < 0) {
; 721  : 					sprintf(NEXT_LINE, "      OpenCL%d:   %s",  openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].status);
; 722  : 				} else {
; 723  : 					sprintf(NEXT_LINE, "      OpenCL%d-%d: %s", openCLDeviceSearchThreadInfoArray[i].index, openCLDeviceSearchThreadInfoArray[i].subindex, openCLDeviceSearchThreadInfoArray[i].status);
; 724  : 				}
; 725  : 			}
; 726  : 		}
; 727  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 728  : 	}
; 729  : #if FALSE
; 730  : 	if (CUDADeviceSearchThreadInfoArray && IsCUDADeviceOptimizationInProgress())
; 731  : 		sprintf(NEXT_LINE, "      [optimization in progress]");
; 732  : #endif
; 733  : 
; 734  : 	double currentSpeed_childProcesses = 0;
; 735  : 	double averageSpeed_childProcesses = 0;
; 736  : 	double totalNumGeneratedTripcodes_childProcesses = 0;
; 737  : 	uint32_t numDiscardedTripcodes_childProcesses = 0;
; 738  : 	// printf("numOpenCLDeviceSearchThreads = %d\n", numOpenCLDeviceSearchThreads);
; 739  : 	if (openCLDeviceSearchThreadInfoArray && openCLRunChildProcesses) {
; 740  : 		opencl_device_search_thread_info_array_spinlock.lock();
; 741  : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {
; 742  : 			// printf("deviceNo = %d\n", openCLDeviceSearchThreadInfoArray[i].deviceNo);
; 743  : 			if (!(openCLDeviceSearchThreadInfoArray[i].runChildProcess))
; 744  : 				continue;
; 745  : 			currentSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].currentSpeed;
; 746  : 			averageSpeed_childProcesses               += openCLDeviceSearchThreadInfoArray[i].averageSpeed;
; 747  : 			totalNumGeneratedTripcodes_childProcesses += openCLDeviceSearchThreadInfoArray[i].totalNumGeneratedTripcodes;
; 748  : 			numDiscardedTripcodes_childProcesses      += openCLDeviceSearchThreadInfoArray[i].numDiscardedTripcodes;
; 749  : 		}
; 750  : 		opencl_device_search_thread_info_array_spinlock.unlock();
; 751  : 	}
; 752  : 
; 753  : 	double averageSpeed;
; 754  : 	double averageSpeed_GPU;
; 755  : 	double averageSpeed_CPU;
; 756  : 	double timeForOneMatch;
; 757  : 	double actualMatchingProb;
; 758  : 	double matchingProbDiff;
; 759  : 	double invalidTripcodeRatio = (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0)
; 760  : 			                            ? ((double)(prevNumDiscardedTripcodes) / (prevNumValidTripcodes + prevNumDiscardedTripcodes))
; 761  : 										: 0;
; 762  : 	if (totalTime > 0) {
; 763  : 		uint32_t remainingSeconds = (uint32_t)totalTime;
; 764  : 		uint32_t totalTimeDays    = remainingSeconds / (24 * 60 * 60); remainingSeconds -= totalTimeDays    * 24 * 60 * 60;
; 765  : 		uint32_t totalTimeHours   = remainingSeconds / (     60 * 60); remainingSeconds -= totalTimeHours        * 60 * 60;
; 766  : 		uint32_t totalTimeMinutes = remainingSeconds / (          60); remainingSeconds -= totalTimeMinutes           * 60;
; 767  : 		uint32_t totalTimeSeconds = remainingSeconds;
; 768  : 		
; 769  : 		sprintf(NEXT_LINE, "");
; 770  : 		sprintf(NEXT_LINE, "  %.3lfT tripcodes were generated in %dd %dh %dm %02ds at:",
; 771  : 				(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) * 0.000000000001,
; 772  : 				totalTimeDays,
; 773  : 				totalTimeHours,
; 774  : 				totalTimeMinutes,
; 775  : 				totalTimeSeconds);
; 776  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (current)", (currentSpeed_thisProcess + currentSpeed_childProcesses) / 1000000);
; 777  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 778  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", (currentSpeed_thisProcess_GPU + currentSpeed_childProcesses) / 1000000);
; 779  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", currentSpeed_CPU / 1000000);
; 780  : 		}
; 781  : #ifdef DISPLAY_MAXIMUM_SPEED
; 782  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (maximum)", maximumSpeed);
; 783  : #endif
; 784  : 		averageSpeed     = prevTotalNumGeneratedTripcodes     / totalTime + averageSpeed_childProcesses;
; 785  : 		averageSpeed_GPU = prevTotalNumGeneratedTripcodes_GPU / totalTime + averageSpeed_childProcesses;
; 786  : 		averageSpeed_CPU = prevTotalNumGeneratedTripcodes_CPU / totalTime;
; 787  : 		sprintf(NEXT_LINE, "      %3.2lfM tripcode/s (average)",  averageSpeed / 1000000);
; 788  : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 789  : 			sprintf(NEXT_LINE, "          GPU: %7.2lfM tripcode/s", averageSpeed_GPU / 1000000);
; 790  : 			sprintf(NEXT_LINE, "          CPU: %7.2lfM tripcode/s", averageSpeed_CPU / 1000000);
; 791  : 		}
; 792  : 		
; 793  : 		timeForOneMatch = numAverageTrialsForOneMatch / averageSpeed;
; 794  : 		if (averageSpeed > 0 && !searchForSpecialPatternsOnCPU) {
; 795  : 			if (timeForOneMatch >= 100.0 * 365 * 24 * 60 * 60) {
; 796  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf centuries to find one match at this speed.", timeForOneMatch / (100.0 * 365 * 24 * 60 * 60));			
; 797  : 			} else if (timeForOneMatch >= 365.0 * 24 * 60 * 60) {
; 798  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf years to find one match at this speed.", timeForOneMatch / (365.0 * 24 * 60 * 60));			
; 799  : 			} else if (timeForOneMatch >= 30.4 * 24 * 60 * 60) {
; 800  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf months to find one match at this speed.", timeForOneMatch / (30.4 * 24 * 60 * 60));			
; 801  : 			} else if (timeForOneMatch >= 24 * 60 * 60) {
; 802  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf days to find one match at this speed.", timeForOneMatch / (24 * 60 * 60));			
; 803  : 			} else if (timeForOneMatch >= 60 * 60) {
; 804  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf hours to find one match at this speed.", timeForOneMatch / (60 * 60));			
; 805  : 			} else if (timeForOneMatch >= 60) {
; 806  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf minutes to find one match at this speed.", timeForOneMatch / 60);			
; 807  : 			} else {
; 808  : 				sprintf(NEXT_LINE, "  On average, it takes %.1lf seconds to find one match at this speed.", timeForOneMatch);			
; 809  : 			}
; 810  : 		}
; 811  : 		sprintf(NEXT_LINE, "");
; 812  : 		if (numValidTripcodes <= 0) {
; 813  : 			sprintf(NEXT_LINE, "  No matches were found yet.");
; 814  : 		} else {
; 815  : 			if (prevNumValidTripcodes > 0) {
; 816  : 				sprintf(NEXT_LINE, "  %ld match%s found at %.2lf matches/h and %.2lfG tripcodes/match.",
; 817  : 						prevNumValidTripcodes,
; 818  : 						(prevNumValidTripcodes == 1) ? "" : "es",
; 819  : 						prevNumValidTripcodes / (totalTime / 3600),
; 820  : 						(double)(prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses) / prevNumValidTripcodes * 0.000000001);
; 821  : 			}
; 822  : 			actualMatchingProb = (prevNumValidTripcodes + prevNumDiscardedTripcodes + numDiscardedTripcodes_childProcesses) / (prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses);
; 823  : 			matchingProbDiff = (actualMatchingProb - matchingProb) / matchingProb;
; 824  : #ifdef DEBUG_DISPLAY_MATCHING_PROBABILITY
; 825  : 			sprintf(NEXT_LINE, "  The theoretical matching probability is %0.20lf%%.", matchingProb);
; 826  : #endif
; 827  : 			if (!searchForSpecialPatternsOnCPU) {
; 828  : 				if (matchingProbDiff > 0.01) {
; 829  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% higher than expected.", matchingProbDiff * 100);
; 830  : 				} else if (matchingProbDiff < -0.01) {
; 831  : 					sprintf(NEXT_LINE, "  The actual matching probability is %.0f%% lower than expected.",
; 832  : 							-matchingProbDiff * 100);
; 833  : 				} else {
; 834  : 					sprintf(NEXT_LINE, "  The actual matching probability is about the same as expected.");
; 835  : 				}
; 836  : 			}
; 837  : 			if (prevNumValidTripcodes + prevNumDiscardedTripcodes > 0) {
; 838  : 				sprintf(NEXT_LINE, "  %.0f%% of matching tripcodes were invalid.",
; 839  : 						invalidTripcodeRatio * 100);
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 	
; 844  : 	if (!options.redirection) {
; 845  : 		for (int32_t i = 0; i < lineCount; ++i)
; 846  : 			printf("%-79s\n", &(msg[i][0]));
; 847  : 		reset_cursor_pos(-lineCount);
; 848  : 		prevLineCount = lineCount;
; 849  : 	} else {
; 850  : 		if (totalTime > 0 && !searchForSpecialPatternsOnCPU) {
; 851  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,%.1lf,%s%d%%,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 852  : 			       totalTime,
; 853  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 854  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 855  : 				   currentSpeed_CPU,
; 856  : 				   averageSpeed,
; 857  : 				   timeForOneMatch,
; 858  : 				   ((int32_t)(matchingProbDiff * 100) > 0) ? "+" : "", // All I want to do here is to avoid "-0%" and "+0%".
; 859  : 				    (int32_t)(matchingProbDiff * 100),
; 860  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 861  : 				   prevNumValidTripcodes,
; 862  : 				   FALSE,
; 863  : 				   averageSpeed_GPU,
; 864  : 				   averageSpeed_CPU,
; 865  : 				   prevNumDiscardedTripcodes,
; 866  : 				   invalidTripcodeRatio * 100);
; 867  : 		} else if (totalTime > 0) {
; 868  : 			printf("[status],%.0lf,%.0lf,%.0lf,%.0lf,%.0lf,-,-,%.0lf,%ld,%d,%.0lf,%.0lf,%u,%.0f%%\n",
; 869  : 			       totalTime,
; 870  : 				   currentSpeed_thisProcess     + currentSpeed_childProcesses,
; 871  : 				   currentSpeed_thisProcess_GPU + currentSpeed_childProcesses,
; 872  : 				   currentSpeed_CPU,
; 873  : 				   averageSpeed,
; 874  : 				   prevTotalNumGeneratedTripcodes + totalNumGeneratedTripcodes_childProcesses,
; 875  : 				   prevNumValidTripcodes,
; 876  : 				   FALSE,
; 877  : 				   averageSpeed_GPU,
; 878  : 				   averageSpeed_CPU,
; 879  : 				   prevNumDiscardedTripcodes,
; 880  : 				   invalidTripcodeRatio * 100);
; 881  : 		}
; 882  : 		fflush(stdout);
; 883  : 	}
; 884  : 	
; 885  : 	current_state_spinlock.unlock();
; 886  : #undef NEXT_LINE
; 887  : }
; 888  : 
; 889  : BOOL WINAPI ControlHandler(_In_  DWORD dwCtrlType)
; 890  : {
; 891  : 	switch (dwCtrlType) {
; 892  : 	case CTRL_C_EVENT:
; 893  : 	case CTRL_CLOSE_EVENT:
; 894  : 	case CTRL_SHUTDOWN_EVENT:
; 895  : 	case CTRL_LOGOFF_EVENT:
; 896  : 		SetTerminationState();
; 897  : 		while (TRUE)
; 898  : 			Sleep(1000);
; 899  : 		return TRUE;
; 900  : 	default:
; 901  : 		return FALSE;
; 902  : 	}
; 903  : }
; 904  : 
; 905  : void InitProcess()
; 906  : {
; 907  : 	hide_cursor();
; 908  : 	SetConsoleCtrlHandler(ControlHandler, true);

	lea	rcx, OFFSET FLAT:?ControlHandler@@YAHK@Z ; ControlHandler
	mov	edx, 1
	call	QWORD PTR __imp_SetConsoleCtrlHandler

; 2043 : 	}
; 2044 : 
; 2045 : 	InitProcess();
; 2046 : 	if (    argc <= 1
; 2047 : 		|| (   strcmp(argv[1], "--gpu-list"              ) != 0
; 2048 : 		    && !displayDeviceInformationAndExit
; 2049 : 			&& !listExpandedPatternsAndExit
; 2050 : 		    && strcmp(argv[1], "--output-for-redirection") != 0))

	cmp	ebp, 1
	jle	SHORT $LN54@main
	mov	r15, QWORD PTR [r14+8]
	lea	rdx, OFFSET FLAT:$SG4294856503
	mov	rcx, r15
	call	strcmp
	test	eax, eax
	je	SHORT $LN55@main
	test	edi, edi
	jne	SHORT $LN55@main
	test	ebx, ebx
	jne	SHORT $LN55@main
	lea	rdx, OFFSET FLAT:$SG4294856502
	mov	rcx, r15
	call	strcmp
	test	eax, eax
	je	SHORT $LN55@main
$LN54@main:

; 2051 : 		DisplayCopyrights();

	call	?DisplayCopyrights@@YAXXZ		; DisplayCopyrights
$LN55@main:

; 2052 : 	ObtainOptions(argc, argv);

	mov	rdx, r14
	mov	ecx, ebp
	call	?ObtainOptions@@YAXHPEAPEAD@Z		; ObtainOptions

; 2053 : 	if (argc > 1 && strcmp(argv[1], "--gpu-list") == 0)

	cmp	ebp, 1
	jle	SHORT $LN53@main
	mov	rcx, QWORD PTR [r14+8]
	lea	rdx, OFFSET FLAT:$SG4294856501
	call	strcmp
	test	eax, eax
	jne	SHORT $LN53@main

; 909  : }
; 910  : 
; 911  : void ListCUDADevices()
; 912  : {
; 913  : 	int32_t i;
; 914  : 	cudaDeviceProp CUDADeviceProperties;
; 915  : 	
; 916  : 	cudaGetDeviceCount(&CUDADeviceCount);
; 917  : 
; 918  : 	for (i = 0; i < CUDADeviceCount; ++i) {
; 919  : 		cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 920  : 		printf("NVIDIA %s (CUDA)\n", CUDADeviceProperties.name); 
; 921  : 	}
; 922  : }
; 923  : 
; 924  : void CountOpenCLDevices()
; 925  : {
; 926  :     cl_int        errorCode;
; 927  :     cl_uint       numPlatforms;
; 928  : 	cl_uint       deviceCount;
; 929  : 	cl_device_id *devices = NULL;
; 930  : 
; 931  : 	openCLDeviceCount = 0;
; 932  : 
; 933  : 	// Get a list of platforms
; 934  : 	errorCode = clGetPlatformIDs(0, NULL, &numPlatforms);
; 935  :     if (errorCode != CL_SUCCESS || numPlatforms <= 0)
; 936  : 		return;
; 937  : 	cl_platform_id* platforms = (cl_platform_id*)malloc(sizeof(cl_platform_id) * numPlatforms);
; 938  : 	ERROR0(platforms == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 939  :     errorCode = clGetPlatformIDs(numPlatforms, platforms, NULL);
; 940  :     OPENCL_ERROR(errorCode);
; 941  : 
; 942  : 	int32_t openCLDeviceIDArrayIndex = 0;
; 943  : 	for (int32_t pass = 0; pass <= 1; ++pass) {
; 944  : 		for (int32_t platformIndex = 0; platformIndex < numPlatforms; ++platformIndex) {
; 945  : 			// Skip CUDA devices.
; 946  : 			char platformVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 947  : 			errorCode = clGetPlatformInfo(platforms[platformIndex], CL_PLATFORM_VENDOR, sizeof(platformVendor), platformVendor, NULL);
; 948  : 			// OPENCL_ERROR(errorCode);
; 949  : 			if (errorCode != CL_SUCCESS)
; 950  : 				continue;
; 951  : 			if (   (strcmp(platformVendor, OPENCL_VENDOR_NVIDIA) == 0 && !options.useOpenCLForCUDADevices)
; 952  : 				||  strcmp(platformVendor, OPENCL_VENDOR_INTEL ) == 0                                     )
; 953  : 				continue;
; 954  : 		
; 955  : 			// Get a list of devices on the platform.
; 956  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
; 957  : 			// OPENCL_ERROR(errorCode);
; 958  : 			// if (errorCode == CL_DEVICE_NOT_FOUND)
; 959  : 			//	continue;
; 960  : 			if (errorCode != CL_SUCCESS)
; 961  : 				continue;
; 962  : 			devices = (cl_device_id*)malloc(sizeof(cl_device_id) * deviceCount);
; 963  : 			ERROR0(devices == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 964  : 			errorCode = clGetDeviceIDs(platforms[platformIndex], CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR, deviceCount, devices, &deviceCount);
; 965  : 			if (errorCode != CL_DEVICE_NOT_FOUND) {
; 966  : 				OPENCL_ERROR(errorCode);
; 967  : 				for(int32_t deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex) {
; 968  : 					if (pass == 0) {
; 969  : 						++openCLDeviceCount;
; 970  : 					} else {
; 971  : 						openCLDeviceIDArray[openCLDeviceIDArrayIndex++] = devices[deviceIndex];
; 972  : 					}
; 973  : 				}
; 974  : 			}
; 975  : 			free(devices);
; 976  : 		}
; 977  : 		if (pass == 0) {
; 978  : 			openCLDeviceIDArray = (cl_device_id *)malloc(sizeof(cl_device_id) * openCLDeviceCount);
; 979  : 			ERROR0(openCLDeviceIDArray == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 980  : 		}
; 981  : 	}
; 982  : 
; 983  :     free(platforms);
; 984  : }
; 985  : 
; 986  : void ListOpenCLDevices()
; 987  : {
; 988  :     cl_int  errorCode;
; 989  :     cl_uint numPlatforms;
; 990  : 	cl_uint deviceCount;
; 991  : 	char    deviceVendor[LEN_LINE_BUFFER_FOR_SCREEN];
; 992  : 	char    deviceName  [LEN_LINE_BUFFER_FOR_SCREEN];
; 993  : 	cl_uint numComputeUnits;
; 994  : 
; 995  : 	CountOpenCLDevices();
; 996  : 
; 997  : 	for(int32_t deviceIndex = 0; deviceIndex < openCLDeviceCount; ++deviceIndex) {  
; 998  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_VENDOR,            sizeof(deviceVendor),    &deviceVendor,    NULL));
; 999  : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_NAME,              sizeof(deviceName),      &deviceName,      NULL));
; 1000 : 		OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[deviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numComputeUnits), &numComputeUnits, NULL));
; 1001 : 		// printf("%d: ", CUDADeviceCount + deviceIndex);
; 1002 : 		if (strcmp(deviceVendor, OPENCL_VENDOR_AMD) == 0) {
; 1003 : 			printf("AMD ");
; 1004 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_INTEL) == 0) {
; 1005 : 			// Do not print anything.
; 1006 : 		} else if (strcmp(deviceVendor, OPENCL_VENDOR_NVIDIA) == 0) {
; 1007 : 			printf("NVIDIA ");
; 1008 : 		} else {
; 1009 : 			printf("%s ", deviceVendor);
; 1010 : 		}
; 1011 : 		char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1012 : 		if (productName) {
; 1013 : 			printf("%s", productName);
; 1014 : 		} else {
; 1015 : 			printf("%s", deviceName);
; 1016 : 		}
; 1017 : 		printf(" (OpenCL)\n");
; 1018 : 	}
; 1019 : }
; 1020 : 
; 1021 : void ListGPUsAndExit()
; 1022 : {
; 1023 : 	if (!options.useOpenCLForCUDADevices)

	cmp	DWORD PTR ?options@@3UOptions@@A+76, esi
	jne	$LN68@main
	jmp	$LN660@main
$LN53@main:

; 2054 : 		ListGPUsAndExit();
; 2055 : 	InitSearchDevices((!options.redirection && !listExpandedPatternsAndExit) || displayDeviceInformationAndExit);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	jne	SHORT $LN59@main
	test	ebx, ebx
	je	SHORT $LN60@main
$LN59@main:
	mov	ecx, esi
	test	edi, edi
	je	SHORT $LN61@main
$LN60@main:
	mov	ecx, 1
$LN61@main:
	call	?InitSearchDevices@@YAXH@Z		; InitSearchDevices

; 2056 : 
; 2057 : 	if (displayDeviceInformationAndExit)

	test	edi, edi
	jne	$LN662@main

; 2059 : 
; 2060 : 	CreateCharacterTables();

	call	?CreateCharacterTables@@YAXXZ		; CreateCharacterTables

; 2061 : 	LoadTargetPatterns(!options.redirection && !listExpandedPatternsAndExit);

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	jne	SHORT $LN62@main
	lea	ecx, QWORD PTR [rdi+1]
	test	ebx, ebx
	je	SHORT $LN63@main
$LN62@main:
	mov	ecx, esi
$LN63@main:
	call	?LoadTargetPatterns@@YAXH@Z		; LoadTargetPatterns

; 2062 : 
; 2063 : 	if (listExpandedPatternsAndExit) {

	test	ebx, ebx
	je	SHORT $LN51@main

; 1985 : }
; 1986 : 
; 1987 : void StartCPUSearchThreads()
; 1988 : {
; 1989 : 	ASSERT(numCPUSearchThreads > 0);
; 1990 : 
; 1991 : 	uint32_t winThreadID;
; 1992 : 	
; 1993 : 	if (cpu_search_threads)
; 1994 : 		delete [] cpu_search_threads;
; 1995 : 	ERROR0((cpu_search_threads = new (std::nothrow) std::thread *[numCPUSearchThreads]) == NULL, ERROR_NO_MEMORY, GetErrorMessage(ERROR_NO_MEMORY));
; 1996 : 	
; 1997 : 	for (int32_t i = 0; i < numCPUSearchThreads; ++i) {
; 1998 : 		if (lenTripcode == 12) {
; 1999 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForSHA1TripcodesOnCPU);
; 2000 : 		} else {
; 2001 : 			ASSERT(lenTripcode == 10);
; 2002 : 			cpu_search_threads[i] = new (std::nothrow) std::thread(Thread_SearchForDESTripcodesOnCPU);
; 2003 : 		}
; 2004 : 		ERROR0((cpu_search_threads[i] == NULL), ERROR_SEARCH_THREAD, "Failed to start a CPU search thread.");
; 2005 : 	}
; 2006 : }
; 2007 : 
; 2008 : int32_t GetParentProcessID()
; 2009 : {
; 2010 : 	int32_t processID = GetCurrentProcessId();
; 2011 : 	int32_t parentProcessID = -1;
; 2012 : 	HANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
; 2013 : 	PROCESSENTRY32 processEntry = {0};
; 2014 : 	processEntry.dwSize = sizeof(PROCESSENTRY32);
; 2015 : 
; 2016 : 	if(Process32First(hSnapProcess, &processEntry)) {
; 2017 : 		do {
; 2018 :     		if (processEntry.th32ProcessID == processID) {
; 2019 :     			parentProcessID = processEntry.th32ParentProcessID;
; 2020 :     			break;
; 2021 : 			}
; 2022 : 		} while( Process32Next(hSnapProcess, &processEntry));
; 2023 : 	}
; 2024 : 
; 2025 : 	CloseHandle(hSnapProcess);
; 2026 : 	return parentProcessID;
; 2027 : }
; 2028 : 
; 2029 : void ListExpandedPatterns()
; 2030 : {
; 2031 : 	for (int32_t i = 0; i < numExpandedPatterns; ++i)

	cmp	DWORD PTR ?numExpandedPatterns@@3IA, esi ; numExpandedPatterns
	jbe	$LN663@main
	mov	rbx, rsi
	npad	9
$LL74@main:

; 2032 : 		printf("%d: `%s' @ %d\n", i, expandedPatternArray[i].c, expandedPatternArray[i].pos);

	mov	rdx, QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA ; expandedPatternArray
	movsxd	rax, esi
	movzx	r9d, BYTE PTR [rbx+rdx]
	lea	r8, QWORD PTR [rdx+1]
	mov	edx, esi
	imul	rcx, rax, 14
	add	r8, rcx
	lea	rcx, OFFSET FLAT:$SG4294856506
	call	printf
	inc	esi
	lea	rbx, QWORD PTR [rbx+14]
	cmp	esi, DWORD PTR ?numExpandedPatterns@@3IA ; numExpandedPatterns
	jb	SHORT $LL74@main
	jmp	$LN663@main
$LN51@main:

; 2066 : 	}
; 2067 : 
; 2068 : 	if (!options.redirection)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	jne	SHORT $LL129@main

; 1027 : }
; 1028 : 
; 1029 : void InitSearchDevices(BOOL displayDeviceInformation)
; 1030 : {
; 1031 : 	int32_t i;
; 1032 : 	cudaDeviceProp CUDADeviceProperties;
; 1033 : 	
; 1034 : 	if (options.useOpenCLForCUDADevices) {
; 1035 : 		CUDADeviceCount = 0;
; 1036 : 	} else {
; 1037 : 		cudaGetDeviceCount(&CUDADeviceCount);
; 1038 : 	}
; 1039 : 	CountOpenCLDevices();
; 1040 : 	ERROR0(   options.GPUIndex != GPU_INDEX_ALL
; 1041 : 		   && (options.GPUIndex < 0 || CUDADeviceCount + openCLDeviceCount <= options.GPUIndex),
; 1042 : 			ERROR_INVALID_OPTION,
; 1043 : 			"An invalid device was specified.");
; 1044 : 	if (options.searchDevice == SEARCH_DEVICE_NIL) {
; 1045 : 		searchDevice = (CUDADeviceCount <= 0 && openCLDeviceCount <= 0) ? (SEARCH_DEVICE_CPU) : (SEARCH_DEVICE_GPU);
; 1046 : 	} else {
; 1047 : 		searchDevice = options.searchDevice;
; 1048 : 	}
; 1049 : #ifdef DEBUG_USE_CPU_ONLY
; 1050 : 	searchDevice = SEARCH_DEVICE_CPU;
; 1051 : #endif
; 1052 : 	
; 1053 : #if FALSE
; 1054 : 	if (displayDeviceInformation) {
; 1055 : 		if (searchDevice == SEARCH_DEVICE_CPU) {
; 1056 : 			printf("CPU will be used as a search device.\n\n");
; 1057 : 		} else if (searchDevice == SEARCH_DEVICE_GPU && CUDADeviceCount + openCLDeviceCount <= 1 || options.GPUIndex != GPU_INDEX_ALL) {
; 1058 : 			printf("GPU will be used as a search device.\n\n");
; 1059 : 		} else if (searchDevice == SEARCH_DEVICE_GPU) {
; 1060 : 			printf("GPUs will be used as search devices.\n\n");
; 1061 : 		} else {
; 1062 : 			printf("Both GPU(s) and CPU will be used as search devices.\n\n");
; 1063 : 		}
; 1064 : 	}
; 1065 : #endif
; 1066 : 	ERROR0((searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) && CUDADeviceCount <= 0 && openCLDeviceCount <= 0,
; 1067 : 		   ERROR_INVALID_OPTION, "There is no GPU.");
; 1068 : 		
; 1069 : 	numCUDADeviceSearchThreads   = 0;
; 1070 : 	numOpenCLDeviceSearchThreads = 0;
; 1071 : 	numCPUSearchThreads          = 0;
; 1072 : 
; 1073 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1074 : 		&& CUDADeviceCount > 0
; 1075 : 		&& !options.useOpenCLForCUDADevices
; 1076 : 		&& (options.GPUIndex == GPU_INDEX_ALL || options.GPUIndex < CUDADeviceCount)) {
; 1077 : 
; 1078 : 		if (displayDeviceInformation && CUDADeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1079 : 			printf("CUDA DEVICES\n");
; 1080 : 			printf("============\n");
; 1081 : 			printf(        "  CUDA Device Count:        %d\n\n", CUDADeviceCount);
; 1082 : 		} else if (displayDeviceInformation) {
; 1083 : 			printf("CUDA DEVICE\n");
; 1084 : 			printf("===========\n");
; 1085 : 		}
; 1086 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? 0               :  options.GPUIndex     );
; 1087 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount : (options.GPUIndex + 1));
; 1088 : 			 ++i) {
; 1089 : 			if (displayDeviceInformation) {
; 1090 : 				cudaGetDeviceProperties(&CUDADeviceProperties, i);
; 1091 : 				printf(    "  Device No.:               %d\n",      i);
; 1092 : 				printf(    "  Device Name:              %s\n",      CUDADeviceProperties.name);
; 1093 : 				printf(    "  Multiprocessor Count:     %d\n",      CUDADeviceProperties.multiProcessorCount);
; 1094 : 				printf(    "  Clock Rate:               %.0fMHz\n", CUDADeviceProperties.clockRate * 1e-3f);
; 1095 : 				printf(    "  Compute Capability:       %d.%d\n",   CUDADeviceProperties.major, CUDADeviceProperties.minor);
; 1096 : 				printf(    "  Compute Mode:             %s\n",
; 1097 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeDefault         ) ? "cudaComputeModeDefault"          :
; 1098 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusive       ) ? "cudaComputeModeExclusive"        :
; 1099 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeProhibited      ) ? "cudaComputeModeProhibited"       :
; 1100 : 					   (CUDADeviceProperties.computeMode == cudaComputeModeExclusiveProcess) ? "cudaComputeModeExclusiveProcess" :
; 1101 : 					                                                                           "(unknown)"                        );
; 1102 : 				printf("\n");
; 1103 : 			}
; 1104 : 			numCUDADeviceSearchThreads += CUDA_NUM_THREADS_PER_DEVICE;
; 1105 : 		}
; 1106 : 	}
; 1107 : 
; 1108 : 	if (   (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1109 : 		&& openCLDeviceCount > 0
; 1110 : 		&& (options.GPUIndex == GPU_INDEX_ALL || CUDADeviceCount <= options.GPUIndex)) {
; 1111 : 
; 1112 : 		if (displayDeviceInformation && openCLDeviceCount > 1 && options.GPUIndex == GPU_INDEX_ALL) {
; 1113 : 			printf("OPENCL DEVICES\n");
; 1114 : 			printf("==============\n");
; 1115 : 			printf(        "  OpenCL Device Count:      %d\n\n", openCLDeviceCount);
; 1116 : 		} else if (displayDeviceInformation) {
; 1117 : 			printf("OPENCL DEVICE\n");
; 1118 : 			printf("=============\n");
; 1119 : 		}
; 1120 : 		openCLRunChildProcesses =    (   options.openCLRunChildProcesses
; 1121 : 		                              && (openCLDeviceCount > 1)
; 1122 : 			                          && (options.GPUIndex == GPU_INDEX_ALL))
; 1123 : 								  || options.openCLNumProcesses > 1;
; 1124 : 
; 1125 : 		// printf("openCLRunChildProcesses = %d\n", openCLRunChildProcesses);
; 1126 : 		for (i = ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount                     : (options.GPUIndex    ));
; 1127 : 		     i < ((options.GPUIndex == GPU_INDEX_ALL) ? CUDADeviceCount + openCLDeviceCount : (options.GPUIndex + 1));
; 1128 : 			 ++i) {
; 1129 : 			int32_t openCLDeviceIndex = i - CUDADeviceCount;
; 1130 : 			char deviceVendor [LEN_LINE_BUFFER_FOR_SCREEN];
; 1131 : 			char deviceName   [LEN_LINE_BUFFER_FOR_SCREEN];
; 1132 : 			char deviceVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1133 : 			char driverVersion[LEN_LINE_BUFFER_FOR_SCREEN];
; 1134 : 			cl_ulong globalMemorySize;
; 1135 : 			cl_uint  clockFrequency;
; 1136 : 			cl_uint  numComputeUnits;
; 1137 : 			size_t maxWorkGroupSize;
; 1138 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VENDOR,              sizeof(deviceVendor),     &deviceVendor,     NULL));
; 1139 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_NAME,                sizeof(deviceName),       &deviceName,       NULL));
; 1140 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_VERSION,             sizeof(deviceVersion),    &deviceVersion,    NULL));
; 1141 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DRIVER_VERSION,             sizeof(driverVersion),    &driverVersion,    NULL));
; 1142 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_GLOBAL_MEM_SIZE,     sizeof(globalMemorySize), &globalMemorySize, NULL));
; 1143 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(clockFrequency),   &clockFrequency,   NULL));
; 1144 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_COMPUTE_UNITS,   sizeof(numComputeUnits),  &numComputeUnits,  NULL));
; 1145 : 			OPENCL_ERROR(clGetDeviceInfo(openCLDeviceIDArray[openCLDeviceIndex], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL));
; 1146 : 			char *productName = GetProductNameForOpenCLDevice(deviceVendor, deviceName, numComputeUnits);
; 1147 : 			if (displayDeviceInformation) {
; 1148 : 				printf(    "  Vendor:                   %s\n",        deviceVendor);
; 1149 : 				if (productName) {
; 1150 : 					printf(    "  Name:                     %s (%s)\n", deviceName, productName);
; 1151 : 				} else {
; 1152 : 					printf(    "  Name:                     %s\n",      deviceName);
; 1153 : 				}
; 1154 : 				printf(    "  Number of Compute Units:  %d\n",        (int32_t)numComputeUnits);
; 1155 : 				printf(    "  Clock Frequency:          %dMHz\n",     (int32_t)clockFrequency);
; 1156 : 				printf(    "  Global Memory Size:       %dM bytes\n", (int32_t)(globalMemorySize / 1024 / 1024));
; 1157 : 				printf(    "  Max. Work Group Size:     %d\n",        (int32_t)maxWorkGroupSize);
; 1158 : 				printf(    "  Version:                  %s\n",        deviceVersion);
; 1159 : 				printf(    "  Driver Version:           %s\n",        driverVersion);
; 1160 : 				printf("\n");
; 1161 : 			}
; 1162 : 			if (openCLRunChildProcesses) {
; 1163 : 				numOpenCLDeviceSearchThreads += options.openCLNumProcesses;
; 1164 : 			} else {
; 1165 : 				numOpenCLDeviceSearchThreads += options.openCLNumThreads;
; 1166 : 			}
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU) {
; 1171 : 		SYSTEM_INFO sysInfo;
; 1172 : 		GetSystemInfo(&sysInfo);
; 1173 : #ifdef DEBUG_ONE_CPU_SEARCH_THREAD
; 1174 : 		numCPUSearchThreads = 1;
; 1175 : #else
; 1176 : 		if (options.numCPUSearchThreads == NUM_CPU_SEARCH_THREADS_NIL) { 
; 1177 : 			numCPUSearchThreads = sysInfo.dwNumberOfProcessors;
; 1178 : 			if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 1179 : 				numCPUSearchThreads = (numCPUSearchThreads > numCUDADeviceSearchThreads + numOpenCLDeviceSearchThreads)
; 1180 : 										  ? (numCPUSearchThreads - numCUDADeviceSearchThreads - numOpenCLDeviceSearchThreads)
; 1181 : 										  : 0;
; 1182 : 		} else {
; 1183 : 			numCPUSearchThreads = (options.numCPUSearchThreads < sysInfo.dwNumberOfProcessors) ? options.numCPUSearchThreads : sysInfo.dwNumberOfProcessors;
; 1184 : 		}
; 1185 : #endif
; 1186 : 		if (searchDevice == SEARCH_DEVICE_GPU_AND_CPU && numCPUSearchThreads <= 0) {
; 1187 : 			searchDevice = SEARCH_DEVICE_GPU;
; 1188 : 		} else 	if (displayDeviceInformation) {
; 1189 : 			int32_t results[4];
; 1190 : 			__cpuid(results, 1);
; 1191 : 
; 1192 : 			printf("CPU\n");
; 1193 : 			printf("===\n");
; 1194 : 			if (IsCPUBasedOnNehalemMicroarchitecture()) {
; 1195 : 				printf("  Processor Info:           0x%06x (Nehalem)\n", results[0]);
; 1196 : 			} else {
; 1197 : 				printf("  Processor Info:           0x%06x\n", results[0]);
; 1198 : 			}
; 1199 : 			printf("  Number of Logical Cores:  %d\n", sysInfo.dwNumberOfProcessors);
; 1200 : 			printf("  Number of Search Threads: %d\n", numCPUSearchThreads);
; 1201 : 			printf("\n");
; 1202 : 		}
; 1203 : 	}
; 1204 : }
; 1205 : 
; 1206 : void ObtainOptions(int32_t argCount, char **arguments)
; 1207 : {
; 1208 : 	int32_t i;
; 1209 : 	
; 1210 : 	// Get the application path and directory.
; 1211 : 	// strcpy(applicationPath,      arguments[0]);
; 1212 : 	_fullpath(applicationPath, arguments[0], sizeof(applicationPath));
; 1213 : 	strcpy(applicationDirectory, applicationPath);
; 1214 : 	for (i = strlen(applicationPath) - 1; i > 0; --i) {
; 1215 : 		if (applicationDirectory[i] == '\\')
; 1216 : 			break;
; 1217 : 	}
; 1218 : 	if (i < 0)
; 1219 : 		i = 0;
; 1220 : 	applicationDirectory[i] = '\0';
; 1221 : #if FALSE
; 1222 : 	printf("arguments[0]         = \'%s\'\n", arguments[0]);
; 1223 : 	printf("applicationPath      = \'%s\'\n", applicationPath);
; 1224 : 	printf("applicationDirectory = \'%s\'\n", applicationDirectory);
; 1225 : #endif
; 1226 : 
; 1227 : 	// Set default values if necessary.	
; 1228 : 	strncpy(tripcodeFilePath, DEFAULT_NAME_TRIPCODE_FILE, sizeof(tripcodeFilePath));
; 1229 : 
; 1230 : 	for (int32_t indexArg = 1; indexArg < argCount; ++indexArg) {
; 1231 : 		if (strcmp(arguments[indexArg], "-o") == 0 && indexArg + 1 < argCount) {
; 1232 : 			++indexArg;
; 1233 : 			ERROR1(strlen(arguments[indexArg]) + 1 > sizeof(tripcodeFilePath),
; 1234 : 			       ERROR_TRIPCODE_FILE,
; 1235 : 			       "The path of the tripcode file `%s' is too long.",
; 1236 : 			       arguments[indexArg]);
; 1237 : 			strcpy(tripcodeFilePath, arguments[indexArg]);
; 1238 : 
; 1239 : 		} else if (strcmp(arguments[indexArg], "-f") == 0 && indexArg + 1 < argCount) {
; 1240 : 			++indexArg;
; 1241 : 			ERROR1(strlen(arguments[indexArg]) > MAX_LEN_FILE_PATH,
; 1242 : 			       ERROR_PATTERN_FILE,
; 1243 : 			       "The path of the pattern file `%s' is too long.",
; 1244 : 			       arguments[indexArg]);
; 1245 : 			ERROR0(numPatternFiles >= MAX_NUM_PATTERN_FILES, ERROR_PATTERN_FILE, "Too many pattern files were specified.");
; 1246 : 			strcpy(patternFilePathArray[numPatternFiles++], arguments[indexArg]);
; 1247 : 
; 1248 : 		} else if (strcmp(arguments[indexArg], "-d") == 0 && indexArg + 1 < argCount) {
; 1249 : 			options.GPUIndex = atoi(arguments[++indexArg]);
; 1250 : 
; 1251 : 		} else if (strcmp(arguments[indexArg], "-x") == 0 && indexArg + 1 < argCount) {
; 1252 : 			options.CUDANumBlocksPerSM = atoi(arguments[++indexArg]);
; 1253 : 			ERROR1(options.CUDANumBlocksPerSM < CUDA_MIN_NUM_BLOCKS_PER_SM,
; 1254 : 			       ERROR_INVALID_OPTION,
; 1255 : 				   "The number of blocks per SM must be at least %d.", CUDA_MIN_NUM_BLOCKS_PER_SM);
; 1256 : 			ERROR1(options.CUDANumBlocksPerSM > CUDA_MAX_NUM_BLOCKS_PER_SM,
; 1257 : 			       ERROR_INVALID_OPTION,
; 1258 : 				   "The number of blocks per SM cannot exceed %d.",    CUDA_MAX_NUM_BLOCKS_PER_SM);
; 1259 : 
; 1260 : 		} else if (strcmp(arguments[indexArg], "-y") == 0 && indexArg + 1 < argCount) {
; 1261 : 			options.openCLNumWorkItemsPerCU = atoi(arguments[++indexArg]);
; 1262 : 			ERROR1(options.openCLNumWorkItemsPerCU < OPENCL_MIN_NUM_WORK_ITEMS_PER_CU,
; 1263 : 			       ERROR_INVALID_OPTION,
; 1264 : 				   "The number of work items per CU must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_CU);
; 1265 : 			ERROR1(options.openCLNumWorkItemsPerCU > OPENCL_MAX_NUM_WORK_ITEMS_PER_CU,
; 1266 : 			       ERROR_INVALID_OPTION,
; 1267 : 				   "The number of work items per CU cannot exceed %d.", OPENCL_MAX_NUM_WORK_ITEMS_PER_CU);
; 1268 : 
; 1269 : 		} else if (strcmp(arguments[indexArg], "-z") == 0 && indexArg + 1 < argCount) {
; 1270 : 			options.openCLNumWorkItemsPerWG = atoi(arguments[++indexArg]);
; 1271 : 			ERROR1(options.openCLNumWorkItemsPerWG < OPENCL_MIN_NUM_WORK_ITEMS_PER_WG,
; 1272 : 			       ERROR_INVALID_OPTION,
; 1273 : 				   "The number of work items per WG must be at least %d.", OPENCL_MIN_NUM_WORK_ITEMS_PER_WG);
; 1274 : 			ERROR1(options.openCLNumWorkItemsPerWG > OPENCL_MAX_NUM_WORK_ITEMS_PER_WG,
; 1275 : 			       ERROR_INVALID_OPTION,
; 1276 : 				   "The number of work items per WG cannot exceed %d.",    OPENCL_MAX_NUM_WORK_ITEMS_PER_WG);
; 1277 : 			ERROR0(options.openCLNumWorkItemsPerWG % 8 != 0,
; 1278 : 			       ERROR_INVALID_OPTION,
; 1279 : 				   "The number of work items per WG must be a multiple of 8.");
; 1280 : 
; 1281 : 		} else if (strcmp(arguments[indexArg], "-a") == 0 && indexArg + 1 < argCount) {
; 1282 : 			options.openCLNumThreads = atoi(arguments[++indexArg]);
; 1283 : 			ERROR1(options.openCLNumThreads < OPENCL_MIN_NUM_THREADS_PER_AMD_GPU,
; 1284 : 			       ERROR_INVALID_OPTION,
; 1285 : 				   "The number of threads per AMD GPU must be at least %d.", OPENCL_MIN_NUM_THREADS_PER_AMD_GPU);
; 1286 : 			ERROR1(options.openCLNumThreads > OPENCL_MAX_NUM_THREADS_PER_AMD_GPU,
; 1287 : 			       ERROR_INVALID_OPTION,
; 1288 : 				   "The number of threads per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_THREADS_PER_AMD_GPU);
; 1289 : 
; 1290 : 
; 1291 : 		} else if (strcmp(arguments[indexArg], "-b") == 0 && indexArg + 1 < argCount) {
; 1292 : 			options.openCLNumProcesses = atoi(arguments[++indexArg]);
; 1293 : 			ERROR1(options.openCLNumProcesses < OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU,
; 1294 : 			       ERROR_INVALID_OPTION,
; 1295 : 				   "The number of processes per AMD GPU must be at least %d.", OPENCL_MIN_NUM_PROCESSES_PER_AMD_GPU);
; 1296 : 			ERROR1(options.openCLNumProcesses > OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU,
; 1297 : 			       ERROR_INVALID_OPTION,
; 1298 : 				   "The number of processes per AMD GPU cannot exceed %d.",    OPENCL_MAX_NUM_PROCESSES_PER_AMD_GPU);
; 1299 : 
; 1300 : 		} else if (strcmp(arguments[indexArg], "-l") == 0 && indexArg + 1 < argCount) {
; 1301 : 			lenTripcode    = atoi(arguments[++indexArg]);
; 1302 : 			lenTripcodeKey = lenTripcode;
; 1303 : 			ERROR0(lenTripcode != 10 && lenTripcode != 12,
; 1304 : 			       ERROR_INVALID_OPTION,
; 1305 : 			       "The length of tripcodes must be either 10 or 12.");
; 1306 : 
; 1307 : 		} else if (strcmp(arguments[indexArg], "-b") == 0) {
; 1308 : 			options.beepWhenNewTripcodeIsFound = TRUE;
; 1309 : 
; 1310 : 		} else if (strcmp(arguments[indexArg], "-i") == 0) {
; 1311 : 			options.outputInvalidTripcode = TRUE;
; 1312 : 
; 1313 : 		} else if (strcmp(arguments[indexArg], "-w") == 0) {
; 1314 : 			options.warnSpeedDrop= TRUE;
; 1315 : 
; 1316 : 		} else if (strcmp(arguments[indexArg], "-n") == 0) {
; 1317 : 			options.testNewCode = TRUE;
; 1318 : 
; 1319 : 		} else if (strcmp(arguments[indexArg], "-c") == 0) {
; 1320 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL ) ? (SEARCH_DEVICE_CPU)          :
; 1321 : 			                       (options.searchDevice == SEARCH_DEVICE_GPU) ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1322 : 			                                                                      (options.searchDevice);
; 1323 : 
; 1324 : 		} else if (strcmp(arguments[indexArg], "-g") == 0) {
; 1325 : 			options.searchDevice = (options.searchDevice == SEARCH_DEVICE_NIL)  ? (SEARCH_DEVICE_GPU)         :
; 1326 : 			                       (options.searchDevice == SEARCH_DEVICE_CPU)  ? (SEARCH_DEVICE_GPU_AND_CPU) :
; 1327 : 			                                                                      (options.searchDevice);
; 1328 : 
; 1329 : 		} else if (strcmp(arguments[indexArg], "-t") == 0 && indexArg + 1 < argCount) {
; 1330 : 			options.numCPUSearchThreads = atoi(arguments[++indexArg]);
; 1331 : 			ERROR0(options.numCPUSearchThreads <= 0,
; 1332 : 			       ERROR_INVALID_OPTION,
; 1333 : 			       "The number of CPU search threads must be at least 1.");
; 1334 : 
; 1335 : 		} else if (strcmp(arguments[indexArg], "--output-for-redirection") == 0) {
; 1336 : 			options.redirection = TRUE;
; 1337 : 
; 1338 : 		} else if (strcmp(arguments[indexArg], "-e") == 0 && indexArg + 1 < argCount) {
; 1339 : 			++indexArg;
; 1340 : 			strcpy(nameMutexForPausing, arguments[indexArg]);
; 1341 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameMutexForPausingWC, MAX_LEN_INPUT_LINE);
; 1342 : 			if (len < 0) {
; 1343 : 				len = 0;
; 1344 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1345 : 				nameMutexForPausingWC[len] = 0;
; 1346 : 			}
; 1347 : 			nameMutexForPausingWC[MAX_LEN_INPUT_LINE] = 0;
; 1348 : 
; 1349 : 		} else if (strcmp(arguments[indexArg], "-E") == 0 && indexArg + 1 < argCount) {
; 1350 : 			++indexArg;
; 1351 : 			strcpy(nameEventForTerminating, arguments[indexArg]);
; 1352 : 			int32_t len = MultiByteToWideChar(CP_ACP, 0, arguments[indexArg], -1, nameEventForTerminatingWC, MAX_LEN_INPUT_LINE);
; 1353 : 			if (len < 0) {
; 1354 : 				len = 0;
; 1355 : 			} else if (len <= MAX_LEN_INPUT_LINE) {
; 1356 : 				nameEventForTerminatingWC[len] = 0;
; 1357 : 			}
; 1358 : 			nameEventForTerminatingWC[MAX_LEN_INPUT_LINE] = 0;
; 1359 : 
; 1360 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1361 : 			options.useOneByteCharactersForKeys = TRUE;
; 1362 : 
; 1363 : 		} else if (strcmp(arguments[indexArg], "--search-for-hiseki-on-cpu") == 0) {
; 1364 : 			options.searchForHisekiOnCPU = TRUE;
; 1365 : 
; 1366 : 		} else if (strcmp(arguments[indexArg], "--search-for-kakuhi-on-cpu") == 0) {
; 1367 : 			options.searchForKakuhiOnCPU = TRUE;
; 1368 : 
; 1369 : 		} else if (strcmp(arguments[indexArg], "--search-for-kaibun-on-cpu") == 0) {
; 1370 : 			options.searchForKaibunOnCPU = TRUE;
; 1371 : 
; 1372 : 		} else if (strcmp(arguments[indexArg], "--search-for-kagami-on-cpu") == 0) {
; 1373 : 			options.searchForKagamiOnCPU = TRUE;
; 1374 : 
; 1375 : 		} else if (strcmp(arguments[indexArg], "--search-for-yamabiko-on-cpu") == 0) {
; 1376 : 			options.searchForYamabikoOnCPU = TRUE;
; 1377 : 
; 1378 : 		} else if (strcmp(arguments[indexArg], "--search-for-souren-on-cpu") == 0) {
; 1379 : 			options.searchForSourenOnCPU = TRUE;
; 1380 : 			
; 1381 : 		} else if (strcmp(arguments[indexArg], "--use-opencl-for-cuda-devices") == 0) {
; 1382 : 			options.useOpenCLForCUDADevices = TRUE;
; 1383 : 
; 1384 : 		} else if (strcmp(arguments[indexArg], "--disable-avx") == 0) {
; 1385 : 			options.isAVXEnabled = FALSE;
; 1386 : 
; 1387 : 		} else if (strcmp(arguments[indexArg], "--disable-avx2") == 0) {
; 1388 : 			options.isAVX2Enabled = FALSE;
; 1389 : 
; 1390 : 		} else if (strcmp(arguments[indexArg], "--use-one-byte-characters-for-keys") == 0) {
; 1391 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1392 : 			options.useOneByteCharactersForKeys = TRUE;
; 1393 : 
; 1394 : 		} else if (strcmp(arguments[indexArg], "--use-ascii-characters-for-keys") == 0) {
; 1395 : 			options.useOnlyASCIICharactersForKeys = TRUE;
; 1396 : 			options.useOneByteCharactersForKeys = TRUE;
; 1397 : 
; 1398 : 		} else if (strcmp(arguments[indexArg], "--use-one-and-two-byte-characters-for-keys") == 0) {
; 1399 : 			options.useOneByteCharactersForKeys = FALSE;
; 1400 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1401 : 
; 1402 : 		} else if (strcmp(arguments[indexArg], "--maximize-key-space") == 0) {
; 1403 : 			options.useOneByteCharactersForKeys = FALSE;
; 1404 : 			options.useOnlyASCIICharactersForKeys = FALSE;
; 1405 : 			options.maximizeKeySpace = TRUE;
; 1406 : 
; 1407 : 		} else if (strcmp(arguments[indexArg], "--disable-tripcode-checks") == 0) {
; 1408 : 			options.checkTripcodes = FALSE;
; 1409 : 
; 1410 : 		} else if (strcmp(arguments[indexArg], "--disable-gcn-assembler") == 0) {
; 1411 : 			options.enableGCNAssembler = FALSE;
; 1412 : 
; 1413 : 		} else if (   strcmp(arguments[indexArg], "--display-device-information") == 0
; 1414 : 			       || strcmp(arguments[indexArg], "--list-expanded-patterns"    ) == 0
; 1415 : 				   || strcmp(arguments[indexArg], "--gpu-list"                  ) == 0) {
; 1416 : 			// Ignore the option.
; 1417 : 
; 1418 : 		} else {
; 1419 : 			ERROR0(TRUE, ERROR_INVALID_OPTION, "An invalid option was specified.");
; 1420 : 		}
; 1421 : 	}
; 1422 : 
; 1423 : 	if (numPatternFiles <= 0) {
; 1424 : 		strcpy(patternFilePathArray[0], DEFAULT_NAME_PATTERN_FILE);
; 1425 : 		numPatternFiles = 1;
; 1426 : 	}
; 1427 : }
; 1428 : 
; 1429 : void ProcessValidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1430 : {
; 1431 : 	ASSERT(lenTripcode    == 10 || lenTripcode    == 12);
; 1432 : 	ASSERT(lenTripcodeKey == 10 || lenTripcodeKey == 12);
; 1433 : 	
; 1434 : 	process_tripcode_pair_spinlock.lock();
; 1435 : 	if (!options.redirection) {
; 1436 : #ifdef ENGLISH_VERSION
; 1437 : 		fprintf(tripcodeFile, "!");
; 1438 : #else
; 1439 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1440 : #endif
; 1441 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1442 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1443 : 		fprintf(tripcodeFile, " #");
; 1444 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1445 : 			fprintf(tripcodeFile, "%c", key[i]);
; 1446 : 		fprintf(tripcodeFile, " (");
; 1447 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1448 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1449 : 			if (i + 1 < lenTripcodeKey)
; 1450 : 				fprintf(tripcodeFile, " ");
; 1451 : 		}
; 1452 : 		fprintf(tripcodeFile, ")\n");
; 1453 : 		fflush(tripcodeFile);
; 1454 : 	}  
; 1455 : 
; 1456 : 	if (!options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1457 : #ifdef ENGLISH_VERSION
; 1458 : 		printf("  !");
; 1459 : #else
; 1460 : 		printf("  %c%c", 0x81, 0x9f);
; 1461 : #endif
; 1462 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1463 : 			printf("%c", tripcode[i]);
; 1464 : 		printf(" #");
; 1465 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1466 : 			printf("%c", key[i]);
; 1467 : 		printf(" (");
; 1468 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1469 : 			printf("%02X", key[i]);
; 1470 : 			if (i + 1 < lenTripcodeKey)
; 1471 : 				printf(" ");
; 1472 : 		}
; 1473 : 		printf(")");
; 1474 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1475 : 			i < SCREEN_WIDTH - 1;
; 1476 : 			++i) {
; 1477 : 			printf(" ");
; 1478 : 		}
; 1479 : 		printf("\n");
; 1480 : 	} else if (options.redirection) {
; 1481 : 		printf("[tripcode],%c%c", 0x81, 0x9f);
; 1482 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1483 : 			printf("%c", tripcode[i]);
; 1484 : 		printf(",#");
; 1485 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1486 : 			printf("%c", key[i]);
; 1487 : 		printf(",(");
; 1488 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1489 : 			printf("%02X", key[i]);
; 1490 : 			if (i + 1 < lenTripcodeKey)
; 1491 : 				printf(" ");
; 1492 : 		}
; 1493 : 		printf(")\n");
; 1494 : 	}
; 1495 : 	fflush(stdout);
; 1496 : 	process_tripcode_pair_spinlock.unlock();
; 1497 : 
; 1498 : 	current_state_spinlock.lock();
; 1499 : 	++numValidTripcodes;
; 1500 : 	current_state_spinlock.unlock();
; 1501 : 
; 1502 : 	if (!options.redirection)
; 1503 : 		PrintStatus();
; 1504 : 	if (!options.redirection && options.beepWhenNewTripcodeIsFound)
; 1505 : 		printf("\a");
; 1506 : }
; 1507 : 
; 1508 : void ProcessInvalidTripcodePair(unsigned char *tripcode, unsigned char *key)
; 1509 : {
; 1510 : 	process_tripcode_pair_spinlock.lock();
; 1511 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState()) {
; 1512 : #ifdef ENGLISH_VERSION
; 1513 : 		fprintf(tripcodeFile, "!");
; 1514 : #else
; 1515 : 		fprintf(tripcodeFile, "%c%c", 0x81, 0x9f);
; 1516 : #endif
; 1517 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1518 : 			fprintf(tripcodeFile, "%c", tripcode[i]);
; 1519 : 		fprintf(tripcodeFile, "  ");
; 1520 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1521 : 			fprintf(tripcodeFile, " ");
; 1522 : 		fprintf(tripcodeFile, " (");
; 1523 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1524 : 			fprintf(tripcodeFile, "%02X", key[i]);
; 1525 : 			if (i + 1 < lenTripcodeKey)
; 1526 : 				fprintf(tripcodeFile, " ");
; 1527 : 		}
; 1528 : 		fprintf(tripcodeFile, ")\n");
; 1529 : 		fflush(tripcodeFile);
; 1530 : 
; 1531 : #ifdef ENGLISH_VERSION
; 1532 : 		printf("  !");
; 1533 : #else
; 1534 : 		printf("  %c%c", 0x81, 0x9f);
; 1535 : #endif
; 1536 : 		for (int32_t i = 0; i < lenTripcode; ++i)
; 1537 : 			printf("%c", tripcode[i]);
; 1538 : 		printf("  ");
; 1539 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i)
; 1540 : 			printf(" ");
; 1541 : 		printf(" (");
; 1542 : 		for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 1543 : 			printf("%02X", key[i]);
; 1544 : 			if (i + 1 < lenTripcodeKey)
; 1545 : 				printf(" ");
; 1546 : 		}
; 1547 : 		printf(")");
; 1548 : 		for (int32_t i = 4 + lenTripcode + 2 + lenTripcodeKey + 2 + lenTripcodeKey * 3;
; 1549 : 			i < SCREEN_WIDTH - 1;
; 1550 : 			++i) {
; 1551 : 			printf(" ");
; 1552 : 		}
; 1553 : 		printf("\n");
; 1554 : 		fflush(stdout);
; 1555 : 	}
; 1556 : 	process_tripcode_pair_spinlock.unlock();
; 1557 : 
; 1558 : 	current_state_spinlock.lock();
; 1559 : 	++numDiscardedTripcodes;
; 1560 : 	current_state_spinlock.unlock();
; 1561 : 
; 1562 : 	if (options.outputInvalidTripcode && !options.redirection && !GetTerminationState() && !GetErrorState())
; 1563 : 		PrintStatus();
; 1564 : }
; 1565 : 
; 1566 : void OpenTripcodeFile()
; 1567 : {
; 1568 : 	tripcodeFile = fopen(tripcodeFilePath, "a");

	lea	rdx, OFFSET FLAT:$SG4294856622
	lea	rcx, OFFSET FLAT:?tripcodeFilePath@@3PADA ; tripcodeFilePath
	call	fopen
	mov	QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA, rax ; tripcodeFile
	npad	3
$LL129@main:

; 2069 : 		OpenTripcodeFile();
; 2070 : 
; 2071 : #ifdef DEBUG_TEST_NEW_CODE
; 2072 : 	if (options.testNewCode)

	cmp	DWORD PTR ?options@@3UOptions@@A+24, esi
	je	SHORT $LN49@main

; 2073 : 		TestNewCode();

	call	?TestNewCode@@YAXXZ			; TestNewCode
$LN49@main:

; 2074 : #endif
; 2075 : 	
; 2076 : #ifdef REDIRECTION_ONLY
; 2077 : 	if (!options.redirection)
; 2078 : 		exit(0);
; 2079 : #endif
; 2080 : 
; 2081 : 	// Prepare for pausing.
; 2082 : 	HANDLE mutexForPausing = NULL;
; 2083 : 	if (options.redirection && nameMutexForPausingWC[0] != 0x0) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	mov	rdi, rsi
	je	$LN636@main
	cmp	WORD PTR nameMutexForPausingWC, si
	je	$LN636@main

; 2084 : 		mutexForPausing = OpenMutex(MUTEX_ALL_ACCESS, false, nameMutexForPausingWC);

	lea	r8, OFFSET FLAT:nameMutexForPausingWC
	xor	edx, edx
	mov	ecx, 2031617				; 001f0001H
	call	QWORD PTR __imp_OpenMutexW
	mov	rdi, rax

; 2085 : 		ERROR0(!mutexForPausing, ERROR_EVENT, "Failed to open an event.") 

	test	rax, rax
	jne	$LN636@main
	call	?GetErrorState@@YAHXZ			; GetErrorState
	test	eax, eax
	jne	$LN636@main
	call	?SetErrorState@@YAXXZ			; SetErrorState
	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	je	SHORT $LN46@main
	call	__iob_func
	lea	r8d, QWORD PTR [rdi+21]
	lea	rdx, OFFSET FLAT:$SG4294856500
	lea	rcx, QWORD PTR [rax+96]
	call	fprintf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+96]
	call	fflush
	lea	edx, QWORD PTR [rdi+21]
	lea	rcx, OFFSET FLAT:$SG4294856499
	call	printf
	call	__iob_func
	lea	rcx, QWORD PTR [rax+48]
	call	fflush
	jmp	SHORT $LN45@main
$LN46@main:
	mov	ecx, DWORD PTR ?prevLineCount@@3HA	; prevLineCount
	call	?reset_cursor_pos@@YAXH@Z		; reset_cursor_pos
	lea	rdx, OFFSET FLAT:$SG4294856498
	lea	rcx, OFFSET FLAT:$SG4294856497
	call	printf
	call	_getch
	call	?show_cursor@@YAXXZ			; show_cursor
$LN45@main:
	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
	int	3
$LN636@main:

; 2086 : 	}
; 2087 : 	isSearchPaused = FALSE;
; 2088 : 	
; 2089 : 	if (!options.redirection) {

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	mov	DWORD PTR ?isSearchPaused@@3HA, esi	; isSearchPaused
	jne	SHORT $LN44@main

; 2090 : 		printf("TRIPCODES\n");

	lea	rcx, OFFSET FLAT:$SG4294856496
	call	printf

; 2091 : 		printf("=========\n");

	lea	rcx, OFFSET FLAT:$SG4294856495

; 2092 : 	} else {

	jmp	SHORT $LN659@main
$LN44@main:

; 2093 : 		printf("[started]\n");

	lea	rcx, OFFSET FLAT:$SG4294856494
$LN659@main:
	call	printf

; 2094 : 	}
; 2095 : 	PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	r15, 3777893186295716171		; 346dc5d63886594bH
	mov	rax, r15
	imul	rcx
	mov	rbp, rdx
	sar	rbp, 11
	mov	rax, rbp
	shr	rax, 63					; 0000003fH
	add	rbp, rax
	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	dec	eax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T3[rsp], rbp
	cmp	eax, 1
	ja	SHORT $LN206@main
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1981 : 	if (numCUDADeviceSearchThreads > 0)

	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, esi ; numCUDADeviceSearchThreads
	jle	SHORT $LN207@main

; 1982 : 		StartCUDADeviceSearchThreads();

	call	?StartCUDADeviceSearchThreads@@YAXXZ	; StartCUDADeviceSearchThreads
$LN207@main:

; 1983 : 	if (numOpenCLDeviceSearchThreads > 0)

	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, esi ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN206@main

; 1984 : 		StartOpenCLDeviceSearchThreads();

	call	?StartOpenCLDeviceSearchThreads@@YAXXZ	; StartOpenCLDeviceSearchThreads
$LN206@main:
	mov	eax, DWORD PTR ?searchDevice@@3HA	; searchDevice
	dec	eax
	test	eax, -3					; fffffffdH
	jne	SHORT $LN40@main

; 2096 : 	
; 2097 : 	
; 2098 : 	// The main loop.
; 2099 : 	uint64_t startingTime = TIME_SINCE_EPOCH_IN_MILLISECONDS;
; 2100 : 	if (searchDevice == SEARCH_DEVICE_GPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 2101 : 		StartGPUSearchThreads();
; 2102 : 	if (searchDevice == SEARCH_DEVICE_CPU || searchDevice == SEARCH_DEVICE_GPU_AND_CPU)
; 2103 : 		StartCPUSearchThreads();

	call	?StartCPUSearchThreads@@YAXXZ		; StartCPUSearchThreads
$LN40@main:

; 2104 : 	HANDLE parentProcess = OpenProcess(SYNCHRONIZE, FALSE, GetParentProcessID());

	call	?GetParentProcessID@@YAHXZ		; GetParentProcessID
	xor	edx, edx
	mov	ecx, 1048576				; 00100000H
	mov	r8d, eax
	call	QWORD PTR __imp_OpenProcess
	mov	r14, rax

; 2105 : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN647@main
	movaps	XMMWORD PTR [rsp+48], xmm6
	movsdx	xmm6, QWORD PTR __real@3fe0000000000000
	npad	1
$LL38@main:

; 2106 : 		// Break the main loop if necessary.
; 2107 : 		if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	je	SHORT $LN36@main
	xor	edx, edx
	mov	rcx, r14
	call	QWORD PTR __imp_WaitForSingleObject
	cmp	eax, 258				; 00000102H
	jne	$LN657@main
$LN36@main:

; 2108 : 			break;
; 2109 : 
; 2110 : 		// Wait for the duration of STATUS_UPDATE_INTERVAL.
; 2111 : 		uint32_t mutexForPausingState;
; 2112 : 		for (int32_t i = 0; i < NUM_CHECKS_PER_INTERVAL; ++i) {

	mov	ebx, esi
$LL35@main:

; 2113 : 			// Break the loop if the search is paused.
; 2114 : 			if (mutexForPausing) {

	test	rdi, rdi
	je	SHORT $LN29@main

; 2115 : 				mutexForPausingState = WaitForSingleObject(mutexForPausing, 0);

	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_WaitForSingleObject

; 2116 : 				if (mutexForPausingState == WAIT_OBJECT_0) {

	test	eax, eax
	jne	SHORT $LN31@main

; 2117 : 					ReleaseMutex(mutexForPausing);

	mov	rcx, rdi
	call	QWORD PTR __imp_ReleaseMutex
	jmp	SHORT $LN29@main
$LN31@main:

; 2118 : 				} else if (mutexForPausingState == WAIT_TIMEOUT) {

	cmp	eax, 258				; 00000102H
	je	SHORT $LL213@main
$LN29@main:

; 2119 : 					SetPauseState(TRUE);
; 2120 : 					break;
; 2121 : 				}
; 2122 : 			}
; 2123 : 
; 2124 : 			// Break the loop if the search was terminated.
; 2125 : 			if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN626@main

; 2126 : 				break;
; 2127 : 
; 2128 : 			// Break the loop if the parent process has already quit.
; 2129 : 			if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	je	SHORT $LN27@main
	xor	edx, edx
	mov	rcx, r14
	call	QWORD PTR __imp_WaitForSingleObject
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN626@main
$LN27@main:

; 2130 : 				break;
; 2131 : 
; 2132 : 			Sleep((uint32_t)(STATUS_UPDATE_INTERVAL * 1000 / NUM_CHECKS_PER_INTERVAL));

	mov	ecx, 1000				; 000003e8H
	call	QWORD PTR __imp_Sleep
	inc	ebx
	cmp	ebx, 10
	jl	SHORT $LL35@main

; 2108 : 			break;
; 2109 : 
; 2110 : 		// Wait for the duration of STATUS_UPDATE_INTERVAL.
; 2111 : 		uint32_t mutexForPausingState;
; 2112 : 		for (int32_t i = 0; i < NUM_CHECKS_PER_INTERVAL; ++i) {

	jmp	SHORT $LN626@main
	npad	3
$LL213@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN212@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN227@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL213@main
$LN227@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL213@main
$LN212@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, 1	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, esi ; current_state_spinlock
$LN626@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2134 : 		if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	$LN657@main

; 2135 : 			break;
; 2136 : 		UpdateCurrentStatus(startingTime);

	mov	rcx, rbp
	call	?UpdateCurrentStatus@@YAN_K@Z		; UpdateCurrentStatus

; 2137 : 		
; 2138 : 		// Pause searching if necessary.
; 2139 : 		if (mutexForPausing) {

	test	rdi, rdi
	je	$LN332@main

; 2140 : 			while ((mutexForPausingState = WaitForSingleObject(mutexForPausing, 0)) == WAIT_TIMEOUT) {

	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_WaitForSingleObject
	mov	ebx, eax
	cmp	eax, 258				; 00000102H
	jne	$LN646@main
	npad	7
$LL24@main:

; 2141 : 				// Break the loop if the search was terminated.
; 2142 : 				if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN646@main

; 2143 : 					break;
; 2144 : 
; 2145 : 				// Break the loop if the parent process has already quit.
; 2146 : 				if (options.redirection && WaitForSingleObject(parentProcess, 0) != WAIT_TIMEOUT)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	je	SHORT $LL257@main
	xor	edx, edx
	mov	rcx, r14
	call	QWORD PTR __imp_WaitForSingleObject
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN646@main
$LL257@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN256@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN271@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL257@main
$LN271@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL257@main
$LN256@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, 1	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, esi ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2150 : 				KeepSearchThreadsAlive();

	call	?KeepSearchThreadsAlive@@YAXXZ		; KeepSearchThreadsAlive

; 2151 : 				Sleep(PAUSE_INTERVAL);

	mov	ecx, 100				; 00000064H
	call	QWORD PTR __imp_Sleep
	xor	edx, edx
	mov	rcx, rdi
	call	QWORD PTR __imp_WaitForSingleObject
	mov	ebx, eax
	cmp	eax, 258				; 00000102H
	je	$LL24@main
$LN646@main:

; 2152 : 			}
; 2153 : 			if (mutexForPausingState == WAIT_OBJECT_0) {

	test	ebx, ebx
	jne	SHORT $LN332@main

; 2154 : 				ReleaseMutex(mutexForPausing);

	mov	rcx, rdi
	call	QWORD PTR __imp_ReleaseMutex
	npad	5
$LL301@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN300@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN315@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL301@main
$LN315@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL301@main
$LN300@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1625 : 	isSearchPaused = newPauseState;

	mov	DWORD PTR ?isSearchPaused@@3HA, esi	; isSearchPaused
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, esi ; current_state_spinlock
$LN332@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2158 : 		if (GetTerminationState())

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	jne	SHORT $LN657@main

; 2159 : 			break;
; 2160 : 				
; 2161 : 		//
; 2162 : 		CheckSearchThreads();

	call	?CheckSearchThreads@@YAXXZ		; CheckSearchThreads
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r15
	imul	rcx
	mov	rbp, rdx
	sar	rbp, 11
	mov	rax, rbp
	shr	rax, 63					; 0000003fH
	add	rbp, rax

; 105  : 		{	// construct from representation

	mov	QWORD PTR $T1[rsp], rbp
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2164 : 		PrintStatus();

	call	?PrintStatus@@YAXXZ			; PrintStatus

; 2165 : 		
; 2166 : 		// Warn the user if the speed drops suddenly.
; 2167 : 		if (!options.redirection && options.warnSpeedDrop && currentSpeed_thisProcess < maximumSpeed * SPEED_DROP_WARNING_THRESHOLD)

	cmp	DWORD PTR ?options@@3UOptions@@A+32, esi
	jne	SHORT $LN18@main
	cmp	DWORD PTR ?options@@3UOptions@@A+16, esi
	je	SHORT $LN18@main
	movsdx	xmm0, QWORD PTR ?maximumSpeed@@3NA	; maximumSpeed
	mulsd	xmm0, xmm6
	comisd	xmm0, QWORD PTR ?currentSpeed_thisProcess@@3NA ; currentSpeed_thisProcess
	jbe	SHORT $LN18@main

; 2168 : 			printf("\a");

	lea	rcx, OFFSET FLAT:$SG4294856493
	call	printf
$LN18@main:

; 2105 : 	while (!GetTerminationState()) {

	call	?GetTerminationState@@YAHXZ		; GetTerminationState
	test	eax, eax
	je	$LL38@main
$LN657@main:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN647@main:

; 2169 : 	}
; 2170 : 
; 2171 : 	// Close handles.
; 2172 : 	CloseHandle(parentProcess);

	mov	rcx, r14
	call	QWORD PTR __imp_CloseHandle

; 2173 : 	if (mutexForPausing)

	test	rdi, rdi
	je	SHORT $LL379@main

; 2174 : 		CloseHandle(mutexForPausing);

	mov	rcx, rdi
	call	QWORD PTR __imp_CloseHandle
$LL379@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, 0 ; current_state_spinlock
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN378@main
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN393@main

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL379@main
$LN393@main:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL379@main
$LN378@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 1657 : 	wasSearchTerminated = TRUE;

	mov	DWORD PTR ?wasSearchTerminated@@3HA, 1	; wasSearchTerminated
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR ?current_state_spinlock@@3Vspinlock@@A, esi ; current_state_spinlock
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r15
	imul	rcx
	mov	r14, rdx
	sar	r14, 11
	mov	rax, r14
	shr	rax, 63					; 0000003fH
	add	r14, rax
$LL16@main:
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2182 : 		Sleep(100);

	mov	ecx, 100				; 00000064H
	call	QWORD PTR __imp_Sleep

; 2183 : 		allThreadsHaveExited = TRUE;
; 2184 : 		for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i) {

	mov	ebx, esi
	mov	ebp, 1
	cmp	DWORD PTR ?numCUDADeviceSearchThreads@@3HA, ebx ; numCUDADeviceSearchThreads
	jle	SHORT $LN11@main

; 2182 : 		Sleep(100);

	mov	rdi, rsi
$LL13@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR ?cuda_device_search_threads@@3PEAPEAVthread@std@@EA ; cuda_device_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2185 : 			if (WaitForSingleObject(cuda_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rcx, QWORD PTR [rdi+rax]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2185 : 			if (WaitForSingleObject(cuda_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_WaitForSingleObject
	test	eax, eax
	jne	SHORT $LN523@main

; 2183 : 		allThreadsHaveExited = TRUE;
; 2184 : 		for (int32_t i = 0; i < numCUDADeviceSearchThreads; ++i) {

	inc	ebx
	add	rdi, 8
	cmp	ebx, DWORD PTR ?numCUDADeviceSearchThreads@@3HA ; numCUDADeviceSearchThreads
	jl	SHORT $LL13@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN11@main
$LN523@main:

; 2186 : 				allThreadsHaveExited = FALSE;

	mov	ebp, esi
$LN11@main:

; 2187 : 				break;
; 2188 : 			}
; 2189 : 		}
; 2190 : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	mov	ebx, esi
	cmp	DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA, ebx ; numOpenCLDeviceSearchThreads
	jle	SHORT $LN7@main
	mov	rdi, rsi
	npad	7
$LL9@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR ?opencl_device_search_threads@@3PEAPEAVthread@std@@EA ; opencl_device_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2191 : 			if (WaitForSingleObject(opencl_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rcx, QWORD PTR [rdi+rax]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2191 : 			if (WaitForSingleObject(opencl_device_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_WaitForSingleObject
	test	eax, eax
	jne	SHORT $LN524@main

; 2187 : 				break;
; 2188 : 			}
; 2189 : 		}
; 2190 : 		for (int32_t i = 0; i < numOpenCLDeviceSearchThreads; ++i) {

	inc	ebx
	add	rdi, 8
	cmp	ebx, DWORD PTR ?numOpenCLDeviceSearchThreads@@3HA ; numOpenCLDeviceSearchThreads
	jl	SHORT $LL9@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN7@main
$LN524@main:

; 2192 : 				allThreadsHaveExited = FALSE;

	mov	ebp, esi
$LN7@main:

; 2193 : 				break;
; 2194 : 			}
; 2195 : 		}
; 2196 : 		for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	mov	ebx, esi
	cmp	DWORD PTR ?numCPUSearchThreads@@3HA, ebx ; numCPUSearchThreads
	jle	SHORT $LN3@main
	mov	rdi, rsi
	npad	7
$LL5@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rax, QWORD PTR ?cpu_search_threads@@3PEAPEAVthread@std@@EA ; cpu_search_threads
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 102  : 		return (_Thr._Hnd);

	mov	rcx, QWORD PTR [rdi+rax]
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_WaitForSingleObject
	test	eax, eax
	jne	SHORT $LN525@main

; 2193 : 				break;
; 2194 : 			}
; 2195 : 		}
; 2196 : 		for (int32_t i = 0; i < numCPUSearchThreads; ++i) {

	inc	ebx
	add	rdi, 8
	cmp	ebx, DWORD PTR ?numCPUSearchThreads@@3HA ; numCPUSearchThreads
	jl	SHORT $LL5@main

; 2197 : 			if (WaitForSingleObject(cpu_search_threads[i]->native_handle(), 0) != WAIT_OBJECT_0) {

	jmp	SHORT $LN3@main
$LN525@main:

; 2198 : 				allThreadsHaveExited = FALSE;

	mov	ebp, esi
$LN3@main:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\chrono

; 705  : 		return (time_point(duration(_Xtime_get_ticks())));

	call	_Xtime_get_ticks
	mov	rcx, rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2,
; 114  : 		class = typename enable_if<treat_as_floating_point<_Rep>::value
; 115  : 			|| (ratio_divide<_Period2, _Period>::den == 1
; 116  : 				&& !treat_as_floating_point<_Rep2>::value),
; 117  : 			void>::type>
; 118  : 		duration(const duration<_Rep2, _Period2>& _Dur)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef ratio_divide<_Period2, _Period> _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2,
; 263  : 		class = typename enable_if<is_convertible<_Duration2,
; 264  : 			_Duration>::value,
; 265  : 			void>::type>
; 266  : 		time_point(const time_point<_Clock, _Duration2>& _Tp)
; 267  : 		: _MyDur(_Tp.time_since_epoch())
; 268  : 		{	// construct from another duration
; 269  : 		}
; 270  : 
; 271  : 	_Duration time_since_epoch() const
; 272  : 		{	// get duration from epoch
; 273  : 		return (_MyDur);
; 274  : 		}
; 275  : 
; 276  : 	time_point& operator+=(const _Duration& _Dur)
; 277  : 		{	// increment by duration
; 278  : 		_MyDur += _Dur;
; 279  : 		return (*this);
; 280  : 		}
; 281  : 
; 282  : 	time_point& operator-=(const _Duration& _Dur)
; 283  : 		{	// decrement by duration
; 284  : 		_MyDur -= _Dur;
; 285  : 		return (*this);
; 286  : 		}
; 287  : 
; 288  : 	static time_point (min)()
; 289  : 		{	// get minimum time point
; 290  : 		return (time_point((_Duration::min)()));
; 291  : 		}
; 292  : 	static time_point (max)()
; 293  : 		{	// get maximum time point
; 294  : 		return (time_point((_Duration::max)()));
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	_Duration _MyDur;	// duration since the epoch
; 299  : 	};
; 300  : }	// namespace chrono
; 301  : 
; 302  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 303  : template<intmax_t _Ax,
; 304  : 	intmax_t _Bx>
; 305  : 	struct _Lcm
; 306  : 	{   /* compute least common multiple of _Ax and _Bx */
; 307  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 308  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 309  : 	};
; 310  : 
; 311  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 312  : template<class _Rep1,
; 313  : 	class _Period1,
; 314  : 	class _Rep2,
; 315  : 	class _Period2>
; 316  : 	struct common_type<
; 317  : 		chrono::duration<_Rep1, _Period1>,
; 318  : 		chrono::duration<_Rep2, _Period2> >
; 319  : 	{	// common type of two durations
; 320  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 321  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 322  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 323  : 	};
; 324  : 
; 325  : template<class _Clock,
; 326  : 	class _Duration1,
; 327  : 	class _Duration2>
; 328  : 	struct common_type<
; 329  : 		chrono::time_point<_Clock, _Duration1>,
; 330  : 		chrono::time_point<_Clock, _Duration2> >
; 331  : 	{	// common type of two time points
; 332  : 	typedef chrono::time_point<
; 333  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 334  : 	};
; 335  : 
; 336  : namespace chrono {
; 337  : 	// duration ARITHMETIC
; 338  : template<class _Rep1,
; 339  : 	class _Period1,
; 340  : 	class _Rep2,
; 341  : 	class _Period2> inline
; 342  : 	typename common_type<
; 343  : 		duration<_Rep1, _Period1>,
; 344  : 		duration<_Rep2, _Period2> >::type
; 345  : 		operator+(
; 346  : 			const duration<_Rep1, _Period1>& _Left,
; 347  : 			const duration<_Rep2, _Period2>& _Right)
; 348  : 	{	// add two durations
; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);
; 353  : 		}
; 354  : 
; 355  : template<class _Rep1,
; 356  : 	class _Period1,
; 357  : 	class _Rep2,
; 358  : 	class _Period2> inline
; 359  : 	typename common_type<
; 360  : 		duration<_Rep1, _Period1>,
; 361  : 		duration<_Rep2, _Period2> >::type
; 362  : 		operator-(
; 363  : 			const duration<_Rep1, _Period1>& _Left,
; 364  : 			const duration<_Rep2, _Period2>& _Right)
; 365  : 	{	// subtract two durations
; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);
; 369  : 	}
; 370  : 
; 371  : template<class _Rep1,
; 372  : 	class _Period1,
; 373  : 	class _Rep2> inline
; 374  : 	typename enable_if<is_convertible<_Rep2,
; 375  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 376  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 377  : 		operator*(
; 378  : 			const duration<_Rep1, _Period1>& _Left,
; 379  : 			const _Rep2& _Right)
; 380  : 	{	// multiply duration by rep
; 381  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 382  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 383  : 	}
; 384  : 
; 385  : template<class _Rep1,
; 386  : 	class _Rep2,
; 387  : 	class _Period2> inline
; 388  : 	typename enable_if<is_convertible<_Rep1,
; 389  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 390  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 391  : 		operator*(
; 392  : 			const _Rep1& _Left,
; 393  : 			const duration<_Rep2, _Period2>& _Right)
; 394  : 	{	// multiply rep by duration
; 395  : 	return (_Right * _Left);
; 396  : 	}
; 397  : 
; 398  : template<class _Rep1,
; 399  : 	class _Period1,
; 400  : 	class _Rep2> inline
; 401  : 	typename enable_if<is_convertible<_Rep2,
; 402  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 403  : 		&& !_Is_duration<_Rep2>::value,
; 404  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 405  : 		operator/(
; 406  : 			const duration<_Rep1, _Period1>& _Left,
; 407  : 			const _Rep2& _Right)
; 408  : 	{	// divide duration by rep
; 409  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 410  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 411  : 	}
; 412  : 
; 413  : template<class _Rep1,
; 414  : 	class _Period1,
; 415  : 	class _Rep2,
; 416  : 	class _Period2> inline
; 417  : 	typename common_type<_Rep1, _Rep2>::type
; 418  : 		operator/(
; 419  : 			const duration<_Rep1, _Period1>& _Left,
; 420  : 			const duration<_Rep2, _Period2>& _Right)
; 421  : 	{	// divide duration by duration
; 422  : 	typedef typename common_type<
; 423  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 424  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 425  : 	}
; 426  : 
; 427  : template<class _Rep1,
; 428  : 	class _Period1,
; 429  : 	class _Rep2> inline
; 430  : 	typename enable_if<is_convertible<_Rep2,
; 431  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 432  : 		&& !_Is_duration<_Rep2>::value,
; 433  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 434  : 		operator%(
; 435  : 			const duration<_Rep1, _Period1>& _Left,
; 436  : 			const _Rep2& _Right)
; 437  : 	{	// divide duration by rep
; 438  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 439  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 440  : 	}
; 441  : 
; 442  : template<class _Rep1,
; 443  : 	class _Period1,
; 444  : 	class _Rep2,
; 445  : 	class _Period2> inline
; 446  : 	typename common_type<_Rep1, _Rep2>::type
; 447  : 		operator%(
; 448  : 			const duration<_Rep1, _Period1>& _Left,
; 449  : 			const duration<_Rep2, _Period2>& _Right)
; 450  : 	{	// divide duration by duration
; 451  : 	typedef typename common_type<
; 452  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 453  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 454  : 	}
; 455  : 
; 456  : 	// duration COMPARISONS
; 457  : template<class _Rep1,
; 458  : 	class _Period1,
; 459  : 	class _Rep2,
; 460  : 	class _Period2> inline
; 461  : 	bool operator==(
; 462  : 		const duration<_Rep1, _Period1>& _Left,
; 463  : 		const duration<_Rep2, _Period2>& _Right)
; 464  : 	{	// test if duration == duration
; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 469  : 	}
; 470  : 
; 471  : template<class _Rep1,
; 472  : 	class _Period1,
; 473  : 	class _Rep2,
; 474  : 	class _Period2> inline
; 475  : 	bool operator!=(
; 476  : 		const duration<_Rep1, _Period1>& _Left,
; 477  : 		const duration<_Rep2, _Period2>& _Right)
; 478  : 	{	// test if duration != duration
; 479  : 	return (!(_Left == _Right));
; 480  : 	}
; 481  : 
; 482  : template<class _Rep1,
; 483  : 	class _Period1,
; 484  : 	class _Rep2,
; 485  : 	class _Period2> inline
; 486  : 	bool operator<(
; 487  : 		const duration<_Rep1, _Period1>& _Left,
; 488  : 		const duration<_Rep2, _Period2>& _Right)
; 489  : 	{	// test if duration < duration
; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 494  : 	}
; 495  : 
; 496  : template<class _Rep1,
; 497  : 	class _Period1,
; 498  : 	class _Rep2,
; 499  : 	class _Period2> inline
; 500  : 	bool operator<=(
; 501  : 		const duration<_Rep1, _Period1>& _Left,
; 502  : 		const duration<_Rep2, _Period2>& _Right)
; 503  : 	{	// test if duration <= duration
; 504  : 	return (!(_Right < _Left));
; 505  : 	}
; 506  : 
; 507  : template<class _Rep1,
; 508  : 	class _Period1,
; 509  : 	class _Rep2,
; 510  : 	class _Period2> inline
; 511  : 	bool operator>(
; 512  : 		const duration<_Rep1, _Period1>& _Left,
; 513  : 		const duration<_Rep2, _Period2>& _Right)
; 514  : 	{	// test if duration > duration
; 515  : 	return (_Right < _Left);
; 516  : 	}
; 517  : 
; 518  : template<class _Rep1,
; 519  : 	class _Period1,
; 520  : 	class _Rep2,
; 521  : 	class _Period2> inline
; 522  : 	bool operator>=(
; 523  : 		const duration<_Rep1, _Period1>& _Left,
; 524  : 		const duration<_Rep2, _Period2>& _Right)
; 525  : 	{	// test if duration >= duration
; 526  : 	return (!(_Left < _Right));
; 527  : 	}
; 528  : 
; 529  : 	// duration_cast
; 530  : template<class _To,
; 531  : 	class _Rep,
; 532  : 	class _Period> inline
; 533  : 	typename enable_if<_Is_duration<_To>::value,
; 534  : 		_To>::type
; 535  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 536  : 	{	// convert duration to another duration
; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<_ToRep>(
; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<_ToRep>(

	mov	rax, r15
	imul	rcx
	sar	rdx, 11
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File z:\github\merikens-tripcode-engine\sourcefiles\main.cpp

; 2203 : 		deltaTime = currentTime - startingTime;

	sub	rdx, r14

; 2204 : 	} while (deltaTime < 10 * 1000 && !allThreadsHaveExited);	

	cmp	rdx, 10000				; 00002710H
	jae	SHORT $LN1@main
	test	ebp, ebp
	je	$LL16@main
$LN1@main:

; 235  : 	RELEASE_AND_SET_TO_NULL(expandedPatternArray, free);

	mov	rcx, QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA ; expandedPatternArray
	test	rcx, rcx
	je	SHORT $LN499@main
	call	free
	mov	QWORD PTR ?expandedPatternArray@@3PEAUExpandedPattern@@EA, rsi ; expandedPatternArray
$LN499@main:

; 236  : 	RELEASE_AND_SET_TO_NULL(tripcodeChunkArray,   free);

	mov	rcx, QWORD PTR ?tripcodeChunkArray@@3PEAIEA ; tripcodeChunkArray
	test	rcx, rcx
	je	SHORT $LN498@main
	call	free
	mov	QWORD PTR ?tripcodeChunkArray@@3PEAIEA, rsi ; tripcodeChunkArray
$LN498@main:

; 237  : 	RELEASE_AND_SET_TO_NULL(regexPatternArray,    free);

	mov	rcx, QWORD PTR ?regexPatternArray@@3PEAURegexPattern@@EA ; regexPatternArray
	test	rcx, rcx
	je	SHORT $LN497@main
	call	free
	mov	QWORD PTR ?regexPatternArray@@3PEAURegexPattern@@EA, rsi ; regexPatternArray
$LN497@main:

; 238  : 	if (tripcodeFile) {

	mov	rcx, QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA ; tripcodeFile
	test	rcx, rcx
	je	SHORT $LN495@main

; 239  : 		RELEASE_AND_SET_TO_NULL(tripcodeFile,     fclose);

	call	fclose
	mov	QWORD PTR ?tripcodeFile@@3PEAU_iobuf@@EA, rsi ; tripcodeFile
$LN495@main:

; 240  : 	}
; 241  : 	if (eventForTerminating) {

	mov	rcx, QWORD PTR ?eventForTerminating@@3PEAXEA ; eventForTerminating
	test	rcx, rcx
	je	SHORT $LN494@main

; 242  : 		CloseHandle(eventForTerminating);

	call	QWORD PTR __imp_CloseHandle

; 243  : 		eventForTerminating = NULL;

	mov	QWORD PTR ?eventForTerminating@@3PEAXEA, rsi ; eventForTerminating
$LN494@main:

; 2205 : 
; 2206 : 	ReleaseResources();
; 2207 : 
; 2208 : 	return 0;

	xor	eax, eax
	mov	r15, QWORD PTR [rsp+112]

; 2209 : }

	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN660@main:

; 1024 : 		ListCUDADevices();

	call	?ListCUDADevices@@YAXXZ			; ListCUDADevices
$LN68@main:

; 1025 : 	ListOpenCLDevices();

	call	?ListOpenCLDevices@@YAXXZ		; ListOpenCLDevices

; 1026 : 	exit(0);

	xor	ecx, ecx
	call	exit
	int	3
$LN662@main:

; 2058 : 		exit(0);

	xor	ecx, ecx
	call	exit
	int	3
$LN663@main:

; 2064 : 		ListExpandedPatterns();
; 2065 : 		exit(0);

	xor	ecx, ecx
	call	exit
	int	3
$LN658@main:
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 46   : 		{	// construct with _Fx(_Ax...)

$LN67:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rdi, rdx
	mov	rsi, rcx

; 47   : 		_Launch(&_Thr,
; 48   : 			 _STD bind(_Decay_copy(_STD forward<_Fn>(_Fx)),
; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	rbx, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$2[rsp+32], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$2[rsp+40], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
?dtor$0@?0???$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA PROC ; `std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$2[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0A6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA ENDP ; `std::thread::thread<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 46   : 		{	// construct with _Fx(_Ax...)

$LN67:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rdi, rdx
	mov	rsi, rcx

; 47   : 		_Launch(&_Thr,
; 48   : 			 _STD bind(_Decay_copy(_STD forward<_Fn>(_Fx)),
; 49   : 				_Decay_copy(_STD forward<_Args>(_Ax))...));

	mov	rbx, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$2[rsp+32], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR _Launcher$2[rsp+40], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
<_Ax_0>$ = 128
?dtor$0@?0???$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA PROC ; `std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$2[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0A6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@thread@std@@QEAA@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z@4HA ENDP ; `std::thread::thread<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
;	COMDAT ??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z PROC		; std::thread::thread<void (__cdecl&)(void)>, COMDAT

; 46   : 		{	// construct with _Fx(_Ax...)

$LN37:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	rbx, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
	mov	QWORD PTR _Launcher$2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR _Launcher$2[rsp+32], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$2[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 50   : 		}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z ENDP		; std::thread::thread<void (__cdecl&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$ = 120
?dtor$0@?0???$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z@4HA PROC ; `std::thread::thread<void (__cdecl&)(void)>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$2[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0A6AXXZ$$$V@thread@std@@QEAA@A6AXXZ@Z@4HA ENDP ; `std::thread::thread<void (__cdecl&)(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::forward<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	rax, rcx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl&)(CUDADeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAUCUDADeviceSearchThreadInfo@@@std@@YA$$QEAPEAUCUDADeviceSearchThreadInfo@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUCUDADeviceSearchThreadInfo@@@std@@YA$$QEAPEAUCUDADeviceSearchThreadInfo@@AEAPEAU1@@Z PROC ; std::forward<CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAUCUDADeviceSearchThreadInfo@@@std@@YA$$QEAPEAUCUDADeviceSearchThreadInfo@@AEAPEAU1@@Z ENDP ; std::forward<CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@PEAUCUDADeviceSearchThreadInfo@@@std@@YAPEAUCUDADeviceSearchThreadInfo@@$$QEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@PEAUCUDADeviceSearchThreadInfo@@@std@@YAPEAUCUDADeviceSearchThreadInfo@@$$QEAPEAU1@@Z PROC ; std::_Decay_copy<CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	rax, QWORD PTR [rcx]

; 1546 : 	}

	ret	0
??$_Decay_copy@PEAUCUDADeviceSearchThreadInfo@@@std@@YAPEAUCUDADeviceSearchThreadInfo@@$$QEAPEAU1@@Z ENDP ; std::_Decay_copy<CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@XPEAUCUDADeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Pfx$ = 16
<_Args_0>$ = 24
??$bind@XPEAUCUDADeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::bind<void,CUDADeviceSearchThreadInfo * __ptr64,CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	rax, rcx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	ret	0
??$bind@XPEAUCUDADeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::bind<void,CUDADeviceSearchThreadInfo * __ptr64,CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >, COMDAT

; 204  : 	{	// launch a new thread

$LN33:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR _Launcher$[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR _Launcher$[rsp+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA PROC ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA ENDP ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAA6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::forward<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	rax, rcx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZA6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl&)(OpenCLDeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QEAPEAUOpenCLDeviceSearchThreadInfo@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QEAPEAUOpenCLDeviceSearchThreadInfo@@AEAPEAU1@@Z PROC ; std::forward<OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YA$$QEAPEAUOpenCLDeviceSearchThreadInfo@@AEAPEAU1@@Z ENDP ; std::forward<OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAPEAUOpenCLDeviceSearchThreadInfo@@$$QEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAPEAUOpenCLDeviceSearchThreadInfo@@$$QEAPEAU1@@Z PROC ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	rax, QWORD PTR [rcx]

; 1546 : 	}

	ret	0
??$_Decay_copy@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAPEAUOpenCLDeviceSearchThreadInfo@@$$QEAPEAU1@@Z ENDP ; std::_Decay_copy<OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@XPEAUOpenCLDeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Pfx$ = 16
<_Args_0>$ = 24
??$bind@XPEAUOpenCLDeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::bind<void,OpenCLDeviceSearchThreadInfo * __ptr64,OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	rax, rcx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	ret	0
??$bind@XPEAUOpenCLDeviceSearchThreadInfo@@PEAU1@@std@@YA?AV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::bind<void,OpenCLDeviceSearchThreadInfo * __ptr64,OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >, COMDAT

; 204  : 	{	// launch a new thread

$LN33:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR _Launcher$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR _Launcher$[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR _Launcher$[rsp+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA PROC ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@@Z@4HA ENDP ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z PROC		; std::forward<void (__cdecl&)(void)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@A6AXXZ@std@@YAA6AXXZA6AXXZ@Z ENDP		; std::forward<void (__cdecl&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z PROC	; std::_Decay_copy<void (__cdecl&)(void)>, COMDAT

; 1545 : 	return (_STD forward<_Ty>(_Arg));

	mov	rax, rcx

; 1546 : 	}

	ret	0
??$_Decay_copy@A6AXXZ@std@@YAP6AXXZA6AXXZ@Z ENDP	; std::_Decay_copy<void (__cdecl&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Pfx$ = 16
??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z PROC ; std::bind<void>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	QWORD PTR [rcx], rdx

; 1270 : 	return (_Bind<true, _Rx, _Rx (* const)(_Ftypes...), _Types...>(

	mov	rax, rcx

; 1271 : 		_Pfx, _STD forward<_Types>(_Args)...));
; 1272 : 	}

	ret	0
??$bind@X$$$V$$$V@std@@YA?AV?$_Bind@$00XQ6AXXZ$$$V@0@P6AXXZ@Z ENDP ; std::bind<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT

; 204  : 	{	// launch a new thread

$LN21:
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 182  : 		{	// construct from target

	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
	mov	QWORD PTR _Launcher$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR _Launcher$[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

	mov	rdx, rdi
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
	npad	1
	lea	rcx, QWORD PTR _Launcher$[rsp]
	call	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad

; 207  : 	}

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z@4HA PROC ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Launcher$[rdx]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@@Z@4HA ENDP ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(void)> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >, COMDAT
	jmp	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >, COMDAT
	jmp	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT
	jmp	??1_Pad@std@@QEAA@XZ			; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Go, COMDAT

; 186  : 		{	// run the thread function object

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, rbx
	call	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 188  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Go, COMDAT

; 186  : 		{	// run the thread function object

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, rbx
	call	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 188  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@UEAAIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go, COMDAT

; 186  : 		{	// run the thread function object

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rbx, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	call	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 187  : 		return (_Run(this));

	xor	eax, eax

; 188  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@UEAAIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z
_TEXT	SEGMENT
_Ln$ = 48
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Run, COMDAT

; 192  : 		{	// make local copy of function object and call it

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, rbx
	call	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 197  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z
_TEXT	SEGMENT
_Ln$ = 48
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Run, COMDAT

; 192  : 		{	// make local copy of function object and call it

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, rbx
	call	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 197  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@CAIPEAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z
_TEXT	SEGMENT
_Ln$ = 48
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run, COMDAT

; 192  : 		{	// make local copy of function object and call it

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rbx, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

	call	?_Release@_Pad@std@@QEAAXXZ		; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	call	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 196  : 		return (0);

	xor	eax, eax

; 197  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@CAIPEAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1128 : 		}

	mov	rax, rcx
	ret	0
??0?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1128 : 		}

	mov	rax, rcx
	ret	0
??0?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@$$QEAV01@@Z PROC	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>, COMDAT

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1128 : 		}

	mov	rax, rcx
	ret	0
??0?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@$$QEAV01@@Z ENDP	; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
this$ = 8
_Fx$ = 16
<_Args_0>$ = 24
??$?0AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1110 : 		}

	mov	rax, rcx
	ret	0
??$?0AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Tgt$ = 56
??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >, COMDAT

; 182  : 		{	// construct from target

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR [rdi+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z
_TEXT	SEGMENT
this$ = 8
_Fx$ = 16
<_Args_0>$ = 24
??$?0AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1110 : 		}

	mov	rax, rcx
	ret	0
??$?0AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU0@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAA@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z$$QEAPEAU2@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64><void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@0@AEAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Tgt$ = 56
??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >, COMDAT

; 182  : 		{	// construct from target

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

	mov	QWORD PTR [rdi+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> ><std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?0AEAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@AEAP6AXXZ@Z
_TEXT	SEGMENT
this$ = 8
_Fx$ = 16
??$?0AEAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@AEAP6AXXZ@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*& __ptr64)(void)>, COMDAT

; 1109 : 		{	// construct from functor and arguments

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1110 : 		}

	mov	rax, rcx
	ret	0
??$?0AEAP6AXXZ$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAA@AEAP6AXXZ@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Bind<1,void,void (__cdecl*const)(void)><void (__cdecl*& __ptr64)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@AEAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXXZ$$$V@0@AEAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Tgt$ = 56
??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >, COMDAT

; 182  : 		{	// construct from target

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0_Pad@std@@QEAA@XZ			; std::_Pad::_Pad
	lea	rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional

; 1127 : 		{	// construct by moving

	mov	QWORD PTR [rdi+32], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thr\xthread

; 183  : 		}

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0V?$_Bind@$00XQ6AXXZ$$$V@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXXZ$$$V@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXXZ$$$V@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(void)> ><std::_Bind<1,void,void (__cdecl*const)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$?R$$$V@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::operator()<>, COMDAT

; 1131 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,

	mov	rax, rcx

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, QWORD PTR [rcx+8]
	rex_jmp	QWORD PTR [rax]
??$?R$$$V@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$?R$$$V@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::operator()<>, COMDAT

; 1131 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,

	mov	rax, rcx

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, QWORD PTR [rcx+8]
	rex_jmp	QWORD PTR [rax]
??$?R$$$V@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXXZ PROC	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>, COMDAT

; 1139 : 
; 1140 : 	template<class... _Ftypes,
; 1141 : 		size_t... _Bindexes>
; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,
; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	rex_jmp	QWORD PTR [rcx]
??$?R$$$V@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXXZ ENDP	; std::_Bind<1,void,void (__cdecl*const)(void)>::operator()<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@P6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(CUDADeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<CUDADeviceSearchThreadInfo * __ptr64> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<CUDADeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUCUDADeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0PEAUCUDADeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 259  : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUCUDADeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@P6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YA$$QEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(OpenCLDeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@@std@@YA$$QEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUOpenCLDeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0PEAUOpenCLDeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 259  : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUOpenCLDeviceSearchThreadInfo@@PEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXXZ@std@@YA$$QEAP6AXXZAEAP6AXXZ@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@P6AXXZ@std@@YA$$QEAP6AXXZAEAP6AXXZ@Z PROC	; std::forward<void (__cdecl*)(void)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@P6AXXZ@std@@YA$$QEAP6AXXZAEAP6AXXZ@Z ENDP	; std::forward<void (__cdecl*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$$V@std@@@std@@YA$$QEAV?$tuple@$$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QEAV?$tuple@$$$V@0@AEAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QEAV?$tuple@$$$V@0@AEAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ PROC ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::_Get_rest, COMDAT

; 439  : 		return (*this);

	mov	rax, rcx

; 440  : 		}

	ret	0
?_Get_rest@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ PROC ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::_Get_rest, COMDAT

; 439  : 		return (*this);

	mov	rax, rcx

; 440  : 		}

	ret	0
?_Get_rest@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAAAEAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUCUDADeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0PEAUCUDADeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z PROC ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 234  : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUCUDADeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z ENDP ; std::tuple<CUDADeviceSearchThreadInfo * __ptr64>::tuple<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@Z@std@@YAAEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUOpenCLDeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0PEAUOpenCLDeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z PROC ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 234  : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUOpenCLDeviceSearchThreadInfo@@$$$VPEAPEAX@?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z ENDP ; std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>::tuple<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64,void * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAP6AXXZ@std@@YAAEAP6AXXZAEAP6AXXZ@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAP6AXXZ@std@@YAAEAP6AXXZAEAP6AXXZ@Z PROC	; std::forward<void (__cdecl*& __ptr64)(void)>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAP6AXXZ@std@@YAAEAP6AXXZAEAP6AXXZ@Z ENDP	; std::forward<void (__cdecl*& __ptr64)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ PROC		; std::tie<>, COMDAT

; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));

	mov	rax, rcx

; 620  : 	}

	ret	0
??$tie@$$$V@std@@YA?AV?$tuple@$$$V@0@XZ ENDP		; std::tie<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Myfargs$dead$ = 56
__formal$dead$ = 64
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Do_call<,0>, COMDAT

; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,

$LN8:
	sub	rsp, 40					; 00000028H
	mov	rax, rcx

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR [rax]

; 1150 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64>::_Do_call<,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Myfargs$dead$ = 56
__formal$dead$ = 64
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Do_call<,0>, COMDAT

; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,

$LN8:
	sub	rsp, 40					; 00000028H
	mov	rax, rcx

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR [rax]

; 1150 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$_Do_call@$$$V$0A@@?$_Bind@$00XQ6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64>::_Do_call<,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Myfargs$dead$ = 56
__formal$dead$ = 64
??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>, COMDAT

; 1142 : 		typename _Do_call_ret<_Forced, _Ret, _Funx, _Bargs,

$LN4:
	sub	rsp, 40					; 00000028H

; 1143 : 			tuple<_Ftypes&...>,
; 1144 : 			_Arg_idx<_Bindexes...> >::type
; 1145 : 		_Do_call(tuple<_Ftypes&...> _Myfargs,
; 1146 : 			_Arg_idx<_Bindexes...>)
; 1147 : 		{	// call the stored functor with bound arguments
; 1148 : 		return (_Myfun(_Fixarg(_Myfun, _Mybargs, _Myfargs,
; 1149 : 			_STD get<_Bindexes>(_Mybargs))...));

	call	QWORD PTR [rcx]

; 1150 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$_Do_call@$$$V$S@?$_Bind@$00XQ6AXXZ$$$V@std@@QEAAXV?$tuple@$$$V@1@U?$_Arg_idx@$S@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(void)>::_Do_call<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0PEAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z PROC ; std::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64>::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 81   : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUCUDADeviceSearchThreadInfo@@@?$_Tuple_val@PEAUCUDADeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUCUDADeviceSearchThreadInfo@@@Z ENDP ; std::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64>::_Tuple_val<CUDADeviceSearchThreadInfo * __ptr64><CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0PEAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0PEAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z PROC ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64>::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 80   : 		{	// construct with argument

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 81   : 		}

	mov	rax, rcx
	ret	0
??$?0PEAUOpenCLDeviceSearchThreadInfo@@@?$_Tuple_val@PEAUOpenCLDeviceSearchThreadInfo@@@std@@QEAA@$$QEAPEAUOpenCLDeviceSearchThreadInfo@@@Z ENDP ; std::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64>::_Tuple_val<OpenCLDeviceSearchThreadInfo * __ptr64><OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@PEAUCUDADeviceSearchThreadInfo@@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$get@$0A@PEAUCUDADeviceSearchThreadInfo@@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@@Z PROC ; std::get<0,CUDADeviceSearchThreadInfo * __ptr64>, COMDAT

; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);

	mov	rax, rcx

; 580  : 	}

	ret	0
??$get@$0A@PEAUCUDADeviceSearchThreadInfo@@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@@Z ENDP ; std::get<0,CUDADeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Fixarg@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Mybargs$dead$ = 16
_Myfargs$dead$ = 24
_Arg$ = 32
??$_Fixarg@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z PROC ; std::_Fixarg<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64,std::tuple<CUDADeviceSearchThreadInfo * __ptr64>,std::tuple<> >, COMDAT

; 1085 : 	return (_Arg);

	mov	rax, r9

; 1086 : 	}

	ret	0
??$_Fixarg@AEAP6AXPEAUCUDADeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUCUDADeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUCUDADeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUCUDADeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z ENDP ; std::_Fixarg<void (__cdecl*& __ptr64)(CUDADeviceSearchThreadInfo * __ptr64),CUDADeviceSearchThreadInfo * __ptr64,std::tuple<CUDADeviceSearchThreadInfo * __ptr64>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$get@$0A@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@@Z PROC ; std::get<0,OpenCLDeviceSearchThreadInfo * __ptr64>, COMDAT

; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);

	mov	rax, rcx

; 580  : 	}

	ret	0
??$get@$0A@PEAUOpenCLDeviceSearchThreadInfo@@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@@Z ENDP ; std::get<0,OpenCLDeviceSearchThreadInfo * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??$_Fixarg@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Mybargs$dead$ = 16
_Myfargs$dead$ = 24
_Arg$ = 32
??$_Fixarg@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z PROC ; std::_Fixarg<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64,std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>,std::tuple<> >, COMDAT

; 1085 : 	return (_Arg);

	mov	rax, r9

; 1086 : 	}

	ret	0
??$_Fixarg@AEAP6AXPEAUOpenCLDeviceSearchThreadInfo@@@ZPEAU1@V?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@std@@V?$tuple@$$$V@3@@std@@YAAEAPEAUOpenCLDeviceSearchThreadInfo@@AEAP6AXPEAU1@@ZAEAV?$tuple@PEAUOpenCLDeviceSearchThreadInfo@@@0@AEAV?$tuple@$$$V@0@AEAPEAU1@@Z ENDP ; std::_Fixarg<void (__cdecl*& __ptr64)(OpenCLDeviceSearchThreadInfo * __ptr64),OpenCLDeviceSearchThreadInfo * __ptr64,std::tuple<OpenCLDeviceSearchThreadInfo * __ptr64>,std::tuple<> >
_TEXT	ENDS
END
