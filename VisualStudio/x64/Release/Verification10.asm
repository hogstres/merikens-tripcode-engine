; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?_ufc_keytab@@3PAY01IA				; _ufc_keytab
PUBLIC	?_ufc_sb1@@3PAIA				; _ufc_sb1
PUBLIC	?_ufc_sb2@@3PAIA				; _ufc_sb2
PUBLIC	?_ufc_sb3@@3PAIA				; _ufc_sb3
PUBLIC	?_ufc_sb0@@3PAIA				; _ufc_sb0
?_ufc_keytab@@3PAY01IA DD 020H DUP (?)			; _ufc_keytab
initialized DD	01H DUP (?)
?_ufc_sb1@@3PAIA DD 02000H DUP (?)			; _ufc_sb1
?_ufc_sb2@@3PAIA DD 02000H DUP (?)			; _ufc_sb2
?_ufc_sb3@@3PAIA DD 02000H DUP (?)			; _ufc_sb3
direction DD	01H DUP (?)
current_saltbits DD 01H DUP (?)
?_ufc_sb0@@3PAIA DD 02000H DUP (?)			; _ufc_sb0
_BSS	ENDS
current_salt DB	'&&', 00H
	ORG $+1
$SG4294884916 DB '..', 00H
$SG4294884915 DB '..', 00H
bytemask DB	080H
	DB	040H
	DB	020H
	DB	010H
	DB	08H
	DB	04H
	DB	02H
	DB	01H
	ORG $+7
sb	DQ	FLAT:?_ufc_sb0@@3PAIA
	DQ	FLAT:?_ufc_sb1@@3PAIA
	DQ	FLAT:?_ufc_sb2@@3PAIA
	DQ	FLAT:?_ufc_sb3@@3PAIA
perm32	DD	010H
	DD	07H
	DD	014H
	DD	015H
	DD	01dH
	DD	0cH
	DD	01cH
	DD	011H
	DD	01H
	DD	0fH
	DD	017H
	DD	01aH
	DD	05H
	DD	012H
	DD	01fH
	DD	0aH
	DD	02H
	DD	08H
	DD	018H
	DD	0eH
	DD	020H
	DD	01bH
	DD	03H
	DD	09H
	DD	013H
	DD	0dH
	DD	01eH
	DD	06H
	DD	016H
	DD	0bH
	DD	04H
	DD	019H
DES_charToIndexTable DB 07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
pc1	DD	039H
	DD	031H
	DD	029H
	DD	021H
	DD	019H
	DD	011H
	DD	09H
	DD	01H
	DD	03aH
	DD	032H
	DD	02aH
	DD	022H
	DD	01aH
	DD	012H
	DD	0aH
	DD	02H
	DD	03bH
	DD	033H
	DD	02bH
	DD	023H
	DD	01bH
	DD	013H
	DD	0bH
	DD	03H
	DD	03cH
	DD	034H
	DD	02cH
	DD	024H
	DD	03fH
	DD	037H
	DD	02fH
	DD	027H
	DD	01fH
	DD	017H
	DD	0fH
	DD	07H
	DD	03eH
	DD	036H
	DD	02eH
	DD	026H
	DD	01eH
	DD	016H
	DD	0eH
	DD	06H
	DD	03dH
	DD	035H
	DD	02dH
	DD	025H
	DD	01dH
	DD	015H
	DD	0dH
	DD	05H
	DD	01cH
	DD	014H
	DD	0cH
	DD	04H
charTableForSeed DB 02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
	DB	02eH
esel	DD	020H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	020H
	DD	01H
sbox	DD	0eH
	DD	04H
	DD	0dH
	DD	01H
	DD	02H
	DD	0fH
	DD	0bH
	DD	08H
	DD	03H
	DD	0aH
	DD	06H
	DD	0cH
	DD	05H
	DD	09H
	DD	00H
	DD	07H
	DD	00H
	DD	0fH
	DD	07H
	DD	04H
	DD	0eH
	DD	02H
	DD	0dH
	DD	01H
	DD	0aH
	DD	06H
	DD	0cH
	DD	0bH
	DD	09H
	DD	05H
	DD	03H
	DD	08H
	DD	04H
	DD	01H
	DD	0eH
	DD	08H
	DD	0dH
	DD	06H
	DD	02H
	DD	0bH
	DD	0fH
	DD	0cH
	DD	09H
	DD	07H
	DD	03H
	DD	0aH
	DD	05H
	DD	00H
	DD	0fH
	DD	0cH
	DD	08H
	DD	02H
	DD	04H
	DD	09H
	DD	01H
	DD	07H
	DD	05H
	DD	0bH
	DD	03H
	DD	0eH
	DD	0aH
	DD	00H
	DD	06H
	DD	0dH
	DD	0fH
	DD	01H
	DD	08H
	DD	0eH
	DD	06H
	DD	0bH
	DD	03H
	DD	04H
	DD	09H
	DD	07H
	DD	02H
	DD	0dH
	DD	0cH
	DD	00H
	DD	05H
	DD	0aH
	DD	03H
	DD	0dH
	DD	04H
	DD	07H
	DD	0fH
	DD	02H
	DD	08H
	DD	0eH
	DD	0cH
	DD	00H
	DD	01H
	DD	0aH
	DD	06H
	DD	09H
	DD	0bH
	DD	05H
	DD	00H
	DD	0eH
	DD	07H
	DD	0bH
	DD	0aH
	DD	04H
	DD	0dH
	DD	01H
	DD	05H
	DD	08H
	DD	0cH
	DD	06H
	DD	09H
	DD	03H
	DD	02H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0aH
	DD	01H
	DD	03H
	DD	0fH
	DD	04H
	DD	02H
	DD	0bH
	DD	06H
	DD	07H
	DD	0cH
	DD	00H
	DD	05H
	DD	0eH
	DD	09H
	DD	0aH
	DD	00H
	DD	09H
	DD	0eH
	DD	06H
	DD	03H
	DD	0fH
	DD	05H
	DD	01H
	DD	0dH
	DD	0cH
	DD	07H
	DD	0bH
	DD	04H
	DD	02H
	DD	08H
	DD	0dH
	DD	07H
	DD	00H
	DD	09H
	DD	03H
	DD	04H
	DD	06H
	DD	0aH
	DD	02H
	DD	08H
	DD	05H
	DD	0eH
	DD	0cH
	DD	0bH
	DD	0fH
	DD	01H
	DD	0dH
	DD	06H
	DD	04H
	DD	09H
	DD	08H
	DD	0fH
	DD	03H
	DD	00H
	DD	0bH
	DD	01H
	DD	02H
	DD	0cH
	DD	05H
	DD	0aH
	DD	0eH
	DD	07H
	DD	01H
	DD	0aH
	DD	0dH
	DD	00H
	DD	06H
	DD	09H
	DD	08H
	DD	07H
	DD	04H
	DD	0fH
	DD	0eH
	DD	03H
	DD	0bH
	DD	05H
	DD	02H
	DD	0cH
	DD	07H
	DD	0dH
	DD	0eH
	DD	03H
	DD	00H
	DD	06H
	DD	09H
	DD	0aH
	DD	01H
	DD	02H
	DD	08H
	DD	05H
	DD	0bH
	DD	0cH
	DD	04H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0bH
	DD	05H
	DD	06H
	DD	0fH
	DD	00H
	DD	03H
	DD	04H
	DD	07H
	DD	02H
	DD	0cH
	DD	01H
	DD	0aH
	DD	0eH
	DD	09H
	DD	0aH
	DD	06H
	DD	09H
	DD	00H
	DD	0cH
	DD	0bH
	DD	07H
	DD	0dH
	DD	0fH
	DD	01H
	DD	03H
	DD	0eH
	DD	05H
	DD	02H
	DD	08H
	DD	04H
	DD	03H
	DD	0fH
	DD	00H
	DD	06H
	DD	0aH
	DD	01H
	DD	0dH
	DD	08H
	DD	09H
	DD	04H
	DD	05H
	DD	0bH
	DD	0cH
	DD	07H
	DD	02H
	DD	0eH
	DD	02H
	DD	0cH
	DD	04H
	DD	01H
	DD	07H
	DD	0aH
	DD	0bH
	DD	06H
	DD	08H
	DD	05H
	DD	03H
	DD	0fH
	DD	0dH
	DD	00H
	DD	0eH
	DD	09H
	DD	0eH
	DD	0bH
	DD	02H
	DD	0cH
	DD	04H
	DD	07H
	DD	0dH
	DD	01H
	DD	05H
	DD	00H
	DD	0fH
	DD	0aH
	DD	03H
	DD	09H
	DD	08H
	DD	06H
	DD	04H
	DD	02H
	DD	01H
	DD	0bH
	DD	0aH
	DD	0dH
	DD	07H
	DD	08H
	DD	0fH
	DD	09H
	DD	0cH
	DD	05H
	DD	06H
	DD	03H
	DD	00H
	DD	0eH
	DD	0bH
	DD	08H
	DD	0cH
	DD	07H
	DD	01H
	DD	0eH
	DD	02H
	DD	0dH
	DD	06H
	DD	0fH
	DD	00H
	DD	09H
	DD	0aH
	DD	04H
	DD	05H
	DD	03H
	DD	0cH
	DD	01H
	DD	0aH
	DD	0fH
	DD	09H
	DD	02H
	DD	06H
	DD	08H
	DD	00H
	DD	0dH
	DD	03H
	DD	04H
	DD	0eH
	DD	07H
	DD	05H
	DD	0bH
	DD	0aH
	DD	0fH
	DD	04H
	DD	02H
	DD	07H
	DD	0cH
	DD	09H
	DD	05H
	DD	06H
	DD	01H
	DD	0dH
	DD	0eH
	DD	00H
	DD	0bH
	DD	03H
	DD	08H
	DD	09H
	DD	0eH
	DD	0fH
	DD	05H
	DD	02H
	DD	08H
	DD	0cH
	DD	03H
	DD	07H
	DD	00H
	DD	04H
	DD	0aH
	DD	01H
	DD	0dH
	DD	0bH
	DD	06H
	DD	04H
	DD	03H
	DD	02H
	DD	0cH
	DD	09H
	DD	05H
	DD	0fH
	DD	0aH
	DD	0bH
	DD	0eH
	DD	01H
	DD	07H
	DD	06H
	DD	00H
	DD	08H
	DD	0dH
	DD	04H
	DD	0bH
	DD	02H
	DD	0eH
	DD	0fH
	DD	00H
	DD	08H
	DD	0dH
	DD	03H
	DD	0cH
	DD	09H
	DD	07H
	DD	05H
	DD	0aH
	DD	06H
	DD	01H
	DD	0dH
	DD	00H
	DD	0bH
	DD	07H
	DD	04H
	DD	09H
	DD	01H
	DD	0aH
	DD	0eH
	DD	03H
	DD	05H
	DD	0cH
	DD	02H
	DD	0fH
	DD	08H
	DD	06H
	DD	01H
	DD	04H
	DD	0bH
	DD	0dH
	DD	0cH
	DD	03H
	DD	07H
	DD	0eH
	DD	0aH
	DD	0fH
	DD	06H
	DD	08H
	DD	00H
	DD	05H
	DD	09H
	DD	02H
	DD	06H
	DD	0bH
	DD	0dH
	DD	08H
	DD	01H
	DD	04H
	DD	0aH
	DD	07H
	DD	09H
	DD	05H
	DD	00H
	DD	0fH
	DD	0eH
	DD	02H
	DD	03H
	DD	0cH
	DD	0dH
	DD	02H
	DD	08H
	DD	04H
	DD	06H
	DD	0fH
	DD	0bH
	DD	01H
	DD	0aH
	DD	09H
	DD	03H
	DD	0eH
	DD	05H
	DD	00H
	DD	0cH
	DD	07H
	DD	01H
	DD	0fH
	DD	0dH
	DD	08H
	DD	0aH
	DD	03H
	DD	07H
	DD	04H
	DD	0cH
	DD	05H
	DD	06H
	DD	0bH
	DD	00H
	DD	0eH
	DD	09H
	DD	02H
	DD	07H
	DD	0bH
	DD	04H
	DD	01H
	DD	09H
	DD	0cH
	DD	0eH
	DD	02H
	DD	00H
	DD	06H
	DD	0aH
	DD	0dH
	DD	0fH
	DD	03H
	DD	05H
	DD	08H
	DD	02H
	DD	01H
	DD	0eH
	DD	07H
	DD	04H
	DD	0aH
	DD	08H
	DD	0dH
	DD	0fH
	DD	0cH
	DD	09H
	DD	00H
	DD	03H
	DD	05H
	DD	06H
	DD	0bH
longmask DD	080000000H
	DD	040000000H
	DD	020000000H
	DD	010000000H
	DD	08000000H
	DD	04000000H
	DD	02000000H
	DD	01000000H
	DD	0800000H
	DD	0400000H
	DD	0200000H
	DD	0100000H
	DD	080000H
	DD	040000H
	DD	020000H
	DD	010000H
	DD	08000H
	DD	04000H
	DD	02000H
	DD	01000H
	DD	0800H
	DD	0400H
	DD	0200H
	DD	0100H
	DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
	DD	02H
	DD	01H
rots	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
DES_indexToCharTable DB 02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
pc2	DD	0eH
	DD	011H
	DD	0bH
	DD	018H
	DD	01H
	DD	05H
	DD	03H
	DD	01cH
	DD	0fH
	DD	06H
	DD	015H
	DD	0aH
	DD	017H
	DD	013H
	DD	0cH
	DD	04H
	DD	01aH
	DD	08H
	DD	010H
	DD	07H
	DD	01bH
	DD	014H
	DD	0dH
	DD	02H
	DD	029H
	DD	034H
	DD	01fH
	DD	025H
	DD	02fH
	DD	037H
	DD	01eH
	DD	028H
	DD	033H
	DD	02dH
	DD	021H
	DD	030H
	DD	02cH
	DD	031H
	DD	027H
	DD	038H
	DD	022H
	DD	035H
	DD	02eH
	DD	02aH
	DD	032H
	DD	024H
	DD	01dH
	DD	020H
keySchedule DB	0cH
	DB	02eH
	DB	021H
	DB	034H
	DB	030H
	DB	014H
	DB	022H
	DB	037H
	DB	05H
	DB	0dH
	DB	012H
	DB	028H
	DB	04H
	DB	020H
	DB	01aH
	DB	01bH
	DB	026H
	DB	036H
	DB	035H
	DB	06H
	DB	01fH
	DB	019H
	DB	013H
	DB	029H
	DB	0fH
	DB	018H
	DB	01cH
	DB	02bH
	DB	01eH
	DB	03H
	DB	023H
	DB	016H
	DB	02H
	DB	02cH
	DB	0eH
	DB	017H
	DB	033H
	DB	010H
	DB	01dH
	DB	031H
	DB	07H
	DB	011H
	DB	025H
	DB	08H
	DB	09H
	DB	032H
	DB	02aH
	DB	015H
	DB	05H
	DB	027H
	DB	01aH
	DB	02dH
	DB	029H
	DB	0dH
	DB	01bH
	DB	030H
	DB	035H
	DB	06H
	DB	0bH
	DB	021H
	DB	034H
	DB	019H
	DB	013H
	DB	014H
	DB	01fH
	DB	02fH
	DB	02eH
	DB	036H
	DB	037H
	DB	012H
	DB	0cH
	DB	022H
	DB	08H
	DB	011H
	DB	015H
	DB	024H
	DB	017H
	DB	031H
	DB	01cH
	DB	0fH
	DB	018H
	DB	025H
	DB	07H
	DB	010H
	DB	02cH
	DB	09H
	DB	016H
	DB	02aH
	DB	00H
	DB	0aH
	DB	01eH
	DB	01H
	DB	02H
	DB	02bH
	DB	023H
	DB	0eH
	DB	02eH
	DB	019H
	DB	0cH
	DB	01fH
	DB	01bH
	DB	036H
	DB	0dH
	DB	022H
	DB	027H
	DB	02fH
	DB	034H
	DB	013H
	DB	026H
	DB	0bH
	DB	05H
	DB	06H
	DB	030H
	DB	021H
	DB	020H
	DB	028H
	DB	029H
	DB	04H
	DB	035H
	DB	014H
	DB	033H
	DB	03H
	DB	07H
	DB	016H
	DB	09H
	DB	023H
	DB	0eH
	DB	01H
	DB	0aH
	DB	017H
	DB	032H
	DB	02H
	DB	01eH
	DB	018H
	DB	08H
	DB	01cH
	DB	02bH
	DB	031H
	DB	010H
	DB	02cH
	DB	011H
	DB	01dH
	DB	015H
	DB	00H
	DB	020H
	DB	0bH
	DB	035H
	DB	030H
	DB	0dH
	DB	028H
	DB	036H
	DB	014H
	DB	019H
	DB	021H
	DB	026H
	DB	05H
	DB	037H
	DB	034H
	DB	02eH
	DB	02fH
	DB	022H
	DB	013H
	DB	012H
	DB	01aH
	DB	01bH
	DB	02dH
	DB	027H
	DB	06H
	DB	025H
	DB	02aH
	DB	032H
	DB	08H
	DB	018H
	DB	015H
	DB	00H
	DB	02cH
	DB	031H
	DB	09H
	DB	024H
	DB	011H
	DB	010H
	DB	0aH
	DB	033H
	DB	0eH
	DB	01dH
	DB	023H
	DB	02H
	DB	01eH
	DB	03H
	DB	0fH
	DB	07H
	DB	02bH
	DB	012H
	DB	034H
	DB	027H
	DB	022H
	DB	036H
	DB	01aH
	DB	028H
	DB	06H
	DB	0bH
	DB	013H
	DB	037H
	DB	02eH
	DB	029H
	DB	026H
	DB	020H
	DB	021H
	DB	014H
	DB	05H
	DB	04H
	DB	0cH
	DB	0dH
	DB	01fH
	DB	019H
	DB	02fH
	DB	017H
	DB	01cH
	DB	024H
	DB	033H
	DB	0aH
	DB	07H
	DB	02bH
	DB	01eH
	DB	023H
	DB	018H
	DB	016H
	DB	03H
	DB	02H
	DB	031H
	DB	025H
	DB	00H
	DB	0fH
	DB	015H
	DB	011H
	DB	010H
	DB	02aH
	DB	01H
	DB	032H
	DB	01dH
	DB	04H
	DB	026H
	DB	019H
	DB	014H
	DB	028H
	DB	0cH
	DB	01aH
	DB	02fH
	DB	034H
	DB	05H
	DB	029H
	DB	020H
	DB	01bH
	DB	037H
	DB	012H
	DB	013H
	DB	06H
	DB	02eH
	DB	02dH
	DB	035H
	DB	036H
	DB	030H
	DB	0bH
	DB	021H
	DB	09H
	DB	0eH
	DB	016H
	DB	025H
	DB	031H
	DB	032H
	DB	01dH
	DB	010H
	DB	015H
	DB	0aH
	DB	08H
	DB	02aH
	DB	011H
	DB	023H
	DB	017H
	DB	02bH
	DB	01H
	DB	07H
	DB	03H
	DB	02H
	DB	01cH
	DB	02cH
	DB	024H
	DB	0fH
	DB	02dH
	DB	037H
	DB	0bH
	DB	06H
	DB	01aH
	DB	035H
	DB	0cH
	DB	021H
	DB	026H
	DB	02eH
	DB	01bH
	DB	012H
	DB	0dH
	DB	029H
	DB	04H
	DB	05H
	DB	02fH
	DB	020H
	DB	01fH
	DB	027H
	DB	028H
	DB	022H
	DB	034H
	DB	013H
	DB	018H
	DB	00H
	DB	08H
	DB	017H
	DB	023H
	DB	024H
	DB	0fH
	DB	02H
	DB	07H
	DB	031H
	DB	033H
	DB	01cH
	DB	03H
	DB	015H
	DB	09H
	DB	01dH
	DB	02cH
	DB	032H
	DB	02aH
	DB	011H
	DB	0eH
	DB	01eH
	DB	016H
	DB	01H
	DB	01fH
	DB	029H
	DB	034H
	DB	02fH
	DB	0cH
	DB	027H
	DB	035H
	DB	013H
	DB	037H
	DB	020H
	DB	0dH
	DB	04H
	DB	036H
	DB	01bH
	DB	02dH
	DB	02eH
	DB	021H
	DB	012H
	DB	030H
	DB	019H
	DB	01aH
	DB	014H
	DB	026H
	DB	05H
	DB	0aH
	DB	02bH
	DB	033H
	DB	09H
	DB	015H
	DB	016H
	DB	01H
	DB	011H
	DB	032H
	DB	023H
	DB	025H
	DB	0eH
	DB	02aH
	DB	07H
	DB	018H
	DB	0fH
	DB	01eH
	DB	024H
	DB	01cH
	DB	03H
	DB	00H
	DB	010H
	DB	08H
	DB	02cH
	DB	037H
	DB	022H
	DB	02dH
	DB	028H
	DB	05H
	DB	020H
	DB	02eH
	DB	0cH
	DB	030H
	DB	019H
	DB	06H
	DB	034H
	DB	02fH
	DB	014H
	DB	026H
	DB	027H
	DB	01aH
	DB	0bH
	DB	029H
	DB	012H
	DB	013H
	DB	0dH
	DB	01fH
	DB	035H
	DB	03H
	DB	024H
	DB	02cH
	DB	02H
	DB	0eH
	DB	0fH
	DB	033H
	DB	0aH
	DB	02bH
	DB	01cH
	DB	01eH
	DB	07H
	DB	023H
	DB	00H
	DB	011H
	DB	08H
	DB	017H
	DB	01dH
	DB	015H
	DB	031H
	DB	032H
	DB	09H
	DB	01H
	DB	025H
	DB	029H
	DB	014H
	DB	01fH
	DB	01aH
	DB	02eH
	DB	012H
	DB	020H
	DB	035H
	DB	022H
	DB	0bH
	DB	02fH
	DB	026H
	DB	021H
	DB	06H
	DB	037H
	DB	019H
	DB	0cH
	DB	034H
	DB	01bH
	DB	04H
	DB	05H
	DB	036H
	DB	030H
	DB	027H
	DB	02aH
	DB	016H
	DB	01eH
	DB	011H
	DB	00H
	DB	01H
	DB	025H
	DB	031H
	DB	01dH
	DB	0eH
	DB	010H
	DB	032H
	DB	015H
	DB	02bH
	DB	03H
	DB	033H
	DB	09H
	DB	0fH
	DB	07H
	DB	023H
	DB	024H
	DB	018H
	DB	02cH
	DB	017H
	DB	01bH
	DB	06H
	DB	030H
	DB	0cH
	DB	020H
	DB	04H
	DB	012H
	DB	027H
	DB	014H
	DB	034H
	DB	021H
	DB	037H
	DB	013H
	DB	02fH
	DB	029H
	DB	0bH
	DB	035H
	DB	026H
	DB	0dH
	DB	02dH
	DB	02eH
	DB	028H
	DB	022H
	DB	019H
	DB	01cH
	DB	08H
	DB	010H
	DB	03H
	DB	02bH
	DB	02cH
	DB	017H
	DB	023H
	DB	0fH
	DB	00H
	DB	02H
	DB	024H
	DB	07H
	DB	01dH
	DB	02aH
	DB	025H
	DB	018H
	DB	01H
	DB	032H
	DB	015H
	DB	016H
	DB	0aH
	DB	01eH
	DB	09H
	DB	0dH
	DB	02fH
	DB	022H
	DB	035H
	DB	012H
	DB	02dH
	DB	04H
	DB	019H
	DB	06H
	DB	026H
	DB	013H
	DB	029H
	DB	05H
	DB	021H
	DB	01bH
	DB	034H
	DB	027H
	DB	037H
	DB	036H
	DB	01fH
	DB	020H
	DB	01aH
	DB	014H
	DB	0bH
	DB	0eH
	DB	033H
	DB	02H
	DB	02aH
	DB	01dH
	DB	01eH
	DB	09H
	DB	015H
	DB	01H
	DB	02bH
	DB	011H
	DB	016H
	DB	032H
	DB	0fH
	DB	01cH
	DB	017H
	DB	0aH
	DB	02cH
	DB	024H
	DB	07H
	DB	08H
	DB	031H
	DB	010H
	DB	018H
	DB	036H
	DB	021H
	DB	014H
	DB	027H
	DB	04H
	DB	01fH
	DB	02dH
	DB	0bH
	DB	02fH
	DB	037H
	DB	05H
	DB	01bH
	DB	02eH
	DB	013H
	DB	0dH
	DB	026H
	DB	019H
	DB	029H
	DB	028H
	DB	030H
	DB	012H
	DB	0cH
	DB	06H
	DB	034H
	DB	00H
	DB	025H
	DB	011H
	DB	01cH
	DB	0fH
	DB	010H
	DB	018H
	DB	07H
	DB	02cH
	DB	01dH
	DB	03H
	DB	08H
	DB	024H
	DB	01H
	DB	0eH
	DB	09H
	DB	031H
	DB	01eH
	DB	016H
	DB	032H
	DB	033H
	DB	023H
	DB	02H
	DB	0aH
	DB	028H
	DB	013H
	DB	06H
	DB	019H
	DB	02dH
	DB	030H
	DB	01fH
	DB	034H
	DB	021H
	DB	029H
	DB	02eH
	DB	0dH
	DB	020H
	DB	05H
	DB	036H
	DB	037H
	DB	0bH
	DB	01bH
	DB	01aH
	DB	022H
	DB	04H
	DB	035H
	DB	02fH
	DB	026H
	DB	02bH
	DB	017H
	DB	03H
	DB	0eH
	DB	01H
	DB	02H
	DB	0aH
	DB	032H
	DB	01eH
	DB	0fH
	DB	02aH
	DB	033H
	DB	016H
	DB	02cH
	DB	00H
	DB	018H
	DB	023H
	DB	010H
	DB	08H
	DB	024H
	DB	025H
	DB	015H
	DB	011H
	DB	031H
	DB	01aH
	DB	05H
	DB	02fH
	DB	0bH
	DB	01fH
	DB	022H
	DB	030H
	DB	026H
	DB	013H
	DB	01bH
	DB	020H
	DB	036H
	DB	012H
	DB	02eH
	DB	028H
	DB	029H
	DB	034H
	DB	0dH
	DB	0cH
	DB	014H
	DB	02dH
	DB	027H
	DB	021H
	DB	037H
	DB	01dH
	DB	09H
	DB	02aH
	DB	00H
	DB	02cH
	DB	011H
	DB	031H
	DB	024H
	DB	010H
	DB	01H
	DB	01cH
	DB	025H
	DB	08H
	DB	01eH
	DB	02bH
	DB	0aH
	DB	015H
	DB	02H
	DB	033H
	DB	016H
	DB	017H
	DB	07H
	DB	03H
	DB	023H
	DB	013H
	DB	035H
	DB	028H
	DB	04H
	DB	037H
	DB	01bH
	DB	029H
	DB	01fH
	DB	0cH
	DB	014H
	DB	019H
	DB	02fH
	DB	0bH
	DB	027H
	DB	021H
	DB	022H
	DB	02dH
	DB	06H
	DB	05H
	DB	0dH
	DB	026H
	DB	020H
	DB	01aH
	DB	030H
	DB	016H
	DB	02H
	DB	023H
	DB	032H
	DB	025H
	DB	0aH
	DB	02aH
	DB	01dH
	DB	09H
	DB	033H
	DB	015H
	DB	01eH
	DB	01H
	DB	017H
	DB	024H
	DB	03H
	DB	0eH
	DB	018H
	DB	02cH
	DB	0fH
	DB	010H
	DB	00H
	DB	031H
	DB	01cH
final_perm DD	028H
	DD	08H
	DD	030H
	DD	010H
	DD	038H
	DD	018H
	DD	040H
	DD	020H
	DD	027H
	DD	07H
	DD	02fH
	DD	0fH
	DD	037H
	DD	017H
	DD	03fH
	DD	01fH
	DD	026H
	DD	06H
	DD	02eH
	DD	0eH
	DD	036H
	DD	016H
	DD	03eH
	DD	01eH
	DD	025H
	DD	05H
	DD	02dH
	DD	0dH
	DD	035H
	DD	015H
	DD	03dH
	DD	01dH
	DD	024H
	DD	04H
	DD	02cH
	DD	0cH
	DD	034H
	DD	014H
	DD	03cH
	DD	01cH
	DD	023H
	DD	03H
	DD	02bH
	DD	0bH
	DD	033H
	DD	013H
	DD	03bH
	DD	01bH
	DD	022H
	DD	02H
	DD	02aH
	DD	0aH
	DD	032H
	DD	012H
	DD	03aH
	DD	01aH
	DD	021H
	DD	01H
	DD	029H
	DD	09H
	DD	031H
	DD	011H
	DD	039H
	DD	019H
PUBLIC	?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z ; Generate10CharTripcodes
PUBLIC	?_ufc_doit@@YAPEAIIIIII@Z			; _ufc_doit
PUBLIC	?crypt@@YAPEADPEAD0@Z				; crypt
PUBLIC	?_ufc_dofinalperm@@YAPEAIIIII@Z			; _ufc_dofinalperm
PUBLIC	?init_des@@YAXXZ				; init_des
PUBLIC	??0spinlock@@QEAA@XZ				; spinlock::spinlock
PUBLIC	?VerifyDESTripcode@@YAHPEAE0@Z			; VerifyDESTripcode
PUBLIC	?GenerateDESTripcode@@YAXPEAE0@Z		; GenerateDESTripcode
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

eperm32tab DD	0800H DUP (?)
_BSS	ENDS
;	COMDAT ?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA
_BSS	SEGMENT
?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA DB 0eH DUP (?) ; `output_conversion'::`2'::outbuf
	ALIGN	8

errno_ecat DQ	01H DUP (?)
ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?ary@?1??_ufc_dofinalperm@@YAPEAIIIII@Z@4PAIA
_BSS	SEGMENT
?ary@?1??_ufc_dofinalperm@@YAPEAIIIII@Z@4PAIA DD 02H DUP (?) ; `_ufc_dofinalperm'::`2'::ary
	ALIGN	4

efp	DD	0800H DUP (?)
native_ecat DQ	01H DUP (?)
do_pc1	DD	0800H DUP (?)
piecewise_construct DB 01H DUP (?)
	ALIGN	4

descrypt_spinlock DD 01H DUP (?)
do_pc2	DD	0400H DUP (?)
e_inverse DD	040H DUP (?)
posix_category DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z DD imagerel $LN177
	DD	imagerel $LN177+1601
	DD	imagerel $unwind$?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DES_Crypt25@@YAXPEAUDES_Context@@@Z DD imagerel ?DES_Crypt25@@YAXPEAUDES_Context@@@Z
	DD	imagerel ?DES_Crypt25@@YAXPEAUDES_Context@@@Z+185
	DD	imagerel $unwind$?DES_Crypt25@@YAXPEAUDES_Context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DES_SetSalt@@YAXPEAUDES_Context@@H@Z DD imagerel ?DES_SetSalt@@YAXPEAUDES_Context@@H@Z
	DD	imagerel ?DES_SetSalt@@YAXPEAUDES_Context@@H@Z+125
	DD	imagerel $unwind$?DES_SetSalt@@YAXPEAUDES_Context@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z DD imagerel ?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z
	DD	imagerel ?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z+2722
	DD	imagerel $unwind$?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z DD imagerel ?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z
	DD	imagerel ?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z+2695
	DD	imagerel $unwind$?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ufc_doit@@YAPEAIIIIII@Z DD imagerel $LN18
	DD	imagerel $LN18+381
	DD	imagerel $unwind$?_ufc_doit@@YAPEAIIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?crypt@@YAPEADPEAD0@Z DD imagerel $LN13
	DD	imagerel $LN13+124
	DD	imagerel $unwind$?crypt@@YAPEADPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ufc_dofinalperm@@YAPEAIIIII@Z DD imagerel $LN4
	DD	imagerel $LN4+556
	DD	imagerel $unwind$?_ufc_dofinalperm@@YAPEAIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ufc_mk_keytab@@YAXPEAD@Z DD imagerel ?ufc_mk_keytab@@YAXPEAD@Z
	DD	imagerel ?ufc_mk_keytab@@YAXPEAD@Z+350
	DD	imagerel $unwind$?ufc_mk_keytab@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setup_salt@@YAXPEAD@Z DD imagerel ?setup_salt@@YAXPEAD@Z
	DD	imagerel ?setup_salt@@YAXPEAD@Z+60
	DD	imagerel $unwind$?setup_salt@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setup_salt@@YAXPEAD@Z DD imagerel ?setup_salt@@YAXPEAD@Z+60
	DD	imagerel ?setup_salt@@YAXPEAD@Z+560
	DD	imagerel $chain$0$?setup_salt@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setup_salt@@YAXPEAD@Z DD imagerel ?setup_salt@@YAXPEAD@Z+560
	DD	imagerel ?setup_salt@@YAXPEAD@Z+748
	DD	imagerel $chain$1$?setup_salt@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init_des@@YAXXZ DD imagerel $LN112
	DD	imagerel $LN112+1365
	DD	imagerel $unwind$?init_des@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clearmem@@YAXPEADH@Z DD imagerel ?clearmem@@YAXPEADH@Z
	DD	imagerel ?clearmem@@YAXPEADH@Z+20
	DD	imagerel $unwind$?clearmem@@YAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Enative_ecat@system@boost@@YAXXZ DD imagerel ??__Enative_ecat@system@boost@@YAXXZ
	DD	imagerel ??__Enative_ecat@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Enative_ecat@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eerrno_ecat@system@boost@@YAXXZ DD imagerel ??__Eerrno_ecat@system@boost@@YAXXZ
	DD	imagerel ??__Eerrno_ecat@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Eerrno_ecat@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eposix_category@system@boost@@YAXXZ DD imagerel ??__Eposix_category@system@boost@@YAXXZ
	DD	imagerel ??__Eposix_category@system@boost@@YAXXZ+21
	DD	imagerel $unwind$??__Eposix_category@system@boost@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VerifyDESTripcode@@YAHPEAE0@Z DD imagerel $LN84
	DD	imagerel $LN84+389
	DD	imagerel $unwind$?VerifyDESTripcode@@YAHPEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateDESTripcode@@YAXPEAE0@Z DD imagerel $LN76
	DD	imagerel $LN76+289
	DD	imagerel $unwind$?GenerateDESTripcode@@YAXPEAE0@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateDESTripcode@@YAXPEAE0@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VerifyDESTripcode@@YAHPEAE0@Z DD 041919H
	DD	0e340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eposix_category@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eerrno_ecat@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Enative_ecat@system@boost@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clearmem@@YAXPEADH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init_des@@YAXXZ DD 091001H
	DD	0b3410H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setup_salt@@YAXPEAD@Z DD 021H
	DD	imagerel ?setup_salt@@YAXPEAD@Z
	DD	imagerel ?setup_salt@@YAXPEAD@Z+60
	DD	imagerel $unwind$?setup_salt@@YAXPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setup_salt@@YAXPEAD@Z DD 020521H
	DD	067405H
	DD	imagerel ?setup_salt@@YAXPEAD@Z
	DD	imagerel ?setup_salt@@YAXPEAD@Z+60
	DD	imagerel $unwind$?setup_salt@@YAXPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setup_salt@@YAXPEAD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ufc_mk_keytab@@YAXPEAD@Z DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ufc_dofinalperm@@YAPEAIIIII@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?crypt@@YAPEADPEAD0@Z DD 041919H
	DD	0e340aH
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ufc_doit@@YAPEAIIIIII@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z DD 091f01H
	DD	0f01b221fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z DD 091f01H
	DD	0f01b221fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DES_SetSalt@@YAXPEAUDES_Context@@H@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DES_Crypt25@@YAXPEAUDES_Context@@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z DD 0d3819H
	DD	01e17427H
	DD	01e06427H
	DD	01df3427H
	DD	01d80127H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0eb0H
	ORG $-120
posix_category$initializer$ DQ FLAT:??__Eposix_category@system@boost@@YAXXZ
errno_ecat$initializer$ DQ FLAT:??__Eerrno_ecat@system@boost@@YAXXZ
native_ecat$initializer$ DQ FLAT:??__Enative_ecat@system@boost@@YAXXZ
descrypt_spinlock$initializer$ DQ FLAT:??__Edescrypt_spinlock@@YAXXZ
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?GenerateDESTripcode@@YAXPEAE0@Z
_TEXT	SEGMENT
actualKey$ = 48
ktab$1 = 64
__$ArrayPad$ = 80
tripcode$ = 112
key$ = 120
?GenerateDESTripcode@@YAXPEAE0@Z PROC			; GenerateDESTripcode, COMDAT

; 87   : {

$LN76:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx
	npad	1
$LL14@GenerateDE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR descrypt_spinlock, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN13@GenerateDE
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN28@GenerateDE

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL14@GenerateDE
$LN28@GenerateDE:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL14@GenerateDE
$LN13@GenerateDE:
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	mov	r9d, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	mov	rax, QWORD PTR [rbx]
	xor	edx, edx
	xor	r8d, r8d
	mov	BYTE PTR actualKey$[rsp+8], dl
	mov	QWORD PTR actualKey$[rsp], rax
	test	r9d, r9d
	jle	SHORT $LN73@GenerateDE
	xor	eax, eax
	lea	r10d, QWORD PTR [rdx+1]
$LL6@GenerateDE:

; 96   :             if (fillRestWithZero) {

	test	edx, edx
	je	SHORT $LN3@GenerateDE

; 97   :                     actualKey[i] = 0x00;

	cmp	rax, 13
	jae	$LN75@GenerateDE
	mov	BYTE PTR actualKey$[rsp+rax], 0
	jmp	SHORT $LN5@GenerateDE
$LN3@GenerateDE:

; 98   :             } else if (actualKey[i] == 0x80) {

	movsx	ecx, BYTE PTR actualKey$[rsp+rax]
	cmp	ecx, 128				; 00000080H
	cmove	edx, r10d
$LN5@GenerateDE:

; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	r8d
	inc	rax
	cmp	r8d, r9d
	jl	SHORT $LL6@GenerateDE
$LN73@GenerateDE:

; 420  :   }
; 421  : 
; 422  : static int32_t initialized = 0;
; 423  : 
; 424  : /* lookup a 6 bit value in sbox */
; 425  : 
; 426  : #define s_lookup(i,s) sbox[(i)][(((s)>>4) & 0x2)|((s) & 0x1)][((s)>>1) & 0xf];
; 427  : 
; 428  : /*
; 429  :  * Initialize unit - may be invoked directly
; 430  :  * by fcrypt users.
; 431  :  */
; 432  : 
; 433  : void init_des()
; 434  :   { int32_t comes_from_bit;
; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {
; 445  :       comes_from_bit  = pc1[bit] - 1;
; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];
; 447  :       mask2 = longmask[bit % 28 + 4];
; 448  :       for(j = 0; j < 128; j++) {
; 449  :         if(j & mask1) 
; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;
; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {
; 460  :       comes_from_bit  = pc2[bit] - 1;
; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];
; 462  :       mask2 = BITMASK(bit % 24);
; 463  :       for(j = 0; j < 128; j++) {
; 464  :         if(j & mask1)
; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;
; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {
; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;
; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {
; 490  :         if(j & mask1)
; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);
; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {
; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {
; 512  :         s1 = s_lookup(2 * sg, j1);
; 513  :         for(j2 = 0; j2 < 64; j2++) {
; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);
; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);
; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;
; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];
; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];
; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];
; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];
; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];
; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {
; 554  :       e_inverse[esel[bit] - 1     ] = bit;
; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;
; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {
; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */
; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {
; 589  :         if(word_value & mask1)
; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;
; 591  :       }
; 592  :     }
; 593  :     initialized++;
; 594  :   }
; 595  : 
; 596  : /* 
; 597  :  * Process the elements of the sb table permuting the
; 598  :  * bits swapped in the expansion by the current salt.
; 599  :  */
; 600  : 
; 601  : #ifdef _UFC_32_
; 602  : STATIC void shuffle_sb(long32 *k, ufc_long saltbits)
; 603  :   { ufc_long j;
; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {
; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;
; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;
; 609  :     }
; 610  :   }
; 611  : #endif
; 612  : 
; 613  : #ifdef _UFC_64_
; 614  : STATIC void shuffle_sb(k, saltbits)
; 615  :   long64 *k;
; 616  :   ufc_long saltbits;
; 617  :   { ufc_long j;
; 618  :     long64 x;
; 619  :     for(j=4096; j--;) {
; 620  :       x = ((*k >> 32) ^ *k) & (long64)saltbits;
; 621  :       *k++ ^= (x << 32) | x;
; 622  :     }
; 623  :   }
; 624  : #endif
; 625  : 
; 626  : /* 
; 627  :  * Setup the unit for a new salt
; 628  :  * Hopefully we'll not see a new salt in each crypt call.
; 629  :  */
; 630  : 
; 631  : static unsigned char current_salt[3] = "&&"; /* invalid value */
; 632  : static ufc_long current_saltbits = 0;
; 633  : static int32_t direction = 0;
; 634  : 
; 635  : STATIC void setup_salt(char *s)
; 636  :   { ufc_long i, j, saltbits;
; 637  : 
; 638  :     if(!initialized)
; 639  :       init_des();
; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])
; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];
; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;
; 651  :     for(i = 0; i < 2; i++) {
; 652  :       int32_t c=ascii_to_bin(s[i]);
; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)
; 657  :           saltbits |= BITMASK(6 * i + j);
; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 
; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);
; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);
; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);
; 670  : 
; 671  :     current_saltbits = saltbits;
; 672  :   }
; 673  : 
; 674  : STATIC void ufc_mk_keytab(char *key)
; 675  :   { ufc_long v1, v2, *k1;
; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];
; 685  :     for(i = 8; i--;) {
; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;
; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;
; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {
; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));
; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;
; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;
; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;
; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;
; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));
; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;
; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;
; 714  :     }
; 715  : 
; 716  :     direction = 0;
; 717  :   }
; 718  : 
; 719  : /* 
; 720  :  * Undo an extra E selection and do final permutations
; 721  :  */
; 722  : 
; 723  : ufc_long *_ufc_dofinalperm(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2)
; 724  :   { ufc_long v1, v2, x;
; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;
; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;
; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];
; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];
; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];
; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];
; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];
; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];
; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];
; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];
; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];
; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];
; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];
; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];
; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];
; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];
; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];
; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];
; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;
; 753  :     return ary;
; 754  :   }
; 755  : 
; 756  : /* 
; 757  :  * crypt only: convert from 64 bit to 11 bit ASCII 
; 758  :  * prefixing with the salt
; 759  :  */
; 760  : 
; 761  : STATIC char *output_conversion(ufc_long v1, ufc_long v2, char *salt)
; 762  :   { static char outbuf[14];
; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];
; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];
; 767  : 
; 768  :     for(i = 0; i < 5; i++)
; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);
; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;
; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);
; 773  : 
; 774  :     for(i = 5; i < 10; i++)
; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);
; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);
; 778  :     outbuf[13] = 0;
; 779  : 
; 780  :     return outbuf;
; 781  :   }
; 782  : 
; 783  : ufc_long *_ufc_doit(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2, ufc_long itr);
; 784  : 
; 785  : /* 
; 786  :  * UNIX crypt function
; 787  :  */
; 788  :    
; 789  : char *crypt(char *key, char *salt)
; 790  :   { ufc_long *s;
; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	lea	rcx, QWORD PTR actualKey$[rsp+1]
	call	?setup_salt@@YAXPEAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	lea	rdx, QWORD PTR actualKey$[rsp]
	lea	rcx, QWORD PTR ktab$1[rsp]
	mov	r8d, 8

; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	mov	QWORD PTR ktab$1[rsp], 0
	mov	BYTE PTR ktab$1[rsp+8], 0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	rcx, QWORD PTR ktab$1[rsp]
	call	?ufc_mk_keytab@@YAXPEAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPEAIIIIII@Z		; _ufc_doit

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	lea	r8, QWORD PTR actualKey$[rsp+1]
	mov	edx, DWORD PTR [rax+4]
	mov	ecx, DWORD PTR [rax]
	call	?output_conversion@@YAPEADIIPEAD@Z	; output_conversion

; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);

	mov	r8d, 10
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rax+3]
	call	strncpy

; 103  : 	tripcode[10] = '\0';

	mov	BYTE PTR [rdi+10], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR descrypt_spinlock, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 106  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN75@GenerateDE:

; 97   :                     actualKey[i] = 0x00;

	call	__report_rangecheckfailure
	int	3
$LN74@GenerateDE:
?GenerateDESTripcode@@YAXPEAE0@Z ENDP			; GenerateDESTripcode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?VerifyDESTripcode@@YAHPEAE0@Z
_TEXT	SEGMENT
actualKey$ = 48
ktab$1 = 64
__$ArrayPad$ = 80
tripcode$ = 112
key$ = 120
?VerifyDESTripcode@@YAHPEAE0@Z PROC			; VerifyDESTripcode, COMDAT

; 52   : {

$LN84:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx
	npad	1
$LL15@VerifyDEST:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 2385 : 			return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0));

	lock_bts DWORD PTR descrypt_spinlock, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 149  : 		while (flag.test_and_set(std::memory_order_acquire))

	jae	SHORT $LN14@VerifyDEST
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\thread

; 123  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	call	?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ ; Concurrency::details::_CurrentScheduler::_Id
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN29@VerifyDEST

; 124  : 		{	// yield, then quit
; 125  : 		::Concurrency::details::_Context::_Yield();

	call	?_Yield@_Context@details@Concurrency@@SAXXZ ; Concurrency::details::_Context::_Yield

; 126  : 		return;

	jmp	SHORT $LL15@VerifyDEST
$LN29@VerifyDEST:

; 127  : 		}
; 128  : 	_Thrd_yield();

	call	_Thrd_yield
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 150  : 			std::this_thread::yield();

	jmp	SHORT $LL15@VerifyDEST
$LN14@VerifyDEST:
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 55   :         if (strlen((char *)tripcode) != lenTripcode || strlen((char *)key) != lenTripcodeKey)

	or	rcx, -1
	mov	rdx, rcx
	npad	6
$LL81@VerifyDEST:
	inc	rdx
	cmp	BYTE PTR [rdi+rdx], 0
	jne	SHORT $LL81@VerifyDEST
	movsxd	rax, DWORD PTR ?lenTripcode@@3HA	; lenTripcode
	cmp	rdx, rax
	jne	$LN7@VerifyDEST
	npad	7
$LL80@VerifyDEST:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL80@VerifyDEST
	movsxd	r9, DWORD PTR ?lenTripcodeKey@@3HA	; lenTripcodeKey
	cmp	rcx, r9
	jne	$LN7@VerifyDEST

; 57   :         
; 58   :         char actualKey[MAX_LEN_TRIPCODE_KEY + 1];
; 59   :         BOOL fillRestWithZero = FALSE;
; 60   :         
; 61   :         strcpy(actualKey, (char *)key);

	lea	rcx, QWORD PTR actualKey$[rsp]
	xor	edx, edx
	sub	rcx, rbx
	npad	13
$LL11@VerifyDEST:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rcx+rbx-1], al
	test	al, al
	jne	SHORT $LL11@VerifyDEST

; 62   :         for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	xor	r8d, r8d
	test	r9d, r9d
	jle	SHORT $LN77@VerifyDEST
	xor	ecx, ecx
	lea	r10d, QWORD PTR [r8+1]
	npad	3
$LL6@VerifyDEST:

; 63   :                 if (fillRestWithZero) {

	test	edx, edx
	je	SHORT $LN3@VerifyDEST

; 64   :                         actualKey[i] = 0x00;

	cmp	rcx, 13
	jae	$LN83@VerifyDEST
	mov	BYTE PTR actualKey$[rsp+rcx], 0
	jmp	SHORT $LN5@VerifyDEST
$LN3@VerifyDEST:

; 65   :                 } else if (actualKey[i] == 0x80) {

	movsx	eax, BYTE PTR actualKey$[rsp+rcx]
	cmp	eax, 128				; 00000080H
	cmove	edx, r10d
$LN5@VerifyDEST:

; 62   :         for (int32_t i = 0; i < lenTripcodeKey; ++i) {

	inc	r8d
	inc	rcx
	cmp	r8d, r9d
	jl	SHORT $LL6@VerifyDEST
$LN77@VerifyDEST:

; 420  :   }
; 421  : 
; 422  : static int32_t initialized = 0;
; 423  : 
; 424  : /* lookup a 6 bit value in sbox */
; 425  : 
; 426  : #define s_lookup(i,s) sbox[(i)][(((s)>>4) & 0x2)|((s) & 0x1)][((s)>>1) & 0xf];
; 427  : 
; 428  : /*
; 429  :  * Initialize unit - may be invoked directly
; 430  :  * by fcrypt users.
; 431  :  */
; 432  : 
; 433  : void init_des()
; 434  :   { int32_t comes_from_bit;
; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {
; 445  :       comes_from_bit  = pc1[bit] - 1;
; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];
; 447  :       mask2 = longmask[bit % 28 + 4];
; 448  :       for(j = 0; j < 128; j++) {
; 449  :         if(j & mask1) 
; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;
; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {
; 460  :       comes_from_bit  = pc2[bit] - 1;
; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];
; 462  :       mask2 = BITMASK(bit % 24);
; 463  :       for(j = 0; j < 128; j++) {
; 464  :         if(j & mask1)
; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;
; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {
; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;
; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {
; 490  :         if(j & mask1)
; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);
; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {
; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {
; 512  :         s1 = s_lookup(2 * sg, j1);
; 513  :         for(j2 = 0; j2 < 64; j2++) {
; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);
; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);
; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;
; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];
; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];
; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];
; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];
; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];
; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {
; 554  :       e_inverse[esel[bit] - 1     ] = bit;
; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;
; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {
; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */
; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {
; 589  :         if(word_value & mask1)
; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;
; 591  :       }
; 592  :     }
; 593  :     initialized++;
; 594  :   }
; 595  : 
; 596  : /* 
; 597  :  * Process the elements of the sb table permuting the
; 598  :  * bits swapped in the expansion by the current salt.
; 599  :  */
; 600  : 
; 601  : #ifdef _UFC_32_
; 602  : STATIC void shuffle_sb(long32 *k, ufc_long saltbits)
; 603  :   { ufc_long j;
; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {
; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;
; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;
; 609  :     }
; 610  :   }
; 611  : #endif
; 612  : 
; 613  : #ifdef _UFC_64_
; 614  : STATIC void shuffle_sb(k, saltbits)
; 615  :   long64 *k;
; 616  :   ufc_long saltbits;
; 617  :   { ufc_long j;
; 618  :     long64 x;
; 619  :     for(j=4096; j--;) {
; 620  :       x = ((*k >> 32) ^ *k) & (long64)saltbits;
; 621  :       *k++ ^= (x << 32) | x;
; 622  :     }
; 623  :   }
; 624  : #endif
; 625  : 
; 626  : /* 
; 627  :  * Setup the unit for a new salt
; 628  :  * Hopefully we'll not see a new salt in each crypt call.
; 629  :  */
; 630  : 
; 631  : static unsigned char current_salt[3] = "&&"; /* invalid value */
; 632  : static ufc_long current_saltbits = 0;
; 633  : static int32_t direction = 0;
; 634  : 
; 635  : STATIC void setup_salt(char *s)
; 636  :   { ufc_long i, j, saltbits;
; 637  : 
; 638  :     if(!initialized)
; 639  :       init_des();
; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])
; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];
; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;
; 651  :     for(i = 0; i < 2; i++) {
; 652  :       int32_t c=ascii_to_bin(s[i]);
; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)
; 657  :           saltbits |= BITMASK(6 * i + j);
; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 
; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);
; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);
; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);
; 670  : 
; 671  :     current_saltbits = saltbits;
; 672  :   }
; 673  : 
; 674  : STATIC void ufc_mk_keytab(char *key)
; 675  :   { ufc_long v1, v2, *k1;
; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];
; 685  :     for(i = 8; i--;) {
; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;
; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;
; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {
; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));
; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;
; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;
; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;
; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;
; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));
; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;
; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;
; 714  :     }
; 715  : 
; 716  :     direction = 0;
; 717  :   }
; 718  : 
; 719  : /* 
; 720  :  * Undo an extra E selection and do final permutations
; 721  :  */
; 722  : 
; 723  : ufc_long *_ufc_dofinalperm(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2)
; 724  :   { ufc_long v1, v2, x;
; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;
; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;
; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];
; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];
; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];
; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];
; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];
; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];
; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];
; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];
; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];
; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];
; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];
; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];
; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];
; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];
; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];
; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];
; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;
; 753  :     return ary;
; 754  :   }
; 755  : 
; 756  : /* 
; 757  :  * crypt only: convert from 64 bit to 11 bit ASCII 
; 758  :  * prefixing with the salt
; 759  :  */
; 760  : 
; 761  : STATIC char *output_conversion(ufc_long v1, ufc_long v2, char *salt)
; 762  :   { static char outbuf[14];
; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];
; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];
; 767  : 
; 768  :     for(i = 0; i < 5; i++)
; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);
; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;
; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);
; 773  : 
; 774  :     for(i = 5; i < 10; i++)
; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);
; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);
; 778  :     outbuf[13] = 0;
; 779  : 
; 780  :     return outbuf;
; 781  :   }
; 782  : 
; 783  : ufc_long *_ufc_doit(ufc_long l1, ufc_long l2, ufc_long r1, ufc_long r2, ufc_long itr);
; 784  : 
; 785  : /* 
; 786  :  * UNIX crypt function
; 787  :  */
; 788  :    
; 789  : char *crypt(char *key, char *salt)
; 790  :   { ufc_long *s;
; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	lea	rcx, QWORD PTR actualKey$[rsp+1]
	call	?setup_salt@@YAXPEAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	lea	rdx, QWORD PTR actualKey$[rsp]
	lea	rcx, QWORD PTR ktab$1[rsp]
	mov	r8d, 8

; 85   : 
; 86   : void GenerateDESTripcode(unsigned char *tripcode, unsigned char *key)
; 87   : {
; 88   :     descrypt_spinlock.lock();
; 89   : 
; 90   :     char actualKey[MAX_LEN_TRIPCODE_KEY + 1];
; 91   :     BOOL fillRestWithZero = FALSE;
; 92   :         
; 93   :     memcpy(actualKey, (char *)key, 8);
; 94   : 	actualKey[8] = '\0';
; 95   : 	for (int32_t i = 0; i < lenTripcodeKey; ++i) {
; 96   :             if (fillRestWithZero) {
; 97   :                     actualKey[i] = 0x00;
; 98   :             } else if (actualKey[i] == 0x80) {
; 99   :                     fillRestWithZero = TRUE;
; 100  :             }
; 101  :     }
; 102  :     strncpy((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3, 10);
; 103  : 	tripcode[10] = '\0';
; 104  : 
; 105  :     descrypt_spinlock.unlock();
; 106  : }
; 107  : 
; 108  : 
; 109  : 
; 110  : /////////////////////////////////////////////////////////////////////////
; 111  : // The following are modified versions of ufc.c and ufc_util.c in:     //
; 112  : // http://packetstorm.foofus.com/crypt/LIBS/ufc-crypt/ufc-crypt.tar.gz //
; 113  : /////////////////////////////////////////////////////////////////////////
; 114  : 
; 115  : #define _UFC_32_ TRUE
; 116  : 
; 117  : typedef uint32_t ufc_long;
; 118  : typedef uint32_t long32;
; 119  : 
; 120  : /*
; 121  :  * UFC-crypt: ultra fast crypt(3) implementation
; 122  :  *
; 123  :  * Copyright (C) 1991, 1992, Free Software Foundation, Inc.
; 124  :  *
; 125  :  * This library is free software; you can redistribute it and/or
; 126  :  * modify it under the terms of the GNU Library General Public
; 127  :  * License as published by the Free Software Foundation; either
; 128  :  * version 2 of the License, or (at your option) any later version.
; 129  :  *
; 130  :  * This library is distributed in the hope that it will be useful,
; 131  :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
; 132  :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; 133  :  * Library General Public License for more details.
; 134  :  *
; 135  :  * You should have received a copy of the GNU Library General Public
; 136  :  * License along with this library; if not, write to the Free
; 137  :  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
; 138  :  *
; 139  :  * @(#)crypt_util.c        2.31 02/08/92
; 140  :  *
; 141  :  * Support routines
; 142  :  *
; 143  :  */
; 144  : 
; 145  : #ifdef DEBUG
; 146  : #include <stdio.h>
; 147  : #endif
; 148  : 
; 149  : #ifndef STATIC
; 150  : #define STATIC static
; 151  : #endif
; 152  : 
; 153  : // #include "patchlevel.h"
; 154  : // #include "ufc-crypt.h"
; 155  : 
; 156  : // static char patchlevel_str[] = PATCHLEVEL;
; 157  : 
; 158  : /* 
; 159  :  * Permutation done once on the 56 bit 
; 160  :  *  key derived from the original 8 byte ASCII key.
; 161  :  */
; 162  : static int32_t pc1[56] = { 
; 163  :   57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
; 164  :   10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
; 165  :   63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
; 166  :   14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
; 167  : };
; 168  : 
; 169  : /*
; 170  :  * How much to rotate each 28 bit half of the pc1 permutated
; 171  :  *  56 bit key before using pc2 to give the i' key
; 172  :  */
; 173  : static int32_t rots[16] = { 
; 174  :   1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 
; 175  : };
; 176  : 
; 177  : /* 
; 178  :  * Permutation giving the key 
; 179  :  * of the i' DES round 
; 180  :  */
; 181  : static int32_t pc2[48] = { 
; 182  :   14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
; 183  :   23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
; 184  :   41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
; 185  :   44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
; 186  : };
; 187  : 
; 188  : /*
; 189  :  * The E expansion table which selects
; 190  :  * bits from the 32 bit intermediate result.
; 191  :  */
; 192  : static int32_t esel[48] = { 
; 193  :   32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
; 194  :    8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
; 195  :   16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
; 196  :   24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
; 197  : };
; 198  : static int32_t e_inverse[64];
; 199  : 
; 200  : /* 
; 201  :  * Permutation done on the 
; 202  :  * result of sbox lookups 
; 203  :  */
; 204  : static int32_t perm32[32] = {
; 205  :   16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
; 206  :   2,   8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
; 207  : };
; 208  : 
; 209  : /* 
; 210  :  * The sboxes
; 211  :  */
; 212  : static int32_t sbox[8][4][16]= {
; 213  :         { { 14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 },
; 214  :           {  0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8 },
; 215  :           {  4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0 },
; 216  :           { 15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13 }
; 217  :         },
; 218  : 
; 219  :         { { 15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 },
; 220  :           {  3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5 },
; 221  :           {  0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15 },
; 222  :           { 13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 }
; 223  :         },
; 224  : 
; 225  :         { { 10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 },
; 226  :           { 13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1 },
; 227  :           { 13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7 },
; 228  :           {  1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 }
; 229  :         },
; 230  : 
; 231  :         { {  7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 },
; 232  :           { 13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9 },
; 233  :           { 10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4 },
; 234  :           {  3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14 }
; 235  :         },
; 236  : 
; 237  :         { {  2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 },
; 238  :           { 14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6 },
; 239  :           {  4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14 },
; 240  :           { 11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3 }
; 241  :         },
; 242  : 
; 243  :         { { 12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 },
; 244  :           { 10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8 },
; 245  :           {  9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6 },
; 246  :           {  4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13 }
; 247  :         },
; 248  : 
; 249  :         { {  4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 },
; 250  :           { 13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6 },
; 251  :           {  1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2 },
; 252  :           {  6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12 }
; 253  :         },
; 254  : 
; 255  :         { { 13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 },
; 256  :           {  1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2 },
; 257  :           {  7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8 },
; 258  :           {  2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11 }
; 259  :         }
; 260  : };
; 261  : 
; 262  : /* 
; 263  :  * This is the initial 
; 264  :  * permutation matrix
; 265  :  */
; 266  : static int32_t initial_perm[64] = { 
; 267  :   58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12, 4,
; 268  :   62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16, 8,
; 269  :   57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
; 270  :   61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15, 7
; 271  : };
; 272  : 
; 273  : /* 
; 274  :  * This is the final 
; 275  :  * permutation matrix
; 276  :  */
; 277  : static int32_t final_perm[64] = {
; 278  :   40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,
; 279  :   38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,
; 280  :   36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,
; 281  :   34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25
; 282  : };
; 283  : 
; 284  : /* 
; 285  :  * The 16 DES keys in BITMASK format 
; 286  :  */
; 287  : #ifdef _UFC_32_
; 288  : long32 _ufc_keytab[16][2];
; 289  : #endif
; 290  : #ifdef _UFC_64_
; 291  : long64 _ufc_keytab[16];
; 292  : #endif
; 293  : 
; 294  : #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
; 295  : #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
; 296  : 
; 297  : /* Macro to set a bit (0..23) */
; 298  : #define BITMASK(i) ( (1<<(11-(i)%12+3)) << ((i)<12?16:0) )
; 299  : 
; 300  : /*
; 301  :  * sb arrays:
; 302  :  *
; 303  :  * Workhorses of the inner loop of the DES implementation.
; 304  :  * They do sbox lookup, shifting of this  value, 32 bit
; 305  :  * permutation and E permutation for the next round.
; 306  :  *
; 307  :  * Kept in 'BITMASK' format.
; 308  :  */
; 309  : 
; 310  : #ifdef _UFC_32_
; 311  : long32 _ufc_sb0[8192], _ufc_sb1[8192], _ufc_sb2[8192], _ufc_sb3[8192];
; 312  : static long32 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 313  : #endif
; 314  : 
; 315  : #ifdef _UFC_64_
; 316  : long64 _ufc_sb0[4096], _ufc_sb1[4096], _ufc_sb2[4096], _ufc_sb3[4096];
; 317  : static long64 *sb[4] = {_ufc_sb0, _ufc_sb1, _ufc_sb2, _ufc_sb3}; 
; 318  : #endif
; 319  : 
; 320  : /* 
; 321  :  * eperm32tab: do 32 bit permutation and E selection
; 322  :  *
; 323  :  * The first index is the byte number in the 32 bit value to be permuted
; 324  :  *  -  second  -   is the value of this byte
; 325  :  *  -  third   -   selects the two 32 bit values
; 326  :  *
; 327  :  * The table is used and generated internally in init_des to speed it up
; 328  :  */
; 329  : static ufc_long eperm32tab[4][256][2];
; 330  : 
; 331  : /* 
; 332  :  * do_pc1: permform pc1 permutation in the key schedule generation.
; 333  :  *
; 334  :  * The first   index is the byte number in the 8 byte ASCII key
; 335  :  *  -  second    -      -    the two 28 bits halfs of the result
; 336  :  *  -  third     -   selects the 7 bits actually used of each byte
; 337  :  *
; 338  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 339  :  * bits zero.
; 340  :  */
; 341  : static ufc_long do_pc1[8][2][128];
; 342  : 
; 343  : /*
; 344  :  * do_pc2: permform pc2 permutation in the key schedule generation.
; 345  :  *
; 346  :  * The first   index is the septet number in the two 28 bit intermediate values
; 347  :  *  -  second    -    -  -  septet values
; 348  :  *
; 349  :  * Knowledge of the structure of the pc2 permutation is used.
; 350  :  *
; 351  :  * The result is kept with 28 bit per 32 bit with the 4 most significant
; 352  :  * bits zero.
; 353  :  */
; 354  : static ufc_long do_pc2[8][128];
; 355  : 
; 356  : /*
; 357  :  * efp: undo an extra e selection and do final
; 358  :  *      permutation giving the DES result.
; 359  :  * 
; 360  :  *      Invoked 6 bit a time on two 48 bit values
; 361  :  *      giving two 32 bit longs.
; 362  :  */
; 363  : static ufc_long efp[16][64][2];
; 364  : 
; 365  : static unsigned char bytemask[8]  = {
; 366  :   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
; 367  : };
; 368  : 
; 369  : static ufc_long longmask[32] = {
; 370  :   0x80000000, 0x40000000, 0x20000000, 0x10000000,
; 371  :   0x08000000, 0x04000000, 0x02000000, 0x01000000,
; 372  :   0x00800000, 0x00400000, 0x00200000, 0x00100000,
; 373  :   0x00080000, 0x00040000, 0x00020000, 0x00010000,
; 374  :   0x00008000, 0x00004000, 0x00002000, 0x00001000,
; 375  :   0x00000800, 0x00000400, 0x00000200, 0x00000100,
; 376  :   0x00000080, 0x00000040, 0x00000020, 0x00000010,
; 377  :   0x00000008, 0x00000004, 0x00000002, 0x00000001
; 378  : };
; 379  : 
; 380  : #ifdef DEBUG
; 381  : 
; 382  : pr_bits(a, n)
; 383  :   ufc_long *a;
; 384  :   int32_t n;
; 385  :   { ufc_long i, j, t, tmp;
; 386  :     n /= 8;
; 387  :     for(i = 0; i < n; i++) {
; 388  :       tmp=0;
; 389  :       for(j = 0; j < 8; j++) {
; 390  :         t=8*i+j;
; 391  :         tmp|=(a[t/24] & BITMASK(t % 24))?bytemask[j]:0;
; 392  :       }
; 393  :       (void)printf("%02x ",tmp);
; 394  :     }
; 395  :     printf(" ");
; 396  :   }
; 397  : 
; 398  : static set_bits(v, b)
; 399  :   ufc_long v;
; 400  :   ufc_long *b;
; 401  :   { ufc_long i;
; 402  :     *b = 0;
; 403  :     for(i = 0; i < 24; i++) {
; 404  :       if(v & longmask[8 + i])
; 405  :         *b |= BITMASK(i);
; 406  :     }
; 407  :   }
; 408  : 
; 409  : #endif
; 410  : 
; 411  : /*
; 412  :  * Silly rewrite of 'bzero'. I do so
; 413  :  * because some machines don't have
; 414  :  * bzero and some don't have memset.
; 415  :  */
; 416  : 
; 417  : STATIC void clearmem(char *start, int32_t cnt)
; 418  :   { while(cnt--)
; 419  :       *start++ = '\0';

	mov	QWORD PTR ktab$1[rsp], 0
	mov	BYTE PTR ktab$1[rsp+8], 0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	rcx, QWORD PTR ktab$1[rsp]
	call	?ufc_mk_keytab@@YAXPEAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPEAIIIIII@Z		; _ufc_doit

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	lea	r8, QWORD PTR actualKey$[rsp+1]
	mov	edx, DWORD PTR [rax+4]
	mov	ecx, DWORD PTR [rax]
	call	?output_conversion@@YAPEADIIPEAD@Z	; output_conversion

; 66   :                         fillRestWithZero = TRUE;
; 67   :                 }
; 68   :         }
; 69   :         BOOL result = strcmp((char *)tripcode, crypt((char *)actualKey, (char *)(actualKey + 1)) + 3) == 0;

	lea	rdx, QWORD PTR [rax+3]
	sub	rdx, rdi
$LL78@VerifyDEST:
	movzx	ecx, BYTE PTR [rdi]
	movzx	eax, BYTE PTR [rdi+rdx]
	sub	ecx, eax
	jne	SHORT $LN79@VerifyDEST
	inc	rdi
	test	eax, eax
	jne	SHORT $LL78@VerifyDEST
$LN79@VerifyDEST:
	xor	eax, eax
	test	ecx, ecx
	sete	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1363 : 	*_Tgt = _Value;

	mov	DWORD PTR descrypt_spinlock, 0
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 83   :         return result;

	jmp	SHORT $LN9@VerifyDEST
$LN7@VerifyDEST:

; 56   :                 return FALSE;

	xor	eax, eax
$LN9@VerifyDEST:

; 84   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN83@VerifyDEST:

; 64   :                         actualKey[i] = 0x00;

	call	__report_rangecheckfailure
	int	3
$LN82@VerifyDEST:
?VerifyDESTripcode@@YAHPEAE0@Z ENDP			; VerifyDESTripcode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eposix_category@system@boost@@YAXXZ
text$di	SEGMENT
??__Eposix_category@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'posix_category'', COMDAT

; 221  :     static const error_category &  posix_category = generic_category();

	sub	rsp, 40					; 00000028H
	call	?generic_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::generic_category
	mov	QWORD PTR posix_category, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Eposix_category@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'posix_category''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Eerrno_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Eerrno_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'errno_ecat'', COMDAT

; 222  :     static const error_category &  errno_ecat     = generic_category();

	sub	rsp, 40					; 00000028H
	call	?generic_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::generic_category
	mov	QWORD PTR errno_ecat, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Eerrno_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'errno_ecat''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\boost\system\error_code.hpp
;	COMDAT ??__Enative_ecat@system@boost@@YAXXZ
text$di	SEGMENT
??__Enative_ecat@system@boost@@YAXXZ PROC		; boost::system::`dynamic initializer for 'native_ecat'', COMDAT

; 223  :     static const error_category &  native_ecat    = system_category();

	sub	rsp, 40					; 00000028H
	call	?system_category@system@boost@@YAAEBVerror_category@12@XZ ; boost::system::system_category
	mov	QWORD PTR native_ecat, rax
	add	rsp, 40					; 00000028H
	ret	0
??__Enative_ecat@system@boost@@YAXXZ ENDP		; boost::system::`dynamic initializer for 'native_ecat''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h
;	COMDAT ??0spinlock@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0spinlock@@QEAA@XZ PROC				; spinlock::spinlock, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR [rcx], eax
; File z:\github\merikens-tripcode-engine\sourcefiles\types.h

; 145  : 	}

	mov	rax, rcx
	ret	0
??0spinlock@@QEAA@XZ ENDP				; spinlock::spinlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ??__Edescrypt_spinlock@@YAXXZ
text$di	SEGMENT
??__Edescrypt_spinlock@@YAXXZ PROC			; `dynamic initializer for 'descrypt_spinlock'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic.h

; 1377 : 	_INTRIN_SEQ_CST(_InterlockedExchange)((volatile long *)_Tgt, _Value);

	xor	eax, eax
	xchg	DWORD PTR descrypt_spinlock, eax
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp

; 49   : static spinlock descrypt_spinlock;

	ret	0
??__Edescrypt_spinlock@@YAXXZ ENDP			; `dynamic initializer for 'descrypt_spinlock''
text$di	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?clearmem@@YAXPEADH@Z
_TEXT	SEGMENT
start$ = 8
cnt$ = 16
?clearmem@@YAXPEADH@Z PROC				; clearmem, COMDAT

; 418  :   { while(cnt--)

	mov	QWORD PTR [rsp+8], rdi
	mov	rdi, rcx
	xor	eax, eax
	mov	ecx, edx
	rep stosb

; 419  :       *start++ = '\0';
; 420  :   }

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
?clearmem@@YAXPEADH@Z ENDP				; clearmem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?init_des@@YAXXZ
_TEXT	SEGMENT
j1$1$ = 64
tv1632 = 72
tv1662 = 80
?init_des@@YAXXZ PROC					; init_des, COMDAT

; 434  :   { int32_t comes_from_bit;

$LN112:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {

	xor	r8d, r8d
	lea	r14, OFFSET FLAT:pc1
	lea	r12, OFFSET FLAT:__ImageBase
	mov	edi, r8d
	mov	r13d, 128				; 00000080H
	npad	6
$LL37@init_des:

; 445  :       comes_from_bit  = pc1[bit] - 1;

	mov	eax, DWORD PTR [r14]

; 446  :       mask1 = bytemask[comes_from_bit % 8 + 1];
; 447  :       mask2 = longmask[bit % 28 + 4];

	mov	r11d, edi

; 448  :       for(j = 0; j < 128; j++) {

	mov	r9d, r8d
	dec	eax
	mov	r10, r8
	cdq
	and	edx, 7
	add	eax, edx
	mov	ebx, eax
	and	eax, 7
	sub	eax, edx
	sar	ebx, 3
	movsxd	rcx, eax
	mov	eax, 613566757				; 24924925H
	movzx	esi, BYTE PTR bytemask[rcx+r12+1]
	mov	ecx, edi
	mul	edi
	sub	r11d, edx
	shr	r11d, 1
	add	r11d, edx
	shr	r11d, 4
	imul	eax, r11d, 28
	sub	ecx, eax
	lea	eax, DWORD PTR [rcx+4]
	cdqe
	mov	ebp, DWORD PTR longmask[r12+rax*4]
$LL34@init_des:

; 449  :         if(j & mask1) 

	test	r9d, esi
	je	SHORT $LN33@init_des

; 450  :           do_pc1[comes_from_bit / 8][bit / 28][j] |= mask2;

	movsxd	rcx, ebx
	lea	rdx, QWORD PTR [r11+rcx*2]
	shl	rdx, 7
	add	rdx, r10
	or	DWORD PTR do_pc1[r12+rdx*4], ebp
$LN33@init_des:

; 448  :       for(j = 0; j < 128; j++) {

	inc	r9d
	inc	r10
	cmp	r9d, r13d
	jb	SHORT $LL34@init_des

; 435  :     int32_t bit, sg;
; 436  :     ufc_long j;
; 437  :     ufc_long mask1, mask2;
; 438  : 
; 439  :     /*
; 440  :      * Create the do_pc1 table used
; 441  :      * to affect pc1 permutation
; 442  :      * when generating keys
; 443  :      */
; 444  :     for(bit = 0; bit < 56; bit++) {

	inc	edi
	add	r14, 4
	cmp	edi, 56					; 00000038H
	jl	$LL37@init_des

; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {

	mov	edi, r8d
	lea	rsi, OFFSET FLAT:pc2
	mov	ebp, 16
	npad	9
$LL30@init_des:

; 460  :       comes_from_bit  = pc2[bit] - 1;

	mov	ecx, DWORD PTR [rsi]

; 461  :       mask1 = bytemask[comes_from_bit % 7 + 1];

	mov	eax, -1840700269			; ffffffff92492493H

; 462  :       mask2 = BITMASK(bit % 24);

	mov	r9d, edi
	dec	ecx
	mov	r11d, 1
	imul	ecx
	lea	r10d, DWORD PTR [rcx+rdx]
	sar	r10d, 2
	mov	eax, r10d
	shr	eax, 31
	add	r10d, eax
	imul	eax, r10d, 7
	sub	ecx, eax
	lea	eax, DWORD PTR [rcx+1]
	mov	ecx, 14
	cdqe
	movzx	ebx, BYTE PTR bytemask[rax+r12]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	shr	edx, 4
	lea	eax, DWORD PTR [rdx+rdx*2]
	shl	eax, 3
	sub	r9d, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	r9d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r9d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx

; 463  :       for(j = 0; j < 128; j++) {

	mov	rdx, r8
	shl	r11d, cl
	cmp	r9d, 12
	mov	ecx, r8d
	cmovl	ecx, ebp
	shl	r11d, cl
	mov	ecx, r8d
$LL27@init_des:

; 464  :         if(j & mask1)

	test	ecx, ebx
	je	SHORT $LN26@init_des

; 465  :           do_pc2[comes_from_bit / 7][j] |= mask2;

	movsxd	rax, r10d
	shl	rax, 7
	add	rax, rdx
	or	DWORD PTR do_pc2[r12+rax*4], r11d
$LN26@init_des:

; 463  :       for(j = 0; j < 128; j++) {

	inc	ecx
	inc	rdx
	cmp	ecx, r13d
	jb	SHORT $LL27@init_des

; 451  :       }
; 452  :     }
; 453  : 
; 454  :     /*
; 455  :      * Create the do_pc2 table used
; 456  :      * to affect pc2 permutation when
; 457  :      * generating keys
; 458  :      */
; 459  :     for(bit = 0; bit < 48; bit++) {

	inc	edi
	add	rsi, 4
	cmp	edi, 48					; 00000030H
	jl	$LL30@init_des

; 419  :       *start++ = '\0';

	lea	rax, OFFSET FLAT:eperm32tab
	mov	rcx, r13
	npad	2
$LL108@init_des:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	dec	rcx
	jne	SHORT $LL108@init_des

; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {

	mov	edi, r8d
	lea	r15, OFFSET FLAT:esel
$LL23@init_des:

; 484  :       ufc_long mask1,comes_from;
; 485  :         
; 486  :       comes_from = perm32[esel[bit]-1]-1;

	movsxd	rax, DWORD PTR [r15]

; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);

	mov	ebx, edi
	mov	r10d, 256				; 00000100H
	mov	ecx, DWORD PTR perm32[r12+rax*4-4]
	mov	r13d, 16
	dec	ecx
	mov	eax, ecx
	mov	ebp, ecx
	and	eax, 7
	movzx	esi, BYTE PTR bytemask[rax+r12]
	mov	eax, -1431655765			; aaaaaaabH
	lea	r12, OFFSET FLAT:eperm32tab
	mul	edi
	mov	r11d, edx
	shr	r11d, 4
	lea	eax, DWORD PTR [r11+r11*2]
	shl	eax, 3
	sub	ebx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	r14d, DWORD PTR [rdx+rdx*2]
	shl	r14d, 2
	sub	r14d, ebx
$LL20@init_des:

; 490  :         if(j & mask1)

	dec	r10d
	test	esi, r10d
	je	SHORT $LN18@init_des

; 491  :           eperm32tab[comes_from / 8][j][bit / 24] |= BITMASK(bit % 24);

	mov	eax, r10d
	mov	rcx, rbp
	mov	edx, r8d
	shr	rcx, 3
	shl	rcx, 8
	add	rcx, rax
	cmp	ebx, 12
	mov	eax, 1
	cmovl	edx, r13d
	lea	rcx, QWORD PTR [r11+rcx*2]
	lea	r9, QWORD PTR [r12+rcx*4]
	lea	ecx, DWORD PTR [r14+14]
	shl	eax, cl
	movzx	ecx, dl
	shl	eax, cl
	or	DWORD PTR [r9], eax
$LN18@init_des:

; 487  :       mask1      = bytemask[comes_from % 8];
; 488  :         
; 489  :       for(j = 256; j--;) {

	test	r10d, r10d
	jne	SHORT $LL20@init_des

; 466  :       }
; 467  :     }
; 468  : 
; 469  :     /* 
; 470  :      * Now generate the table used to do combined
; 471  :      * 32 bit permutation and e expansion
; 472  :      *
; 473  :      * We use it because we have to permute 16384 32 bit
; 474  :      * longs into 48 bit in order to initialize sb.
; 475  :      *
; 476  :      * Looping 48 rounds per permutation becomes 
; 477  :      * just too slow...
; 478  :      *
; 479  :      */
; 480  : 
; 481  :     clearmem((char*)eperm32tab, sizeof(eperm32tab));
; 482  : 
; 483  :     for(bit = 0; bit < 48; bit++) {

	inc	edi
	add	r15, 4
	lea	r12, OFFSET FLAT:__ImageBase
	cmp	edi, 48					; 00000030H
	jl	$LL23@init_des

; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {

	mov	r14, r8
	lea	r13d, QWORD PTR [r10+24]
	jmp	SHORT $LN17@init_des
	npad	8
$LL110@init_des:
	lea	r12, OFFSET FLAT:__ImageBase
$LN17@init_des:

; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];

	mov	rax, QWORD PTR sb[r14+r12]
	mov	rbx, r8
	mov	edi, r8d
	mov	QWORD PTR tv1662[rsp], rax
	mov	DWORD PTR j1$1$[rsp], r8d
	mov	QWORD PTR tv1632[rsp], rbx
	jmp	SHORT $LN14@init_des
	npad	10
$LL109@init_des:
	lea	r12, OFFSET FLAT:__ImageBase
$LN14@init_des:

; 512  :         s1 = s_lookup(2 * sg, j1);

	mov	rax, rbx
	mov	rcx, rbx
	mov	ebp, edi
	sar	rcx, 4
	and	eax, 1
	mov	r15, r8
	and	ecx, 2
	lea	rdi, OFFSET FLAT:eperm32tab
	or	rcx, rax
	mov	rax, rbx
	lea	rbx, OFFSET FLAT:__ImageBase
	sar	rax, 1
	add	rcx, r14
	and	eax, 15
	shl	rcx, 4
	add	rcx, rax
	mov	esi, DWORD PTR sbox[r12+rcx*4]

; 513  :         for(j2 = 0; j2 < 64; j2++) {

	mov	r12d, r8d
	mov	r8, QWORD PTR tv1662[rsp]
	shl	esi, 4
	shl	ebp, 6
	npad	10
$LL11@init_des:

; 514  :           ufc_long to_permute, inx;
; 515  :     
; 516  :           s2         = s_lookup(2 * sg + 1, j2);

	mov	rax, r15

; 517  :           to_permute = ((s1 << 4)  | s2) << (24 - 8 * sg);

	mov	rcx, r15
	and	eax, 1
	sar	rcx, 4
	and	ecx, 2
	or	rcx, rax
	mov	rax, r15
	inc	r15
	sar	rax, 1
	add	rcx, r14
	and	eax, 15
	shl	rcx, 4
	add	rcx, rax

; 518  : 
; 519  : #ifdef _UFC_32_
; 520  :           inx = ((j1 << 6)  | j2) << 1;

	mov	eax, ebp
	mov	edx, DWORD PTR sbox[rbx+rcx*4+256]
	or	eax, r12d
	mov	ecx, r13d
	or	edx, esi
	inc	r12d
	shl	edx, cl
	lea	ecx, DWORD PTR [rax+rax]

; 521  :           sb[sg][inx  ]  = eperm32tab[0][(to_permute >> 24) & 0xff][0];

	lea	r10, QWORD PTR [r8+rcx*4]
	mov	r11d, edx
	mov	eax, edx
	shr	rax, 24
	lea	rdx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rdx+rdi]
	mov	DWORD PTR [r10], eax

; 522  :           sb[sg][inx+1]  = eperm32tab[0][(to_permute >> 24) & 0xff][1];

	lea	eax, DWORD PTR [rcx+1]
	lea	r9, QWORD PTR [r8+rax*4]
	mov	eax, DWORD PTR [rdx+rdi+4]
	mov	DWORD PTR [r9], eax

; 523  :           sb[sg][inx  ] |= eperm32tab[1][(to_permute >> 16) & 0xff][0];

	mov	eax, r11d
	shr	rax, 16
	movzx	eax, al
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rcx+rdi+2048]
	or	DWORD PTR [r10], eax

; 524  :           sb[sg][inx+1] |= eperm32tab[1][(to_permute >> 16) & 0xff][1];

	mov	eax, DWORD PTR [rcx+rdi+2052]
	or	DWORD PTR [r9], eax

; 525  :             sb[sg][inx  ] |= eperm32tab[2][(to_permute >>  8) & 0xff][0];

	mov	eax, r11d
	shr	rax, 8
	movzx	eax, al
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rcx+rdi+4096]
	or	DWORD PTR [r10], eax

; 526  :           sb[sg][inx+1] |= eperm32tab[2][(to_permute >>  8) & 0xff][1];

	mov	eax, DWORD PTR [rcx+rdi+4100]
	or	DWORD PTR [r9], eax

; 527  :           sb[sg][inx  ] |= eperm32tab[3][(to_permute)       & 0xff][0];

	movzx	eax, r11b
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rcx+rdi+6144]
	or	DWORD PTR [r10], eax

; 528  :           sb[sg][inx+1] |= eperm32tab[3][(to_permute)       & 0xff][1];

	mov	eax, DWORD PTR [rcx+rdi+6148]
	or	DWORD PTR [r9], eax
	cmp	r12d, 64				; 00000040H
	jl	$LL11@init_des

; 508  :       int32_t j1, j2;
; 509  :       int32_t s1, s2;
; 510  :     
; 511  :       for(j1 = 0; j1 < 64; j1++) {

	mov	edi, DWORD PTR j1$1$[rsp]
	mov	rbx, QWORD PTR tv1632[rsp]
	mov	r8d, 0
	inc	edi
	inc	rbx
	mov	DWORD PTR j1$1$[rsp], edi
	mov	QWORD PTR tv1632[rsp], rbx
	cmp	edi, 64					; 00000040H
	jl	$LL109@init_des

; 492  :       }
; 493  :     }
; 494  :     
; 495  :     /* 
; 496  :      * Create the sb tables:
; 497  :      *
; 498  :      * For each 12 bit segment of an 48 bit intermediate
; 499  :      * result, the sb table precomputes the two 4 bit
; 500  :      * values of the sbox lookups done with the two 6
; 501  :      * bit halves, shifts them to their proper place,
; 502  :      * sends them through perm32 and finally E expands
; 503  :      * them so that they are ready for the next
; 504  :      * DES round.
; 505  :      *
; 506  :      */
; 507  :     for(sg = 0; sg < 4; sg++) {

	add	r14, 8
	sub	r13d, 8
	cmp	r14, 32					; 00000020H
	jl	$LL110@init_des

; 529  : #endif
; 530  : #ifdef _UFC_64_
; 531  :           inx = ((j1 << 6)  | j2);
; 532  :           sb[sg][inx]  = 
; 533  :             ((long64)eperm32tab[0][(to_permute >> 24) & 0xff][0] << 32) |
; 534  :              (long64)eperm32tab[0][(to_permute >> 24) & 0xff][1];
; 535  :           sb[sg][inx] |=
; 536  :             ((long64)eperm32tab[1][(to_permute >> 16) & 0xff][0] << 32) |
; 537  :              (long64)eperm32tab[1][(to_permute >> 16) & 0xff][1];
; 538  :             sb[sg][inx] |= 
; 539  :             ((long64)eperm32tab[2][(to_permute >>  8) & 0xff][0] << 32) |
; 540  :              (long64)eperm32tab[2][(to_permute >>  8) & 0xff][1];
; 541  :           sb[sg][inx] |=
; 542  :             ((long64)eperm32tab[3][(to_permute)       & 0xff][0] << 32) |
; 543  :              (long64)eperm32tab[3][(to_permute)       & 0xff][1];
; 544  : #endif
; 545  :         }
; 546  :       }
; 547  :     }  
; 548  : 
; 549  :     /* 
; 550  :      * Create an inverse matrix for esel telling
; 551  :      * where to plug out bits if undoing it
; 552  :      */
; 553  :     for(bit=48; bit--;) {

	mov	edx, 48					; 00000030H
	lea	r9, OFFSET FLAT:esel+192
	lea	r11, OFFSET FLAT:__ImageBase
	lea	r13d, QWORD PTR [rdx+80]
$LL8@init_des:

; 554  :       e_inverse[esel[bit] - 1     ] = bit;

	movsxd	rax, DWORD PTR [r9-4]
	dec	edx
	lea	r9, QWORD PTR [r9-4]
	lea	rcx, QWORD PTR [rax*4]

; 555  :       e_inverse[esel[bit] - 1 + 32] = bit + 48;

	lea	eax, DWORD PTR [rdx+48]
	mov	DWORD PTR e_inverse[rcx+r11-4], edx
	mov	DWORD PTR e_inverse[rcx+r11+124], eax
	jne	SHORT $LL8@init_des

; 419  :       *start++ = '\0';

	lea	rbp, OFFSET FLAT:efp
	mov	rax, rbp
$LL107@init_des:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	dec	r13
	jne	SHORT $LL107@init_des

; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {

	mov	rdi, r8
	lea	rsi, OFFSET FLAT:final_perm
$LL6@init_des:

; 564  :       int32_t o_bit, o_long;
; 565  :       ufc_long word_value, mask1, mask2;
; 566  :       int32_t comes_from_f_bit, comes_from_e_bit;
; 567  :       int32_t comes_from_word, bit_within_word;
; 568  : 
; 569  :       /* See where bit i belongs in the two 32 bit long's */
; 570  :       o_long = bit / 32; /* 0..1  */
; 571  :       o_bit  = bit % 32; /* 0..31 */
; 572  : 
; 573  :       /* 
; 574  :        * And find a bit in the e permutated value setting this bit.
; 575  :        *
; 576  :        * Note: the e selection may have selected the same bit several
; 577  :        * times. By the initialization of e_inverse, we only look
; 578  :        * for one specific instance.
; 579  :        */
; 580  :       comes_from_f_bit = final_perm[bit] - 1;         /* 0..63 */
; 581  :       comes_from_e_bit = e_inverse[comes_from_f_bit]; /* 0..95 */

	movsxd	rax, DWORD PTR [rsi]
	mov	ebx, r8d

; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {

	mov	r9d, 64					; 00000040H
	mov	ecx, DWORD PTR e_inverse[r11+rax*4-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	movsxd	rdx, edx
	add	eax, eax
	sub	ecx, eax
	lea	eax, DWORD PTR [rcx+26]
	cdqe
	mov	r10d, DWORD PTR longmask[r11+rax*4]
	mov	rax, rdi
	and	eax, 31
	shr	ebx, 5
	mov	r11d, DWORD PTR longmask[r11+rax*4]
	npad	3
$LL3@init_des:
	dec	r9d

; 589  :         if(word_value & mask1)

	test	r9d, r10d
	je	SHORT $LN1@init_des

; 590  :           efp[comes_from_word][word_value][o_long] |= mask2;

	mov	eax, r9d
	mov	rcx, rdx
	shl	rcx, 6
	add	rcx, rax
	lea	rax, QWORD PTR [rbx+rcx*2]
	or	DWORD PTR [rbp+rax*4], r11d
$LN1@init_des:

; 582  :       comes_from_word  = comes_from_e_bit / 6;        /* 0..15 */
; 583  :       bit_within_word  = comes_from_e_bit % 6;        /* 0..5  */
; 584  : 
; 585  :       mask1 = longmask[bit_within_word + 26];
; 586  :       mask2 = longmask[o_bit];
; 587  : 
; 588  :       for(word_value = 64; word_value--;) {

	test	r9d, r9d
	jne	SHORT $LL3@init_des

; 556  :     }
; 557  : 
; 558  :     /* 
; 559  :      * create efp: the matrix used to
; 560  :      * undo the E expansion and effect final permutation
; 561  :      */
; 562  :     clearmem((char*)efp, sizeof efp);
; 563  :     for(bit = 0; bit < 64; bit++) {

	inc	r8d
	inc	rdi
	add	rsi, 4
	lea	r11, OFFSET FLAT:__ImageBase
	cmp	r8d, 64					; 00000040H
	jl	$LL6@init_des

; 591  :       }
; 592  :     }
; 593  :     initialized++;

	inc	DWORD PTR initialized

; 594  :   }

	mov	rbx, QWORD PTR [rsp+88]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?init_des@@YAXXZ ENDP					; init_des
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?shuffle_sb@@YAXPEAII@Z
_TEXT	SEGMENT
k$ = 8
saltbits$ = 16
?shuffle_sb@@YAXPEAII@Z PROC				; shuffle_sb, COMDAT

; 604  :     long32 x;
; 605  :     for(j=4096; j--;) {

	mov	r10d, 4096				; 00001000H
	npad	10
$LL2@shuffle_sb:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [rcx]
	mov	r8d, DWORD PTR [rcx+4]

; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;

	lea	rcx, QWORD PTR [rcx+8]
	xor	r8d, eax
	and	r8d, edx
	xor	eax, r8d
	mov	DWORD PTR [rcx-8], eax
	xor	DWORD PTR [rcx-4], r8d
	dec	r10d
	jne	SHORT $LL2@shuffle_sb

; 609  :     }
; 610  :   }

	ret	0
?shuffle_sb@@YAXPEAII@Z ENDP				; shuffle_sb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?setup_salt@@YAXPEAD@Z
_TEXT	SEGMENT
s$ = 48
?setup_salt@@YAXPEAD@Z PROC				; setup_salt, COMDAT

; 636  :   { ufc_long i, j, saltbits;

	push	rbx
	sub	rsp, 32					; 00000020H

; 637  : 
; 638  :     if(!initialized)

	cmp	DWORD PTR initialized, 0
	mov	rbx, rcx
	jne	SHORT $LN11@setup_salt

; 639  :       init_des();

	call	?init_des@@YAXXZ			; init_des
$LN11@setup_salt:

; 640  : 
; 641  :     if(s[0] == current_salt[0] && s[1] == current_salt[1])

	movsx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR current_salt
	cmp	ecx, eax
	jne	SHORT $LN10@setup_salt
	movsx	edx, BYTE PTR [rbx+1]
	movzx	eax, BYTE PTR current_salt+1
	cmp	edx, eax
	je	$LN12@setup_salt
$LN10@setup_salt:

; 642  :       return;
; 643  :     current_salt[0] = s[0]; current_salt[1] = s[1];

	movzx	eax, BYTE PTR [rbx+1]
	mov	QWORD PTR [rsp+48], rdi

; 644  : 
; 645  :     /* 
; 646  :      * This is the only crypt change to DES:
; 647  :      * entries are swapped in the expansion table
; 648  :      * according to the bits set in the salt.
; 649  :      */
; 650  :     saltbits = 0;

	xor	edi, edi
	mov	BYTE PTR current_salt, cl
	mov	r11d, edi
	mov	BYTE PTR current_salt+1, al
	lea	r10d, QWORD PTR [rdi+2]
	npad	10
$LL9@setup_salt:

; 652  :       int32_t c=ascii_to_bin(s[i]);

	movzx	eax, BYTE PTR [rbx]
	movsx	r8d, al
	cmp	al, 97					; 00000061H
	jl	SHORT $LN16@setup_salt
	sub	r8d, 59					; 0000003bH
	jmp	SHORT $LN15@setup_salt
$LN16@setup_salt:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN14@setup_salt
	sub	r8d, 53					; 00000035H
	jmp	SHORT $LN15@setup_salt
$LN14@setup_salt:
	sub	r8d, 46					; 0000002eH
$LN15@setup_salt:
	cmp	r8d, 63					; 0000003fH
	cmova	r8d, edi

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 1
	je	SHORT $LN3@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	r9d, DWORD PTR [r10-2]
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r9d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r9d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r9d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN3@setup_salt:

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 2
	je	SHORT $LN60@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	r9d, DWORD PTR [r10-1]
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r9d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r9d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r9d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN60@setup_salt:

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 4
	je	SHORT $LN62@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r10d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r10d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r10d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN62@setup_salt:

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 8
	je	SHORT $LN64@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	r9d, DWORD PTR [r10+1]
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r9d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r9d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r9d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN64@setup_salt:

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 16
	je	SHORT $LN66@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	r9d, DWORD PTR [r10+2]
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r9d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r9d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r9d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN66@setup_salt:

; 653  :       if(c < 0 || c > 63)
; 654  :         c = 0;
; 655  :       for(j = 0; j < 6; j++) {
; 656  :         if((c >> j) & 0x1)

	test	r8b, 32					; 00000020H
	je	SHORT $LN8@setup_salt

; 657  :           saltbits |= BITMASK(6 * i + j);

	lea	r8d, DWORD PTR [r10+3]
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, 14
	mul	r8d
	shr	edx, 3
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	edx, r8d
	shl	eax, 2
	sub	edx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	cmp	r8d, 12
	sbb	eax, eax
	and	eax, 16
	movzx	ecx, al
	shl	edx, cl
	or	r11d, edx
$LN8@setup_salt:

; 651  :     for(i = 0; i < 2; i++) {

	add	r10d, 6
	inc	rbx
	cmp	r10d, 14
	jb	$LL9@setup_salt

; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 

	mov	r9d, DWORD PTR current_saltbits
	mov	rdi, QWORD PTR [rsp+48]

; 605  :     for(j=4096; j--;) {

	mov	r10d, 4096				; 00001000H

; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 

	lea	r8, OFFSET FLAT:?_ufc_sb0@@3PAIA	; _ufc_sb0

; 605  :     for(j=4096; j--;) {

	mov	ebx, r10d

; 658  :       }
; 659  :     }
; 660  : 
; 661  :     /*
; 662  :      * Permute the sb table values
; 663  :      * to reflect the changed e
; 664  :      * selection table
; 665  :      */
; 666  :     shuffle_sb(_ufc_sb0, current_saltbits ^ saltbits); 

	xor	r9d, r11d
	npad	3
$LL19@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [r8]
	mov	ecx, DWORD PTR [r8+4]

; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;

	lea	r8, QWORD PTR [r8+8]
	xor	ecx, eax
	and	ecx, r9d
	xor	eax, ecx
	mov	DWORD PTR [r8-8], eax
	xor	DWORD PTR [r8-4], ecx
	dec	ebx
	jne	SHORT $LL19@setup_salt

; 667  :     shuffle_sb(_ufc_sb1, current_saltbits ^ saltbits);

	lea	r8, OFFSET FLAT:?_ufc_sb1@@3PAIA	; _ufc_sb1

; 605  :     for(j=4096; j--;) {

	mov	ebx, r10d
	npad	8
$LL23@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [r8]
	mov	ecx, DWORD PTR [r8+4]

; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;

	lea	r8, QWORD PTR [r8+8]
	xor	ecx, eax
	and	ecx, r9d
	xor	eax, ecx
	mov	DWORD PTR [r8-8], eax
	xor	DWORD PTR [r8-4], ecx
	dec	ebx
	jne	SHORT $LL23@setup_salt

; 668  :     shuffle_sb(_ufc_sb2, current_saltbits ^ saltbits);

	lea	r8, OFFSET FLAT:?_ufc_sb2@@3PAIA	; _ufc_sb2

; 605  :     for(j=4096; j--;) {

	mov	ebx, r10d
	npad	8
$LL27@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [r8]

; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;

	lea	r8, QWORD PTR [r8+8]
	mov	ecx, eax
	xor	ecx, DWORD PTR [r8-4]
	and	ecx, r9d
	xor	eax, ecx
	mov	DWORD PTR [r8-8], eax
	xor	DWORD PTR [r8-4], ecx
	dec	ebx
	jne	SHORT $LL27@setup_salt

; 669  :     shuffle_sb(_ufc_sb3, current_saltbits ^ saltbits);

	lea	r8, OFFSET FLAT:?_ufc_sb3@@3PAIA	; _ufc_sb3
	npad	11
$LL31@setup_salt:

; 606  :       x = (k[0] ^ k[1]) & (long32)saltbits;

	mov	eax, DWORD PTR [r8]

; 607  :       *k++ ^= x;
; 608  :       *k++ ^= x;

	lea	r8, QWORD PTR [r8+8]
	mov	ecx, eax
	xor	ecx, DWORD PTR [r8-4]
	and	ecx, r9d
	xor	eax, ecx
	mov	DWORD PTR [r8-8], eax
	xor	DWORD PTR [r8-4], ecx
	dec	r10d
	jne	SHORT $LL31@setup_salt

; 670  : 
; 671  :     current_saltbits = saltbits;

	mov	DWORD PTR current_saltbits, r11d
$LN12@setup_salt:

; 672  :   }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?setup_salt@@YAXPEAD@Z ENDP				; setup_salt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?ufc_mk_keytab@@YAXPEAD@Z
_TEXT	SEGMENT
key$ = 16
?ufc_mk_keytab@@YAXPEAD@Z PROC				; ufc_mk_keytab, COMDAT

; 675  :   { ufc_long v1, v2, *k1;

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14

; 676  :     int32_t i;
; 677  : #ifdef _UFC_32_
; 678  :     long32 v, *k2 = &_ufc_keytab[0][0];
; 679  : #endif
; 680  : #ifdef _UFC_64_
; 681  :     long64 v, *k2 = &_ufc_keytab[0];
; 682  : #endif
; 683  : 
; 684  :     v1 = v2 = 0; k1 = &do_pc1[0][0][0];

	xor	r11d, r11d
	lea	rdi, OFFSET FLAT:?_ufc_keytab@@3PAY01IA	; _ufc_keytab
	lea	rax, OFFSET FLAT:do_pc1

; 685  :     for(i = 8; i--;) {

	lea	r8d, QWORD PTR [r11+8]
	xor	ebx, ebx
	npad	3
$LL5@ufc_mk_key:

; 686  :       v1 |= k1[*key   & 0x7f]; k1 += 128;

	movsx	rdx, BYTE PTR [rcx]

; 687  :       v2 |= k1[*key++ & 0x7f]; k1 += 128;

	lea	rcx, QWORD PTR [rcx+1]
	lea	rax, QWORD PTR [rax+1024]
	and	edx, 127				; 0000007fH
	or	ebx, DWORD PTR [rax+rdx*4-1024]
	or	r11d, DWORD PTR [rax+rdx*4-512]
	dec	r8d
	jne	SHORT $LL5@ufc_mk_key

; 688  :     }
; 689  : 
; 690  :     for(i = 0; i < 16; i++) {

	lea	rsi, OFFSET FLAT:rots
	lea	ebp, QWORD PTR [r8+16]
	lea	r14, OFFSET FLAT:do_pc2
	npad	8
$LL3@ufc_mk_key:

; 691  :       k1 = &do_pc2[0][0];
; 692  : 
; 693  :       v1 = (v1 << rots[i]) | (v1 >> (28 - rots[i]));

	mov	r10d, DWORD PTR [rsi]
	mov	edx, ebx
	mov	eax, ebx
	mov	r9d, 28

; 694  :       v  = k1[(v1 >> 21) & 0x7f]; k1 += 128;
; 695  :       v |= k1[(v1 >> 14) & 0x7f]; k1 += 128;
; 696  :       v |= k1[(v1 >>  7) & 0x7f]; k1 += 128;
; 697  :       v |= k1[(v1      ) & 0x7f]; k1 += 128;
; 698  : 
; 699  : #ifdef _UFC_32_
; 700  :       *k2++ = v;
; 701  :       v = 0;
; 702  : #endif
; 703  : #ifdef _UFC_64_
; 704  :       v <<= 32;
; 705  : #endif
; 706  : 
; 707  :       v2 = (v2 << rots[i]) | (v2 >> (28 - rots[i]));
; 708  :       v |= k1[(v2 >> 21) & 0x7f]; k1 += 128;
; 709  :       v |= k1[(v2 >> 14) & 0x7f]; k1 += 128;
; 710  :       v |= k1[(v2 >>  7) & 0x7f]; k1 += 128;
; 711  :       v |= k1[(v2      ) & 0x7f];
; 712  : 
; 713  :       *k2++ = v;

	lea	rdi, QWORD PTR [rdi+8]
	lea	rsi, QWORD PTR [rsi+4]
	sub	r9d, r10d
	mov	ecx, r9d
	shr	edx, cl
	mov	ecx, r10d
	shl	eax, cl
	mov	ebx, edx
	or	ebx, eax
	mov	r8d, ebx
	mov	ecx, ebx
	mov	eax, ebx
	shr	rax, 14
	shr	rcx, 21
	and	r8d, 127				; 0000007fH
	and	eax, 127				; 0000007fH
	and	ecx, 127				; 0000007fH
	mov	edx, DWORD PTR [r14+rcx*4]
	mov	ecx, r9d
	or	edx, DWORD PTR [r14+rax*4+512]
	mov	eax, ebx
	shr	rax, 7
	and	eax, 127				; 0000007fH
	or	edx, DWORD PTR [r14+rax*4+1024]
	mov	eax, DWORD PTR [r14+r8*4+1536]
	or	eax, edx
	mov	edx, r11d
	mov	DWORD PTR [rdi-8], eax
	shr	edx, cl
	mov	eax, r11d
	mov	r11d, edx
	mov	ecx, r10d
	shl	eax, cl
	or	r11d, eax
	mov	edx, r11d
	mov	eax, r11d
	shr	rax, 21
	and	edx, 127				; 0000007fH
	and	eax, 127				; 0000007fH
	mov	ecx, DWORD PTR [r14+rax*4+2048]
	mov	eax, r11d
	shr	rax, 14
	and	eax, 127				; 0000007fH
	or	ecx, DWORD PTR [r14+rax*4+2560]
	mov	eax, r11d
	shr	rax, 7
	and	eax, 127				; 0000007fH
	mov	eax, DWORD PTR [r14+rax*4+3072]
	or	eax, DWORD PTR [r14+rdx*4+3584]
	or	eax, ecx
	mov	DWORD PTR [rdi-4], eax
	dec	rbp
	jne	$LL3@ufc_mk_key

; 714  :     }
; 715  : 
; 716  :     direction = 0;
; 717  :   }

	mov	rbx, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+40]
	mov	DWORD PTR direction, ebp
	mov	rbp, QWORD PTR [rsp+24]
	pop	r14
	ret	0
?ufc_mk_keytab@@YAXPEAD@Z ENDP				; ufc_mk_keytab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?_ufc_dofinalperm@@YAPEAIIIII@Z
_TEXT	SEGMENT
l1$ = 8
l2$ = 16
r1$ = 24
r2$ = 32
?_ufc_dofinalperm@@YAPEAIIIII@Z PROC			; _ufc_dofinalperm, COMDAT

; 724  :   { ufc_long v1, v2, x;

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 725  :     static ufc_long ary[2];
; 726  : 
; 727  :     x = (l1 ^ l2) & current_saltbits; l1 ^= x; l2 ^= x;
; 728  :     x = (r1 ^ r2) & current_saltbits; r1 ^= x; r2 ^= x;
; 729  : 
; 730  :     v1=v2=0; l1 >>= 3; l2 >>= 3; r1 >>= 3; r2 >>= 3;
; 731  : 
; 732  :     v1 |= efp[15][ r2         & 0x3f][0]; v2 |= efp[15][ r2 & 0x3f][1];

	lea	rsi, OFFSET FLAT:efp
	mov	eax, ecx
	mov	r11d, r8d
	xor	eax, edx
	xor	r11d, r9d
	mov	ebx, edx
	and	eax, DWORD PTR current_saltbits
	and	r11d, DWORD PTR current_saltbits
	mov	edi, ecx
	xor	ebx, eax
	xor	edi, eax
	mov	r10d, r11d
	xor	r11d, r9d
	xor	r10d, r8d
	shr	ebx, 3
	shr	r11d, 3
	shr	r10d, 3
	shr	edi, 3
	mov	eax, r11d

; 733  :     v1 |= efp[14][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[14][ r2 & 0x3f][1];

	shr	r11d, 6
	and	eax, 63					; 0000003fH
	mov	r8d, DWORD PTR [rsi+rax*8+7680]
	mov	r9d, DWORD PTR [rsi+rax*8+7684]
	mov	eax, r11d
	and	eax, 63					; 0000003fH

; 734  :     v1 |= efp[13][(r2 >>= 10) & 0x3f][0]; v2 |= efp[13][ r2 & 0x3f][1];

	shr	r11d, 10
	or	r8d, DWORD PTR [rsi+rax*8+7168]
	or	r9d, DWORD PTR [rsi+rax*8+7172]
	mov	eax, r11d
	and	eax, 63					; 0000003fH

; 735  :     v1 |= efp[12][(r2 >>= 6)  & 0x3f][0]; v2 |= efp[12][ r2 & 0x3f][1];

	shr	r11d, 6
	or	r8d, DWORD PTR [rsi+rax*8+6656]
	or	r9d, DWORD PTR [rsi+rax*8+6660]

; 736  : 
; 737  :     v1 |= efp[11][ r1         & 0x3f][0]; v2 |= efp[11][ r1 & 0x3f][1];

	mov	eax, r10d
	and	eax, 63					; 0000003fH

; 738  :     v1 |= efp[10][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[10][ r1 & 0x3f][1];

	shr	r10d, 6
	lea	rdx, QWORD PTR [rax*8]
	mov	eax, r11d
	and	eax, 63					; 0000003fH
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rdx+rsi+5632]
	or	eax, DWORD PTR [rcx+rsi+6144]
	or	r8d, eax
	mov	eax, DWORD PTR [rdx+rsi+5636]
	or	eax, DWORD PTR [rcx+rsi+6148]
	or	r9d, eax
	mov	eax, r10d

; 739  :     v1 |= efp[ 9][(r1 >>= 10) & 0x3f][0]; v2 |= efp[ 9][ r1 & 0x3f][1];

	shr	r10d, 10
	and	eax, 63					; 0000003fH
	or	r8d, DWORD PTR [rsi+rax*8+5120]
	or	r9d, DWORD PTR [rsi+rax*8+5124]
	mov	eax, r10d
	and	eax, 63					; 0000003fH

; 740  :     v1 |= efp[ 8][(r1 >>= 6)  & 0x3f][0]; v2 |= efp[ 8][ r1 & 0x3f][1];

	shr	r10d, 6
	or	r8d, DWORD PTR [rsi+rax*8+4608]
	or	r9d, DWORD PTR [rsi+rax*8+4612]

; 741  : 
; 742  :     v1 |= efp[ 7][ l2         & 0x3f][0]; v2 |= efp[ 7][ l2 & 0x3f][1];

	mov	eax, ebx
	and	eax, 63					; 0000003fH

; 743  :     v1 |= efp[ 6][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 6][ l2 & 0x3f][1];

	shr	ebx, 6
	lea	rdx, QWORD PTR [rax*8]
	mov	eax, r10d
	and	eax, 63					; 0000003fH
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rdx+rsi+3584]
	or	eax, DWORD PTR [rcx+rsi+4096]
	or	r8d, eax
	mov	eax, DWORD PTR [rdx+rsi+3588]
	or	eax, DWORD PTR [rcx+rsi+4100]
	or	r9d, eax
	mov	eax, ebx

; 744  :     v1 |= efp[ 5][(l2 >>= 10) & 0x3f][0]; v2 |= efp[ 5][ l2 & 0x3f][1];

	shr	ebx, 10
	and	eax, 63					; 0000003fH
	or	r8d, DWORD PTR [rsi+rax*8+3072]
	or	r9d, DWORD PTR [rsi+rax*8+3076]
	mov	eax, ebx
	and	eax, 63					; 0000003fH

; 745  :     v1 |= efp[ 4][(l2 >>= 6)  & 0x3f][0]; v2 |= efp[ 4][ l2 & 0x3f][1];

	shr	ebx, 6
	or	r8d, DWORD PTR [rsi+rax*8+2560]
	or	r9d, DWORD PTR [rsi+rax*8+2564]

; 746  : 
; 747  :     v1 |= efp[ 3][ l1         & 0x3f][0]; v2 |= efp[ 3][ l1 & 0x3f][1];

	mov	eax, edi
	and	eax, 63					; 0000003fH
	lea	rdx, QWORD PTR [rax*8]
	mov	eax, ebx

; 748  :     v1 |= efp[ 2][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 2][ l1 & 0x3f][1];
; 749  :     v1 |= efp[ 1][(l1 >>= 10) & 0x3f][0]; v2 |= efp[ 1][ l1 & 0x3f][1];
; 750  :     v1 |= efp[ 0][(l1 >>= 6)  & 0x3f][0]; v2 |= efp[ 0][ l1 & 0x3f][1];
; 751  : 
; 752  :     ary[0] = v1; ary[1] = v2;
; 753  :     return ary;
; 754  :   }

	mov	rbx, QWORD PTR [rsp+8]
	and	eax, 63					; 0000003fH
	shr	edi, 6
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rdx+rsi+1536]
	or	eax, DWORD PTR [rcx+rsi+2048]
	or	r8d, eax
	mov	eax, DWORD PTR [rdx+rsi+1540]
	or	eax, DWORD PTR [rcx+rsi+2052]
	or	r9d, eax
	mov	eax, edi
	shr	edi, 10
	and	eax, 63					; 0000003fH
	or	r8d, DWORD PTR [rsi+rax*8+1024]
	or	r9d, DWORD PTR [rsi+rax*8+1028]
	mov	eax, edi
	and	eax, 63					; 0000003fH
	shr	edi, 6
	or	r8d, DWORD PTR [rsi+rax*8+512]
	or	r9d, DWORD PTR [rsi+rax*8+516]
	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+24]
	and	eax, 63					; 0000003fH
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rcx+rsi]
	or	eax, r8d
	mov	DWORD PTR ?ary@?1??_ufc_dofinalperm@@YAPEAIIIII@Z@4PAIA, eax
	mov	eax, DWORD PTR [rcx+rsi+4]
	mov	rsi, QWORD PTR [rsp+16]
	or	eax, r9d
	mov	DWORD PTR ?ary@?1??_ufc_dofinalperm@@YAPEAIIIII@Z@4PAIA+4, eax
	lea	rax, OFFSET FLAT:?ary@?1??_ufc_dofinalperm@@YAPEAIIIII@Z@4PAIA
	ret	0
?_ufc_dofinalperm@@YAPEAIIIII@Z ENDP			; _ufc_dofinalperm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?output_conversion@@YAPEADIIPEAD@Z
_TEXT	SEGMENT
v1$ = 8
v2$ = 16
salt$ = 24
?output_conversion@@YAPEADIIPEAD@Z PROC			; output_conversion, COMDAT

; 763  :     int32_t i, s;
; 764  : 
; 765  :     outbuf[0] = salt[0];

	movzx	eax, BYTE PTR [r8]
	mov	r11d, edx
	mov	r10d, ecx
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA, al

; 766  :     outbuf[1] = salt[1] ? salt[1] : salt[0];

	movzx	eax, BYTE PTR [r8+1]
	test	al, al
	jne	SHORT $LN10@output_con
	movzx	eax, BYTE PTR [r8]
$LN10@output_con:
	mov	edx, 26
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA+1, al
	lea	r8, OFFSET FLAT:?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA+2
	mov	ecx, edx
$LL6@output_con:

; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);

	mov	eax, r10d
	shr	eax, cl
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN13@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN12@output_con
$LN13@output_con:
	cmp	eax, 12
	jb	SHORT $LN11@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN12@output_con
$LN11@output_con:
	add	eax, 46					; 0000002eH
$LN12@output_con:

; 767  : 
; 768  :     for(i = 0; i < 5; i++)

	sub	ecx, 6

; 769  :       outbuf[i + 2] = bin_to_ascii((v1 >> (26 - 6 * i)) & 0x3f);

	mov	BYTE PTR [r8], al
	inc	r8
	cmp	ecx, -4
	jg	SHORT $LL6@output_con

; 770  : 
; 771  :     s  = (v2 & 0xf) << 2;

	mov	eax, r11d

; 772  :     v2 = (v2 >> 2) | ((v1 & 0x3) << 30);

	shl	r10d, 30
	shr	r11d, 2
	and	eax, 15
	or	r10d, r11d
	lea	r8, OFFSET FLAT:?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA+7
	lea	r9d, DWORD PTR [rax*4]
	npad	2
$LL3@output_con:

; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);

	mov	eax, r10d
	mov	ecx, edx
	shr	eax, cl
	and	eax, 63					; 0000003fH
	cmp	eax, 38					; 00000026H
	jb	SHORT $LN17@output_con
	add	eax, 59					; 0000003bH
	jmp	SHORT $LN16@output_con
$LN17@output_con:
	cmp	eax, 12
	jb	SHORT $LN15@output_con
	add	eax, 53					; 00000035H
	jmp	SHORT $LN16@output_con
$LN15@output_con:
	add	eax, 46					; 0000002eH
$LN16@output_con:

; 773  : 
; 774  :     for(i = 5; i < 10; i++)

	sub	edx, 6

; 775  :       outbuf[i + 2] = bin_to_ascii((v2 >> (56 - 6 * i)) & 0x3f);

	mov	BYTE PTR [r8], al
	inc	r8
	cmp	edx, -4
	jg	SHORT $LL3@output_con

; 776  : 
; 777  :     outbuf[12] = bin_to_ascii(s);

	cmp	r9d, 38					; 00000026H
	jl	SHORT $LN21@output_con
	add	r9d, 59					; 0000003bH
	jmp	SHORT $LN20@output_con
$LN21@output_con:
	cmp	r9d, 12
	jl	SHORT $LN19@output_con
	add	r9d, 53					; 00000035H
	jmp	SHORT $LN20@output_con
$LN19@output_con:
	add	r9d, 46					; 0000002eH
$LN20@output_con:
	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA+12, r9b

; 778  :     outbuf[13] = 0;

	mov	BYTE PTR ?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA+13, 0

; 779  : 
; 780  :     return outbuf;

	lea	rax, OFFSET FLAT:?outbuf@?1??output_conversion@@YAPEADIIPEAD@Z@4PADA

; 781  :   }

	ret	0
?output_conversion@@YAPEADIIPEAD@Z ENDP			; output_conversion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?crypt@@YAPEADPEAD0@Z
_TEXT	SEGMENT
ktab$ = 48
__$ArrayPad$ = 64
key$ = 96
salt$ = 104
?crypt@@YAPEADPEAD0@Z PROC				; crypt, COMDAT

; 790  :   { ufc_long *s;

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 791  :     char ktab[9];
; 792  : 
; 793  :     /*
; 794  :      * Hack DES tables according to salt
; 795  :      */
; 796  :     setup_salt(salt);

	mov	rcx, rdx
	mov	rdi, rdx
	call	?setup_salt@@YAXPEAD@Z			; setup_salt

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	lea	rcx, QWORD PTR ktab$[rsp]
	mov	r8d, 8
	mov	rdx, rbx

; 419  :       *start++ = '\0';

	mov	QWORD PTR ktab$[rsp], 0
	mov	BYTE PTR ktab$[rsp+8], 0

; 797  : 
; 798  :     /*
; 799  :      * Setup key schedule
; 800  :      */
; 801  :     clearmem(ktab, sizeof ktab);
; 802  :     (void)strncpy(ktab, key, 8);

	call	strncpy

; 803  :     ufc_mk_keytab(ktab);

	lea	rcx, QWORD PTR ktab$[rsp]
	call	?ufc_mk_keytab@@YAXPEAD@Z		; ufc_mk_keytab

; 804  : 
; 805  :     /*
; 806  :      * Go for the 25 DES encryptions
; 807  :      */
; 808  :     s = _ufc_doit((ufc_long)0, (ufc_long)0, 
; 809  :                   (ufc_long)0, (ufc_long)0, (ufc_long)25);

	call	?_ufc_doit@@YAPEAIIIIII@Z		; _ufc_doit

; 810  : 
; 811  :     /*
; 812  :      * And convert back to 6 bit ASCII
; 813  :      */
; 814  :     return output_conversion(s[0], s[1], salt);

	mov	r8, rdi
	mov	edx, DWORD PTR [rax+4]
	mov	ecx, DWORD PTR [rax]
	call	?output_conversion@@YAPEADIIPEAD@Z	; output_conversion

; 815  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?crypt@@YAPEADPEAD0@Z ENDP				; crypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?_ufc_doit@@YAPEAIIIIII@Z
_TEXT	SEGMENT
l1$dead$ = 48
l2$dead$ = 56
r1$dead$ = 64
r2$dead$ = 72
itr$dead$ = 80
?_ufc_doit@@YAPEAIIIIII@Z PROC				; _ufc_doit, COMDAT

; 970  :   { int32_t i;

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	xor	eax, eax
	mov	edi, 25
	lea	r14, OFFSET FLAT:?_ufc_keytab@@3PAY01IA	; _ufc_keytab
	mov	r10d, eax
	mov	r11d, eax
	mov	ebx, eax
	lea	rbp, OFFSET FLAT:__ImageBase
	npad	9
$LL4@ufc_doit:

; 971  :     long32 s, *k;
; 972  : 
; 973  :     while(itr--) {

	dec	edi

; 974  :       k = &_ufc_keytab[0][0];

	mov	r9, r14

; 975  :       for(i=8; i--; ) {

	mov	esi, 8
	npad	6
$LL2@ufc_doit:

; 976  :         s = *k++ ^ r1;

	mov	r8d, DWORD PTR [r9]

; 977  :         l1 ^= SBA(_ufc_sb1, s & 0xffff); l2 ^= SBA(_ufc_sb1, (s & 0xffff)+4);  
; 978  :         l1 ^= SBA(_ufc_sb0, s >>= 16);   l2 ^= SBA(_ufc_sb0, (s)         +4); 
; 979  :         s = *k++ ^ r2; 
; 980  :         l1 ^= SBA(_ufc_sb3, s & 0xffff); l2 ^= SBA(_ufc_sb3, (s & 0xffff)+4);
; 981  :         l1 ^= SBA(_ufc_sb2, s >>= 16);   l2 ^= SBA(_ufc_sb2, (s)         +4);
; 982  : 
; 983  :         s = *k++ ^ l1; 
; 984  :         r1 ^= SBA(_ufc_sb1, s & 0xffff); r2 ^= SBA(_ufc_sb1, (s & 0xffff)+4);  
; 985  :         r1 ^= SBA(_ufc_sb0, s >>= 16);   r2 ^= SBA(_ufc_sb0, (s)         +4); 
; 986  :         s = *k++ ^ l2; 

	lea	r9, QWORD PTR [r9+16]
	xor	r8d, r10d
	movzx	ecx, r8w
	movzx	edx, r8w
	shr	r8d, 16
	xor	ebx, DWORD PTR ?_ufc_sb1@@3PAIA[rdx+rbp]
	add	ecx, 4
	xor	r11d, DWORD PTR ?_ufc_sb1@@3PAIA[rcx+rbp]
	xor	ebx, DWORD PTR ?_ufc_sb0@@3PAIA[r8+rbp]
	lea	ecx, DWORD PTR [r8+4]
	xor	r11d, DWORD PTR ?_ufc_sb0@@3PAIA[rcx+rbp]
	mov	r8d, DWORD PTR [r9-12]
	xor	r8d, eax
	movzx	ecx, r8w
	movzx	edx, r8w
	shr	r8d, 16
	xor	ebx, DWORD PTR ?_ufc_sb3@@3PAIA[rdx+rbp]
	add	ecx, 4
	xor	r11d, DWORD PTR ?_ufc_sb3@@3PAIA[rcx+rbp]
	xor	ebx, DWORD PTR ?_ufc_sb2@@3PAIA[r8+rbp]
	lea	ecx, DWORD PTR [r8+4]
	xor	r11d, DWORD PTR ?_ufc_sb2@@3PAIA[rcx+rbp]
	mov	r8d, DWORD PTR [r9-8]
	xor	r8d, ebx
	movzx	ecx, r8w
	movzx	edx, r8w
	shr	r8d, 16
	xor	r10d, DWORD PTR ?_ufc_sb1@@3PAIA[rdx+rbp]
	add	ecx, 4
	xor	eax, DWORD PTR ?_ufc_sb1@@3PAIA[rcx+rbp]
	xor	r10d, DWORD PTR ?_ufc_sb0@@3PAIA[r8+rbp]
	lea	ecx, DWORD PTR [r8+4]
	xor	eax, DWORD PTR ?_ufc_sb0@@3PAIA[rcx+rbp]
	mov	r8d, DWORD PTR [r9-4]
	xor	r8d, r11d

; 987  :         r1 ^= SBA(_ufc_sb3, s & 0xffff); r2 ^= SBA(_ufc_sb3, (s & 0xffff)+4);  

	movzx	ecx, r8w
	movzx	edx, r8w

; 988  :         r1 ^= SBA(_ufc_sb2, s >>= 16);   r2 ^= SBA(_ufc_sb2, (s)         +4);

	shr	r8d, 16
	xor	r10d, DWORD PTR ?_ufc_sb3@@3PAIA[rdx+rbp]
	add	ecx, 4
	xor	eax, DWORD PTR ?_ufc_sb3@@3PAIA[rcx+rbp]
	xor	r10d, DWORD PTR ?_ufc_sb2@@3PAIA[r8+rbp]
	lea	ecx, DWORD PTR [r8+4]
	xor	eax, DWORD PTR ?_ufc_sb2@@3PAIA[rcx+rbp]
	dec	esi
	jne	$LL2@ufc_doit

; 989  :       } 
; 990  :       s=l1; l1=r1; r1=s; s=l2; l2=r2; r2=s;

	mov	edx, ebx
	mov	r9d, r11d
	mov	ebx, r10d
	mov	r11d, eax
	mov	r10d, edx
	mov	eax, r9d
	test	edi, edi
	jne	$LL4@ufc_doit

; 991  :     }
; 992  :     return _ufc_dofinalperm(l1, l2, r1, r2);

	mov	r8d, edx
	mov	ecx, ebx
	mov	edx, r11d

; 993  :   }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 991  :     }
; 992  :     return _ufc_dofinalperm(l1, l2, r1, r2);

	jmp	?_ufc_dofinalperm@@YAPEAIIIII@Z		; _ufc_dofinalperm
?_ufc_doit@@YAPEAIIIIII@Z ENDP				; _ufc_doit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z
_TEXT	SEGMENT
var9$9$ = 0
var3$3$ = 0
var1$1$ = 0
var0$13$ = 0
var0$7$ = 0
var10$8$ = 4
tv1971 = 8
var5$13$ = 96
var5$12$ = 96
expansionFunction$ = 96
expandedKeySchedule$ = 104
dataBlocks$ = 112
var9$2$ = 120
var8$4$ = 120
var3$10$ = 120
var3$5$ = 120
var1$7$ = 120
var0$14$ = 120
keyScheduleIndexBase$ = 120
?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z PROC			; CPU_DES_SBoxes1, COMDAT

; 1581 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 24

; 1582 : 	vtype var0;
; 1583 : 	vtype var1;
; 1584 : 	vtype var2;
; 1585 : 	vtype var3; 
; 1586 : 	vtype var4; 
; 1587 : 	vtype var5; 
; 1588 : 	vtype var6; 
; 1589 : 	vtype var7; 
; 1590 : 	vtype var8; 
; 1591 : 	vtype var9; 
; 1592 : 	vtype var10; 
; 1593 : 	vtype var11; 
; 1594 : 	vtype var12; 
; 1595 : 	vtype var13; 
; 1596 : 	vtype var14; 
; 1597 : 	vtype var15; 
; 1598 : 	vtype var16; 
; 1599 : 	vtype var17; 
; 1600 : 	vtype var18;  
; 1601 : 
; 1602 : 	s1(x( 0),     x( 1),     x( 2),     x( 3),     x( 4),     x( 5),     z(40), z(48), z(54), z(62));

	movzx	eax, BYTE PTR [rcx]
	movsxd	r9, r9d
	mov	rbx, r8
	mov	r14d, DWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [rcx+1]
	mov	r11, rdx
	mov	eax, DWORD PTR [r8+rax*4]
	xor	r14d, DWORD PTR [rdx+r9*4]
	mov	QWORD PTR tv1971[rsp], r9
	xor	eax, DWORD PTR [rdx+r9*4+4]
	mov	DWORD PTR var1$1$[rsp], eax
	movzx	eax, BYTE PTR [rcx+2]
	mov	r10d, DWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [rcx+3]
	mov	r8d, DWORD PTR [r8+rax*4]
	xor	r10d, DWORD PTR [rdx+r9*4+8]
	movzx	eax, BYTE PTR [rcx+4]
	mov	r12d, DWORD PTR [rbx+rax*4]
	xor	r8d, DWORD PTR [rdx+r9*4+12]
	movzx	eax, BYTE PTR [rcx+5]
	xor	r12d, DWORD PTR [rdx+r9*4+16]
	mov	edx, DWORD PTR [rbx+rax*4]
	mov	ecx, r10d
	xor	edx, DWORD PTR [r11+r9*4+20]
	xor	ecx, r14d
	mov	ebx, r12d
	mov	eax, ecx
	not	ebx
	not	ecx
	and	ebx, r14d
	mov	esi, edx
	mov	r15d, edx
	mov	r13d, ebx
	or	r15d, r10d
	xor	esi, r12d
	and	eax, r15d
	xor	r13d, r8d
	and	ecx, esi
	mov	r9d, eax
	or	eax, edx
	not	ebx
	xor	r9d, r8d
	and	ebx, r10d
	mov	edi, esi
	xor	edi, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	mov	r11d, r13d
	not	edi
	not	r11d
	not	ebx
	and	edi, r13d
	and	r11d, r9d
	not	r9d
	xor	edi, eax
	mov	eax, edx
	and	r9d, r12d
	or	eax, r14d
	mov	ebp, r11d
	mov	edx, eax
	not	eax
	not	ebp
	and	eax, r8d
	mov	r8d, DWORD PTR var1$1$[rsp]
	or	edx, edi
	xor	eax, r9d
	and	ebp, edi
	and	edi, r15d
	or	eax, ecx
	mov	ecx, r9d
	mov	DWORD PTR var9$2$[rsp], eax
	xor	ecx, edx
	mov	eax, r13d
	xor	eax, edx
	and	ebx, eax
	mov	eax, ebx
	not	eax
	xor	edi, eax
	mov	eax, r8d
	not	eax
	and	ecx, eax
	xor	ecx, edi
	xor	DWORD PTR [r10+216], ecx
	or	r13d, r12d
	mov	eax, ebp
	or	eax, r8d
	or	r11d, r8d
	mov	ecx, esi
	xor	r11d, DWORD PTR [r10+160]
	xor	ecx, ebx

; 1603 : 	s2(x( 6),     x( 7),     x( 8),     x( 9),     x(10),     x(11),     z(44), z(59), z(33), z(49));

	mov	rbx, QWORD PTR expandedKeySchedule$[rsp]
	or	ecx, r9d
	xor	ecx, r15d
	xor	r15d, edx
	mov	rdx, QWORD PTR tv1971[rsp]
	or	r15d, DWORD PTR var9$2$[rsp]
	xor	ecx, r14d
	and	ebp, ecx
	xor	edi, ecx
	xor	r15d, ecx
	mov	rcx, QWORD PTR expansionFunction$[rsp]
	or	esi, edi
	xor	r11d, edi
	mov	DWORD PTR [r10+160], r11d
	xor	eax, esi
	xor	eax, DWORD PTR [r10+192]
	xor	eax, r15d
	not	r15d
	mov	DWORD PTR [r10+192], eax
	and	r13d, r15d
	xor	r13d, ebp
	or	r13d, r8d
	xor	r13d, DWORD PTR var9$2$[rsp]
	xor	DWORD PTR [r10+248], r13d
	movzx	eax, BYTE PTR [rcx+6]
	mov	ebp, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rcx+7]
	mov	r8d, DWORD PTR [r10+rax*4]
	xor	ebp, DWORD PTR [rbx+rdx*4+24]
	movzx	eax, BYTE PTR [rcx+8]
	mov	esi, DWORD PTR [r10+rax*4]
	xor	r8d, DWORD PTR [rbx+rdx*4+28]
	movzx	eax, BYTE PTR [rcx+9]
	mov	r11d, DWORD PTR [r10+rax*4]
	xor	esi, DWORD PTR [rbx+rdx*4+32]
	movzx	eax, BYTE PTR [rcx+10]
	mov	r15d, DWORD PTR [r10+rax*4]
	xor	r11d, DWORD PTR [rbx+rdx*4+36]
	movzx	eax, BYTE PTR [rcx+11]
	mov	ecx, DWORD PTR [r10+rax*4]
	xor	r15d, DWORD PTR [rbx+rdx*4+40]
	mov	DWORD PTR var3$3$[rsp], r11d
	xor	ecx, DWORD PTR [rbx+rdx*4+44]
	mov	r9d, r15d
	xor	r9d, r8d
	mov	r13d, ecx
	mov	edi, ecx
	not	r13d
	and	edi, esi
	mov	edx, r9d
	mov	eax, r13d
	and	r13d, r9d
	and	edx, ebp
	and	eax, ebp
	mov	ebx, r13d
	xor	edx, r15d
	not	eax
	mov	r10d, edi
	not	ebx
	and	eax, r15d
	not	r10d
	mov	r14d, ebx
	xor	r13d, eax
	mov	r12d, eax
	mov	eax, r10d
	or	r12d, r8d
	not	ebp
	and	r14d, edx
	and	r13d, r12d
	and	eax, r13d
	and	r13d, esi
	xor	ebp, r13d
	xor	r9d, ecx
	mov	rcx, QWORD PTR dataBlocks$[rsp]
	not	eax
	and	r10d, r9d
	and	eax, r11d
	mov	DWORD PTR var8$4$[rsp], r9d
	mov	r9d, r10d
	xor	eax, DWORD PTR [rcx+236]
	xor	r9d, ebp
	not	r10d
	xor	eax, r9d
	and	r10d, r8d
	mov	DWORD PTR [rcx+236], eax
	xor	r13d, r10d
	mov	r11d, r10d
	xor	r11d, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	not	r11d
	mov	r8d, r11d
	and	r8d, ebp
	mov	ebp, DWORD PTR var8$4$[rsp]
	mov	ecx, ebp
	xor	ecx, esi
	mov	esi, DWORD PTR var3$3$[rsp]
	xor	r8d, ecx
	or	r14d, esi
	mov	eax, esi
	not	eax
	and	eax, r12d
	xor	r12d, r9d
	xor	eax, DWORD PTR [rdx+176]
	or	ebp, r12d
	or	edi, r12d
	xor	eax, r8d
	mov	DWORD PTR [rdx+176], eax
	mov	edx, r13d
	xor	r13d, r8d
	mov	r8, QWORD PTR dataBlocks$[rsp]
	or	edx, ecx

; 1604 : 	s3(y( 7, 12), y( 8, 13), y( 9, 14), y(10, 15), y(11, 16), y(12, 17), z(55), z(47), z(61), z(37));

	mov	rcx, QWORD PTR tv1971[rsp]
	and	r13d, edi
	xor	r13d, r15d
	and	r13d, ebx
	xor	r13d, r9d
	and	r11d, r13d
	mov	eax, r13d
	mov	r13d, DWORD PTR [r8+48]
	or	eax, esi
	xor	r11d, r14d
	xor	eax, DWORD PTR [r8+132]
	xor	r11d, ebp
	xor	DWORD PTR [r8+196], r11d
	xor	eax, edx
	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	eax, edi
	mov	DWORD PTR [r8+132], eax
	mov	r14d, DWORD PTR [rdx+rcx*4+52]
	mov	r11d, DWORD PTR [rdx+rcx*4+48]
	xor	r11d, DWORD PTR [r8+28]
	mov	eax, DWORD PTR [rdx+rcx*4+56]
	mov	r9d, DWORD PTR [rdx+rcx*4+60]
	xor	eax, DWORD PTR [r8+36]
	mov	r12d, DWORD PTR [rdx+rcx*4+64]
	mov	ebx, DWORD PTR [rdx+rcx*4+68]
	xor	r9d, DWORD PTR [r8+40]
	xor	r14d, DWORD PTR [r8+32]
	xor	r12d, DWORD PTR [r8+44]
	xor	ebx, r13d
	mov	DWORD PTR var3$5$[rsp], eax
	mov	r8d, r14d
	mov	edx, ebx
	not	r8d
	mov	ebp, r11d
	xor	edx, eax
	mov	eax, r8d
	mov	ecx, ebx
	and	eax, r11d
	not	ebp
	xor	ecx, r9d
	or	eax, edx
	and	ebp, ecx
	mov	DWORD PTR var0$7$[rsp], r11d
	mov	r10d, edx
	and	edx, ecx
	mov	r15d, ebp
	xor	r15d, eax
	xor	r10d, r14d
	not	edx
	mov	esi, r15d
	mov	edi, ebx
	not	edi
	and	esi, ebx
	and	ebx, r9d
	and	edi, r10d
	or	esi, r9d
	and	r8d, ebx
	xor	edi, eax
	and	esi, r11d
	mov	r11, QWORD PTR dataBlocks$[rsp]
	xor	esi, r10d
	mov	eax, r12d
	not	eax
	and	eax, r15d
	xor	eax, DWORD PTR [r11+148]
	xor	eax, esi
	mov	DWORD PTR [r11+148], eax
	mov	r11d, edi
	not	edi
	and	edi, r15d
	mov	eax, r9d
	mov	r9d, DWORD PTR var3$5$[rsp]
	xor	eax, DWORD PTR var0$7$[rsp]
	not	edi
	mov	ecx, r9d
	xor	r11d, eax
	or	ebp, eax
	not	ecx
	or	r11d, DWORD PTR var3$5$[rsp]
	and	edi, r12d
	or	r9d, r14d
	mov	r14, QWORD PTR dataBlocks$[rsp]
	and	r11d, edx
	mov	edx, ebp
	not	edx
	mov	eax, r10d
	xor	ebp, r10d
	or	eax, ebx
	and	edx, esi
	not	ebp
	xor	edx, r8d
	and	ecx, edx
	or	edx, r12d
	not	ecx
	and	ecx, eax
	mov	eax, r11d
	xor	r11d, DWORD PTR var0$7$[rsp]
	and	eax, r12d
	or	r11d, ebp
	xor	ecx, eax
	mov	rax, QWORD PTR dataBlocks$[rsp]
	xor	r11d, edx
	xor	ecx, DWORD PTR [rax+188]
	xor	r11d, DWORD PTR [r14+244]

; 1605 : 	s4(y(11, 18), y(12, 19), y(13, 20), y(14, 21), y(15, 22), y(16, 23), z(57), z(51), z(41), z(32));

	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	ecx, DWORD PTR var0$7$[rsp]
	xor	r11d, esi
	mov	DWORD PTR [rax+188], ecx
	mov	rcx, QWORD PTR tv1971[rsp]
	xor	r11d, r15d
	xor	r11d, r9d
	mov	eax, r9d
	not	eax
	mov	DWORD PTR [r14+244], r11d
	and	eax, r15d
	xor	edi, eax
	xor	edi, ebp
	xor	DWORD PTR [r14+220], edi
	mov	edi, DWORD PTR [rdx+rcx*4+76]
	mov	eax, DWORD PTR [rdx+rcx*4+80]
	mov	r15d, DWORD PTR [rdx+rcx*4+84]
	xor	eax, DWORD PTR [r14+52]
	xor	edi, r13d
	xor	r15d, DWORD PTR [r14+56]
	mov	r10d, DWORD PTR [rdx+rcx*4+72]
	mov	ebx, DWORD PTR [rdx+rcx*4+88]
	mov	r12d, DWORD PTR [rdx+rcx*4+92]
	xor	r12d, DWORD PTR [r14+64]
	xor	ebx, DWORD PTR [r14+60]
	xor	r10d, DWORD PTR [r14+44]
	xor	r10d, eax
	mov	r9d, r15d
	mov	edx, ebx
	xor	edx, eax
	or	r9d, edi
	mov	r14d, edi
	xor	r9d, ebx
	not	r14d
	and	r14d, edx
	not	r9d
	and	r9d, edx
	mov	ecx, r14d
	or	r14d, ebx
	xor	ecx, r15d
	mov	eax, r9d
	xor	r15d, edi
	not	eax
	mov	r8d, ecx
	not	r15d
	or	r8d, r10d
	and	r8d, eax
	mov	ebp, r8d
	xor	ebp, edi
	mov	eax, ebp
	mov	r11d, ebp
	xor	eax, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	and	r11d, ecx
	xor	r14d, eax
	mov	esi, r11d
	mov	ecx, r15d
	not	esi
	and	ecx, r14d
	and	esi, edx

; 1606 : 	s5(x(24),     x(25),     x(26),     x(27),     x(28),     x(29),     z(39), z(45), z(56), z(34));

	mov	rdx, QWORD PTR expansionFunction$[rsp]
	xor	ecx, r8d
	mov	r8, QWORD PTR tv1971[rsp]
	not	esi
	and	esi, eax
	xor	esi, r9d
	mov	r9, QWORD PTR expandedKeySchedule$[rsp]
	mov	eax, esi
	not	eax
	and	eax, r12d
	xor	eax, ecx
	not	ecx
	xor	DWORD PTR [r10+228], eax
	mov	eax, r12d
	not	eax
	and	eax, esi
	xor	esi, ecx
	xor	eax, DWORD PTR [r10+204]
	and	esi, r15d
	xor	eax, ecx
	or	esi, r11d
	mov	DWORD PTR [r10+204], eax
	mov	eax, ebp
	and	ebp, r12d
	xor	ebp, DWORD PTR [r10+128]
	or	eax, r12d
	xor	esi, r14d
	xor	eax, esi
	xor	ebp, esi
	xor	DWORD PTR [r10+164], eax
	mov	DWORD PTR [r10+128], ebp
	movzx	eax, BYTE PTR [rdx+24]
	mov	r13d, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rdx+25]
	mov	eax, DWORD PTR [r10+rax*4]
	xor	r13d, DWORD PTR [r9+r8*4+96]
	xor	eax, DWORD PTR [r9+r8*4+100]
	mov	DWORD PTR var1$7$[rsp], eax
	movzx	eax, BYTE PTR [rdx+26]
	mov	ecx, DWORD PTR [r10+rax*4]
	xor	ecx, DWORD PTR [r9+r8*4+104]
	movzx	eax, BYTE PTR [rdx+27]
	mov	esi, ecx
	mov	r14d, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rdx+28]
	or	esi, r13d
	mov	ebx, DWORD PTR [r10+rax*4]
	xor	r14d, DWORD PTR [r9+r8*4+108]
	movzx	eax, BYTE PTR [rdx+29]
	mov	edx, DWORD PTR [r10+rax*4]
	xor	ebx, DWORD PTR [r9+r8*4+112]
	mov	ebp, r14d
	xor	edx, DWORD PTR [r9+r8*4+116]
	not	ebp
	mov	eax, edx
	not	eax
	and	eax, esi
	and	ebp, eax
	mov	r12d, eax
	xor	ebp, ecx
	xor	r12d, r13d
	mov	edi, r12d
	mov	r9d, ebp
	xor	edi, ecx
	and	r9d, ebx
	mov	r15d, edi
	or	edi, r13d
	xor	r9d, edi
	mov	r11d, edi
	and	edi, ebp
	xor	r9d, r14d
	and	r11d, r14d
	or	r15d, r14d
	xor	edx, r9d
	mov	r8d, r15d
	mov	eax, edx
	mov	DWORD PTR var9$9$[rsp], edx
	xor	r8d, ebx
	or	eax, r12d
	mov	edx, r13d
	mov	r10d, eax
	not	edx
	and	edx, eax
	and	r10d, ebx
	mov	ebx, DWORD PTR var1$7$[rsp]
	mov	ecx, edx
	xor	r11d, r10d
	mov	eax, ebx
	xor	ecx, ebp
	not	eax
	xor	r11d, r12d
	not	ecx
	and	ecx, r8d
	not	ecx
	and	ecx, eax
	mov	rax, QWORD PTR dataBlocks$[rsp]
	xor	ecx, DWORD PTR [rax+224]
	xor	ecx, r9d
	mov	r9d, r8d
	mov	DWORD PTR [rax+224], ecx
	xor	r9d, edx
	mov	edx, DWORD PTR var9$9$[rsp]
	or	r9d, r11d
	mov	eax, r10d
	not	eax
	and	eax, ebp
	not	eax
	and	r9d, eax
	and	edx, r9d
	xor	edx, r8d
	or	edi, edx
	mov	ecx, edx
	xor	edi, r10d
	and	ecx, r14d
	and	edi, ebx
	xor	ecx, esi
	xor	edi, r11d
	mov	r11, QWORD PTR dataBlocks$[rsp]
	xor	ecx, r9d
	xor	DWORD PTR [r11+136], edi
	xor	ecx, r13d
	not	r9d
	and	r9d, r15d
	mov	eax, r15d
	and	r15d, ebx
	xor	eax, ebp
	or	r9d, ebx

; 1607 : 	s6(x(30),     x(31),     x(32),     x(33),     x(34),     x(35),     z(35), z(60), z(42), z(50));

	mov	rbx, QWORD PTR expandedKeySchedule$[rsp]
	xor	r9d, DWORD PTR [r11+156]
	xor	r9d, ecx
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR expansionFunction$[rsp]
	mov	DWORD PTR [r11+156], r9d
	mov	r9, QWORD PTR tv1971[rsp]
	xor	eax, r15d
	xor	eax, DWORD PTR [r11+180]
	xor	eax, edx
	xor	eax, r12d
	mov	DWORD PTR [r11+180], eax
	movzx	eax, BYTE PTR [rcx+30]
	mov	edx, DWORD PTR [r11+rax*4]
	movzx	eax, BYTE PTR [rcx+31]
	mov	r13d, DWORD PTR [r11+rax*4]
	xor	edx, DWORD PTR [rbx+r9*4+120]
	movzx	eax, BYTE PTR [rcx+32]
	mov	r8d, DWORD PTR [r11+rax*4]
	xor	r13d, DWORD PTR [rbx+r9*4+124]
	movzx	eax, BYTE PTR [rcx+33]
	mov	r10d, DWORD PTR [r11+rax*4]
	xor	r8d, DWORD PTR [rbx+r9*4+128]
	movzx	eax, BYTE PTR [rcx+34]
	mov	r14d, DWORD PTR [r11+rax*4]
	xor	r10d, DWORD PTR [rbx+r9*4+132]
	movzx	eax, BYTE PTR [rcx+35]
	mov	ecx, DWORD PTR [r11+rax*4]
	xor	r14d, DWORD PTR [rbx+r9*4+136]
	mov	edi, r8d
	xor	ecx, DWORD PTR [rbx+r9*4+140]
	xor	edi, edx
	mov	DWORD PTR var3$10$[rsp], r10d
	mov	r12d, ecx
	mov	DWORD PTR var0$13$[rsp], edx
	mov	DWORD PTR var5$12$[rsp], ecx
	or	r12d, r13d
	mov	r15d, edi
	and	r12d, edx
	mov	ebp, r12d
	xor	ebp, r14d
	xor	ebp, r13d
	mov	eax, ebp
	xor	eax, ecx
	mov	ebx, eax
	and	eax, edx
	mov	edx, ecx
	mov	DWORD PTR var10$8$[rsp], eax
	xor	eax, r13d
	not	ebx
	or	r15d, eax
	and	ebx, r14d
	not	edx
	mov	r9d, r15d
	xor	r15d, r13d
	mov	ecx, ebx
	or	ecx, eax
	xor	r9d, ebp
	not	r15d
	mov	esi, r9d
	mov	r11d, ecx
	and	esi, r8d
	and	edx, esi
	xor	r11d, edx
	mov	eax, r11d
	and	eax, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	xor	eax, r9d
	xor	DWORD PTR [r10+200], eax
	mov	r10d, r15d
	and	r10d, DWORD PTR var5$12$[rsp]
	xor	r10d, r8d
	mov	r8d, esi
	not	r8d
	and	r8d, r14d
	or	ebx, DWORD PTR var3$10$[rsp]
	or	r9d, DWORD PTR var0$13$[rsp]
	not	edx
	and	r9d, ecx
	or	r8d, r10d
	or	edi, r13d
	xor	r9d, r10d
	xor	r10d, DWORD PTR var0$13$[rsp]
	xor	r15d, edi
	and	edx, r9d
	xor	ebp, r9d
	mov	eax, r8d
	or	eax, r12d
	xor	edx, ebx
	mov	rbx, QWORD PTR dataBlocks$[rsp]
	xor	DWORD PTR [rbx+168], edx
	mov	edx, DWORD PTR var3$10$[rsp]
	not	ebp
	and	ebp, r14d
	not	edx
	mov	ecx, r15d
	xor	ecx, ebp
	and	ecx, edx
	and	edx, r8d
	xor	ecx, eax
	mov	eax, DWORD PTR var10$8$[rsp]
	xor	eax, DWORD PTR var5$12$[rsp]
	xor	ecx, edi
	and	eax, r10d
	xor	ecx, r11d
	xor	DWORD PTR [rbx+240], ecx
	xor	eax, edx

; 1608 : 	s7(y(23, 36), y(24, 37), y(25, 38),	y(26, 39), y(27, 40), y(28, 41), z(63), z(43), z(53), z(38));

	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	eax, DWORD PTR [rbx+140]
	xor	eax, esi
	xor	eax, r15d
	mov	DWORD PTR [rbx+140], eax
	mov	rax, QWORD PTR tv1971[rsp]
	mov	r13d, DWORD PTR [rdx+rax*4+156]
	mov	ecx, DWORD PTR [rdx+rax*4+144]
	mov	r12d, DWORD PTR [rdx+rax*4+160]
	mov	r9d, DWORD PTR [rdx+rax*4+152]
	mov	r15d, DWORD PTR [rdx+rax*4+148]
	xor	ecx, DWORD PTR [rbx+92]
	xor	r13d, DWORD PTR [rbx+104]
	xor	r12d, DWORD PTR [rbx+108]
	xor	r9d, DWORD PTR [rbx+100]
	xor	r15d, DWORD PTR [rbx+96]
	mov	ebx, DWORD PTR [rdx+rax*4+164]
	mov	rax, QWORD PTR dataBlocks$[rsp]
	xor	ebx, DWORD PTR [rax+112]
	mov	r10d, r13d
	mov	DWORD PTR var0$14$[rsp], ecx
	xor	r10d, ecx
	mov	r14d, r12d
	mov	DWORD PTR var5$13$[rsp], ebx
	mov	esi, r10d
	not	r14d
	xor	esi, r12d
	mov	r8d, r14d
	and	r8d, r13d
	mov	ebp, esi
	xor	ebp, r9d
	mov	eax, r8d
	xor	eax, r15d
	mov	r11d, ebp
	mov	edx, eax
	not	r11d
	and	r11d, ecx
	or	edx, r9d
	xor	r11d, r8d
	xor	edx, esi
	mov	edi, r11d
	and	edi, eax
	mov	ecx, edi
	xor	ecx, r8d
	mov	r8, QWORD PTR dataBlocks$[rsp]
	mov	eax, ecx
	not	eax
	and	eax, ebx
	xor	eax, DWORD PTR [r8+152]
	xor	eax, edx
	or	r13d, r15d
	mov	edx, ebp
	mov	DWORD PTR [r8+152], eax
	xor	edx, ecx
	mov	rcx, QWORD PTR dataBlocks$[rsp]
	mov	ebx, r13d
	mov	r8d, r11d
	and	ebx, r9d
	mov	r9d, edx
	xor	edx, r15d
	not	r9d
	mov	eax, ebx
	not	ebx
	or	eax, DWORD PTR var0$14$[rsp]
	and	ebx, r10d
	mov	r10d, DWORD PTR var5$13$[rsp]
	and	esi, eax
	and	r9d, r11d
	not	r8d
	and	r8d, eax
	or	edx, esi
	not	r9d
	and	r9d, r13d
	and	esi, ebp
	mov	eax, r8d
	or	eax, r10d
	or	edi, esi
	xor	eax, DWORD PTR [rcx+252]
	and	edi, r14d
	xor	eax, r9d
	xor	r9d, ebx
	xor	eax, edx
	and	r9d, r10d
	mov	DWORD PTR [rcx+252], eax
	mov	ecx, ebx
	mov	eax, esi
	not	ecx
	xor	eax, r15d
	and	eax, ecx
	and	ecx, r12d
	xor	ecx, r8d
	xor	eax, r11d
	or	ecx, DWORD PTR var0$14$[rsp]
	xor	edx, eax
	not	eax
	and	edx, r10d
	xor	ecx, r9d
	xor	edi, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	xor	ecx, eax
	xor	DWORD PTR [rdx+172], ecx

; 1609 : 	s8(y(27, 42), y(28, 43), y(29, 44), y(30, 45), y(31, 46), y( 0, 47), z(36), z(58), z(46), z(52));

	mov	rcx, QWORD PTR expandedKeySchedule$[rsp]
	mov	rax, QWORD PTR tv1971[rsp]
	xor	edi, ebp
	xor	edi, r13d
	xor	DWORD PTR [rdx+212], edi
	mov	r9d, DWORD PTR [rcx+rax*4+176]
	mov	ebx, DWORD PTR [rcx+rax*4+172]
	xor	r9d, DWORD PTR [rdx+116]
	xor	ebx, DWORD PTR [rdx+112]
	mov	r14d, DWORD PTR [rcx+rax*4+184]
	xor	r14d, DWORD PTR [rdx+124]
	mov	r12d, DWORD PTR [rcx+rax*4+168]
	mov	r13d, DWORD PTR [rcx+rax*4+180]
	xor	r12d, DWORD PTR [rdx+108]
	xor	r13d, DWORD PTR [rdx+120]
	mov	r15d, DWORD PTR [rcx+rax*4+188]
	xor	r15d, DWORD PTR [rdx]
	mov	ebp, r9d
	mov	r10d, ebx
	not	ebp
	not	r10d
	and	r10d, r9d
	mov	edx, ebp
	and	edx, r14d
	mov	edi, r10d
	xor	edx, r13d
	not	edi
	mov	ecx, edx
	and	ecx, r12d
	and	edi, ecx
	not	edx
	and	ebp, ebx
	xor	ebp, r14d
	mov	esi, edx
	and	esi, ebx
	mov	eax, ebp
	mov	r11d, esi
	or	r11d, r12d
	and	eax, r11d
	not	r11d
	mov	r8d, eax
	and	r11d, r9d
	or	r8d, ecx
	xor	r11d, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	xor	r11d, eax
	mov	eax, edi
	or	eax, r15d
	xor	r10d, r11d
	xor	r11d, ebx
	xor	eax, DWORD PTR [rdx+232]
	xor	eax, r10d
	xor	r10d, r12d
	mov	DWORD PTR [rdx+232], eax
	mov	eax, r8d
	and	r8d, r15d
	xor	r8d, DWORD PTR [rdx+184]
	mov	ecx, r10d
	and	ecx, r14d
	xor	ecx, r11d
	or	r11d, r13d
	not	r13d
	xor	eax, ecx
	xor	esi, ecx
	or	eax, ebx
	xor	ebp, esi
	xor	eax, r10d
	xor	r11d, ebp
	xor	r14d, eax
	mov	eax, r11d
	and	r13d, r14d
	xor	eax, r12d
	xor	r8d, r14d
	and	r13d, ebp
	and	eax, r15d
	mov	DWORD PTR [rdx+184], r8d
	xor	r13d, edi
	xor	eax, esi
	xor	DWORD PTR [rdx+208], eax
	xor	r13d, r11d
	or	r13d, r15d
	xor	r13d, DWORD PTR [rdx+144]
	xor	r13d, esi
	mov	DWORD PTR [rdx+144], r13d

; 1610 : }

	add	rsp, 24
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z ENDP			; CPU_DES_SBoxes1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z
_TEXT	SEGMENT
var9$9$ = 0
var3$3$ = 0
var1$1$ = 0
var0$13$ = 0
var0$7$ = 0
var10$8$ = 4
tv1970 = 8
var5$13$ = 96
var5$12$ = 96
expansionFunction$ = 96
expandedKeySchedule$ = 104
dataBlocks$ = 112
var9$2$ = 120
var8$4$ = 120
var3$10$ = 120
var3$5$ = 120
var1$7$ = 120
var0$14$ = 120
keyScheduleIndexBase$ = 120
?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z PROC			; CPU_DES_SBoxes2, COMDAT

; 1613 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 24

; 1614 : 	vtype var0;
; 1615 : 	vtype var1;
; 1616 : 	vtype var2;
; 1617 : 	vtype var3; 
; 1618 : 	vtype var4; 
; 1619 : 	vtype var5; 
; 1620 : 	vtype var6; 
; 1621 : 	vtype var7; 
; 1622 : 	vtype var8; 
; 1623 : 	vtype var9; 
; 1624 : 	vtype var10; 
; 1625 : 	vtype var11; 
; 1626 : 	vtype var12; 
; 1627 : 	vtype var13; 
; 1628 : 	vtype var14; 
; 1629 : 	vtype var15; 
; 1630 : 	vtype var16; 
; 1631 : 	vtype var17; 
; 1632 : 	vtype var18; 
; 1633 : 
; 1634 : 	s1(x(48),     x(49),     x(50),     x(51),     x(52),     x(53),     z( 8), z(16), z(22), z(30));

	movzx	eax, BYTE PTR [rcx+48]
	movsxd	r9, r9d
	mov	rbx, r8
	mov	r14d, DWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [rcx+49]
	mov	r11, rdx
	mov	eax, DWORD PTR [r8+rax*4]
	xor	r14d, DWORD PTR [rdx+r9*4+192]
	mov	QWORD PTR tv1970[rsp], r9
	xor	eax, DWORD PTR [rdx+r9*4+196]
	mov	DWORD PTR var1$1$[rsp], eax
	movzx	eax, BYTE PTR [rcx+50]
	mov	r10d, DWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [rcx+51]
	mov	r8d, DWORD PTR [r8+rax*4]
	xor	r10d, DWORD PTR [rdx+r9*4+200]
	movzx	eax, BYTE PTR [rcx+52]
	mov	r12d, DWORD PTR [rbx+rax*4]
	xor	r8d, DWORD PTR [rdx+r9*4+204]
	movzx	eax, BYTE PTR [rcx+53]
	xor	r12d, DWORD PTR [rdx+r9*4+208]
	mov	edx, DWORD PTR [rbx+rax*4]
	mov	ecx, r10d
	xor	edx, DWORD PTR [r11+r9*4+212]
	xor	ecx, r14d
	mov	ebx, r12d
	mov	eax, ecx
	not	ebx
	not	ecx
	and	ebx, r14d
	mov	esi, edx
	mov	r15d, edx
	mov	r13d, ebx
	or	r15d, r10d
	xor	esi, r12d
	and	eax, r15d
	xor	r13d, r8d
	and	ecx, esi
	mov	r9d, eax
	or	eax, edx
	not	ebx
	xor	r9d, r8d
	and	ebx, r10d
	mov	edi, esi
	xor	edi, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	mov	r11d, r13d
	not	edi
	not	r11d
	not	ebx
	and	edi, r13d
	and	r11d, r9d
	not	r9d
	xor	edi, eax
	mov	eax, edx
	and	r9d, r12d
	or	eax, r14d
	mov	ebp, r11d
	mov	edx, eax
	not	eax
	not	ebp
	and	eax, r8d
	mov	r8d, DWORD PTR var1$1$[rsp]
	or	edx, edi
	xor	eax, r9d
	and	ebp, edi
	and	edi, r15d
	or	eax, ecx
	mov	ecx, r9d
	mov	DWORD PTR var9$2$[rsp], eax
	xor	ecx, edx
	mov	eax, r13d
	xor	eax, edx
	and	ebx, eax
	mov	eax, ebx
	not	eax
	xor	edi, eax
	mov	eax, r8d
	not	eax
	and	ecx, eax
	xor	ecx, DWORD PTR [r10+88]
	xor	ecx, edi
	or	r13d, r12d
	mov	eax, ebp
	mov	DWORD PTR [r10+88], ecx
	or	eax, r8d
	mov	ecx, esi
	xor	ecx, ebx

; 1635 : 	s2(x(54),     x(55),     x(56),     x(57),     x(58),     x(59),     z(12), z(27), z( 1), z(17));

	mov	rbx, QWORD PTR expandedKeySchedule$[rsp]
	or	r11d, r8d
	or	ecx, r9d
	xor	ecx, r15d
	xor	r15d, edx
	mov	rdx, QWORD PTR tv1970[rsp]
	or	r15d, DWORD PTR var9$2$[rsp]
	xor	ecx, r14d
	xor	edi, ecx
	xor	r15d, ecx
	and	ebp, ecx
	mov	rcx, QWORD PTR expansionFunction$[rsp]
	or	esi, edi
	xor	r11d, edi
	xor	DWORD PTR [r10+32], r11d
	xor	eax, esi
	xor	eax, DWORD PTR [r10+64]
	xor	eax, r15d
	not	r15d
	mov	DWORD PTR [r10+64], eax
	and	r13d, r15d
	xor	r13d, ebp
	or	r13d, r8d
	xor	r13d, DWORD PTR [r10+120]
	xor	r13d, DWORD PTR var9$2$[rsp]
	mov	DWORD PTR [r10+120], r13d
	movzx	eax, BYTE PTR [rcx+54]
	mov	ebp, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rcx+55]
	mov	r8d, DWORD PTR [r10+rax*4]
	xor	ebp, DWORD PTR [rbx+rdx*4+216]
	movzx	eax, BYTE PTR [rcx+56]
	mov	esi, DWORD PTR [r10+rax*4]
	xor	r8d, DWORD PTR [rbx+rdx*4+220]
	movzx	eax, BYTE PTR [rcx+57]
	mov	r11d, DWORD PTR [r10+rax*4]
	xor	esi, DWORD PTR [rbx+rdx*4+224]
	movzx	eax, BYTE PTR [rcx+58]
	mov	r15d, DWORD PTR [r10+rax*4]
	xor	r11d, DWORD PTR [rbx+rdx*4+228]
	movzx	eax, BYTE PTR [rcx+59]
	mov	ecx, DWORD PTR [r10+rax*4]
	xor	r15d, DWORD PTR [rbx+rdx*4+232]
	mov	DWORD PTR var3$3$[rsp], r11d
	xor	ecx, DWORD PTR [rbx+rdx*4+236]
	mov	r9d, r15d
	xor	r9d, r8d
	mov	r13d, ecx
	mov	edi, ecx
	not	r13d
	and	edi, esi
	mov	edx, r9d
	mov	eax, r13d
	and	r13d, r9d
	and	edx, ebp
	and	eax, ebp
	mov	ebx, r13d
	xor	edx, r15d
	not	eax
	mov	r10d, edi
	not	ebx
	and	eax, r15d
	not	r10d
	mov	r14d, ebx
	xor	r13d, eax
	mov	r12d, eax
	mov	eax, r10d
	or	r12d, r8d
	not	ebp
	and	r14d, edx
	and	r13d, r12d
	and	eax, r13d
	and	r13d, esi
	xor	ebp, r13d
	not	eax
	xor	r9d, ecx
	mov	rcx, QWORD PTR dataBlocks$[rsp]
	and	eax, r11d
	and	r10d, r9d
	mov	DWORD PTR var8$4$[rsp], r9d
	mov	r9d, r10d
	not	r10d
	xor	r9d, ebp
	and	r10d, r8d
	xor	eax, r9d
	xor	r13d, r10d
	mov	r11d, r10d
	xor	DWORD PTR [rcx+108], eax
	xor	r11d, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	not	r11d
	mov	r8d, r11d
	and	r8d, ebp
	mov	ebp, DWORD PTR var8$4$[rsp]
	mov	ecx, ebp
	xor	ecx, esi
	mov	esi, DWORD PTR var3$3$[rsp]
	xor	r8d, ecx
	or	r14d, esi
	mov	eax, esi
	not	eax
	and	eax, r12d
	xor	r12d, r9d
	xor	eax, DWORD PTR [rdx+48]
	or	ebp, r12d
	or	edi, r12d
	xor	eax, r8d
	mov	DWORD PTR [rdx+48], eax
	mov	edx, r13d
	xor	r13d, r8d
	mov	r8, QWORD PTR dataBlocks$[rsp]
	or	edx, ecx

; 1636 : 	s3(y(39, 60), y(40, 61), y(41, 62), y(42, 63), y(43, 64), y(44, 65), z(23), z(15), z(29), z( 5));

	mov	rcx, QWORD PTR tv1970[rsp]
	and	r13d, edi
	xor	r13d, r15d
	and	r13d, ebx
	xor	r13d, r9d
	and	r11d, r13d
	mov	eax, r13d
	mov	r13d, DWORD PTR [r8+176]
	or	eax, esi
	xor	r11d, r14d
	xor	eax, DWORD PTR [r8+4]
	xor	r11d, ebp
	xor	DWORD PTR [r8+68], r11d
	xor	eax, edx
	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	eax, edi
	mov	DWORD PTR [r8+4], eax
	mov	r14d, DWORD PTR [rdx+rcx*4+244]
	mov	r11d, DWORD PTR [rdx+rcx*4+240]
	xor	r11d, DWORD PTR [r8+156]
	mov	eax, DWORD PTR [rdx+rcx*4+248]
	mov	r9d, DWORD PTR [rdx+rcx*4+252]
	xor	eax, DWORD PTR [r8+164]
	mov	r12d, DWORD PTR [rdx+rcx*4+256]
	mov	ebx, DWORD PTR [rdx+rcx*4+260]
	xor	r9d, DWORD PTR [r8+168]
	xor	r14d, DWORD PTR [r8+160]
	xor	r12d, DWORD PTR [r8+172]
	xor	ebx, r13d
	mov	DWORD PTR var3$5$[rsp], eax
	mov	r8d, r14d
	mov	edx, ebx
	not	r8d
	mov	ebp, r11d
	xor	edx, eax
	mov	eax, r8d
	mov	ecx, ebx
	and	eax, r11d
	not	ebp
	xor	ecx, r9d
	or	eax, edx
	and	ebp, ecx
	mov	DWORD PTR var0$7$[rsp], r11d
	mov	r10d, edx
	and	edx, ecx
	mov	r15d, ebp
	xor	r15d, eax
	xor	r10d, r14d
	not	edx
	mov	edi, ebx
	mov	esi, r15d
	not	edi
	and	esi, ebx
	and	ebx, r9d
	and	edi, r10d
	or	esi, r9d
	and	r8d, ebx
	xor	edi, eax
	and	esi, r11d
	mov	r11, QWORD PTR dataBlocks$[rsp]
	xor	esi, r10d
	mov	eax, r12d
	not	eax
	and	eax, r15d
	xor	eax, DWORD PTR [r11+20]
	xor	eax, esi
	mov	DWORD PTR [r11+20], eax
	mov	r11d, edi
	not	edi
	and	edi, r15d
	mov	eax, r9d
	mov	r9d, DWORD PTR var3$5$[rsp]
	xor	eax, DWORD PTR var0$7$[rsp]
	not	edi
	mov	ecx, r9d
	xor	r11d, eax
	or	ebp, eax
	not	ecx
	or	r11d, DWORD PTR var3$5$[rsp]
	and	edi, r12d
	or	r9d, r14d
	mov	r14, QWORD PTR dataBlocks$[rsp]
	and	r11d, edx
	mov	edx, ebp
	not	edx
	mov	eax, r10d
	xor	ebp, r10d
	or	eax, ebx
	and	edx, esi
	not	ebp
	xor	edx, r8d
	and	ecx, edx
	or	edx, r12d
	not	ecx
	and	ecx, eax
	mov	eax, r11d
	xor	r11d, DWORD PTR var0$7$[rsp]
	and	eax, r12d
	or	r11d, ebp
	xor	ecx, eax
	mov	rax, QWORD PTR dataBlocks$[rsp]
	xor	r11d, edx
	xor	ecx, DWORD PTR [rax+60]
	xor	r11d, DWORD PTR [r14+116]

; 1637 : 	s4(y(43, 66), y(44, 67), y(45, 68), y(46, 69), y(47, 70), y(48, 71), z(25), z(19), z( 9), z( 0));

	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	ecx, DWORD PTR var0$7$[rsp]
	xor	r11d, esi
	mov	DWORD PTR [rax+60], ecx
	mov	rcx, QWORD PTR tv1970[rsp]
	xor	r11d, r15d
	xor	r11d, r9d
	mov	eax, r9d
	not	eax
	mov	DWORD PTR [r14+116], r11d
	and	eax, r15d
	xor	edi, eax
	xor	edi, DWORD PTR [r14+92]
	xor	edi, ebp
	mov	DWORD PTR [r14+92], edi
	mov	edi, DWORD PTR [rdx+rcx*4+268]
	mov	eax, DWORD PTR [rdx+rcx*4+272]
	mov	r15d, DWORD PTR [rdx+rcx*4+276]
	xor	edi, r13d
	xor	eax, DWORD PTR [r14+180]
	mov	r10d, DWORD PTR [rdx+rcx*4+264]
	mov	ebx, DWORD PTR [rdx+rcx*4+280]
	mov	r12d, DWORD PTR [rdx+rcx*4+284]
	xor	r15d, DWORD PTR [r14+184]
	xor	ebx, DWORD PTR [r14+188]
	xor	r12d, DWORD PTR [r14+192]
	xor	r10d, DWORD PTR [r14+172]
	mov	r9d, r15d
	mov	edx, ebx
	xor	edx, eax
	xor	r10d, eax
	or	r9d, edi
	xor	r9d, ebx
	mov	ebp, edi
	not	ebp
	not	r9d
	and	ebp, edx
	and	r9d, edx
	mov	ecx, ebp
	mov	eax, r9d
	or	ebp, ebx
	not	eax
	xor	ecx, r15d
	xor	r15d, edi
	mov	r8d, ecx
	not	r15d
	or	r8d, r10d
	and	r8d, eax
	mov	r14d, r8d
	xor	r14d, edi
	mov	eax, r14d
	mov	r11d, r14d
	xor	eax, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	and	r11d, ecx
	xor	ebp, eax
	mov	esi, r11d
	mov	ecx, r15d
	not	esi
	and	ecx, ebp
	and	esi, edx

; 1638 : 	s5(x(72),     x(73),     x(74),     x(75),     x(76),     x(77),     z( 7), z(13), z(24), z( 2));

	mov	rdx, QWORD PTR expansionFunction$[rsp]
	xor	ecx, r8d
	mov	r8, QWORD PTR tv1970[rsp]
	not	esi
	and	esi, eax
	xor	esi, r9d
	mov	r9, QWORD PTR expandedKeySchedule$[rsp]
	mov	eax, esi
	not	eax
	and	eax, r12d
	xor	eax, DWORD PTR [r10+100]
	xor	eax, ecx
	not	ecx
	mov	DWORD PTR [r10+100], eax
	mov	eax, r12d
	not	eax
	and	eax, esi
	xor	esi, ecx
	xor	eax, ecx
	and	esi, r15d
	xor	DWORD PTR [r10+76], eax
	mov	eax, r14d
	and	r14d, r12d
	xor	r14d, DWORD PTR [r10]
	or	eax, r12d
	or	esi, r11d
	xor	eax, DWORD PTR [r10+36]
	xor	esi, ebp
	xor	eax, esi
	xor	r14d, esi
	mov	DWORD PTR [r10+36], eax
	mov	DWORD PTR [r10], r14d
	movzx	eax, BYTE PTR [rdx+72]
	mov	r13d, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rdx+73]
	mov	eax, DWORD PTR [r10+rax*4]
	xor	r13d, DWORD PTR [r9+r8*4+288]
	xor	eax, DWORD PTR [r9+r8*4+292]
	mov	DWORD PTR var1$7$[rsp], eax
	movzx	eax, BYTE PTR [rdx+74]
	mov	ecx, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rdx+75]
	xor	ecx, DWORD PTR [r9+r8*4+296]
	mov	r14d, DWORD PTR [r10+rax*4]
	movzx	eax, BYTE PTR [rdx+76]
	mov	ebx, DWORD PTR [r10+rax*4]
	xor	r14d, DWORD PTR [r9+r8*4+300]
	movzx	eax, BYTE PTR [rdx+77]
	mov	edx, DWORD PTR [r10+rax*4]
	xor	ebx, DWORD PTR [r9+r8*4+304]
	mov	esi, ecx
	xor	edx, DWORD PTR [r9+r8*4+308]
	or	esi, r13d
	mov	ebp, r14d
	mov	eax, edx
	not	ebp
	not	eax
	and	eax, esi
	and	ebp, eax
	mov	r12d, eax
	xor	ebp, ecx
	xor	r12d, r13d
	mov	edi, r12d
	mov	r9d, ebp
	xor	edi, ecx
	and	r9d, ebx
	mov	r15d, edi
	or	edi, r13d
	xor	r9d, edi
	mov	r11d, edi
	and	edi, ebp
	xor	r9d, r14d
	and	r11d, r14d
	or	r15d, r14d
	xor	edx, r9d
	mov	r8d, r15d
	mov	eax, edx
	mov	DWORD PTR var9$9$[rsp], edx
	xor	r8d, ebx
	or	eax, r12d
	mov	edx, r13d
	mov	r10d, eax
	not	edx
	and	edx, eax
	and	r10d, ebx
	mov	ebx, DWORD PTR var1$7$[rsp]
	mov	ecx, edx
	xor	r11d, r10d
	mov	eax, ebx
	xor	ecx, ebp
	not	eax
	xor	r11d, r12d
	not	ecx
	and	ecx, r8d
	not	ecx
	and	ecx, eax
	mov	rax, QWORD PTR dataBlocks$[rsp]
	xor	ecx, DWORD PTR [rax+96]
	xor	ecx, r9d
	mov	r9d, r8d
	mov	DWORD PTR [rax+96], ecx
	xor	r9d, edx
	mov	edx, DWORD PTR var9$9$[rsp]
	or	r9d, r11d
	mov	eax, r10d
	not	eax
	and	eax, ebp
	not	eax
	and	r9d, eax
	mov	rax, QWORD PTR dataBlocks$[rsp]
	and	edx, r9d
	xor	edx, r8d
	or	edi, edx
	mov	ecx, edx
	xor	edi, r10d
	and	edi, ebx
	xor	edi, DWORD PTR [rax+8]
	xor	edi, r11d
	mov	r11, rax
	and	ecx, r14d
	mov	DWORD PTR [rax+8], edi
	xor	ecx, esi
	xor	ecx, r9d
	not	r9d
	and	r9d, r15d
	xor	ecx, r13d
	or	r9d, ebx
	xor	r9d, DWORD PTR [rax+28]
	xor	r9d, ecx
	not	ecx
	mov	DWORD PTR [rax+28], r9d

; 1639 : 	s6(x(78),     x(79),     x(80),     x(81),     x(82),     x(83),     z( 3), z(28), z(10), z(18));

	mov	r9, QWORD PTR tv1970[rsp]
	mov	eax, r15d
	xor	eax, ebp
	and	r15d, ebx
	mov	rbx, QWORD PTR expandedKeySchedule$[rsp]
	and	eax, ecx
	mov	rcx, QWORD PTR expansionFunction$[rsp]
	xor	eax, r15d
	xor	eax, edx
	xor	eax, r12d
	xor	DWORD PTR [r11+52], eax
	movzx	eax, BYTE PTR [rcx+78]
	mov	edx, DWORD PTR [r11+rax*4]
	movzx	eax, BYTE PTR [rcx+79]
	mov	r13d, DWORD PTR [r11+rax*4]
	xor	edx, DWORD PTR [rbx+r9*4+312]
	movzx	eax, BYTE PTR [rcx+80]
	mov	r8d, DWORD PTR [r11+rax*4]
	xor	r13d, DWORD PTR [rbx+r9*4+316]
	movzx	eax, BYTE PTR [rcx+81]
	mov	r10d, DWORD PTR [r11+rax*4]
	movzx	eax, BYTE PTR [rcx+82]
	xor	r8d, DWORD PTR [rbx+r9*4+320]
	mov	r14d, DWORD PTR [r11+rax*4]
	xor	r10d, DWORD PTR [rbx+r9*4+324]
	movzx	eax, BYTE PTR [rcx+83]
	mov	ecx, DWORD PTR [r11+rax*4]
	xor	r14d, DWORD PTR [rbx+r9*4+328]
	mov	DWORD PTR var0$13$[rsp], edx
	xor	ecx, DWORD PTR [rbx+r9*4+332]
	mov	DWORD PTR var3$10$[rsp], r10d
	mov	edi, r8d
	xor	edi, edx
	mov	r12d, ecx
	mov	DWORD PTR var5$12$[rsp], ecx
	or	r12d, r13d
	mov	r15d, edi
	and	r12d, edx
	mov	ebp, r12d
	xor	ebp, r14d
	xor	ebp, r13d
	mov	eax, ebp
	xor	eax, ecx
	mov	r11d, eax
	and	eax, edx
	mov	edx, ecx
	mov	DWORD PTR var10$8$[rsp], eax
	xor	eax, r13d
	not	r11d
	or	r15d, eax
	and	r11d, r14d
	not	edx
	mov	r9d, r15d
	xor	r15d, r13d
	mov	ecx, r11d
	or	ecx, eax
	xor	r9d, ebp
	not	r15d
	mov	esi, r9d
	mov	ebx, ecx
	and	esi, r8d
	and	edx, esi
	xor	ebx, edx
	mov	eax, ebx
	and	eax, r10d
	mov	r10, QWORD PTR dataBlocks$[rsp]
	xor	eax, DWORD PTR [r10+72]
	xor	eax, r9d
	mov	DWORD PTR [r10+72], eax
	mov	r10d, r15d
	and	r10d, DWORD PTR var5$12$[rsp]
	or	r11d, DWORD PTR var3$10$[rsp]
	or	r9d, DWORD PTR var0$13$[rsp]
	xor	r10d, r8d
	and	r9d, ecx
	not	edx
	or	edi, r13d
	xor	r9d, r10d
	xor	r15d, edi
	mov	r8d, esi
	and	edx, r9d
	xor	ebp, r9d
	not	r8d
	xor	edx, r11d
	mov	r11, QWORD PTR dataBlocks$[rsp]
	and	r8d, r14d
	xor	DWORD PTR [r11+40], edx
	mov	edx, DWORD PTR var3$10$[rsp]
	or	r8d, r10d
	xor	r10d, DWORD PTR var0$13$[rsp]
	not	edx
	mov	eax, r8d
	or	eax, r12d
	not	ebp
	mov	ecx, r15d
	and	ebp, r14d
	xor	ecx, ebp
	and	ecx, edx
	and	edx, r8d
	xor	ecx, eax
	mov	eax, DWORD PTR var10$8$[rsp]
	xor	eax, DWORD PTR var5$12$[rsp]
	xor	ecx, DWORD PTR [r11+112]
	and	eax, r10d
	xor	ecx, edi
	xor	eax, edx

; 1640 : 	s7(y(55, 84), y(56, 85), y(57, 86), y(58, 87), y(59, 88), y(60, 89), z(31), z(11), z(21), z( 6));

	mov	rdx, QWORD PTR expandedKeySchedule$[rsp]
	xor	ecx, ebx
	mov	DWORD PTR [r11+112], ecx
	xor	eax, esi
	xor	eax, r15d
	xor	DWORD PTR [r11+12], eax
	mov	rax, QWORD PTR tv1970[rsp]
	mov	r13d, DWORD PTR [rdx+rax*4+348]
	mov	ecx, DWORD PTR [rdx+rax*4+336]
	mov	r12d, DWORD PTR [rdx+rax*4+352]
	xor	ecx, DWORD PTR [r11+220]
	mov	r9d, DWORD PTR [rdx+rax*4+344]
	mov	r15d, DWORD PTR [rdx+rax*4+340]
	mov	ebx, DWORD PTR [rdx+rax*4+356]
	xor	r13d, DWORD PTR [r11+232]
	xor	r12d, DWORD PTR [r11+236]
	xor	r9d, DWORD PTR [r11+228]
	xor	r15d, DWORD PTR [r11+224]
	xor	ebx, DWORD PTR [r11+240]
	mov	r10d, r13d
	mov	DWORD PTR var0$14$[rsp], ecx
	mov	r14d, r12d
	xor	r10d, ecx
	not	r14d
	mov	DWORD PTR var5$13$[rsp], ebx
	mov	esi, r10d
	mov	r8d, r14d
	xor	esi, r12d
	and	r8d, r13d
	mov	ebp, esi
	mov	eax, r8d
	xor	eax, r15d
	xor	ebp, r9d
	mov	edx, eax
	mov	r11d, ebp
	not	r11d
	or	edx, r9d
	and	r11d, ecx
	xor	edx, esi
	xor	r11d, r8d
	mov	edi, r11d
	and	edi, eax
	mov	ecx, edi
	xor	ecx, r8d
	mov	eax, ecx
	not	eax
	mov	r8, QWORD PTR dataBlocks$[rsp]
	and	eax, ebx
	or	r13d, r15d
	xor	eax, DWORD PTR [r8+24]
	mov	ebx, r13d
	xor	eax, edx
	and	ebx, r9d
	mov	edx, ebp
	mov	DWORD PTR [r8+24], eax
	xor	edx, ecx
	mov	rcx, QWORD PTR dataBlocks$[rsp]
	mov	r9d, edx
	xor	edx, r15d
	mov	eax, ebx
	or	eax, DWORD PTR var0$14$[rsp]
	not	r9d
	not	ebx
	and	esi, eax
	and	ebx, r10d
	mov	r10d, DWORD PTR var5$13$[rsp]
	or	edx, esi
	and	r9d, r11d
	and	esi, ebp
	or	edi, esi
	not	r9d
	mov	r8d, r11d
	and	r9d, r13d
	and	edi, r14d
	not	r8d
	and	r8d, eax
	mov	eax, r8d
	or	eax, r10d
	xor	eax, DWORD PTR [rcx+124]
	xor	eax, r9d
	xor	r9d, ebx
	xor	eax, edx
	and	r9d, r10d
	mov	DWORD PTR [rcx+124], eax
	mov	ecx, ebx
	mov	eax, esi
	not	ecx
	xor	eax, r15d
	and	eax, ecx
	and	ecx, r12d
	xor	ecx, r8d
	xor	eax, r11d
	or	ecx, DWORD PTR var0$14$[rsp]
	xor	edx, eax
	not	eax
	and	edx, r10d
	xor	ecx, r9d
	xor	edi, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	xor	ecx, eax
	xor	DWORD PTR [rdx+44], ecx
	xor	edi, DWORD PTR [rdx+84]

; 1641 : 	s8(y(59, 90), y(60, 91), y(61, 92), y(62, 93), y(63, 94), y(32, 95), z( 4), z(26), z(14), z(20));

	mov	rax, QWORD PTR tv1970[rsp]
	mov	rcx, QWORD PTR expandedKeySchedule$[rsp]
	xor	edi, ebp
	xor	edi, r13d
	mov	DWORD PTR [rdx+84], edi
	mov	r9d, DWORD PTR [rcx+rax*4+368]
	mov	ebx, DWORD PTR [rcx+rax*4+364]
	xor	r9d, DWORD PTR [rdx+244]
	xor	ebx, DWORD PTR [rdx+240]
	mov	r14d, DWORD PTR [rcx+rax*4+376]
	xor	r14d, DWORD PTR [rdx+252]
	mov	r15d, DWORD PTR [rcx+rax*4+360]
	mov	r13d, DWORD PTR [rcx+rax*4+372]
	xor	r15d, DWORD PTR [rdx+236]
	xor	r13d, DWORD PTR [rdx+248]
	mov	r12d, DWORD PTR [rcx+rax*4+380]
	xor	r12d, DWORD PTR [rdx+128]
	mov	ebp, r9d
	mov	r10d, ebx
	not	ebp
	not	r10d
	mov	edx, ebp
	and	r10d, r9d
	and	edx, r14d
	xor	edx, r13d
	mov	ecx, edx
	not	edx
	and	ebp, ebx
	and	ecx, r15d
	xor	ebp, r14d
	mov	esi, r10d
	mov	edi, edx
	mov	eax, ebp
	not	esi
	and	esi, ecx
	and	edi, ebx
	mov	r11d, edi
	or	r11d, r15d
	and	eax, r11d
	not	r11d
	mov	r8d, eax
	and	r11d, r9d
	or	r8d, ecx
	xor	r11d, edx
	mov	rdx, QWORD PTR dataBlocks$[rsp]
	xor	r11d, eax
	mov	eax, esi
	or	eax, r12d
	xor	r10d, r11d
	xor	r11d, ebx
	xor	eax, DWORD PTR [rdx+104]
	xor	eax, r10d
	xor	r10d, r15d
	mov	DWORD PTR [rdx+104], eax
	mov	eax, r8d
	and	r8d, r12d
	xor	r8d, DWORD PTR [rdx+56]
	mov	ecx, r10d
	and	ecx, r14d
	xor	ecx, r11d
	or	r11d, r13d
	not	r13d
	xor	eax, ecx
	xor	edi, ecx
	or	eax, ebx
	xor	ebp, edi
	xor	eax, r10d
	xor	r11d, ebp
	xor	r14d, eax
	mov	eax, r11d
	and	r13d, r14d
	xor	eax, r15d
	xor	r8d, r14d
	and	r13d, ebp
	and	eax, r12d
	mov	DWORD PTR [rdx+56], r8d
	xor	eax, DWORD PTR [rdx+80]
	xor	r13d, esi
	xor	r13d, r11d
	xor	eax, edi
	or	r13d, r12d
	mov	DWORD PTR [rdx+80], eax
	xor	r13d, edi
	xor	DWORD PTR [rdx+16], r13d

; 1642 : }

	add	rsp, 24
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z ENDP			; CPU_DES_SBoxes2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_GetTripcode@@YAPEAEPEAUDES_Context@@HPEAE@Z
_TEXT	SEGMENT
context$ = 8
tripcodeIndex$ = 16
tripcode$ = 24
?DES_GetTripcode@@YAPEAEPEAUDES_Context@@HPEAE@Z PROC	; DES_GetTripcode, COMDAT

; 1675 : {

	mov	r11, rcx

; 1676 : 	// Perform the final permutation as necessary.
; 1677 :   	tripcode[0] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 63, 31, 38,  6, 46, 14, 0)];

	and	edx, 31
	mov	r9d, 0
	movzx	ecx, dl
	mov	eax, r9d
	mov	edx, r9d
	mov	r10d, 1
	shl	r10d, cl
	test	DWORD PTR [r11+3420], r10d
	setne	dl
	add	edx, edx
	test	DWORD PTR [r11+3292], r10d
	setne	al
	or	edx, eax
	mov	eax, r9d
	add	edx, edx
	test	DWORD PTR [r11+3320], r10d
	setne	al
	or	edx, eax
	mov	eax, r9d
	add	edx, edx
	test	DWORD PTR [r11+3192], r10d
	setne	al
	or	edx, eax
	mov	eax, r9d
	add	edx, edx
	test	DWORD PTR [r11+3352], r10d
	setne	al
	or	edx, eax
	mov	eax, r9d
	add	edx, edx
	test	DWORD PTR [r11+3224], r10d
	setne	al
	movsxd	rcx, edx
	lea	rdx, OFFSET FLAT:DES_indexToCharTable
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1678 :   	tripcode[1] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 54, 22, 62, 30, 37,  5, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8], al
	test	DWORD PTR [r11+3384], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3256], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3416], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3288], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3316], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3188], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1679 :   	tripcode[2] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 45, 13, 53, 21, 61, 29, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+1], al
	test	DWORD PTR [r11+3348], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3220], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3380], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3252], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3412], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3284], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1680 :   	tripcode[3] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 36,  4, 44, 12, 52, 20, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+2], al
	test	DWORD PTR [r11+3312], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3184], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3344], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3216], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3376], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3248], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1681 :   	tripcode[4] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 60, 28, 35,  3, 43, 11, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+3], al
	test	DWORD PTR [r11+3408], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3280], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3308], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3180], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3340], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3212], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]
	mov	BYTE PTR [r8+4], al

; 1682 :   	tripcode[5] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 51, 19, 59, 27, 34,  2, 0)];

	test	DWORD PTR [r11+3372], r10d
	mov	eax, r9d
	mov	ecx, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3244], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3404], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3276], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3304], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3176], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1683 :   	tripcode[6] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 42, 10, 50, 18, 58, 26, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+5], al
	test	DWORD PTR [r11+3336], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3208], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3368], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3240], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3400], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3272], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1684 :   	tripcode[7] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 33,  1, 41,  9, 49, 17, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+6], al
	test	DWORD PTR [r11+3300], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3172], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3332], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3204], r10d
	setne	al
	or	ecx, eax
	add	ecx, ecx
	test	DWORD PTR [r11+3364], r10d
	mov	eax, r9d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3236], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1685 :   	tripcode[8] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX(context->dataBlocks, tripcodeIndex, 57, 25, 32,  0, 40,  8, 0)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+7], al
	test	DWORD PTR [r11+3396], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3268], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3296], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3168], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3328], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3200], r10d
	setne	al
	movsxd	rcx, ecx
	or	rcx, rax
	movzx	eax, BYTE PTR [rcx+rdx]

; 1686 : 	tripcode[9] = DES_indexToCharTable[GET_TRIPCODE_CHAR_INDEX_LAST(context->dataBlocks, tripcodeIndex, 48, 16, 56, 24)];

	mov	ecx, r9d
	mov	BYTE PTR [r8+8], al
	test	DWORD PTR [r11+3360], r10d
	mov	eax, r9d
	setne	cl
	add	ecx, ecx
	test	DWORD PTR [r11+3232], r10d
	setne	al
	or	ecx, eax
	mov	eax, r9d
	add	ecx, ecx
	test	DWORD PTR [r11+3392], r10d
	setne	al
	or	ecx, eax
	test	DWORD PTR [r11+3264], r10d

; 1687 :  	tripcode[10] = '\0';

	mov	BYTE PTR [r8+10], 0
	lea	eax, DWORD PTR [rcx+rcx]
	setne	r9b
	or	eax, r9d
	shl	eax, 2
	cdqe
	movzx	eax, BYTE PTR [rax+rdx]
	mov	BYTE PTR [r8+9], al

; 1688 : 
; 1689 : 	return tripcode;

	mov	rax, r8

; 1690 : }

	ret	0
?DES_GetTripcode@@YAPEAEPEAUDES_Context@@HPEAE@Z ENDP	; DES_GetTripcode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_SetSalt@@YAXPEAUDES_Context@@H@Z
_TEXT	SEGMENT
context$ = 8
salt$ = 16
?DES_SetSalt@@YAXPEAUDES_Context@@H@Z PROC		; DES_SetSalt, COMDAT

; 1703 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 1704 : 	int32_t mask;
; 1705 : 	int32_t src, dst;
; 1706 : 
; 1707 : 	mask = 1;

	mov	ebx, 1

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	xor	r9d, r9d
	lea	r10, QWORD PTR [rcx+24]
	lea	r11, QWORD PTR [rcx+72]
	lea	rdi, OFFSET FLAT:?expansionTable@@3QBEB	; expansionTable
	lea	rax, QWORD PTR [rbx-25]
	mov	r8d, ebx
	npad	8
$LL8@DES_SetSal:

; 1709 : 		if (dst == 24) mask = 1;

	cmp	r9d, 24
	cmove	r8d, ebx

; 1710 : 
; 1711 : 		if (salt & mask) {

	test	r8d, edx
	je	SHORT $LN4@DES_SetSal

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	cmp	r9d, 24
	jge	SHORT $LN3@DES_SetSal
	lea	rcx, QWORD PTR [rax+48]
	jmp	SHORT $LN1@DES_SetSal
$LN3@DES_SetSal:
	mov	rcx, rax
	jmp	SHORT $LN1@DES_SetSal
$LN4@DES_SetSal:

; 1713 : 		} else src = dst;

	lea	rcx, QWORD PTR [rax+24]
$LN1@DES_SetSal:

; 1714 : 
; 1715 : 		context->expansionFunction[dst     ] = expansionTable[src];

	movzx	ecx, BYTE PTR [rcx+rdi]
	inc	r9d
	inc	rax
	mov	BYTE PTR [r10+rax-1], cl

; 1716 : 		context->expansionFunction[dst + 48] = expansionTable[src] + 32;

	add	cl, 32					; 00000020H

; 1717 : 
; 1718 : 		mask <<= 1;

	add	r8d, r8d
	mov	BYTE PTR [r11+rax-1], cl
	cmp	r9d, 48					; 00000030H
	jl	SHORT $LL8@DES_SetSal

; 1719 : 	}
; 1720 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?DES_SetSalt@@YAXPEAUDES_Context@@H@Z ENDP		; DES_SetSalt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?DES_Crypt25@@YAXPEAUDES_Context@@@Z
_TEXT	SEGMENT
context$ = 64
?DES_Crypt25@@YAXPEAUDES_Context@@@Z PROC		; DES_Crypt25, COMDAT

; 1783 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1784 : 	int32_t iterations, roundsAndSwapped; 
; 1785 : 	int32_t keyScheduleIndexBase = 0;

	xor	ebx, ebx
	mov	rbp, rcx

; 1788 : 	iterations = 25;

	lea	edi, QWORD PTR [rbx+25]
$LN17@DES_Crypt2:

; 1786 : 
; 1787 : 	roundsAndSwapped = 8;

	mov	esi, 8
	npad	11
$start$19:

; 1789 : 
; 1790 : start:
; 1791 : 	CPU_DES_SBoxes1(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r8, QWORD PTR [rbp+3168]
	lea	rdx, QWORD PTR [rbp+96]
	mov	r9d, ebx
	mov	rcx, rbp
	call	?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes1

; 1792 : 
; 1793 : 	if (roundsAndSwapped == 0x100)

	cmp	esi, 256				; 00000100H
	jne	SHORT $LN9@DES_Crypt2

; 1806 : 		goto swap;
; 1807 : 	return;
; 1808 : 
; 1809 : next:
; 1810 : 	keyScheduleIndexBase -= (0x300 - 48);

	sub	ebx, 720				; 000002d0H
$next$20:

; 1811 : 	roundsAndSwapped = 8;
; 1812 : 	iterations--;

	dec	edi

; 1813 : 	goto start;

	jmp	SHORT $LN17@DES_Crypt2
$LN9@DES_Crypt2:

; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r8, QWORD PTR [rbp+3168]
	lea	rdx, QWORD PTR [rbp+96]
	mov	r9d, ebx
	mov	rcx, rbp
	call	?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes2

; 1798 : 
; 1799 : 	keyScheduleIndexBase += 96;

	add	ebx, 96					; 00000060H

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	dec	esi
	jne	SHORT $start$19
$swap$21:

; 1802 : 		goto start;
; 1803 : 	keyScheduleIndexBase -= (0x300 + 48);
; 1804 : 	roundsAndSwapped = 0x108;
; 1805 : 	if (--iterations)

	dec	edi
	je	SHORT $LN1@DES_Crypt2

; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r9d, DWORD PTR [rbx-816]
	lea	r8, QWORD PTR [rbp+3168]
	lea	rdx, QWORD PTR [rbp+96]
	mov	rcx, rbp
	call	?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes2

; 1798 : 
; 1799 : 	keyScheduleIndexBase += 96;

	add	ebx, -720				; fffffffffffffd30H

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	mov	esi, 263				; 00000107H
	jmp	SHORT $start$19
$LN1@DES_Crypt2:

; 1814 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?DES_Crypt25@@YAXPEAUDES_Context@@@Z ENDP		; DES_Crypt25
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\github\merikens-tripcode-engine\sourcefiles\verification10.cpp
;	COMDAT ?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z
_TEXT	SEGMENT
tripcodeIndex$1$ = 32
numTripcodes$1$ = 36
context$ = 48
__$ArrayPad$ = 3760
p$ = 3824
numTripcodes$ = 3832
?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z PROC ; Generate10CharTripcodes, COMDAT

; 1869 : {

$LN177:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-3520]
	sub	rsp, 3776				; 00000ec0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1870 : 	DES_Context context;
; 1871 : 
; 1872 : 	CLEAR_KEYS(0);

	xor	esi, esi
	mov	r12d, edx
	mov	DWORD PTR numTripcodes$1$[rsp], edx

; 1873 : 	CLEAR_KEYS(1);
; 1874 : 	CLEAR_KEYS(2);
; 1875 : 	CLEAR_KEYS(3);

	mov	ebx, esi
	mov	r15, rcx
	mov	QWORD PTR context$[rbp+3220], rsi
	mov	QWORD PTR context$[rbp+3228], rsi
	mov	QWORD PTR context$[rbp+3236], rsi
	mov	r9d, esi
	mov	DWORD PTR context$[rbp+3328], ebx
	mov	DWORD PTR context$[rbp+3244], esi
	mov	QWORD PTR context$[rbp+3248], rsi
	mov	QWORD PTR context$[rbp+3256], rsi
	mov	QWORD PTR context$[rbp+3264], rsi
	mov	r10d, esi
	mov	DWORD PTR context$[rbp+3272], esi
	mov	QWORD PTR context$[rbp+3276], rsi
	mov	QWORD PTR context$[rbp+3284], rsi
	mov	QWORD PTR context$[rbp+3292], rsi
	mov	r11d, esi
	mov	DWORD PTR context$[rbp+3300], esi
	mov	QWORD PTR context$[rbp+3304], rsi
	mov	QWORD PTR context$[rbp+3312], rsi
	mov	QWORD PTR context$[rbp+3320], rsi

; 1876 : 	CLEAR_KEYS(4);

	mov	QWORD PTR context$[rbp+3332], rsi
	mov	QWORD PTR context$[rbp+3340], rsi
	mov	QWORD PTR context$[rbp+3348], rsi
	mov	edi, esi
	mov	DWORD PTR context$[rbp+3356], esi

; 1877 : 	CLEAR_KEYS(5);

	mov	QWORD PTR context$[rbp+3360], rsi
	mov	QWORD PTR context$[rbp+3368], rsi
	mov	QWORD PTR context$[rbp+3376], rsi
	mov	r14d, esi
	mov	DWORD PTR context$[rbp+3384], esi

; 1878 : 	CLEAR_KEYS(6);

	mov	QWORD PTR context$[rbp+3388], rsi
	mov	QWORD PTR context$[rbp+3396], rsi
	mov	QWORD PTR context$[rbp+3404], rsi
	mov	r13d, esi
	mov	DWORD PTR context$[rbp+3412], esi

; 1879 : 	CLEAR_KEYS(7);

	mov	QWORD PTR context$[rbp+3416], rsi
	mov	QWORD PTR context$[rbp+3424], rsi
	mov	QWORD PTR context$[rbp+3432], rsi
	mov	r8d, esi
	mov	DWORD PTR context$[rbp+3440], esi

; 1880 : 
; 1881 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	mov	DWORD PTR tripcodeIndex$1$[rsp], esi
	test	edx, edx
	jle	$LN66@Generate10
	lea	ecx, QWORD PTR [rsi+1]
	mov	esi, ebx
	npad	13
$LL68@Generate10:

; 1882 : 		SET_BIT_FOR_KEY( 0, 0, 0);

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rdx, QWORD PTR [r15+rax*8]
	movzx	eax, BYTE PTR [r15+rax*8+12]
	test	al, 1
	je	SHORT $LN65@Generate10
	or	DWORD PTR context$[rbp+3220], ecx
$LN65@Generate10:

; 1883 : 		SET_BIT_FOR_KEY( 1, 0, 1);

	test	al, 2
	je	SHORT $LN64@Generate10
	or	DWORD PTR context$[rbp+3224], ecx
$LN64@Generate10:

; 1884 : 		SET_BIT_FOR_KEY( 2, 0, 2);

	test	al, 4
	je	SHORT $LN63@Generate10
	or	DWORD PTR context$[rbp+3228], ecx
$LN63@Generate10:

; 1885 : 		SET_BIT_FOR_KEY( 3, 0, 3);

	test	al, 8
	je	SHORT $LN62@Generate10
	or	DWORD PTR context$[rbp+3232], ecx
$LN62@Generate10:

; 1886 : 		SET_BIT_FOR_KEY( 4, 0, 4);

	test	al, 16
	je	SHORT $LN61@Generate10
	or	DWORD PTR context$[rbp+3236], ecx
$LN61@Generate10:

; 1887 : 		SET_BIT_FOR_KEY( 5, 0, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN60@Generate10
	or	DWORD PTR context$[rbp+3240], ecx
$LN60@Generate10:

; 1888 : 		SET_BIT_FOR_KEY( 6, 0, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN59@Generate10
	or	r9d, ecx
$LN59@Generate10:

; 1889 : 
; 1890 : 		SET_BIT_FOR_KEY( 7, 1, 0);

	movzx	eax, BYTE PTR [rdx+13]
	test	al, 1
	je	SHORT $LN58@Generate10
	or	DWORD PTR context$[rbp+3248], ecx
$LN58@Generate10:

; 1891 : 		SET_BIT_FOR_KEY( 8, 1, 1);

	test	al, 2
	je	SHORT $LN57@Generate10
	or	DWORD PTR context$[rbp+3252], ecx
$LN57@Generate10:

; 1892 : 		SET_BIT_FOR_KEY( 9, 1, 2);

	test	al, 4
	je	SHORT $LN56@Generate10
	or	DWORD PTR context$[rbp+3256], ecx
$LN56@Generate10:

; 1893 : 		SET_BIT_FOR_KEY(10, 1, 3);

	test	al, 8
	je	SHORT $LN55@Generate10
	or	DWORD PTR context$[rbp+3260], ecx
$LN55@Generate10:

; 1894 : 		SET_BIT_FOR_KEY(11, 1, 4);

	test	al, 16
	je	SHORT $LN54@Generate10
	or	DWORD PTR context$[rbp+3264], ecx
$LN54@Generate10:

; 1895 : 		SET_BIT_FOR_KEY(12, 1, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN53@Generate10
	or	DWORD PTR context$[rbp+3268], ecx
$LN53@Generate10:

; 1896 : 		SET_BIT_FOR_KEY(13, 1, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN52@Generate10
	or	r10d, ecx
$LN52@Generate10:

; 1897 : 	
; 1898 : 		SET_BIT_FOR_KEY(14, 2, 0);

	movzx	eax, BYTE PTR [rdx+14]
	test	al, 1
	je	SHORT $LN51@Generate10
	or	DWORD PTR context$[rbp+3276], ecx
$LN51@Generate10:

; 1899 : 		SET_BIT_FOR_KEY(15, 2, 1);

	test	al, 2
	je	SHORT $LN50@Generate10
	or	DWORD PTR context$[rbp+3280], ecx
$LN50@Generate10:

; 1900 : 		SET_BIT_FOR_KEY(16, 2, 2);

	test	al, 4
	je	SHORT $LN49@Generate10
	or	DWORD PTR context$[rbp+3284], ecx
$LN49@Generate10:

; 1901 : 		SET_BIT_FOR_KEY(17, 2, 3);

	test	al, 8
	je	SHORT $LN48@Generate10
	or	DWORD PTR context$[rbp+3288], ecx
$LN48@Generate10:

; 1902 : 		SET_BIT_FOR_KEY(18, 2, 4);

	test	al, 16
	je	SHORT $LN47@Generate10
	or	DWORD PTR context$[rbp+3292], ecx
$LN47@Generate10:

; 1903 : 		SET_BIT_FOR_KEY(19, 2, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN46@Generate10
	or	DWORD PTR context$[rbp+3296], ecx
$LN46@Generate10:

; 1904 : 		SET_BIT_FOR_KEY(20, 2, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN45@Generate10
	or	r11d, ecx
$LN45@Generate10:

; 1905 : 
; 1906 : 		SET_BIT_FOR_KEY(21, 3, 0);

	movzx	eax, BYTE PTR [rdx+15]
	test	al, 1
	je	SHORT $LN44@Generate10
	or	DWORD PTR context$[rbp+3304], ecx
$LN44@Generate10:

; 1907 : 		SET_BIT_FOR_KEY(22, 3, 1);

	test	al, 2
	je	SHORT $LN43@Generate10
	or	DWORD PTR context$[rbp+3308], ecx
$LN43@Generate10:

; 1908 : 		SET_BIT_FOR_KEY(23, 3, 2);

	test	al, 4
	je	SHORT $LN42@Generate10
	or	DWORD PTR context$[rbp+3312], ecx
$LN42@Generate10:

; 1909 : 		SET_BIT_FOR_KEY(24, 3, 3);

	test	al, 8
	je	SHORT $LN41@Generate10
	or	DWORD PTR context$[rbp+3316], ecx
$LN41@Generate10:

; 1910 : 		SET_BIT_FOR_KEY(25, 3, 4);

	test	al, 16
	je	SHORT $LN40@Generate10
	or	DWORD PTR context$[rbp+3320], ecx
$LN40@Generate10:

; 1911 : 		SET_BIT_FOR_KEY(26, 3, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN39@Generate10
	or	DWORD PTR context$[rbp+3324], ecx
$LN39@Generate10:

; 1912 : 		SET_BIT_FOR_KEY(27, 3, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN38@Generate10
	or	ebx, ecx
$LN38@Generate10:

; 1913 : 
; 1914 : 		SET_BIT_FOR_KEY(28, 4, 0);

	movzx	eax, BYTE PTR [rdx+16]
	test	al, 1
	je	SHORT $LN37@Generate10
	or	DWORD PTR context$[rbp+3332], ecx
$LN37@Generate10:

; 1915 : 		SET_BIT_FOR_KEY(29, 4, 1);

	test	al, 2
	je	SHORT $LN36@Generate10
	or	DWORD PTR context$[rbp+3336], ecx
$LN36@Generate10:

; 1916 : 		SET_BIT_FOR_KEY(30, 4, 2);

	test	al, 4
	je	SHORT $LN35@Generate10
	or	DWORD PTR context$[rbp+3340], ecx
$LN35@Generate10:

; 1917 : 		SET_BIT_FOR_KEY(31, 4, 3);

	test	al, 8
	je	SHORT $LN34@Generate10
	or	DWORD PTR context$[rbp+3344], ecx
$LN34@Generate10:

; 1918 : 		SET_BIT_FOR_KEY(32, 4, 4);

	test	al, 16
	je	SHORT $LN33@Generate10
	or	DWORD PTR context$[rbp+3348], ecx
$LN33@Generate10:

; 1919 : 		SET_BIT_FOR_KEY(33, 4, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN32@Generate10
	or	DWORD PTR context$[rbp+3352], ecx
$LN32@Generate10:

; 1920 : 		SET_BIT_FOR_KEY(34, 4, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN31@Generate10
	or	edi, ecx
$LN31@Generate10:

; 1921 : 
; 1922 : 		SET_BIT_FOR_KEY(35, 5, 0);

	movzx	eax, BYTE PTR [rdx+17]
	test	al, 1
	je	SHORT $LN30@Generate10
	or	DWORD PTR context$[rbp+3360], ecx
$LN30@Generate10:

; 1923 : 		SET_BIT_FOR_KEY(36, 5, 1);

	test	al, 2
	je	SHORT $LN29@Generate10
	or	DWORD PTR context$[rbp+3364], ecx
$LN29@Generate10:

; 1924 : 		SET_BIT_FOR_KEY(37, 5, 2);

	test	al, 4
	je	SHORT $LN28@Generate10
	or	DWORD PTR context$[rbp+3368], ecx
$LN28@Generate10:

; 1925 : 		SET_BIT_FOR_KEY(38, 5, 3);

	test	al, 8
	je	SHORT $LN27@Generate10
	or	DWORD PTR context$[rbp+3372], ecx
$LN27@Generate10:

; 1926 : 		SET_BIT_FOR_KEY(39, 5, 4);

	test	al, 16
	je	SHORT $LN26@Generate10
	or	DWORD PTR context$[rbp+3376], ecx
$LN26@Generate10:

; 1927 : 		SET_BIT_FOR_KEY(40, 5, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN25@Generate10
	or	DWORD PTR context$[rbp+3380], ecx
$LN25@Generate10:

; 1928 : 		SET_BIT_FOR_KEY(41, 5, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN24@Generate10
	or	r14d, ecx
$LN24@Generate10:

; 1929 : 
; 1930 : 		SET_BIT_FOR_KEY(42, 6, 0);

	movzx	eax, BYTE PTR [rdx+18]
	test	al, 1
	je	SHORT $LN23@Generate10
	or	DWORD PTR context$[rbp+3388], ecx
$LN23@Generate10:

; 1931 : 		SET_BIT_FOR_KEY(43, 6, 1);

	test	al, 2
	je	SHORT $LN22@Generate10
	or	DWORD PTR context$[rbp+3392], ecx
$LN22@Generate10:

; 1932 : 		SET_BIT_FOR_KEY(44, 6, 2);

	test	al, 4
	je	SHORT $LN21@Generate10
	or	DWORD PTR context$[rbp+3396], ecx
$LN21@Generate10:

; 1933 : 		SET_BIT_FOR_KEY(45, 6, 3);

	test	al, 8
	je	SHORT $LN20@Generate10
	or	DWORD PTR context$[rbp+3400], ecx
$LN20@Generate10:

; 1934 : 		SET_BIT_FOR_KEY(46, 6, 4);

	test	al, 16
	je	SHORT $LN19@Generate10
	or	DWORD PTR context$[rbp+3404], ecx
$LN19@Generate10:

; 1935 : 		SET_BIT_FOR_KEY(47, 6, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN18@Generate10
	or	DWORD PTR context$[rbp+3408], ecx
$LN18@Generate10:

; 1936 : 		SET_BIT_FOR_KEY(48, 6, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN17@Generate10
	or	r13d, ecx
$LN17@Generate10:

; 1937 : 
; 1938 : 		SET_BIT_FOR_KEY(49, 7, 0);

	movzx	eax, BYTE PTR [rdx+19]
	test	al, 1
	je	SHORT $LN16@Generate10
	or	DWORD PTR context$[rbp+3416], ecx
$LN16@Generate10:

; 1939 : 		SET_BIT_FOR_KEY(50, 7, 1);

	test	al, 2
	je	SHORT $LN15@Generate10
	or	DWORD PTR context$[rbp+3420], ecx
$LN15@Generate10:

; 1940 : 		SET_BIT_FOR_KEY(51, 7, 2);

	test	al, 4
	je	SHORT $LN14@Generate10
	or	DWORD PTR context$[rbp+3424], ecx
$LN14@Generate10:

; 1941 : 		SET_BIT_FOR_KEY(52, 7, 3);

	test	al, 8
	je	SHORT $LN13@Generate10
	or	DWORD PTR context$[rbp+3428], ecx
$LN13@Generate10:

; 1942 : 		SET_BIT_FOR_KEY(53, 7, 4);

	test	al, 16
	je	SHORT $LN12@Generate10
	or	DWORD PTR context$[rbp+3432], ecx
$LN12@Generate10:

; 1943 : 		SET_BIT_FOR_KEY(54, 7, 5);

	test	al, 32					; 00000020H
	je	SHORT $LN11@Generate10
	or	DWORD PTR context$[rbp+3436], ecx
$LN11@Generate10:

; 1944 : 		SET_BIT_FOR_KEY(55, 7, 6);

	test	al, 64					; 00000040H
	je	SHORT $LN67@Generate10
	or	r8d, ecx
$LN67@Generate10:

; 1880 : 
; 1881 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	rol	ecx, 1
	mov	eax, DWORD PTR tripcodeIndex$1$[rsp]
	inc	rsi
	inc	eax
	mov	DWORD PTR tripcodeIndex$1$[rsp], eax
	cmp	eax, r12d
	jl	$LL68@Generate10

; 1944 : 		SET_BIT_FOR_KEY(55, 7, 6);

	mov	DWORD PTR context$[rbp+3440], r8d
	mov	DWORD PTR context$[rbp+3244], r9d
	mov	DWORD PTR context$[rbp+3272], r10d
	mov	DWORD PTR context$[rbp+3300], r11d
	mov	DWORD PTR context$[rbp+3328], ebx
	mov	DWORD PTR context$[rbp+3356], edi
	mov	DWORD PTR context$[rbp+3384], r14d
	mov	DWORD PTR context$[rbp+3412], r13d
	xor	esi, esi
$LN66@Generate10:

; 1945 : 	}
; 1946 : 
; 1947 : 	for (int32_t i = 0; i < 0x300; ++i)

	mov	rdx, rsi
	lea	r10, OFFSET FLAT:__ImageBase
	npad	6
$LL9@Generate10:

; 1948 : 		context.expandedKeySchedule[i] = context.keys[keySchedule[i]];

	movzx	eax, BYTE PTR keySchedule[rdx+r10]
	add	rdx, 6
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	movzx	eax, BYTE PTR keySchedule[rdx+r10-5]
	mov	DWORD PTR context$[rsp+rdx*4+72], ecx
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	movzx	eax, BYTE PTR keySchedule[rdx+r10-4]
	mov	DWORD PTR context$[rsp+rdx*4+76], ecx
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	movzx	eax, BYTE PTR keySchedule[rdx+r10-3]
	mov	DWORD PTR context$[rbp+rdx*4-176], ecx
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	movzx	eax, BYTE PTR keySchedule[rdx+r10-2]
	mov	DWORD PTR context$[rbp+rdx*4-172], ecx
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	movzx	eax, BYTE PTR keySchedule[rdx+r10-1]
	mov	DWORD PTR context$[rbp+rdx*4-168], ecx
	mov	ecx, DWORD PTR context$[rbp+rax*4+3220]
	mov	DWORD PTR context$[rbp+rdx*4-164], ecx
	cmp	rdx, 768				; 00000300H
	jl	$LL9@Generate10

; 1949 : 
; 1950 : 	for (int32_t i = 0; i < NUM_DATA_BLOCKS; ++i) {
; 1951 : 		context.dataBlocks[i] = 0;

	lea	rax, QWORD PTR context$[rbp+2912]
	mov	ecx, 4
	npad	11
$LL174@Generate10:
	mov	QWORD PTR [rax], rsi
	mov	QWORD PTR [rax+8], rsi
	mov	QWORD PTR [rax+16], rsi
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], rsi
	mov	QWORD PTR [rax-32], rsi
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-16], rsi
	mov	QWORD PTR [rax-8], rsi
	dec	rcx
	jne	SHORT $LL174@Generate10

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	movzx	eax, BYTE PTR [r15+14]

; 1707 : 	mask = 1;

	mov	r12d, 1

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	mov	r8d, esi

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	movzx	ecx, BYTE PTR charTableForSeed[rax+r10]
	movzx	eax, BYTE PTR [r15+13]

; 1707 : 	mask = 1;

	mov	edx, r12d

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	movsx	r9d, BYTE PTR DES_charToIndexTable[rcx+r10]
	movzx	ecx, BYTE PTR charTableForSeed[rax+r10]
	movsx	eax, BYTE PTR DES_charToIndexTable[rcx+r10]
	shl	r9d, 6

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	mov	rcx, rsi

; 1952 : 	}
; 1953 : 
; 1954 : 	DES_SetSalt(&context,
; 1955 : 				DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[1])]
; 1956 : 			| (DES_charToIndexTable[CONVERT_CHAR_FOR_SALT(p[0].key.c[2])] << 6));	

	or	r9d, eax
	npad	4
$LL102@Generate10:

; 1709 : 		if (dst == 24) mask = 1;

	cmp	r8d, 24
	cmove	edx, r12d

; 1710 : 
; 1711 : 		if (salt & mask) {

	test	edx, r9d
	je	SHORT $LN98@Generate10

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	cmp	r8d, 24
	jge	SHORT $LN97@Generate10

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	lea	rax, QWORD PTR [rcx+24]

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	jmp	SHORT $LN95@Generate10
$LN97@Generate10:

; 1708 : 	for (dst = 0; dst < 48; dst++) {

	lea	rax, QWORD PTR [rcx-24]

; 1712 : 			if (dst < 24) src = dst + 24; else src = dst - 24;

	jmp	SHORT $LN95@Generate10
$LN98@Generate10:

; 1713 : 		} else src = dst;

	mov	rax, rcx
$LN95@Generate10:

; 1714 : 
; 1715 : 		context->expansionFunction[dst     ] = expansionTable[src];

	movzx	eax, BYTE PTR ?expansionTable@@3QBEB[rax+r10]
	inc	r8d
	inc	rcx
	mov	BYTE PTR context$[rsp+rcx-1], al

; 1716 : 		context->expansionFunction[dst + 48] = expansionTable[src] + 32;

	add	al, 32					; 00000020H

; 1717 : 
; 1718 : 		mask <<= 1;

	add	edx, edx
	mov	BYTE PTR context$[rsp+rcx+47], al
	cmp	r8d, 48					; 00000030H
	jl	SHORT $LL102@Generate10
	mov	r12d, DWORD PTR numTripcodes$1$[rsp]

; 1719 : 	}
; 1720 : }
; 1721 : 
; 1722 : static char DES_charToIndexTable[0x100] = {
; 1723 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1724 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1725 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1726 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1727 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1728 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x01,
; 1729 : 	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
; 1730 : 	0x0a, 0x0b, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1731 : 	0x7f, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
; 1732 : 	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
; 1733 : 	0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
; 1734 : 	0x23, 0x24, 0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1735 : 	0x7f, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
; 1736 : 	0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
; 1737 : 	0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c,
; 1738 : 	0x3d, 0x3e, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1739 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1740 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1741 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1742 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1743 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1744 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1745 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1746 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1747 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1748 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1749 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1750 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1751 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1752 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1753 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1754 : 	0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
; 1755 : };
; 1756 : 
; 1757 : // The following table was adopted from:
; 1758 : // http://sourceforge.jp/projects/naniya/wiki/2chtrip#h2-Salt.E7.94.9F.E6.88.90.E8.A6.8F.E5.89.87
; 1759 : 
; 1760 : static unsigned char charTableForSeed[256] = {
; 1761 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1762 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1763 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '/',
; 1764 : 	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
; 1765 : 	'G', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
; 1766 : 	'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',
; 1767 : 	'f', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
; 1768 : 	'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', '.', '.', '.', '.',
; 1769 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1770 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1771 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1772 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1773 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1774 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1775 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1776 : 	'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
; 1777 : };
; 1778 : 
; 1779 : #define CONVERT_CHAR_FOR_SALT(ch) (charTableForSeed[(unsigned char)(ch)])
; 1780 : 
; 1781 : 
; 1782 : static void DES_Crypt25(DES_Context *context)
; 1783 : {
; 1784 : 	int32_t iterations, roundsAndSwapped; 
; 1785 : 	int32_t keyScheduleIndexBase = 0;

	mov	ebx, esi

; 1788 : 	iterations = 25;

	mov	r14d, 25
$LN175@Generate10:

; 1786 : 
; 1787 : 	roundsAndSwapped = 8;

	mov	edi, 8
	npad	11
$start$178:

; 1789 : 
; 1790 : start:
; 1791 : 	CPU_DES_SBoxes1(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r8, QWORD PTR context$[rbp+2912]
	lea	rdx, QWORD PTR context$[rbp-160]
	lea	rcx, QWORD PTR context$[rsp]
	mov	r9d, ebx
	call	?CPU_DES_SBoxes1@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes1

; 1792 : 
; 1793 : 	if (roundsAndSwapped == 0x100)

	cmp	edi, 256				; 00000100H
	jne	SHORT $LN125@Generate10

; 1806 : 		goto swap;
; 1807 : 	return;
; 1808 : 
; 1809 : next:
; 1810 : 	keyScheduleIndexBase -= (0x300 - 48);

	sub	ebx, 720				; 000002d0H
$next$179:

; 1811 : 	roundsAndSwapped = 8;
; 1812 : 	iterations--;

	dec	r14d

; 1813 : 	goto start;

	jmp	SHORT $LN175@Generate10
$LN125@Generate10:

; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r8, QWORD PTR context$[rbp+2912]
	lea	rdx, QWORD PTR context$[rbp-160]
	lea	rcx, QWORD PTR context$[rsp]
	mov	r9d, ebx
	call	?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes2

; 1798 : 
; 1799 : 	keyScheduleIndexBase += 96;

	add	ebx, 96					; 00000060H

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	dec	edi
	jne	SHORT $start$178
	npad	6
$swap$180:

; 1802 : 		goto start;
; 1803 : 	keyScheduleIndexBase -= (0x300 + 48);
; 1804 : 	roundsAndSwapped = 0x108;
; 1805 : 	if (--iterations)

	dec	r14d
	je	SHORT $LN105@Generate10

; 1794 : 		goto next;
; 1795 : 
; 1796 : swap:
; 1797 : 	CPU_DES_SBoxes2(context->expansionFunction, context->expandedKeySchedule, context->dataBlocks, keyScheduleIndexBase);

	lea	r9d, DWORD PTR [rbx-816]
	lea	r8, QWORD PTR context$[rbp+2912]
	lea	rdx, QWORD PTR context$[rbp-160]
	lea	rcx, QWORD PTR context$[rsp]
	call	?CPU_DES_SBoxes2@@YAXPEAEPEAI1H@Z	; CPU_DES_SBoxes2

; 1798 : 
; 1799 : 	keyScheduleIndexBase += 96;

	add	ebx, -720				; fffffffffffffd30H

; 1800 : 
; 1801 : 	if (--roundsAndSwapped)

	mov	edi, 263				; 00000107H

; 1870 : 	DES_Context context;
; 1871 : 
; 1872 : 	CLEAR_KEYS(0);

	jmp	SHORT $start$178
$LN105@Generate10:

; 1957 : 
; 1958 : 	DES_Crypt25(&context);
; 1959 : 	
; 1960 : 	for (int32_t tripcodeIndex = 0; tripcodeIndex < numTripcodes; ++tripcodeIndex) {

	test	r12d, r12d
	jle	SHORT $LN1@Generate10
	lea	rbx, QWORD PTR [r15+10]
	npad	9
$LL3@Generate10:

; 1961 : 		DES_GetTripcode(&context, tripcodeIndex, p[tripcodeIndex].tripcode.c);

	lea	rcx, QWORD PTR context$[rsp]
	mov	r8, r15
	mov	edx, esi
	call	?DES_GetTripcode@@YAPEAEPEAUDES_Context@@HPEAE@Z ; DES_GetTripcode
	inc	esi
	add	r15, 24

; 1962 : 		p[tripcodeIndex].tripcode.c[10] = '\0';

	mov	BYTE PTR [rbx], 0
	lea	rbx, QWORD PTR [rbx+24]
	cmp	esi, r12d
	jl	SHORT $LL3@Generate10
$LN1@Generate10:

; 1963 : 	}
; 1964 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+3776]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?Generate10CharTripcodes@@YAXPEAUTripcodeKeyPair@@H@Z ENDP ; Generate10CharTripcodes
_TEXT	ENDS
END
